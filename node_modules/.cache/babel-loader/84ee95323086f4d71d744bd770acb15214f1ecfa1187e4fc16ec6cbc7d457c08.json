{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar SortableSet = require(\"./SortableSet\");\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Entrypoint\").EntryOptions} EntryOptions */\n\n/** @typedef {string | SortableSet<string> | undefined} RuntimeSpec */\n/** @typedef {RuntimeSpec | boolean} RuntimeCondition */\n\n/**\n * @param {Compilation} compilation the compilation\n * @param {string} name name of the entry\n * @param {EntryOptions=} options optionally already received entry options\n * @returns {RuntimeSpec} runtime\n */\nexports.getEntryRuntime = function (compilation, name, options) {\n  var dependOn;\n  var runtime;\n  if (options) {\n    dependOn = options.dependOn;\n    runtime = options.runtime;\n  } else {\n    var entry = compilation.entries.get(name);\n    if (!entry) return name;\n    var _entry$options = entry.options;\n    dependOn = _entry$options.dependOn;\n    runtime = _entry$options.runtime;\n  }\n  if (dependOn) {\n    /** @type {RuntimeSpec} */\n    var result = undefined;\n    var queue = new Set(dependOn);\n    var _iterator = _createForOfIteratorHelper(queue),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _name = _step.value;\n        var dep = compilation.entries.get(_name);\n        if (!dep) continue;\n        var _dep$options = dep.options,\n          _dependOn = _dep$options.dependOn,\n          _runtime = _dep$options.runtime;\n        if (_dependOn) {\n          var _iterator2 = _createForOfIteratorHelper(_dependOn),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _name2 = _step2.value;\n              queue.add(_name2);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        } else {\n          result = mergeRuntimeOwned(result, _runtime || _name);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return result || name;\n  } else {\n    return runtime || name;\n  }\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime\n * @param {function(string): void} fn functor\n * @param {boolean} deterministicOrder enforce a deterministic order\n * @returns {void}\n */\nexports.forEachRuntime = function (runtime, fn) {\n  var deterministicOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (runtime === undefined) {\n    fn(undefined);\n  } else if (typeof runtime === \"string\") {\n    fn(runtime);\n  } else {\n    if (deterministicOrder) runtime.sort();\n    var _iterator3 = _createForOfIteratorHelper(runtime),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var r = _step3.value;\n        fn(r);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n};\nvar getRuntimesKey = function getRuntimesKey(set) {\n  set.sort();\n  return Array.from(set).join(\"\\n\");\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime(s)\n * @returns {string} key of runtimes\n */\nvar getRuntimeKey = function getRuntimeKey(runtime) {\n  if (runtime === undefined) return \"*\";\n  if (typeof runtime === \"string\") return runtime;\n  return runtime.getFromUnorderedCache(getRuntimesKey);\n};\nexports.getRuntimeKey = getRuntimeKey;\n\n/**\n * @param {string} key key of runtimes\n * @returns {RuntimeSpec} runtime(s)\n */\nvar keyToRuntime = function keyToRuntime(key) {\n  if (key === \"*\") return undefined;\n  var items = key.split(\"\\n\");\n  if (items.length === 1) return items[0];\n  return new SortableSet(items);\n};\nexports.keyToRuntime = keyToRuntime;\nvar getRuntimesString = function getRuntimesString(set) {\n  set.sort();\n  return Array.from(set).join(\"+\");\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime(s)\n * @returns {string} readable version\n */\nvar runtimeToString = function runtimeToString(runtime) {\n  if (runtime === undefined) return \"*\";\n  if (typeof runtime === \"string\") return runtime;\n  return runtime.getFromUnorderedCache(getRuntimesString);\n};\nexports.runtimeToString = runtimeToString;\n\n/**\n * @param {RuntimeCondition} runtimeCondition runtime condition\n * @returns {string} readable version\n */\nexports.runtimeConditionToString = function (runtimeCondition) {\n  if (runtimeCondition === true) return \"true\";\n  if (runtimeCondition === false) return \"false\";\n  return runtimeToString(runtimeCondition);\n};\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {boolean} true, when they are equal\n */\nvar runtimeEqual = function runtimeEqual(a, b) {\n  if (a === b) {\n    return true;\n  } else if (a === undefined || b === undefined || typeof a === \"string\" || typeof b === \"string\") {\n    return false;\n  } else if (a.size !== b.size) {\n    return false;\n  } else {\n    a.sort();\n    b.sort();\n    var aIt = a[Symbol.iterator]();\n    var bIt = b[Symbol.iterator]();\n    for (;;) {\n      var aV = aIt.next();\n      if (aV.done) return true;\n      var bV = bIt.next();\n      if (aV.value !== bV.value) return false;\n    }\n  }\n};\nexports.runtimeEqual = runtimeEqual;\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {-1|0|1} compare\n */\nexports.compareRuntime = function (a, b) {\n  if (a === b) {\n    return 0;\n  } else if (a === undefined) {\n    return -1;\n  } else if (b === undefined) {\n    return 1;\n  } else {\n    var aKey = getRuntimeKey(a);\n    var bKey = getRuntimeKey(b);\n    if (aKey < bKey) return -1;\n    if (aKey > bKey) return 1;\n    return 0;\n  }\n};\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\nvar mergeRuntime = function mergeRuntime(a, b) {\n  if (a === undefined) {\n    return b;\n  } else if (b === undefined) {\n    return a;\n  } else if (a === b) {\n    return a;\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"string\") {\n      var set = new SortableSet();\n      set.add(a);\n      set.add(b);\n      return set;\n    } else if (b.has(a)) {\n      return b;\n    } else {\n      var _set = new SortableSet(b);\n      _set.add(a);\n      return _set;\n    }\n  } else {\n    if (typeof b === \"string\") {\n      if (a.has(b)) return a;\n      var _set2 = new SortableSet(a);\n      _set2.add(b);\n      return _set2;\n    } else {\n      var _set3 = new SortableSet(a);\n      var _iterator4 = _createForOfIteratorHelper(b),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var item = _step4.value;\n          _set3.add(item);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      if (_set3.size === a.size) return a;\n      return _set3;\n    }\n  }\n};\nexports.mergeRuntime = mergeRuntime;\n\n/**\n * @param {RuntimeCondition} a first\n * @param {RuntimeCondition} b second\n * @param {RuntimeSpec} runtime full runtime\n * @returns {RuntimeCondition} result\n */\nexports.mergeRuntimeCondition = function (a, b, runtime) {\n  if (a === false) return b;\n  if (b === false) return a;\n  if (a === true || b === true) return true;\n  var merged = mergeRuntime(a, b);\n  if (merged === undefined) return undefined;\n  if (typeof merged === \"string\") {\n    if (typeof runtime === \"string\" && merged === runtime) return true;\n    return merged;\n  }\n  if (typeof runtime === \"string\" || runtime === undefined) return merged;\n  if (merged.size === runtime.size) return true;\n  return merged;\n};\n\n/**\n * @param {RuntimeSpec | true} a first\n * @param {RuntimeSpec | true} b second\n * @param {RuntimeSpec} runtime full runtime\n * @returns {RuntimeSpec | true} result\n */\nexports.mergeRuntimeConditionNonFalse = function (a, b, runtime) {\n  if (a === true || b === true) return true;\n  var merged = mergeRuntime(a, b);\n  if (merged === undefined) return undefined;\n  if (typeof merged === \"string\") {\n    if (typeof runtime === \"string\" && merged === runtime) return true;\n    return merged;\n  }\n  if (typeof runtime === \"string\" || runtime === undefined) return merged;\n  if (merged.size === runtime.size) return true;\n  return merged;\n};\n\n/**\n * @param {RuntimeSpec} a first (may be modified)\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\nvar mergeRuntimeOwned = function mergeRuntimeOwned(a, b) {\n  if (b === undefined) {\n    return a;\n  } else if (a === b) {\n    return a;\n  } else if (a === undefined) {\n    if (typeof b === \"string\") {\n      return b;\n    } else {\n      return new SortableSet(b);\n    }\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"string\") {\n      var set = new SortableSet();\n      set.add(a);\n      set.add(b);\n      return set;\n    } else {\n      var _set4 = new SortableSet(b);\n      _set4.add(a);\n      return _set4;\n    }\n  } else {\n    if (typeof b === \"string\") {\n      a.add(b);\n      return a;\n    } else {\n      var _iterator5 = _createForOfIteratorHelper(b),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var item = _step5.value;\n          a.add(item);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      return a;\n    }\n  }\n};\nexports.mergeRuntimeOwned = mergeRuntimeOwned;\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\nexports.intersectRuntime = function (a, b) {\n  if (a === undefined) {\n    return b;\n  } else if (b === undefined) {\n    return a;\n  } else if (a === b) {\n    return a;\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"string\") {\n      return undefined;\n    } else if (b.has(a)) {\n      return a;\n    } else {\n      return undefined;\n    }\n  } else {\n    if (typeof b === \"string\") {\n      if (a.has(b)) return b;\n      return undefined;\n    } else {\n      var set = new SortableSet();\n      var _iterator6 = _createForOfIteratorHelper(b),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _item = _step6.value;\n          if (a.has(_item)) set.add(_item);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      if (set.size === 0) return undefined;\n      if (set.size === 1) {\n        var _iterator7 = _createForOfIteratorHelper(set),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var item = _step7.value;\n            return item;\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n      return set;\n    }\n  }\n};\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} result\n */\nvar subtractRuntime = function subtractRuntime(a, b) {\n  if (a === undefined) {\n    return undefined;\n  } else if (b === undefined) {\n    return a;\n  } else if (a === b) {\n    return undefined;\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"string\") {\n      return a;\n    } else if (b.has(a)) {\n      return undefined;\n    } else {\n      return a;\n    }\n  } else {\n    if (typeof b === \"string\") {\n      if (!a.has(b)) return a;\n      if (a.size === 2) {\n        var _iterator8 = _createForOfIteratorHelper(a),\n          _step8;\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var item = _step8.value;\n            if (item !== b) return item;\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n      }\n      var set = new SortableSet(a);\n      set.delete(b);\n    } else {\n      var _set5 = new SortableSet();\n      var _iterator9 = _createForOfIteratorHelper(a),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var _item3 = _step9.value;\n          if (!b.has(_item3)) _set5.add(_item3);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n      if (_set5.size === 0) return undefined;\n      if (_set5.size === 1) {\n        var _iterator10 = _createForOfIteratorHelper(_set5),\n          _step10;\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var _item2 = _step10.value;\n            return _item2;\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      }\n      return _set5;\n    }\n  }\n};\nexports.subtractRuntime = subtractRuntime;\n\n/**\n * @param {RuntimeCondition} a first\n * @param {RuntimeCondition} b second\n * @param {RuntimeSpec} runtime runtime\n * @returns {RuntimeCondition} result\n */\nexports.subtractRuntimeCondition = function (a, b, runtime) {\n  if (b === true) return false;\n  if (b === false) return a;\n  if (a === false) return false;\n  var result = subtractRuntime(a === true ? runtime : a, b);\n  return result === undefined ? false : result;\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime\n * @param {function(RuntimeSpec): boolean} filter filter function\n * @returns {boolean | RuntimeSpec} true/false if filter is constant for all runtimes, otherwise runtimes that are active\n */\nexports.filterRuntime = function (runtime, filter) {\n  if (runtime === undefined) return filter(undefined);\n  if (typeof runtime === \"string\") return filter(runtime);\n  var some = false;\n  var every = true;\n  var result = undefined;\n  var _iterator11 = _createForOfIteratorHelper(runtime),\n    _step11;\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var r = _step11.value;\n      var v = filter(r);\n      if (v) {\n        some = true;\n        result = mergeRuntimeOwned(result, r);\n      } else {\n        every = false;\n      }\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n  if (!some) return false;\n  if (every) return true;\n  return result;\n};\n\n/**\n * @template T\n */\nvar RuntimeSpecMap = /*#__PURE__*/function () {\n  /**\n   * @param {RuntimeSpecMap<T>=} clone copy form this\n   */\n  function RuntimeSpecMap(clone) {\n    _classCallCheck(this, RuntimeSpecMap);\n    this._mode = clone ? clone._mode : 0; // 0 = empty, 1 = single entry, 2 = map\n    /** @type {RuntimeSpec} */\n    this._singleRuntime = clone ? clone._singleRuntime : undefined;\n    /** @type {T} */\n    this._singleValue = clone ? clone._singleValue : undefined;\n    /** @type {Map<string, T> | undefined} */\n    this._map = clone && clone._map ? new Map(clone._map) : undefined;\n  }\n\n  /**\n   * @param {RuntimeSpec} runtime the runtimes\n   * @returns {T} value\n   */\n  _createClass(RuntimeSpecMap, [{\n    key: \"get\",\n    value: function get(runtime) {\n      switch (this._mode) {\n        case 0:\n          return undefined;\n        case 1:\n          return runtimeEqual(this._singleRuntime, runtime) ? this._singleValue : undefined;\n        default:\n          return this._map.get(getRuntimeKey(runtime));\n      }\n    }\n\n    /**\n     * @param {RuntimeSpec} runtime the runtimes\n     * @returns {boolean} true, when the runtime is stored\n     */\n  }, {\n    key: \"has\",\n    value: function has(runtime) {\n      switch (this._mode) {\n        case 0:\n          return false;\n        case 1:\n          return runtimeEqual(this._singleRuntime, runtime);\n        default:\n          return this._map.has(getRuntimeKey(runtime));\n      }\n    }\n  }, {\n    key: \"set\",\n    value: function set(runtime, value) {\n      switch (this._mode) {\n        case 0:\n          this._mode = 1;\n          this._singleRuntime = runtime;\n          this._singleValue = value;\n          break;\n        case 1:\n          if (runtimeEqual(this._singleRuntime, runtime)) {\n            this._singleValue = value;\n            break;\n          }\n          this._mode = 2;\n          this._map = new Map();\n          this._map.set(getRuntimeKey(this._singleRuntime), this._singleValue);\n          this._singleRuntime = undefined;\n          this._singleValue = undefined;\n        /* falls through */\n        default:\n          this._map.set(getRuntimeKey(runtime), value);\n      }\n    }\n  }, {\n    key: \"provide\",\n    value: function provide(runtime, computer) {\n      switch (this._mode) {\n        case 0:\n          this._mode = 1;\n          this._singleRuntime = runtime;\n          return this._singleValue = computer();\n        case 1:\n          {\n            if (runtimeEqual(this._singleRuntime, runtime)) {\n              return this._singleValue;\n            }\n            this._mode = 2;\n            this._map = new Map();\n            this._map.set(getRuntimeKey(this._singleRuntime), this._singleValue);\n            this._singleRuntime = undefined;\n            this._singleValue = undefined;\n            var newValue = computer();\n            this._map.set(getRuntimeKey(runtime), newValue);\n            return newValue;\n          }\n        default:\n          {\n            var key = getRuntimeKey(runtime);\n            var value = this._map.get(key);\n            if (value !== undefined) return value;\n            var _newValue = computer();\n            this._map.set(key, _newValue);\n            return _newValue;\n          }\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(runtime) {\n      switch (this._mode) {\n        case 0:\n          return;\n        case 1:\n          if (runtimeEqual(this._singleRuntime, runtime)) {\n            this._mode = 0;\n            this._singleRuntime = undefined;\n            this._singleValue = undefined;\n          }\n          return;\n        default:\n          this._map.delete(getRuntimeKey(runtime));\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(runtime, fn) {\n      switch (this._mode) {\n        case 0:\n          throw new Error(\"runtime passed to update must exist\");\n        case 1:\n          {\n            if (runtimeEqual(this._singleRuntime, runtime)) {\n              this._singleValue = fn(this._singleValue);\n              break;\n            }\n            var newValue = fn(undefined);\n            if (newValue !== undefined) {\n              this._mode = 2;\n              this._map = new Map();\n              this._map.set(getRuntimeKey(this._singleRuntime), this._singleValue);\n              this._singleRuntime = undefined;\n              this._singleValue = undefined;\n              this._map.set(getRuntimeKey(runtime), newValue);\n            }\n            break;\n          }\n        default:\n          {\n            var key = getRuntimeKey(runtime);\n            var oldValue = this._map.get(key);\n            var _newValue2 = fn(oldValue);\n            if (_newValue2 !== oldValue) this._map.set(key, _newValue2);\n          }\n      }\n    }\n  }, {\n    key: \"keys\",\n    value: function keys() {\n      switch (this._mode) {\n        case 0:\n          return [];\n        case 1:\n          return [this._singleRuntime];\n        default:\n          return Array.from(this._map.keys(), keyToRuntime);\n      }\n    }\n  }, {\n    key: \"values\",\n    value: function values() {\n      switch (this._mode) {\n        case 0:\n          return [][Symbol.iterator]();\n        case 1:\n          return [this._singleValue][Symbol.iterator]();\n        default:\n          return this._map.values();\n      }\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      if (this._mode <= 1) return this._mode;\n      return this._map.size;\n    }\n  }]);\n  return RuntimeSpecMap;\n}();\nexports.RuntimeSpecMap = RuntimeSpecMap;\nvar RuntimeSpecSet = /*#__PURE__*/function (_Symbol$iterator) {\n  function RuntimeSpecSet(iterable) {\n    _classCallCheck(this, RuntimeSpecSet);\n    /** @type {Map<string, RuntimeSpec>} */\n    this._map = new Map();\n    if (iterable) {\n      var _iterator12 = _createForOfIteratorHelper(iterable),\n        _step12;\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var item = _step12.value;\n          this.add(item);\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n    }\n  }\n  _createClass(RuntimeSpecSet, [{\n    key: \"add\",\n    value: function add(runtime) {\n      this._map.set(getRuntimeKey(runtime), runtime);\n    }\n  }, {\n    key: \"has\",\n    value: function has(runtime) {\n      return this._map.has(getRuntimeKey(runtime));\n    }\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      return this._map.values();\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._map.size;\n    }\n  }]);\n  return RuntimeSpecSet;\n}(Symbol.iterator);\nexports.RuntimeSpecSet = RuntimeSpecSet;","map":{"version":3,"names":["SortableSet","require","exports","getEntryRuntime","compilation","name","options","dependOn","runtime","entry","entries","get","result","undefined","queue","Set","dep","add","mergeRuntimeOwned","forEachRuntime","fn","deterministicOrder","sort","r","getRuntimesKey","set","Array","from","join","getRuntimeKey","getFromUnorderedCache","keyToRuntime","key","items","split","length","getRuntimesString","runtimeToString","runtimeConditionToString","runtimeCondition","runtimeEqual","a","b","size","aIt","Symbol","iterator","bIt","aV","next","done","bV","value","compareRuntime","aKey","bKey","mergeRuntime","has","item","mergeRuntimeCondition","merged","mergeRuntimeConditionNonFalse","intersectRuntime","subtractRuntime","delete","subtractRuntimeCondition","filterRuntime","filter","some","every","v","RuntimeSpecMap","clone","_mode","_singleRuntime","_singleValue","_map","Map","computer","newValue","Error","oldValue","keys","values","RuntimeSpecSet","iterable"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/util/runtime.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst SortableSet = require(\"./SortableSet\");\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Entrypoint\").EntryOptions} EntryOptions */\n\n/** @typedef {string | SortableSet<string> | undefined} RuntimeSpec */\n/** @typedef {RuntimeSpec | boolean} RuntimeCondition */\n\n/**\n * @param {Compilation} compilation the compilation\n * @param {string} name name of the entry\n * @param {EntryOptions=} options optionally already received entry options\n * @returns {RuntimeSpec} runtime\n */\nexports.getEntryRuntime = (compilation, name, options) => {\n\tlet dependOn;\n\tlet runtime;\n\tif (options) {\n\t\t({ dependOn, runtime } = options);\n\t} else {\n\t\tconst entry = compilation.entries.get(name);\n\t\tif (!entry) return name;\n\t\t({ dependOn, runtime } = entry.options);\n\t}\n\tif (dependOn) {\n\t\t/** @type {RuntimeSpec} */\n\t\tlet result = undefined;\n\t\tconst queue = new Set(dependOn);\n\t\tfor (const name of queue) {\n\t\t\tconst dep = compilation.entries.get(name);\n\t\t\tif (!dep) continue;\n\t\t\tconst { dependOn, runtime } = dep.options;\n\t\t\tif (dependOn) {\n\t\t\t\tfor (const name of dependOn) {\n\t\t\t\t\tqueue.add(name);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = mergeRuntimeOwned(result, runtime || name);\n\t\t\t}\n\t\t}\n\t\treturn result || name;\n\t} else {\n\t\treturn runtime || name;\n\t}\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime\n * @param {function(string): void} fn functor\n * @param {boolean} deterministicOrder enforce a deterministic order\n * @returns {void}\n */\nexports.forEachRuntime = (runtime, fn, deterministicOrder = false) => {\n\tif (runtime === undefined) {\n\t\tfn(undefined);\n\t} else if (typeof runtime === \"string\") {\n\t\tfn(runtime);\n\t} else {\n\t\tif (deterministicOrder) runtime.sort();\n\t\tfor (const r of runtime) {\n\t\t\tfn(r);\n\t\t}\n\t}\n};\n\nconst getRuntimesKey = set => {\n\tset.sort();\n\treturn Array.from(set).join(\"\\n\");\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime(s)\n * @returns {string} key of runtimes\n */\nconst getRuntimeKey = runtime => {\n\tif (runtime === undefined) return \"*\";\n\tif (typeof runtime === \"string\") return runtime;\n\treturn runtime.getFromUnorderedCache(getRuntimesKey);\n};\nexports.getRuntimeKey = getRuntimeKey;\n\n/**\n * @param {string} key key of runtimes\n * @returns {RuntimeSpec} runtime(s)\n */\nconst keyToRuntime = key => {\n\tif (key === \"*\") return undefined;\n\tconst items = key.split(\"\\n\");\n\tif (items.length === 1) return items[0];\n\treturn new SortableSet(items);\n};\nexports.keyToRuntime = keyToRuntime;\n\nconst getRuntimesString = set => {\n\tset.sort();\n\treturn Array.from(set).join(\"+\");\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime(s)\n * @returns {string} readable version\n */\nconst runtimeToString = runtime => {\n\tif (runtime === undefined) return \"*\";\n\tif (typeof runtime === \"string\") return runtime;\n\treturn runtime.getFromUnorderedCache(getRuntimesString);\n};\nexports.runtimeToString = runtimeToString;\n\n/**\n * @param {RuntimeCondition} runtimeCondition runtime condition\n * @returns {string} readable version\n */\nexports.runtimeConditionToString = runtimeCondition => {\n\tif (runtimeCondition === true) return \"true\";\n\tif (runtimeCondition === false) return \"false\";\n\treturn runtimeToString(runtimeCondition);\n};\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {boolean} true, when they are equal\n */\nconst runtimeEqual = (a, b) => {\n\tif (a === b) {\n\t\treturn true;\n\t} else if (\n\t\ta === undefined ||\n\t\tb === undefined ||\n\t\ttypeof a === \"string\" ||\n\t\ttypeof b === \"string\"\n\t) {\n\t\treturn false;\n\t} else if (a.size !== b.size) {\n\t\treturn false;\n\t} else {\n\t\ta.sort();\n\t\tb.sort();\n\t\tconst aIt = a[Symbol.iterator]();\n\t\tconst bIt = b[Symbol.iterator]();\n\t\tfor (;;) {\n\t\t\tconst aV = aIt.next();\n\t\t\tif (aV.done) return true;\n\t\t\tconst bV = bIt.next();\n\t\t\tif (aV.value !== bV.value) return false;\n\t\t}\n\t}\n};\nexports.runtimeEqual = runtimeEqual;\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {-1|0|1} compare\n */\nexports.compareRuntime = (a, b) => {\n\tif (a === b) {\n\t\treturn 0;\n\t} else if (a === undefined) {\n\t\treturn -1;\n\t} else if (b === undefined) {\n\t\treturn 1;\n\t} else {\n\t\tconst aKey = getRuntimeKey(a);\n\t\tconst bKey = getRuntimeKey(b);\n\t\tif (aKey < bKey) return -1;\n\t\tif (aKey > bKey) return 1;\n\t\treturn 0;\n\t}\n};\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\nconst mergeRuntime = (a, b) => {\n\tif (a === undefined) {\n\t\treturn b;\n\t} else if (b === undefined) {\n\t\treturn a;\n\t} else if (a === b) {\n\t\treturn a;\n\t} else if (typeof a === \"string\") {\n\t\tif (typeof b === \"string\") {\n\t\t\tconst set = new SortableSet();\n\t\t\tset.add(a);\n\t\t\tset.add(b);\n\t\t\treturn set;\n\t\t} else if (b.has(a)) {\n\t\t\treturn b;\n\t\t} else {\n\t\t\tconst set = new SortableSet(b);\n\t\t\tset.add(a);\n\t\t\treturn set;\n\t\t}\n\t} else {\n\t\tif (typeof b === \"string\") {\n\t\t\tif (a.has(b)) return a;\n\t\t\tconst set = new SortableSet(a);\n\t\t\tset.add(b);\n\t\t\treturn set;\n\t\t} else {\n\t\t\tconst set = new SortableSet(a);\n\t\t\tfor (const item of b) set.add(item);\n\t\t\tif (set.size === a.size) return a;\n\t\t\treturn set;\n\t\t}\n\t}\n};\nexports.mergeRuntime = mergeRuntime;\n\n/**\n * @param {RuntimeCondition} a first\n * @param {RuntimeCondition} b second\n * @param {RuntimeSpec} runtime full runtime\n * @returns {RuntimeCondition} result\n */\nexports.mergeRuntimeCondition = (a, b, runtime) => {\n\tif (a === false) return b;\n\tif (b === false) return a;\n\tif (a === true || b === true) return true;\n\tconst merged = mergeRuntime(a, b);\n\tif (merged === undefined) return undefined;\n\tif (typeof merged === \"string\") {\n\t\tif (typeof runtime === \"string\" && merged === runtime) return true;\n\t\treturn merged;\n\t}\n\tif (typeof runtime === \"string\" || runtime === undefined) return merged;\n\tif (merged.size === runtime.size) return true;\n\treturn merged;\n};\n\n/**\n * @param {RuntimeSpec | true} a first\n * @param {RuntimeSpec | true} b second\n * @param {RuntimeSpec} runtime full runtime\n * @returns {RuntimeSpec | true} result\n */\nexports.mergeRuntimeConditionNonFalse = (a, b, runtime) => {\n\tif (a === true || b === true) return true;\n\tconst merged = mergeRuntime(a, b);\n\tif (merged === undefined) return undefined;\n\tif (typeof merged === \"string\") {\n\t\tif (typeof runtime === \"string\" && merged === runtime) return true;\n\t\treturn merged;\n\t}\n\tif (typeof runtime === \"string\" || runtime === undefined) return merged;\n\tif (merged.size === runtime.size) return true;\n\treturn merged;\n};\n\n/**\n * @param {RuntimeSpec} a first (may be modified)\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\nconst mergeRuntimeOwned = (a, b) => {\n\tif (b === undefined) {\n\t\treturn a;\n\t} else if (a === b) {\n\t\treturn a;\n\t} else if (a === undefined) {\n\t\tif (typeof b === \"string\") {\n\t\t\treturn b;\n\t\t} else {\n\t\t\treturn new SortableSet(b);\n\t\t}\n\t} else if (typeof a === \"string\") {\n\t\tif (typeof b === \"string\") {\n\t\t\tconst set = new SortableSet();\n\t\t\tset.add(a);\n\t\t\tset.add(b);\n\t\t\treturn set;\n\t\t} else {\n\t\t\tconst set = new SortableSet(b);\n\t\t\tset.add(a);\n\t\t\treturn set;\n\t\t}\n\t} else {\n\t\tif (typeof b === \"string\") {\n\t\t\ta.add(b);\n\t\t\treturn a;\n\t\t} else {\n\t\t\tfor (const item of b) a.add(item);\n\t\t\treturn a;\n\t\t}\n\t}\n};\nexports.mergeRuntimeOwned = mergeRuntimeOwned;\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\nexports.intersectRuntime = (a, b) => {\n\tif (a === undefined) {\n\t\treturn b;\n\t} else if (b === undefined) {\n\t\treturn a;\n\t} else if (a === b) {\n\t\treturn a;\n\t} else if (typeof a === \"string\") {\n\t\tif (typeof b === \"string\") {\n\t\t\treturn undefined;\n\t\t} else if (b.has(a)) {\n\t\t\treturn a;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t} else {\n\t\tif (typeof b === \"string\") {\n\t\t\tif (a.has(b)) return b;\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst set = new SortableSet();\n\t\t\tfor (const item of b) {\n\t\t\t\tif (a.has(item)) set.add(item);\n\t\t\t}\n\t\t\tif (set.size === 0) return undefined;\n\t\t\tif (set.size === 1) for (const item of set) return item;\n\t\t\treturn set;\n\t\t}\n\t}\n};\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} result\n */\nconst subtractRuntime = (a, b) => {\n\tif (a === undefined) {\n\t\treturn undefined;\n\t} else if (b === undefined) {\n\t\treturn a;\n\t} else if (a === b) {\n\t\treturn undefined;\n\t} else if (typeof a === \"string\") {\n\t\tif (typeof b === \"string\") {\n\t\t\treturn a;\n\t\t} else if (b.has(a)) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\treturn a;\n\t\t}\n\t} else {\n\t\tif (typeof b === \"string\") {\n\t\t\tif (!a.has(b)) return a;\n\t\t\tif (a.size === 2) {\n\t\t\t\tfor (const item of a) {\n\t\t\t\t\tif (item !== b) return item;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst set = new SortableSet(a);\n\t\t\tset.delete(b);\n\t\t} else {\n\t\t\tconst set = new SortableSet();\n\t\t\tfor (const item of a) {\n\t\t\t\tif (!b.has(item)) set.add(item);\n\t\t\t}\n\t\t\tif (set.size === 0) return undefined;\n\t\t\tif (set.size === 1) for (const item of set) return item;\n\t\t\treturn set;\n\t\t}\n\t}\n};\nexports.subtractRuntime = subtractRuntime;\n\n/**\n * @param {RuntimeCondition} a first\n * @param {RuntimeCondition} b second\n * @param {RuntimeSpec} runtime runtime\n * @returns {RuntimeCondition} result\n */\nexports.subtractRuntimeCondition = (a, b, runtime) => {\n\tif (b === true) return false;\n\tif (b === false) return a;\n\tif (a === false) return false;\n\tconst result = subtractRuntime(a === true ? runtime : a, b);\n\treturn result === undefined ? false : result;\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime\n * @param {function(RuntimeSpec): boolean} filter filter function\n * @returns {boolean | RuntimeSpec} true/false if filter is constant for all runtimes, otherwise runtimes that are active\n */\nexports.filterRuntime = (runtime, filter) => {\n\tif (runtime === undefined) return filter(undefined);\n\tif (typeof runtime === \"string\") return filter(runtime);\n\tlet some = false;\n\tlet every = true;\n\tlet result = undefined;\n\tfor (const r of runtime) {\n\t\tconst v = filter(r);\n\t\tif (v) {\n\t\t\tsome = true;\n\t\t\tresult = mergeRuntimeOwned(result, r);\n\t\t} else {\n\t\t\tevery = false;\n\t\t}\n\t}\n\tif (!some) return false;\n\tif (every) return true;\n\treturn result;\n};\n\n/**\n * @template T\n */\nclass RuntimeSpecMap {\n\t/**\n\t * @param {RuntimeSpecMap<T>=} clone copy form this\n\t */\n\tconstructor(clone) {\n\t\tthis._mode = clone ? clone._mode : 0; // 0 = empty, 1 = single entry, 2 = map\n\t\t/** @type {RuntimeSpec} */\n\t\tthis._singleRuntime = clone ? clone._singleRuntime : undefined;\n\t\t/** @type {T} */\n\t\tthis._singleValue = clone ? clone._singleValue : undefined;\n\t\t/** @type {Map<string, T> | undefined} */\n\t\tthis._map = clone && clone._map ? new Map(clone._map) : undefined;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtimes\n\t * @returns {T} value\n\t */\n\tget(runtime) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn undefined;\n\t\t\tcase 1:\n\t\t\t\treturn runtimeEqual(this._singleRuntime, runtime)\n\t\t\t\t\t? this._singleValue\n\t\t\t\t\t: undefined;\n\t\t\tdefault:\n\t\t\t\treturn this._map.get(getRuntimeKey(runtime));\n\t\t}\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtimes\n\t * @returns {boolean} true, when the runtime is stored\n\t */\n\thas(runtime) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn false;\n\t\t\tcase 1:\n\t\t\t\treturn runtimeEqual(this._singleRuntime, runtime);\n\t\t\tdefault:\n\t\t\t\treturn this._map.has(getRuntimeKey(runtime));\n\t\t}\n\t}\n\n\tset(runtime, value) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\tthis._mode = 1;\n\t\t\t\tthis._singleRuntime = runtime;\n\t\t\t\tthis._singleValue = value;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (runtimeEqual(this._singleRuntime, runtime)) {\n\t\t\t\t\tthis._singleValue = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis._mode = 2;\n\t\t\t\tthis._map = new Map();\n\t\t\t\tthis._map.set(getRuntimeKey(this._singleRuntime), this._singleValue);\n\t\t\t\tthis._singleRuntime = undefined;\n\t\t\t\tthis._singleValue = undefined;\n\t\t\t/* falls through */\n\t\t\tdefault:\n\t\t\t\tthis._map.set(getRuntimeKey(runtime), value);\n\t\t}\n\t}\n\n\tprovide(runtime, computer) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\tthis._mode = 1;\n\t\t\t\tthis._singleRuntime = runtime;\n\t\t\t\treturn (this._singleValue = computer());\n\t\t\tcase 1: {\n\t\t\t\tif (runtimeEqual(this._singleRuntime, runtime)) {\n\t\t\t\t\treturn this._singleValue;\n\t\t\t\t}\n\t\t\t\tthis._mode = 2;\n\t\t\t\tthis._map = new Map();\n\t\t\t\tthis._map.set(getRuntimeKey(this._singleRuntime), this._singleValue);\n\t\t\t\tthis._singleRuntime = undefined;\n\t\t\t\tthis._singleValue = undefined;\n\t\t\t\tconst newValue = computer();\n\t\t\t\tthis._map.set(getRuntimeKey(runtime), newValue);\n\t\t\t\treturn newValue;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tconst key = getRuntimeKey(runtime);\n\t\t\t\tconst value = this._map.get(key);\n\t\t\t\tif (value !== undefined) return value;\n\t\t\t\tconst newValue = computer();\n\t\t\t\tthis._map.set(key, newValue);\n\t\t\t\treturn newValue;\n\t\t\t}\n\t\t}\n\t}\n\n\tdelete(runtime) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn;\n\t\t\tcase 1:\n\t\t\t\tif (runtimeEqual(this._singleRuntime, runtime)) {\n\t\t\t\t\tthis._mode = 0;\n\t\t\t\t\tthis._singleRuntime = undefined;\n\t\t\t\t\tthis._singleValue = undefined;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\tdefault:\n\t\t\t\tthis._map.delete(getRuntimeKey(runtime));\n\t\t}\n\t}\n\n\tupdate(runtime, fn) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\tthrow new Error(\"runtime passed to update must exist\");\n\t\t\tcase 1: {\n\t\t\t\tif (runtimeEqual(this._singleRuntime, runtime)) {\n\t\t\t\t\tthis._singleValue = fn(this._singleValue);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst newValue = fn(undefined);\n\t\t\t\tif (newValue !== undefined) {\n\t\t\t\t\tthis._mode = 2;\n\t\t\t\t\tthis._map = new Map();\n\t\t\t\t\tthis._map.set(getRuntimeKey(this._singleRuntime), this._singleValue);\n\t\t\t\t\tthis._singleRuntime = undefined;\n\t\t\t\t\tthis._singleValue = undefined;\n\t\t\t\t\tthis._map.set(getRuntimeKey(runtime), newValue);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tconst key = getRuntimeKey(runtime);\n\t\t\t\tconst oldValue = this._map.get(key);\n\t\t\t\tconst newValue = fn(oldValue);\n\t\t\t\tif (newValue !== oldValue) this._map.set(key, newValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tkeys() {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn [];\n\t\t\tcase 1:\n\t\t\t\treturn [this._singleRuntime];\n\t\t\tdefault:\n\t\t\t\treturn Array.from(this._map.keys(), keyToRuntime);\n\t\t}\n\t}\n\n\tvalues() {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn [][Symbol.iterator]();\n\t\t\tcase 1:\n\t\t\t\treturn [this._singleValue][Symbol.iterator]();\n\t\t\tdefault:\n\t\t\t\treturn this._map.values();\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (this._mode <= 1) return this._mode;\n\t\treturn this._map.size;\n\t}\n}\n\nexports.RuntimeSpecMap = RuntimeSpecMap;\n\nclass RuntimeSpecSet {\n\tconstructor(iterable) {\n\t\t/** @type {Map<string, RuntimeSpec>} */\n\t\tthis._map = new Map();\n\t\tif (iterable) {\n\t\t\tfor (const item of iterable) {\n\t\t\t\tthis.add(item);\n\t\t\t}\n\t\t}\n\t}\n\n\tadd(runtime) {\n\t\tthis._map.set(getRuntimeKey(runtime), runtime);\n\t}\n\n\thas(runtime) {\n\t\treturn this._map.has(getRuntimeKey(runtime));\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn this._map.values();\n\t}\n\n\tget size() {\n\t\treturn this._map.size;\n\t}\n}\n\nexports.RuntimeSpecSet = RuntimeSpecSet;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}