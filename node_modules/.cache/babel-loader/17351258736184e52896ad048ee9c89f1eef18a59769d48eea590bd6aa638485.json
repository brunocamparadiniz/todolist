{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/**\n * @template K\n * @template V\n */\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar StackedCacheMap = /*#__PURE__*/function (_Symbol$iterator) {\n  function StackedCacheMap() {\n    _classCallCheck(this, StackedCacheMap);\n    /** @type {Map<K, V>} */\n    this.map = new Map();\n    /** @type {ReadonlyMap<K, V>[]} */\n    this.stack = [];\n  }\n\n  /**\n   * @param {ReadonlyMap<K, V>} map map to add\n   * @param {boolean} immutable if 'map' is immutable and StackedCacheMap can keep referencing it\n   */\n  _createClass(StackedCacheMap, [{\n    key: \"addAll\",\n    value: function addAll(map, immutable) {\n      if (immutable) {\n        this.stack.push(map);\n\n        // largest map should go first\n        for (var i = this.stack.length - 1; i > 0; i--) {\n          var beforeLast = this.stack[i - 1];\n          if (beforeLast.size >= map.size) break;\n          this.stack[i] = beforeLast;\n          this.stack[i - 1] = map;\n        }\n      } else {\n        var _iterator = _createForOfIteratorHelper(map),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n              key = _step$value[0],\n              value = _step$value[1];\n            this.map.set(key, value);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    }\n\n    /**\n     * @param {K} item the key of the element to add\n     * @param {V} value the value of the element to add\n     * @returns {void}\n     */\n  }, {\n    key: \"set\",\n    value: function set(item, value) {\n      this.map.set(item, value);\n    }\n\n    /**\n     * @param {K} item the item to delete\n     * @returns {void}\n     */\n  }, {\n    key: \"delete\",\n    value: function _delete(item) {\n      throw new Error(\"Items can't be deleted from a StackedCacheMap\");\n    }\n\n    /**\n     * @param {K} item the item to test\n     * @returns {boolean} true if the item exists in this set\n     */\n  }, {\n    key: \"has\",\n    value: function has(item) {\n      throw new Error(\"Checking StackedCacheMap.has before reading is inefficient, use StackedCacheMap.get and check for undefined\");\n    }\n\n    /**\n     * @param {K} item the key of the element to return\n     * @returns {V} the value of the element\n     */\n  }, {\n    key: \"get\",\n    value: function get(item) {\n      var _iterator2 = _createForOfIteratorHelper(this.stack),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var map = _step2.value;\n          var value = map.get(item);\n          if (value !== undefined) return value;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return this.map.get(item);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.stack.length = 0;\n      this.map.clear();\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      var size = this.map.size;\n      var _iterator3 = _createForOfIteratorHelper(this.stack),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var map = _step3.value;\n          size += map.size;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return size;\n    }\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      var iterators = this.stack.map(function (map) {\n        return map[Symbol.iterator]();\n      });\n      var current = this.map[Symbol.iterator]();\n      return {\n        next: function next() {\n          var result = current.next();\n          while (result.done && iterators.length > 0) {\n            current = iterators.pop();\n            result = current.next();\n          }\n          return result;\n        }\n      };\n    }\n  }]);\n  return StackedCacheMap;\n}(Symbol.iterator);\nmodule.exports = StackedCacheMap;","map":{"version":3,"names":["StackedCacheMap","map","Map","stack","immutable","push","i","length","beforeLast","size","key","value","set","item","Error","get","undefined","clear","iterators","Symbol","iterator","current","next","result","done","pop","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/util/StackedCacheMap.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/**\n * @template K\n * @template V\n */\nclass StackedCacheMap {\n\tconstructor() {\n\t\t/** @type {Map<K, V>} */\n\t\tthis.map = new Map();\n\t\t/** @type {ReadonlyMap<K, V>[]} */\n\t\tthis.stack = [];\n\t}\n\n\t/**\n\t * @param {ReadonlyMap<K, V>} map map to add\n\t * @param {boolean} immutable if 'map' is immutable and StackedCacheMap can keep referencing it\n\t */\n\taddAll(map, immutable) {\n\t\tif (immutable) {\n\t\t\tthis.stack.push(map);\n\n\t\t\t// largest map should go first\n\t\t\tfor (let i = this.stack.length - 1; i > 0; i--) {\n\t\t\t\tconst beforeLast = this.stack[i - 1];\n\t\t\t\tif (beforeLast.size >= map.size) break;\n\t\t\t\tthis.stack[i] = beforeLast;\n\t\t\t\tthis.stack[i - 1] = map;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const [key, value] of map) {\n\t\t\t\tthis.map.set(key, value);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {K} item the key of the element to add\n\t * @param {V} value the value of the element to add\n\t * @returns {void}\n\t */\n\tset(item, value) {\n\t\tthis.map.set(item, value);\n\t}\n\n\t/**\n\t * @param {K} item the item to delete\n\t * @returns {void}\n\t */\n\tdelete(item) {\n\t\tthrow new Error(\"Items can't be deleted from a StackedCacheMap\");\n\t}\n\n\t/**\n\t * @param {K} item the item to test\n\t * @returns {boolean} true if the item exists in this set\n\t */\n\thas(item) {\n\t\tthrow new Error(\n\t\t\t\"Checking StackedCacheMap.has before reading is inefficient, use StackedCacheMap.get and check for undefined\"\n\t\t);\n\t}\n\n\t/**\n\t * @param {K} item the key of the element to return\n\t * @returns {V} the value of the element\n\t */\n\tget(item) {\n\t\tfor (const map of this.stack) {\n\t\t\tconst value = map.get(item);\n\t\t\tif (value !== undefined) return value;\n\t\t}\n\t\treturn this.map.get(item);\n\t}\n\n\tclear() {\n\t\tthis.stack.length = 0;\n\t\tthis.map.clear();\n\t}\n\n\tget size() {\n\t\tlet size = this.map.size;\n\t\tfor (const map of this.stack) {\n\t\t\tsize += map.size;\n\t\t}\n\t\treturn size;\n\t}\n\n\t[Symbol.iterator]() {\n\t\tconst iterators = this.stack.map(map => map[Symbol.iterator]());\n\t\tlet current = this.map[Symbol.iterator]();\n\t\treturn {\n\t\t\tnext() {\n\t\t\t\tlet result = current.next();\n\t\t\t\twhile (result.done && iterators.length > 0) {\n\t\t\t\t\tcurrent = iterators.pop();\n\t\t\t\t\tresult = current.next();\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\t}\n}\n\nmodule.exports = StackedCacheMap;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA,IAIMA,eAAe;EACpB,2BAAc;IAAA;IACb;IACA,IAAI,CAACC,GAAG,GAAG,IAAIC,GAAG,EAAE;IACpB;IACA,IAAI,CAACC,KAAK,GAAG,EAAE;EAChB;;EAEA;AACD;AACA;AACA;EAHC;IAAA;IAAA,OAIA,gBAAOF,GAAG,EAAEG,SAAS,EAAE;MACtB,IAAIA,SAAS,EAAE;QACd,IAAI,CAACD,KAAK,CAACE,IAAI,CAACJ,GAAG,CAAC;;QAEpB;QACA,KAAK,IAAIK,CAAC,GAAG,IAAI,CAACH,KAAK,CAACI,MAAM,GAAG,CAAC,EAAED,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;UAC/C,IAAME,UAAU,GAAG,IAAI,CAACL,KAAK,CAACG,CAAC,GAAG,CAAC,CAAC;UACpC,IAAIE,UAAU,CAACC,IAAI,IAAIR,GAAG,CAACQ,IAAI,EAAE;UACjC,IAAI,CAACN,KAAK,CAACG,CAAC,CAAC,GAAGE,UAAU;UAC1B,IAAI,CAACL,KAAK,CAACG,CAAC,GAAG,CAAC,CAAC,GAAGL,GAAG;QACxB;MACD,CAAC,MAAM;QAAA,2CACqBA,GAAG;UAAA;QAAA;UAA9B,oDAAgC;YAAA;cAApBS,GAAG;cAAEC,KAAK;YACrB,IAAI,CAACV,GAAG,CAACW,GAAG,CAACF,GAAG,EAAEC,KAAK,CAAC;UACzB;QAAC;UAAA;QAAA;UAAA;QAAA;MACF;IACD;;IAEA;AACD;AACA;AACA;AACA;EAJC;IAAA;IAAA,OAKA,aAAIE,IAAI,EAAEF,KAAK,EAAE;MAChB,IAAI,CAACV,GAAG,CAACW,GAAG,CAACC,IAAI,EAAEF,KAAK,CAAC;IAC1B;;IAEA;AACD;AACA;AACA;EAHC;IAAA;IAAA,OAIA,iBAAOE,IAAI,EAAE;MACZ,MAAM,IAAIC,KAAK,CAAC,+CAA+C,CAAC;IACjE;;IAEA;AACD;AACA;AACA;EAHC;IAAA;IAAA,OAIA,aAAID,IAAI,EAAE;MACT,MAAM,IAAIC,KAAK,CACd,6GAA6G,CAC7G;IACF;;IAEA;AACD;AACA;AACA;EAHC;IAAA;IAAA,OAIA,aAAID,IAAI,EAAE;MAAA,4CACS,IAAI,CAACV,KAAK;QAAA;MAAA;QAA5B,uDAA8B;UAAA,IAAnBF,GAAG;UACb,IAAMU,KAAK,GAAGV,GAAG,CAACc,GAAG,CAACF,IAAI,CAAC;UAC3B,IAAIF,KAAK,KAAKK,SAAS,EAAE,OAAOL,KAAK;QACtC;MAAC;QAAA;MAAA;QAAA;MAAA;MACD,OAAO,IAAI,CAACV,GAAG,CAACc,GAAG,CAACF,IAAI,CAAC;IAC1B;EAAC;IAAA;IAAA,OAED,iBAAQ;MACP,IAAI,CAACV,KAAK,CAACI,MAAM,GAAG,CAAC;MACrB,IAAI,CAACN,GAAG,CAACgB,KAAK,EAAE;IACjB;EAAC;IAAA;IAAA,KAED,eAAW;MACV,IAAIR,IAAI,GAAG,IAAI,CAACR,GAAG,CAACQ,IAAI;MAAC,4CACP,IAAI,CAACN,KAAK;QAAA;MAAA;QAA5B,uDAA8B;UAAA,IAAnBF,GAAG;UACbQ,IAAI,IAAIR,GAAG,CAACQ,IAAI;QACjB;MAAC;QAAA;MAAA;QAAA;MAAA;MACD,OAAOA,IAAI;IACZ;EAAC;IAAA;IAAA,OAED,iBAAoB;MACnB,IAAMS,SAAS,GAAG,IAAI,CAACf,KAAK,CAACF,GAAG,CAAC,UAAAA,GAAG;QAAA,OAAIA,GAAG,CAACkB,MAAM,CAACC,QAAQ,CAAC,EAAE;MAAA,EAAC;MAC/D,IAAIC,OAAO,GAAG,IAAI,CAACpB,GAAG,CAACkB,MAAM,CAACC,QAAQ,CAAC,EAAE;MACzC,OAAO;QACNE,IAAI,kBAAG;UACN,IAAIC,MAAM,GAAGF,OAAO,CAACC,IAAI,EAAE;UAC3B,OAAOC,MAAM,CAACC,IAAI,IAAIN,SAAS,CAACX,MAAM,GAAG,CAAC,EAAE;YAC3Cc,OAAO,GAAGH,SAAS,CAACO,GAAG,EAAE;YACzBF,MAAM,GAAGF,OAAO,CAACC,IAAI,EAAE;UACxB;UACA,OAAOC,MAAM;QACd;MACD,CAAC;IACF;EAAC;EAAA;AAAA,EAbAJ,MAAM,CAACC,QAAQ;AAgBjBM,MAAM,CAACC,OAAO,GAAG3B,eAAe"},"metadata":{},"sourceType":"script","externalDependencies":[]}