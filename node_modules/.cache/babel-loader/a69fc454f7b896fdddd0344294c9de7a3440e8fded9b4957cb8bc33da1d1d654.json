{"ast":null,"code":"var _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sourceMap = {}));\n})(this, function (exports) {\n  'use strict';\n\n  var comma = ','.charCodeAt(0);\n  var semicolon = ';'.charCodeAt(0);\n  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  var intToChar = new Uint8Array(64); // 64 possible chars.\n  var charToInteger = new Uint8Array(128); // z is 122 in ASCII\n  for (var i = 0; i < chars.length; i++) {\n    var c = chars.charCodeAt(i);\n    charToInteger[c] = i;\n    intToChar[i] = c;\n  }\n  // Provide a fallback for older environments.\n  var td = typeof TextDecoder !== 'undefined' ? new TextDecoder() : typeof Buffer !== 'undefined' ? {\n    decode: function decode(buf) {\n      var out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n      return out.toString();\n    }\n  } : {\n    decode: function decode(buf) {\n      var out = '';\n      for (var _i = 0; _i < buf.length; _i++) {\n        out += String.fromCharCode(buf[_i]);\n      }\n      return out;\n    }\n  };\n  function decode(mappings) {\n    var state = new Int32Array(5);\n    var decoded = [];\n    var line = [];\n    var sorted = true;\n    var lastCol = 0;\n    for (var _i2 = 0; _i2 < mappings.length;) {\n      var _c = mappings.charCodeAt(_i2);\n      if (_c === comma) {\n        _i2++;\n      } else if (_c === semicolon) {\n        state[0] = lastCol = 0;\n        if (!sorted) sort(line);\n        sorted = true;\n        decoded.push(line);\n        line = [];\n        _i2++;\n      } else {\n        _i2 = decodeInteger(mappings, _i2, state, 0); // generatedCodeColumn\n        var col = state[0];\n        if (col < lastCol) sorted = false;\n        lastCol = col;\n        if (!hasMoreSegments(mappings, _i2)) {\n          line.push([col]);\n          continue;\n        }\n        _i2 = decodeInteger(mappings, _i2, state, 1); // sourceFileIndex\n        _i2 = decodeInteger(mappings, _i2, state, 2); // sourceCodeLine\n        _i2 = decodeInteger(mappings, _i2, state, 3); // sourceCodeColumn\n        if (!hasMoreSegments(mappings, _i2)) {\n          line.push([col, state[1], state[2], state[3]]);\n          continue;\n        }\n        _i2 = decodeInteger(mappings, _i2, state, 4); // nameIndex\n        line.push([col, state[1], state[2], state[3], state[4]]);\n      }\n    }\n    if (!sorted) sort(line);\n    decoded.push(line);\n    return decoded;\n  }\n  function decodeInteger(mappings, pos, state, j) {\n    var value = 0;\n    var shift = 0;\n    var integer = 0;\n    do {\n      var _c2 = mappings.charCodeAt(pos++);\n      integer = charToInteger[_c2];\n      value |= (integer & 31) << shift;\n      shift += 5;\n    } while (integer & 32);\n    var shouldNegate = value & 1;\n    value >>>= 1;\n    if (shouldNegate) {\n      value = -0x80000000 | -value;\n    }\n    state[j] += value;\n    return pos;\n  }\n  function hasMoreSegments(mappings, i) {\n    if (i >= mappings.length) return false;\n    var c = mappings.charCodeAt(i);\n    if (c === comma || c === semicolon) return false;\n    return true;\n  }\n  function sort(line) {\n    line.sort(sortComparator$1);\n  }\n  function sortComparator$1(a, b) {\n    return a[0] - b[0];\n  }\n  function encode(decoded) {\n    var state = new Int32Array(5);\n    var buf = new Uint8Array(1024);\n    var pos = 0;\n    for (var _i3 = 0; _i3 < decoded.length; _i3++) {\n      var line = decoded[_i3];\n      if (_i3 > 0) {\n        buf = reserve(buf, pos, 1);\n        buf[pos++] = semicolon;\n      }\n      if (line.length === 0) continue;\n      state[0] = 0;\n      for (var j = 0; j < line.length; j++) {\n        var segment = line[j];\n        // We can push up to 5 ints, each int can take at most 7 chars, and we\n        // may push a comma.\n        buf = reserve(buf, pos, 36);\n        if (j > 0) buf[pos++] = comma;\n        pos = encodeInteger(buf, pos, state, segment, 0); // generatedCodeColumn\n        if (segment.length === 1) continue;\n        pos = encodeInteger(buf, pos, state, segment, 1); // sourceFileIndex\n        pos = encodeInteger(buf, pos, state, segment, 2); // sourceCodeLine\n        pos = encodeInteger(buf, pos, state, segment, 3); // sourceCodeColumn\n        if (segment.length === 4) continue;\n        pos = encodeInteger(buf, pos, state, segment, 4); // nameIndex\n      }\n    }\n\n    return td.decode(buf.subarray(0, pos));\n  }\n  function reserve(buf, pos, count) {\n    if (buf.length > pos + count) return buf;\n    var swap = new Uint8Array(buf.length * 2);\n    swap.set(buf);\n    return swap;\n  }\n  function encodeInteger(buf, pos, state, segment, j) {\n    var next = segment[j];\n    var num = next - state[j];\n    state[j] = next;\n    num = num < 0 ? -num << 1 | 1 : num << 1;\n    do {\n      var clamped = num & 31;\n      num >>>= 5;\n      if (num > 0) clamped |= 32;\n      buf[pos++] = intToChar[clamped];\n    } while (num > 0);\n    return pos;\n  }\n\n  // Matches the scheme of a URL, eg \"http://\"\n  var schemeRegex = /^[\\w+.-]+:\\/\\//;\n  /**\n   * Matches the parts of a URL:\n   * 1. Scheme, including \":\", guaranteed.\n   * 2. User/password, including \"@\", optional.\n   * 3. Host, guaranteed.\n   * 4. Port, including \":\", optional.\n   * 5. Path, including \"/\", optional.\n   */\n  var urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?/;\n  /**\n   * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n   * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n   *\n   * 1. Host, optional.\n   * 2. Path, which may inclue \"/\", guaranteed.\n   */\n  var fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/]*)?)?(\\/?.*)/i;\n  function isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n  }\n  function isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n  }\n  function isAbsolutePath(input) {\n    return input.startsWith('/');\n  }\n  function isFileUrl(input) {\n    return input.startsWith('file:');\n  }\n  function parseAbsoluteUrl(input) {\n    var match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/');\n  }\n  function parseFileUrl(input) {\n    var match = fileRegex.exec(input);\n    var path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path);\n  }\n  function makeUrl(scheme, user, host, port, path) {\n    return {\n      scheme: scheme,\n      user: user,\n      host: host,\n      port: port,\n      path: path,\n      relativePath: false\n    };\n  }\n  function parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n      var _url = parseAbsoluteUrl('http:' + input);\n      _url.scheme = '';\n      return _url;\n    }\n    if (isAbsolutePath(input)) {\n      var _url2 = parseAbsoluteUrl('http://foo.com' + input);\n      _url2.scheme = '';\n      _url2.host = '';\n      return _url2;\n    }\n    if (isFileUrl(input)) return parseFileUrl(input);\n    if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n    var url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.relativePath = true;\n    return url;\n  }\n  function stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..')) return path;\n    var index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n  }\n  function mergePaths(url, base) {\n    // If we're not a relative path, then we're an absolute path, and it doesn't matter what base is.\n    if (!url.relativePath) return;\n    normalizePath(base);\n    // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n    if (url.path === '/') {\n      url.path = base.path;\n    } else {\n      // Resolution happens relative to the base path's directory, not the file.\n      url.path = stripPathFilename(base.path) + url.path;\n    }\n    // If the base path is absolute, then our path is now absolute too.\n    url.relativePath = base.relativePath;\n  }\n  /**\n   * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n   * \"foo/.\". We need to normalize to a standard representation.\n   */\n  function normalizePath(url) {\n    var relativePath = url.relativePath;\n    var pieces = url.path.split('/');\n    // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n    var pointer = 1;\n    // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n    var positive = 0;\n    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n    var addTrailingSlash = false;\n    for (var _i4 = 1; _i4 < pieces.length; _i4++) {\n      var piece = pieces[_i4];\n      // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n      if (!piece) {\n        addTrailingSlash = true;\n        continue;\n      }\n      // If we encounter a real directory, then we don't need to append anymore.\n      addTrailingSlash = false;\n      // A current directory, which we can always drop.\n      if (piece === '.') continue;\n      // A parent directory, we need to see if there are any real directories we can pop. Else, we\n      // have an excess of parents, and we'll need to keep the \"..\".\n      if (piece === '..') {\n        if (positive) {\n          addTrailingSlash = true;\n          positive--;\n          pointer--;\n        } else if (relativePath) {\n          // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n          // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n          pieces[pointer++] = piece;\n        }\n        continue;\n      }\n      // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n      // any popped or dropped directories.\n      pieces[pointer++] = piece;\n      positive++;\n    }\n    var path = '';\n    for (var _i5 = 1; _i5 < pointer; _i5++) {\n      path += '/' + pieces[_i5];\n    }\n    if (!path || addTrailingSlash && !path.endsWith('/..')) {\n      path += '/';\n    }\n    url.path = path;\n  }\n  /**\n   * Attempts to resolve `input` URL/path relative to `base`.\n   */\n  function resolve$1(input, base) {\n    if (!input && !base) return '';\n    var url = parseUrl(input);\n    // If we have a base, and the input isn't already an absolute URL, then we need to merge.\n    if (base && !url.scheme) {\n      var baseUrl = parseUrl(base);\n      url.scheme = baseUrl.scheme;\n      // If there's no host, then we were just a path.\n      if (!url.host) {\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      }\n      mergePaths(url, baseUrl);\n    }\n    normalizePath(url);\n    // If the input (and base, if there was one) are both relative, then we need to output a relative.\n    if (url.relativePath) {\n      // The first char is always a \"/\".\n      var path = url.path.slice(1);\n      if (!path) return '.';\n      // If base started with a leading \".\", or there is no base and input started with a \".\", then we\n      // need to ensure that the relative path starts with a \".\". We don't know if relative starts\n      // with a \"..\", though, so check before prepending.\n      var keepRelative = (base || input).startsWith('.');\n      return !keepRelative || path.startsWith('.') ? path : './' + path;\n    }\n    // If there's no host (and no scheme/user/port), then we need to output an absolute path.\n    if (!url.scheme && !url.host) return url.path;\n    // We're outputting either an absolute URL, or a protocol relative one.\n    return \"\".concat(url.scheme, \"//\").concat(url.user).concat(url.host).concat(url.port).concat(url.path);\n  }\n  function resolve(input, base) {\n    // The base is always treated as a directory, if it's not empty.\n    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n    if (base && !base.endsWith('/')) base += '/';\n    return resolve$1(input, base);\n  }\n\n  /**\n   * Removes everything after the last \"/\", but leaves the slash.\n   */\n  function stripFilename(path) {\n    if (!path) return '';\n    var index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n  }\n  var COLUMN$1 = 0;\n  var SOURCES_INDEX$1 = 1;\n  var SOURCE_LINE$1 = 2;\n  var SOURCE_COLUMN$1 = 3;\n  var NAMES_INDEX$1 = 4;\n  function maybeSort(mappings, owned) {\n    var unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n    if (unsortedIndex === mappings.length) return mappings;\n    // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n    // not, we do not want to modify the consumer's input array.\n    if (!owned) mappings = mappings.slice();\n    for (var _i6 = unsortedIndex; _i6 < mappings.length; _i6 = nextUnsortedSegmentLine(mappings, _i6 + 1)) {\n      mappings[_i6] = sortSegments(mappings[_i6], owned);\n    }\n    return mappings;\n  }\n  function nextUnsortedSegmentLine(mappings, start) {\n    for (var _i7 = start; _i7 < mappings.length; _i7++) {\n      if (!isSorted(mappings[_i7])) return _i7;\n    }\n    return mappings.length;\n  }\n  function isSorted(line) {\n    for (var j = 1; j < line.length; j++) {\n      if (line[j][COLUMN$1] < line[j - 1][COLUMN$1]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function sortSegments(line, owned) {\n    if (!owned) line = line.slice();\n    return line.sort(sortComparator);\n  }\n  function sortComparator(a, b) {\n    return a[COLUMN$1] - b[COLUMN$1];\n  }\n  var found = false;\n  /**\n   * A binary search implementation that returns the index if a match is found.\n   * If no match is found, then the left-index (the index associated with the item that comes just\n   * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n   * the next index:\n   *\n   * ```js\n   * const array = [1, 3];\n   * const needle = 2;\n   * const index = binarySearch(array, needle, (item, needle) => item - needle);\n   *\n   * assert.equal(index, 0);\n   * array.splice(index + 1, 0, needle);\n   * assert.deepEqual(array, [1, 2, 3]);\n   * ```\n   */\n  function binarySearch(haystack, needle, low, high) {\n    while (low <= high) {\n      var mid = low + (high - low >> 1);\n      var cmp = haystack[mid][COLUMN$1] - needle;\n      if (cmp === 0) {\n        found = true;\n        return mid;\n      }\n      if (cmp < 0) {\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n    found = false;\n    return low - 1;\n  }\n  function upperBound(haystack, needle, index) {\n    for (var _i8 = index + 1; _i8 < haystack.length; _i8++, index++) {\n      if (haystack[_i8][COLUMN$1] !== needle) break;\n    }\n    return index;\n  }\n  function lowerBound(haystack, needle, index) {\n    for (var _i9 = index - 1; _i9 >= 0; _i9--, index--) {\n      if (haystack[_i9][COLUMN$1] !== needle) break;\n    }\n    return index;\n  }\n  function memoizedState() {\n    return {\n      lastKey: -1,\n      lastNeedle: -1,\n      lastIndex: -1\n    };\n  }\n  /**\n   * This overly complicated beast is just to record the last tested line/column and the resulting\n   * index, allowing us to skip a few tests if mappings are monotonically increasing.\n   */\n  function memoizedBinarySearch(haystack, needle, state, key) {\n    var lastKey = state.lastKey,\n      lastNeedle = state.lastNeedle,\n      lastIndex = state.lastIndex;\n    var low = 0;\n    var high = haystack.length - 1;\n    if (key === lastKey) {\n      if (needle === lastNeedle) {\n        found = lastIndex !== -1 && haystack[lastIndex][COLUMN$1] === needle;\n        return lastIndex;\n      }\n      if (needle >= lastNeedle) {\n        // lastIndex may be -1 if the previous needle was not found.\n        low = lastIndex === -1 ? 0 : lastIndex;\n      } else {\n        high = lastIndex;\n      }\n    }\n    state.lastKey = key;\n    state.lastNeedle = needle;\n    return state.lastIndex = binarySearch(haystack, needle, low, high);\n  }\n  var AnyMap = function AnyMap(map, mapUrl) {\n    var parsed = typeof map === 'string' ? JSON.parse(map) : map;\n    if (!('sections' in parsed)) return new TraceMap(parsed, mapUrl);\n    var mappings = [];\n    var sources = [];\n    var sourcesContent = [];\n    var names = [];\n    var sections = parsed.sections;\n    var i = 0;\n    for (; i < sections.length - 1; i++) {\n      var no = sections[i + 1].offset;\n      addSection(sections[i], mapUrl, mappings, sources, sourcesContent, names, no.line, no.column);\n    }\n    if (sections.length > 0) {\n      addSection(sections[i], mapUrl, mappings, sources, sourcesContent, names, Infinity, Infinity);\n    }\n    var joined = {\n      version: 3,\n      file: parsed.file,\n      names: names,\n      sources: sources,\n      sourcesContent: sourcesContent,\n      mappings: mappings\n    };\n    return presortedDecodedMap(joined);\n  };\n  function addSection(section, mapUrl, mappings, sources, sourcesContent, names, stopLine, stopColumn) {\n    var map = AnyMap(section.map, mapUrl);\n    var _section$offset = section.offset,\n      lineOffset = _section$offset.line,\n      columnOffset = _section$offset.column;\n    var sourcesOffset = sources.length;\n    var namesOffset = names.length;\n    var decoded = decodedMappings(map);\n    var resolvedSources = map.resolvedSources;\n    append(sources, resolvedSources);\n    append(sourcesContent, map.sourcesContent || fillSourcesContent(resolvedSources.length));\n    append(names, map.names);\n    // If this section jumps forwards several lines, we need to add lines to the output mappings catch up.\n    for (var _i10 = mappings.length; _i10 <= lineOffset; _i10++) mappings.push([]);\n    // We can only add so many lines before we step into the range that the next section's map\n    // controls. When we get to the last line, then we'll start checking the segments to see if\n    // they've crossed into the column range.\n    var stopI = stopLine - lineOffset;\n    var len = Math.min(decoded.length, stopI + 1);\n    for (var _i11 = 0; _i11 < len; _i11++) {\n      var line = decoded[_i11];\n      // On the 0th loop, the line will already exist due to a previous section, or the line catch up\n      // loop above.\n      var out = _i11 === 0 ? mappings[lineOffset] : mappings[lineOffset + _i11] = [];\n      // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n      // map can be multiple lines), it doesn't.\n      var cOffset = _i11 === 0 ? columnOffset : 0;\n      for (var j = 0; j < line.length; j++) {\n        var seg = line[j];\n        var column = cOffset + seg[COLUMN$1];\n        // If this segment steps into the column range that the next section's map controls, we need\n        // to stop early.\n        if (_i11 === stopI && column >= stopColumn) break;\n        if (seg.length === 1) {\n          out.push([column]);\n          continue;\n        }\n        var sourcesIndex = sourcesOffset + seg[SOURCES_INDEX$1];\n        var sourceLine = seg[SOURCE_LINE$1];\n        var sourceColumn = seg[SOURCE_COLUMN$1];\n        if (seg.length === 4) {\n          out.push([column, sourcesIndex, sourceLine, sourceColumn]);\n          continue;\n        }\n        out.push([column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX$1]]);\n      }\n    }\n  }\n  function append(arr, other) {\n    for (var _i12 = 0; _i12 < other.length; _i12++) arr.push(other[_i12]);\n  }\n  // Sourcemaps don't need to have sourcesContent, and if they don't, we need to create an array of\n  // equal length to the sources. This is because the sources and sourcesContent are paired arrays,\n  // where `sourcesContent[i]` is the content of the `sources[i]` file. If we didn't, then joined\n  // sourcemap would desynchronize the sources/contents.\n  function fillSourcesContent(len) {\n    var sourcesContent = [];\n    for (var _i13 = 0; _i13 < len; _i13++) sourcesContent[_i13] = null;\n    return sourcesContent;\n  }\n  var INVALID_ORIGINAL_MAPPING = Object.freeze({\n    source: null,\n    line: null,\n    column: null,\n    name: null\n  });\n  Object.freeze({\n    line: null,\n    column: null\n  });\n  var LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\n  var COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n  var LEAST_UPPER_BOUND = -1;\n  var GREATEST_LOWER_BOUND = 1;\n  /**\n   * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n   */\n  var decodedMappings;\n  /**\n   * A higher-level API to find the source/line/column associated with a generated line/column\n   * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n   * `source-map` library.\n   */\n  var _originalPositionFor;\n  /**\n   * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n   * maps.\n   */\n  var presortedDecodedMap;\n  var TraceMap = /*#__PURE__*/_createClass(function TraceMap(map, mapUrl) {\n    _classCallCheck(this, TraceMap);\n    this._decodedMemo = memoizedState();\n    this._bySources = undefined;\n    this._bySourceMemos = undefined;\n    var isString = typeof map === 'string';\n    if (!isString && map.constructor === TraceMap) return map;\n    var parsed = isString ? JSON.parse(map) : map;\n    var version = parsed.version,\n      file = parsed.file,\n      names = parsed.names,\n      sourceRoot = parsed.sourceRoot,\n      sources = parsed.sources,\n      sourcesContent = parsed.sourcesContent;\n    this.version = version;\n    this.file = file;\n    this.names = names;\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n    if (sourceRoot || mapUrl) {\n      var from = resolve(sourceRoot || '', stripFilename(mapUrl));\n      this.resolvedSources = sources.map(function (s) {\n        return resolve(s || '', from);\n      });\n    } else {\n      this.resolvedSources = sources.map(function (s) {\n        return s || '';\n      });\n    }\n    var mappings = parsed.mappings;\n    if (typeof mappings === 'string') {\n      this._encoded = mappings;\n      this._decoded = undefined;\n    } else {\n      this._encoded = undefined;\n      this._decoded = maybeSort(mappings, isString);\n    }\n  });\n  (function () {\n    decodedMappings = function decodedMappings(map) {\n      return map._decoded || (map._decoded = decode(map._encoded));\n    };\n    _originalPositionFor = function originalPositionFor(map, _ref) {\n      var line = _ref.line,\n        column = _ref.column,\n        bias = _ref.bias;\n      line--;\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n      var decoded = decodedMappings(map);\n      // It's common for parent source maps to have pointers to lines that have no\n      // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n      if (line >= decoded.length) return INVALID_ORIGINAL_MAPPING;\n      var segment = traceSegmentInternal(decoded[line], map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n      if (segment == null) return INVALID_ORIGINAL_MAPPING;\n      if (segment.length == 1) return INVALID_ORIGINAL_MAPPING;\n      var names = map.names,\n        resolvedSources = map.resolvedSources;\n      return {\n        source: resolvedSources[segment[SOURCES_INDEX$1]],\n        line: segment[SOURCE_LINE$1] + 1,\n        column: segment[SOURCE_COLUMN$1],\n        name: segment.length === 5 ? names[segment[NAMES_INDEX$1]] : null\n      };\n    };\n    presortedDecodedMap = function presortedDecodedMap(map, mapUrl) {\n      var clone = Object.assign({}, map);\n      clone.mappings = [];\n      var tracer = new TraceMap(clone, mapUrl);\n      tracer._decoded = map.mappings;\n      return tracer;\n    };\n  })();\n  function traceSegmentInternal(segments, memo, line, column, bias) {\n    var index = memoizedBinarySearch(segments, column, memo, line);\n    if (found) {\n      index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n    } else if (bias === LEAST_UPPER_BOUND) index++;\n    if (index === -1 || index === segments.length) return null;\n    return segments[index];\n  }\n\n  /**\n   * Gets the index associated with `key` in the backing array, if it is already present.\n   */\n  var get;\n  /**\n   * Puts `key` into the backing array, if it is not already present. Returns\n   * the index of the `key` in the backing array.\n   */\n  var put;\n  /**\n   * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n   * index of the `key` in the backing array.\n   *\n   * This is designed to allow synchronizing a second array with the contents of the backing array,\n   * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n   * and there are never duplicates.\n   */\n  var SetArray = /*#__PURE__*/_createClass(function SetArray() {\n    _classCallCheck(this, SetArray);\n    this._indexes = {\n      __proto__: null\n    };\n    this.array = [];\n  });\n  (function () {\n    get = function get(strarr, key) {\n      return strarr._indexes[key];\n    };\n    put = function put(strarr, key) {\n      // The key may or may not be present. If it is present, it's a number.\n      var index = get(strarr, key);\n      if (index !== undefined) return index;\n      var array = strarr.array,\n        indexes = strarr._indexes;\n      return indexes[key] = array.push(key) - 1;\n    };\n  })();\n  var COLUMN = 0;\n  var SOURCES_INDEX = 1;\n  var SOURCE_LINE = 2;\n  var SOURCE_COLUMN = 3;\n  var NAMES_INDEX = 4;\n  var NO_NAME = -1;\n  /**\n   * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n   * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n   * not add a mapping with a lower generated line/column than one that came before.\n   */\n  var maybeAddMapping;\n  /**\n   * Adds/removes the content of the source file to the source map.\n   */\n  var _setSourceContent;\n  /**\n   * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n   * a sourcemap, or to JSON.stringify.\n   */\n  var _toDecodedMap;\n  /**\n   * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n   * a sourcemap, or to JSON.stringify.\n   */\n  var toEncodedMap;\n  // This split declaration is only so that terser can elminiate the static initialization block.\n  var addSegmentInternal;\n  /**\n   * Provides the state to generate a sourcemap.\n   */\n  var GenMapping = /*#__PURE__*/_createClass(function GenMapping() {\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      file = _ref2.file,\n      sourceRoot = _ref2.sourceRoot;\n    _classCallCheck(this, GenMapping);\n    this._names = new SetArray();\n    this._sources = new SetArray();\n    this._sourcesContent = [];\n    this._mappings = [];\n    this.file = file;\n    this.sourceRoot = sourceRoot;\n  });\n  (function () {\n    maybeAddMapping = function maybeAddMapping(map, mapping) {\n      return addMappingInternal(true, map, mapping);\n    };\n    _setSourceContent = function setSourceContent(map, source, content) {\n      var sources = map._sources,\n        sourcesContent = map._sourcesContent;\n      sourcesContent[put(sources, source)] = content;\n    };\n    _toDecodedMap = function toDecodedMap(map) {\n      var file = map.file,\n        sourceRoot = map.sourceRoot,\n        mappings = map._mappings,\n        sources = map._sources,\n        sourcesContent = map._sourcesContent,\n        names = map._names;\n      removeEmptyFinalLines(mappings);\n      return {\n        version: 3,\n        file: file || undefined,\n        names: names.array,\n        sourceRoot: sourceRoot || undefined,\n        sources: sources.array,\n        sourcesContent: sourcesContent,\n        mappings: mappings\n      };\n    };\n    toEncodedMap = function toEncodedMap(map) {\n      var decoded = _toDecodedMap(map);\n      return Object.assign(Object.assign({}, decoded), {\n        mappings: encode(decoded.mappings)\n      });\n    };\n    // Internal helpers\n    addSegmentInternal = function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name) {\n      var mappings = map._mappings,\n        sources = map._sources,\n        sourcesContent = map._sourcesContent,\n        names = map._names;\n      var line = getLine(mappings, genLine);\n      var index = getColumnIndex(line, genColumn);\n      if (!source) {\n        if (skipable && skipSourceless(line, index)) return;\n        return insert(line, index, [genColumn]);\n      }\n      var sourcesIndex = put(sources, source);\n      var namesIndex = name ? put(names, name) : NO_NAME;\n      if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = null;\n      if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n        return;\n      }\n      return insert(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);\n    };\n  })();\n  function getLine(mappings, index) {\n    for (var _i14 = mappings.length; _i14 <= index; _i14++) {\n      mappings[_i14] = [];\n    }\n    return mappings[index];\n  }\n  function getColumnIndex(line, genColumn) {\n    var index = line.length;\n    for (var _i15 = index - 1; _i15 >= 0; index = _i15--) {\n      var current = line[_i15];\n      if (genColumn >= current[COLUMN]) break;\n    }\n    return index;\n  }\n  function insert(array, index, value) {\n    for (var _i16 = array.length; _i16 > index; _i16--) {\n      array[_i16] = array[_i16 - 1];\n    }\n    array[index] = value;\n  }\n  function removeEmptyFinalLines(mappings) {\n    var length = mappings.length;\n    var len = length;\n    for (var _i17 = len - 1; _i17 >= 0; len = _i17, _i17--) {\n      if (mappings[_i17].length > 0) break;\n    }\n    if (len < length) mappings.length = len;\n  }\n  function skipSourceless(line, index) {\n    // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n    // doesn't generate any useful information.\n    if (index === 0) return true;\n    var prev = line[index - 1];\n    // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n    // genrate any new information. Else, this segment will end the source/named segment and point to\n    // a sourceless position, which is useful.\n    return prev.length === 1;\n  }\n  function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n    // A source/named segment at the start of a line gives position at that genColumn\n    if (index === 0) return false;\n    var prev = line[index - 1];\n    // If the previous segment is sourceless, then we're transitioning to a source.\n    if (prev.length === 1) return false;\n    // If the previous segment maps to the exact same source position, then this segment doesn't\n    // provide any new position information.\n    return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);\n  }\n  function addMappingInternal(skipable, map, mapping) {\n    var generated = mapping.generated,\n      source = mapping.source,\n      original = mapping.original,\n      name = mapping.name;\n    if (!source) {\n      return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null);\n    }\n    var s = source;\n    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name);\n  }\n  var SourceMapConsumer = /*#__PURE__*/function () {\n    function SourceMapConsumer(map, mapUrl) {\n      _classCallCheck(this, SourceMapConsumer);\n      var trace = this._map = new AnyMap(map, mapUrl);\n      this.file = trace.file;\n      this.names = trace.names;\n      this.sourceRoot = trace.sourceRoot;\n      this.sources = trace.resolvedSources;\n      this.sourcesContent = trace.sourcesContent;\n    }\n    _createClass(SourceMapConsumer, [{\n      key: \"originalPositionFor\",\n      value: function originalPositionFor(needle) {\n        return _originalPositionFor(this._map, needle);\n      }\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        // noop.\n      }\n    }]);\n    return SourceMapConsumer;\n  }();\n  var SourceMapGenerator = /*#__PURE__*/function () {\n    function SourceMapGenerator(opts) {\n      _classCallCheck(this, SourceMapGenerator);\n      this._map = new GenMapping(opts);\n    }\n    _createClass(SourceMapGenerator, [{\n      key: \"addMapping\",\n      value: function addMapping(mapping) {\n        maybeAddMapping(this._map, mapping);\n      }\n    }, {\n      key: \"setSourceContent\",\n      value: function setSourceContent(source, content) {\n        _setSourceContent(this._map, source, content);\n      }\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        return toEncodedMap(this._map);\n      }\n    }, {\n      key: \"toDecodedMap\",\n      value: function toDecodedMap() {\n        return _toDecodedMap(this._map);\n      }\n    }]);\n    return SourceMapGenerator;\n  }();\n  exports.SourceMapConsumer = SourceMapConsumer;\n  exports.SourceMapGenerator = SourceMapGenerator;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"mappings":"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","names":["comma","charCodeAt","semicolon","chars","intToChar","Uint8Array","charToInteger","i","length","c","td","TextDecoder","Buffer","decode","buf","out","from","buffer","byteOffset","byteLength","toString","String","fromCharCode","mappings","state","Int32Array","decoded","line","sorted","lastCol","sort","push","decodeInteger","col","hasMoreSegments","pos","j","value","shift","integer","shouldNegate","sortComparator","a","b","encode","reserve","segment","encodeInteger","subarray","count","swap","set","next","num","clamped","schemeRegex","urlRegex","fileRegex","isAbsoluteUrl","input","test","isSchemeRelativeUrl","startsWith","isAbsolutePath","isFileUrl","parseAbsoluteUrl","match","exec","makeUrl","parseFileUrl","path","scheme","user","host","port","relativePath","parseUrl","url","stripPathFilename","endsWith","index","lastIndexOf","slice","mergePaths","base","normalizePath","pieces","split","pointer","positive","addTrailingSlash","piece","resolve","baseUrl","keepRelative","resolveUri","stripFilename","COLUMN","SOURCES_INDEX","SOURCE_LINE","SOURCE_COLUMN","NAMES_INDEX","maybeSort","owned","unsortedIndex","nextUnsortedSegmentLine","sortSegments","start","isSorted","found","binarySearch","haystack","needle","low","high","mid","cmp","upperBound","lowerBound","memoizedState","lastKey","lastNeedle","lastIndex","memoizedBinarySearch","key","AnyMap","map","mapUrl","parsed","JSON","parse","TraceMap","sources","sourcesContent","names","sections","no","offset","addSection","column","Infinity","joined","version","file","presortedDecodedMap","section","stopLine","stopColumn","lineOffset","columnOffset","sourcesOffset","namesOffset","decodedMappings","resolvedSources","append","fillSourcesContent","stopI","len","Math","min","cOffset","seg","sourcesIndex","sourceLine","sourceColumn","arr","other","INVALID_ORIGINAL_MAPPING","Object","freeze","source","name","LINE_GTR_ZERO","COL_GTR_EQ_ZERO","LEAST_UPPER_BOUND","GREATEST_LOWER_BOUND","originalPositionFor","_decodedMemo","_bySources","undefined","_bySourceMemos","isString","constructor","sourceRoot","s","_encoded","_decoded","bias","Error","traceSegmentInternal","clone","assign","tracer","segments","memo","get","put","SetArray","_indexes","__proto__","array","strarr","indexes","NO_NAME","maybeAddMapping","setSourceContent","toDecodedMap","toEncodedMap","addSegmentInternal","GenMapping","_names","_sources","_sourcesContent","_mappings","mapping","addMappingInternal","content","removeEmptyFinalLines","skipable","genLine","genColumn","getLine","getColumnIndex","skipSourceless","insert","namesIndex","skipSource","current","prev","generated","original","SourceMapConsumer","trace","_map","SourceMapGenerator","opts"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@jridgewell/source-map/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs","/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@jridgewell/source-map/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs","/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@jridgewell/source-map/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs","/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@jridgewell/source-map/node_modules/@jridgewell/set-array/dist/set-array.mjs","/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@jridgewell/source-map/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs","/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@jridgewell/src/source-map.ts"],"sourcesContent":["const comma = ','.charCodeAt(0);\nconst semicolon = ';'.charCodeAt(0);\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInteger = new Uint8Array(128); // z is 122 in ASCII\nfor (let i = 0; i < chars.length; i++) {\n    const c = chars.charCodeAt(i);\n    charToInteger[c] = i;\n    intToChar[i] = c;\n}\n// Provide a fallback for older environments.\nconst td = typeof TextDecoder !== 'undefined'\n    ? new TextDecoder()\n    : typeof Buffer !== 'undefined'\n        ? {\n            decode(buf) {\n                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                return out.toString();\n            },\n        }\n        : {\n            decode(buf) {\n                let out = '';\n                for (let i = 0; i < buf.length; i++) {\n                    out += String.fromCharCode(buf[i]);\n                }\n                return out;\n            },\n        };\nfunction decode(mappings) {\n    const state = new Int32Array(5);\n    const decoded = [];\n    let line = [];\n    let sorted = true;\n    let lastCol = 0;\n    for (let i = 0; i < mappings.length;) {\n        const c = mappings.charCodeAt(i);\n        if (c === comma) {\n            i++;\n        }\n        else if (c === semicolon) {\n            state[0] = lastCol = 0;\n            if (!sorted)\n                sort(line);\n            sorted = true;\n            decoded.push(line);\n            line = [];\n            i++;\n        }\n        else {\n            i = decodeInteger(mappings, i, state, 0); // generatedCodeColumn\n            const col = state[0];\n            if (col < lastCol)\n                sorted = false;\n            lastCol = col;\n            if (!hasMoreSegments(mappings, i)) {\n                line.push([col]);\n                continue;\n            }\n            i = decodeInteger(mappings, i, state, 1); // sourceFileIndex\n            i = decodeInteger(mappings, i, state, 2); // sourceCodeLine\n            i = decodeInteger(mappings, i, state, 3); // sourceCodeColumn\n            if (!hasMoreSegments(mappings, i)) {\n                line.push([col, state[1], state[2], state[3]]);\n                continue;\n            }\n            i = decodeInteger(mappings, i, state, 4); // nameIndex\n            line.push([col, state[1], state[2], state[3], state[4]]);\n        }\n    }\n    if (!sorted)\n        sort(line);\n    decoded.push(line);\n    return decoded;\n}\nfunction decodeInteger(mappings, pos, state, j) {\n    let value = 0;\n    let shift = 0;\n    let integer = 0;\n    do {\n        const c = mappings.charCodeAt(pos++);\n        integer = charToInteger[c];\n        value |= (integer & 31) << shift;\n        shift += 5;\n    } while (integer & 32);\n    const shouldNegate = value & 1;\n    value >>>= 1;\n    if (shouldNegate) {\n        value = -0x80000000 | -value;\n    }\n    state[j] += value;\n    return pos;\n}\nfunction hasMoreSegments(mappings, i) {\n    if (i >= mappings.length)\n        return false;\n    const c = mappings.charCodeAt(i);\n    if (c === comma || c === semicolon)\n        return false;\n    return true;\n}\nfunction sort(line) {\n    line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[0] - b[0];\n}\nfunction encode(decoded) {\n    const state = new Int32Array(5);\n    let buf = new Uint8Array(1024);\n    let pos = 0;\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        if (i > 0) {\n            buf = reserve(buf, pos, 1);\n            buf[pos++] = semicolon;\n        }\n        if (line.length === 0)\n            continue;\n        state[0] = 0;\n        for (let j = 0; j < line.length; j++) {\n            const segment = line[j];\n            // We can push up to 5 ints, each int can take at most 7 chars, and we\n            // may push a comma.\n            buf = reserve(buf, pos, 36);\n            if (j > 0)\n                buf[pos++] = comma;\n            pos = encodeInteger(buf, pos, state, segment, 0); // generatedCodeColumn\n            if (segment.length === 1)\n                continue;\n            pos = encodeInteger(buf, pos, state, segment, 1); // sourceFileIndex\n            pos = encodeInteger(buf, pos, state, segment, 2); // sourceCodeLine\n            pos = encodeInteger(buf, pos, state, segment, 3); // sourceCodeColumn\n            if (segment.length === 4)\n                continue;\n            pos = encodeInteger(buf, pos, state, segment, 4); // nameIndex\n        }\n    }\n    return td.decode(buf.subarray(0, pos));\n}\nfunction reserve(buf, pos, count) {\n    if (buf.length > pos + count)\n        return buf;\n    const swap = new Uint8Array(buf.length * 2);\n    swap.set(buf);\n    return swap;\n}\nfunction encodeInteger(buf, pos, state, segment, j) {\n    const next = segment[j];\n    let num = next - state[j];\n    state[j] = next;\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\n    do {\n        let clamped = num & 0b011111;\n        num >>>= 5;\n        if (num > 0)\n            clamped |= 0b100000;\n        buf[pos++] = intToChar[clamped];\n    } while (num > 0);\n    return pos;\n}\n\nexport { decode, encode };\n//# sourceMappingURL=sourcemap-codec.mjs.map\n","// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?/;\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may inclue \"/\", guaranteed.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/]*)?)?(\\/?.*)/i;\nfunction isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n}\nfunction isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n}\nfunction isAbsolutePath(input) {\n    return input.startsWith('/');\n}\nfunction isFileUrl(input) {\n    return input.startsWith('file:');\n}\nfunction parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/');\n}\nfunction parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path);\n}\nfunction makeUrl(scheme, user, host, port, path) {\n    return {\n        scheme,\n        user,\n        host,\n        port,\n        path,\n        relativePath: false,\n    };\n}\nfunction parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n        const url = parseAbsoluteUrl('http:' + input);\n        url.scheme = '';\n        return url;\n    }\n    if (isAbsolutePath(input)) {\n        const url = parseAbsoluteUrl('http://foo.com' + input);\n        url.scheme = '';\n        url.host = '';\n        return url;\n    }\n    if (isFileUrl(input))\n        return parseFileUrl(input);\n    if (isAbsoluteUrl(input))\n        return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.relativePath = true;\n    return url;\n}\nfunction stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..'))\n        return path;\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\nfunction mergePaths(url, base) {\n    // If we're not a relative path, then we're an absolute path, and it doesn't matter what base is.\n    if (!url.relativePath)\n        return;\n    normalizePath(base);\n    // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n    if (url.path === '/') {\n        url.path = base.path;\n    }\n    else {\n        // Resolution happens relative to the base path's directory, not the file.\n        url.path = stripPathFilename(base.path) + url.path;\n    }\n    // If the base path is absolute, then our path is now absolute too.\n    url.relativePath = base.relativePath;\n}\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url) {\n    const { relativePath } = url;\n    const pieces = url.path.split('/');\n    // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n    let pointer = 1;\n    // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n    let positive = 0;\n    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n    let addTrailingSlash = false;\n    for (let i = 1; i < pieces.length; i++) {\n        const piece = pieces[i];\n        // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n        if (!piece) {\n            addTrailingSlash = true;\n            continue;\n        }\n        // If we encounter a real directory, then we don't need to append anymore.\n        addTrailingSlash = false;\n        // A current directory, which we can always drop.\n        if (piece === '.')\n            continue;\n        // A parent directory, we need to see if there are any real directories we can pop. Else, we\n        // have an excess of parents, and we'll need to keep the \"..\".\n        if (piece === '..') {\n            if (positive) {\n                addTrailingSlash = true;\n                positive--;\n                pointer--;\n            }\n            else if (relativePath) {\n                // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                pieces[pointer++] = piece;\n            }\n            continue;\n        }\n        // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n        // any popped or dropped directories.\n        pieces[pointer++] = piece;\n        positive++;\n    }\n    let path = '';\n    for (let i = 1; i < pointer; i++) {\n        path += '/' + pieces[i];\n    }\n    if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n        path += '/';\n    }\n    url.path = path;\n}\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nfunction resolve(input, base) {\n    if (!input && !base)\n        return '';\n    const url = parseUrl(input);\n    // If we have a base, and the input isn't already an absolute URL, then we need to merge.\n    if (base && !url.scheme) {\n        const baseUrl = parseUrl(base);\n        url.scheme = baseUrl.scheme;\n        // If there's no host, then we were just a path.\n        if (!url.host) {\n            // The host, user, and port are joined, you can't copy one without the others.\n            url.user = baseUrl.user;\n            url.host = baseUrl.host;\n            url.port = baseUrl.port;\n        }\n        mergePaths(url, baseUrl);\n    }\n    normalizePath(url);\n    // If the input (and base, if there was one) are both relative, then we need to output a relative.\n    if (url.relativePath) {\n        // The first char is always a \"/\".\n        const path = url.path.slice(1);\n        if (!path)\n            return '.';\n        // If base started with a leading \".\", or there is no base and input started with a \".\", then we\n        // need to ensure that the relative path starts with a \".\". We don't know if relative starts\n        // with a \"..\", though, so check before prepending.\n        const keepRelative = (base || input).startsWith('.');\n        return !keepRelative || path.startsWith('.') ? path : './' + path;\n    }\n    // If there's no host (and no scheme/user/port), then we need to output an absolute path.\n    if (!url.scheme && !url.host)\n        return url.path;\n    // We're outputting either an absolute URL, or a protocol relative one.\n    return `${url.scheme}//${url.user}${url.host}${url.port}${url.path}`;\n}\n\nexport { resolve as default };\n//# sourceMappingURL=resolve-uri.mjs.map\n","import { encode, decode } from '@jridgewell/sourcemap-codec';\nimport resolveUri from '@jridgewell/resolve-uri';\n\nfunction resolve(input, base) {\n    // The base is always treated as a directory, if it's not empty.\n    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n    if (base && !base.endsWith('/'))\n        base += '/';\n    return resolveUri(input, base);\n}\n\n/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nfunction stripFilename(path) {\n    if (!path)\n        return '';\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\n\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\nconst REV_GENERATED_LINE = 1;\nconst REV_GENERATED_COLUMN = 2;\n\nfunction maybeSort(mappings, owned) {\n    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n    if (unsortedIndex === mappings.length)\n        return mappings;\n    // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n    // not, we do not want to modify the consumer's input array.\n    if (!owned)\n        mappings = mappings.slice();\n    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n        mappings[i] = sortSegments(mappings[i], owned);\n    }\n    return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n    for (let i = start; i < mappings.length; i++) {\n        if (!isSorted(mappings[i]))\n            return i;\n    }\n    return mappings.length;\n}\nfunction isSorted(line) {\n    for (let j = 1; j < line.length; j++) {\n        if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction sortSegments(line, owned) {\n    if (!owned)\n        line = line.slice();\n    return line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[COLUMN] - b[COLUMN];\n}\n\nlet found = false;\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nfunction binarySearch(haystack, needle, low, high) {\n    while (low <= high) {\n        const mid = low + ((high - low) >> 1);\n        const cmp = haystack[mid][COLUMN] - needle;\n        if (cmp === 0) {\n            found = true;\n            return mid;\n        }\n        if (cmp < 0) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    found = false;\n    return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n    for (let i = index + 1; i < haystack.length; i++, index++) {\n        if (haystack[i][COLUMN] !== needle)\n            break;\n    }\n    return index;\n}\nfunction lowerBound(haystack, needle, index) {\n    for (let i = index - 1; i >= 0; i--, index--) {\n        if (haystack[i][COLUMN] !== needle)\n            break;\n    }\n    return index;\n}\nfunction memoizedState() {\n    return {\n        lastKey: -1,\n        lastNeedle: -1,\n        lastIndex: -1,\n    };\n}\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n    const { lastKey, lastNeedle, lastIndex } = state;\n    let low = 0;\n    let high = haystack.length - 1;\n    if (key === lastKey) {\n        if (needle === lastNeedle) {\n            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n            return lastIndex;\n        }\n        if (needle >= lastNeedle) {\n            // lastIndex may be -1 if the previous needle was not found.\n            low = lastIndex === -1 ? 0 : lastIndex;\n        }\n        else {\n            high = lastIndex;\n        }\n    }\n    state.lastKey = key;\n    state.lastNeedle = needle;\n    return (state.lastIndex = binarySearch(haystack, needle, low, high));\n}\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nfunction buildBySources(decoded, memos) {\n    const sources = memos.map(buildNullArray);\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            if (seg.length === 1)\n                continue;\n            const sourceIndex = seg[SOURCES_INDEX];\n            const sourceLine = seg[SOURCE_LINE];\n            const sourceColumn = seg[SOURCE_COLUMN];\n            const originalSource = sources[sourceIndex];\n            const originalLine = (originalSource[sourceLine] || (originalSource[sourceLine] = []));\n            const memo = memos[sourceIndex];\n            // The binary search either found a match, or it found the left-index just before where the\n            // segment should go. Either way, we want to insert after that. And there may be multiple\n            // generated segments associated with an original location, so there may need to move several\n            // indexes before we find where we need to insert.\n            const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n            insert(originalLine, (memo.lastIndex = index + 1), [sourceColumn, i, seg[COLUMN]]);\n        }\n    }\n    return sources;\n}\nfunction insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n        array[i] = array[i - 1];\n    }\n    array[index] = value;\n}\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray() {\n    return { __proto__: null };\n}\n\nconst AnyMap = function (map, mapUrl) {\n    const parsed = typeof map === 'string' ? JSON.parse(map) : map;\n    if (!('sections' in parsed))\n        return new TraceMap(parsed, mapUrl);\n    const mappings = [];\n    const sources = [];\n    const sourcesContent = [];\n    const names = [];\n    const { sections } = parsed;\n    let i = 0;\n    for (; i < sections.length - 1; i++) {\n        const no = sections[i + 1].offset;\n        addSection(sections[i], mapUrl, mappings, sources, sourcesContent, names, no.line, no.column);\n    }\n    if (sections.length > 0) {\n        addSection(sections[i], mapUrl, mappings, sources, sourcesContent, names, Infinity, Infinity);\n    }\n    const joined = {\n        version: 3,\n        file: parsed.file,\n        names,\n        sources,\n        sourcesContent,\n        mappings,\n    };\n    return presortedDecodedMap(joined);\n};\nfunction addSection(section, mapUrl, mappings, sources, sourcesContent, names, stopLine, stopColumn) {\n    const map = AnyMap(section.map, mapUrl);\n    const { line: lineOffset, column: columnOffset } = section.offset;\n    const sourcesOffset = sources.length;\n    const namesOffset = names.length;\n    const decoded = decodedMappings(map);\n    const { resolvedSources } = map;\n    append(sources, resolvedSources);\n    append(sourcesContent, map.sourcesContent || fillSourcesContent(resolvedSources.length));\n    append(names, map.names);\n    // If this section jumps forwards several lines, we need to add lines to the output mappings catch up.\n    for (let i = mappings.length; i <= lineOffset; i++)\n        mappings.push([]);\n    // We can only add so many lines before we step into the range that the next section's map\n    // controls. When we get to the last line, then we'll start checking the segments to see if\n    // they've crossed into the column range.\n    const stopI = stopLine - lineOffset;\n    const len = Math.min(decoded.length, stopI + 1);\n    for (let i = 0; i < len; i++) {\n        const line = decoded[i];\n        // On the 0th loop, the line will already exist due to a previous section, or the line catch up\n        // loop above.\n        const out = i === 0 ? mappings[lineOffset] : (mappings[lineOffset + i] = []);\n        // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n        // map can be multiple lines), it doesn't.\n        const cOffset = i === 0 ? columnOffset : 0;\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            const column = cOffset + seg[COLUMN];\n            // If this segment steps into the column range that the next section's map controls, we need\n            // to stop early.\n            if (i === stopI && column >= stopColumn)\n                break;\n            if (seg.length === 1) {\n                out.push([column]);\n                continue;\n            }\n            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n            const sourceLine = seg[SOURCE_LINE];\n            const sourceColumn = seg[SOURCE_COLUMN];\n            if (seg.length === 4) {\n                out.push([column, sourcesIndex, sourceLine, sourceColumn]);\n                continue;\n            }\n            out.push([column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n        }\n    }\n}\nfunction append(arr, other) {\n    for (let i = 0; i < other.length; i++)\n        arr.push(other[i]);\n}\n// Sourcemaps don't need to have sourcesContent, and if they don't, we need to create an array of\n// equal length to the sources. This is because the sources and sourcesContent are paired arrays,\n// where `sourcesContent[i]` is the content of the `sources[i]` file. If we didn't, then joined\n// sourcemap would desynchronize the sources/contents.\nfunction fillSourcesContent(len) {\n    const sourcesContent = [];\n    for (let i = 0; i < len; i++)\n        sourcesContent[i] = null;\n    return sourcesContent;\n}\n\nconst INVALID_ORIGINAL_MAPPING = Object.freeze({\n    source: null,\n    line: null,\n    column: null,\n    name: null,\n});\nconst INVALID_GENERATED_MAPPING = Object.freeze({\n    line: null,\n    column: null,\n});\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\nconst LEAST_UPPER_BOUND = -1;\nconst GREATEST_LOWER_BOUND = 1;\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nlet encodedMappings;\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nlet decodedMappings;\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nlet traceSegment;\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nlet originalPositionFor;\n/**\n * Finds the source/line/column directly after the mapping returned by originalPositionFor, provided\n * the found mapping is from the same source and line as the originalPositionFor mapping.\n *\n * Eg, in the code `let id = 1`, `originalPositionAfter` could find the mapping associated with `1`\n * using the same needle that would return `id` when calling `originalPositionFor`.\n */\nlet generatedPositionFor;\n/**\n * Iterates each mapping in generated position order.\n */\nlet eachMapping;\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nlet presortedDecodedMap;\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nlet decodedMap;\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nlet encodedMap;\nclass TraceMap {\n    constructor(map, mapUrl) {\n        this._decodedMemo = memoizedState();\n        this._bySources = undefined;\n        this._bySourceMemos = undefined;\n        const isString = typeof map === 'string';\n        if (!isString && map.constructor === TraceMap)\n            return map;\n        const parsed = (isString ? JSON.parse(map) : map);\n        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n        this.version = version;\n        this.file = file;\n        this.names = names;\n        this.sourceRoot = sourceRoot;\n        this.sources = sources;\n        this.sourcesContent = sourcesContent;\n        if (sourceRoot || mapUrl) {\n            const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n            this.resolvedSources = sources.map((s) => resolve(s || '', from));\n        }\n        else {\n            this.resolvedSources = sources.map((s) => s || '');\n        }\n        const { mappings } = parsed;\n        if (typeof mappings === 'string') {\n            this._encoded = mappings;\n            this._decoded = undefined;\n        }\n        else {\n            this._encoded = undefined;\n            this._decoded = maybeSort(mappings, isString);\n        }\n    }\n}\n(() => {\n    encodedMappings = (map) => {\n        var _a;\n        return ((_a = map._encoded) !== null && _a !== void 0 ? _a : (map._encoded = encode(map._decoded)));\n    };\n    decodedMappings = (map) => {\n        return (map._decoded || (map._decoded = decode(map._encoded)));\n    };\n    traceSegment = (map, line, column) => {\n        const decoded = decodedMappings(map);\n        // It's common for parent source maps to have pointers to lines that have no\n        // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n        if (line >= decoded.length)\n            return null;\n        return traceSegmentInternal(decoded[line], map._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n    };\n    originalPositionFor = (map, { line, column, bias }) => {\n        line--;\n        if (line < 0)\n            throw new Error(LINE_GTR_ZERO);\n        if (column < 0)\n            throw new Error(COL_GTR_EQ_ZERO);\n        const decoded = decodedMappings(map);\n        // It's common for parent source maps to have pointers to lines that have no\n        // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n        if (line >= decoded.length)\n            return INVALID_ORIGINAL_MAPPING;\n        const segment = traceSegmentInternal(decoded[line], map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n        if (segment == null)\n            return INVALID_ORIGINAL_MAPPING;\n        if (segment.length == 1)\n            return INVALID_ORIGINAL_MAPPING;\n        const { names, resolvedSources } = map;\n        return {\n            source: resolvedSources[segment[SOURCES_INDEX]],\n            line: segment[SOURCE_LINE] + 1,\n            column: segment[SOURCE_COLUMN],\n            name: segment.length === 5 ? names[segment[NAMES_INDEX]] : null,\n        };\n    };\n    generatedPositionFor = (map, { source, line, column, bias }) => {\n        line--;\n        if (line < 0)\n            throw new Error(LINE_GTR_ZERO);\n        if (column < 0)\n            throw new Error(COL_GTR_EQ_ZERO);\n        const { sources, resolvedSources } = map;\n        let sourceIndex = sources.indexOf(source);\n        if (sourceIndex === -1)\n            sourceIndex = resolvedSources.indexOf(source);\n        if (sourceIndex === -1)\n            return INVALID_GENERATED_MAPPING;\n        const generated = (map._bySources || (map._bySources = buildBySources(decodedMappings(map), (map._bySourceMemos = sources.map(memoizedState)))));\n        const memos = map._bySourceMemos;\n        const segments = generated[sourceIndex][line];\n        if (segments == null)\n            return INVALID_GENERATED_MAPPING;\n        const segment = traceSegmentInternal(segments, memos[sourceIndex], line, column, bias || GREATEST_LOWER_BOUND);\n        if (segment == null)\n            return INVALID_GENERATED_MAPPING;\n        return {\n            line: segment[REV_GENERATED_LINE] + 1,\n            column: segment[REV_GENERATED_COLUMN],\n        };\n    };\n    eachMapping = (map, cb) => {\n        const decoded = decodedMappings(map);\n        const { names, resolvedSources } = map;\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                const generatedLine = i + 1;\n                const generatedColumn = seg[0];\n                let source = null;\n                let originalLine = null;\n                let originalColumn = null;\n                let name = null;\n                if (seg.length !== 1) {\n                    source = resolvedSources[seg[1]];\n                    originalLine = seg[2] + 1;\n                    originalColumn = seg[3];\n                }\n                if (seg.length === 5)\n                    name = names[seg[4]];\n                cb({\n                    generatedLine,\n                    generatedColumn,\n                    source,\n                    originalLine,\n                    originalColumn,\n                    name,\n                });\n            }\n        }\n    };\n    presortedDecodedMap = (map, mapUrl) => {\n        const clone = Object.assign({}, map);\n        clone.mappings = [];\n        const tracer = new TraceMap(clone, mapUrl);\n        tracer._decoded = map.mappings;\n        return tracer;\n    };\n    decodedMap = (map) => {\n        return {\n            version: 3,\n            file: map.file,\n            names: map.names,\n            sourceRoot: map.sourceRoot,\n            sources: map.sources,\n            sourcesContent: map.sourcesContent,\n            mappings: decodedMappings(map),\n        };\n    };\n    encodedMap = (map) => {\n        return {\n            version: 3,\n            file: map.file,\n            names: map.names,\n            sourceRoot: map.sourceRoot,\n            sources: map.sources,\n            sourcesContent: map.sourcesContent,\n            mappings: encodedMappings(map),\n        };\n    };\n})();\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n    let index = memoizedBinarySearch(segments, column, memo, line);\n    if (found) {\n        index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n    }\n    else if (bias === LEAST_UPPER_BOUND)\n        index++;\n    if (index === -1 || index === segments.length)\n        return null;\n    return segments[index];\n}\n\nexport { AnyMap, GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND, TraceMap, decodedMap, decodedMappings, eachMapping, encodedMap, encodedMappings, generatedPositionFor, originalPositionFor, presortedDecodedMap, traceSegment };\n//# sourceMappingURL=trace-mapping.mjs.map\n","/**\n * Gets the index associated with `key` in the backing array, if it is already present.\n */\nlet get;\n/**\n * Puts `key` into the backing array, if it is not already present. Returns\n * the index of the `key` in the backing array.\n */\nlet put;\n/**\n * Pops the last added item out of the SetArray.\n */\nlet pop;\n/**\n * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n * index of the `key` in the backing array.\n *\n * This is designed to allow synchronizing a second array with the contents of the backing array,\n * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n * and there are never duplicates.\n */\nclass SetArray {\n    constructor() {\n        this._indexes = { __proto__: null };\n        this.array = [];\n    }\n}\n(() => {\n    get = (strarr, key) => strarr._indexes[key];\n    put = (strarr, key) => {\n        // The key may or may not be present. If it is present, it's a number.\n        const index = get(strarr, key);\n        if (index !== undefined)\n            return index;\n        const { array, _indexes: indexes } = strarr;\n        return (indexes[key] = array.push(key) - 1);\n    };\n    pop = (strarr) => {\n        const { array, _indexes: indexes } = strarr;\n        if (array.length === 0)\n            return;\n        const last = array.pop();\n        indexes[last] = undefined;\n    };\n})();\n\nexport { SetArray, get, pop, put };\n//# sourceMappingURL=set-array.mjs.map\n","import { SetArray, put } from '@jridgewell/set-array';\nimport { encode } from '@jridgewell/sourcemap-codec';\nimport { TraceMap, decodedMappings } from '@jridgewell/trace-mapping';\n\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\n\nconst NO_NAME = -1;\n/**\n * A low-level API to associate a generated position with an original source position. Line and\n * column here are 0-based, unlike `addMapping`.\n */\nlet addSegment;\n/**\n * A high-level API to associate a generated position with an original source position. Line is\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n */\nlet addMapping;\n/**\n * Same as `addSegment`, but will only add the segment if it generates useful information in the\n * resulting map. This only works correctly if segments are added **in order**, meaning you should\n * not add a segment with a lower generated line/column than one that came before.\n */\nlet maybeAddSegment;\n/**\n * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n * not add a mapping with a lower generated line/column than one that came before.\n */\nlet maybeAddMapping;\n/**\n * Adds/removes the content of the source file to the source map.\n */\nlet setSourceContent;\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nlet toDecodedMap;\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nlet toEncodedMap;\n/**\n * Constructs a new GenMapping, using the already present mappings of the input.\n */\nlet fromMap;\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\nlet allMappings;\n// This split declaration is only so that terser can elminiate the static initialization block.\nlet addSegmentInternal;\n/**\n * Provides the state to generate a sourcemap.\n */\nclass GenMapping {\n    constructor({ file, sourceRoot } = {}) {\n        this._names = new SetArray();\n        this._sources = new SetArray();\n        this._sourcesContent = [];\n        this._mappings = [];\n        this.file = file;\n        this.sourceRoot = sourceRoot;\n    }\n}\n(() => {\n    addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name) => {\n        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name);\n    };\n    maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name) => {\n        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name);\n    };\n    addMapping = (map, mapping) => {\n        return addMappingInternal(false, map, mapping);\n    };\n    maybeAddMapping = (map, mapping) => {\n        return addMappingInternal(true, map, mapping);\n    };\n    setSourceContent = (map, source, content) => {\n        const { _sources: sources, _sourcesContent: sourcesContent } = map;\n        sourcesContent[put(sources, source)] = content;\n    };\n    toDecodedMap = (map) => {\n        const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = map;\n        removeEmptyFinalLines(mappings);\n        return {\n            version: 3,\n            file: file || undefined,\n            names: names.array,\n            sourceRoot: sourceRoot || undefined,\n            sources: sources.array,\n            sourcesContent,\n            mappings,\n        };\n    };\n    toEncodedMap = (map) => {\n        const decoded = toDecodedMap(map);\n        return Object.assign(Object.assign({}, decoded), { mappings: encode(decoded.mappings) });\n    };\n    allMappings = (map) => {\n        const out = [];\n        const { _mappings: mappings, _sources: sources, _names: names } = map;\n        for (let i = 0; i < mappings.length; i++) {\n            const line = mappings[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                const generated = { line: i + 1, column: seg[COLUMN] };\n                let source = undefined;\n                let original = undefined;\n                let name = undefined;\n                if (seg.length !== 1) {\n                    source = sources.array[seg[SOURCES_INDEX]];\n                    original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n                    if (seg.length === 5)\n                        name = names.array[seg[NAMES_INDEX]];\n                }\n                out.push({ generated, source, original, name });\n            }\n        }\n        return out;\n    };\n    fromMap = (input) => {\n        const map = new TraceMap(input);\n        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n        putAll(gen._names, map.names);\n        putAll(gen._sources, map.sources);\n        gen._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n        gen._mappings = decodedMappings(map);\n        return gen;\n    };\n    // Internal helpers\n    addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name) => {\n        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = map;\n        const line = getLine(mappings, genLine);\n        const index = getColumnIndex(line, genColumn);\n        if (!source) {\n            if (skipable && skipSourceless(line, index))\n                return;\n            return insert(line, index, [genColumn]);\n        }\n        const sourcesIndex = put(sources, source);\n        const namesIndex = name ? put(names, name) : NO_NAME;\n        if (sourcesIndex === sourcesContent.length)\n            sourcesContent[sourcesIndex] = null;\n        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n            return;\n        }\n        return insert(line, index, name\n            ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\n            : [genColumn, sourcesIndex, sourceLine, sourceColumn]);\n    };\n})();\nfunction getLine(mappings, index) {\n    for (let i = mappings.length; i <= index; i++) {\n        mappings[i] = [];\n    }\n    return mappings[index];\n}\nfunction getColumnIndex(line, genColumn) {\n    let index = line.length;\n    for (let i = index - 1; i >= 0; index = i--) {\n        const current = line[i];\n        if (genColumn >= current[COLUMN])\n            break;\n    }\n    return index;\n}\nfunction insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n        array[i] = array[i - 1];\n    }\n    array[index] = value;\n}\nfunction removeEmptyFinalLines(mappings) {\n    const { length } = mappings;\n    let len = length;\n    for (let i = len - 1; i >= 0; len = i, i--) {\n        if (mappings[i].length > 0)\n            break;\n    }\n    if (len < length)\n        mappings.length = len;\n}\nfunction putAll(strarr, array) {\n    for (let i = 0; i < array.length; i++)\n        put(strarr, array[i]);\n}\nfunction skipSourceless(line, index) {\n    // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n    // doesn't generate any useful information.\n    if (index === 0)\n        return true;\n    const prev = line[index - 1];\n    // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n    // genrate any new information. Else, this segment will end the source/named segment and point to\n    // a sourceless position, which is useful.\n    return prev.length === 1;\n}\nfunction skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n    // A source/named segment at the start of a line gives position at that genColumn\n    if (index === 0)\n        return false;\n    const prev = line[index - 1];\n    // If the previous segment is sourceless, then we're transitioning to a source.\n    if (prev.length === 1)\n        return false;\n    // If the previous segment maps to the exact same source position, then this segment doesn't\n    // provide any new position information.\n    return (sourcesIndex === prev[SOURCES_INDEX] &&\n        sourceLine === prev[SOURCE_LINE] &&\n        sourceColumn === prev[SOURCE_COLUMN] &&\n        namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME));\n}\nfunction addMappingInternal(skipable, map, mapping) {\n    const { generated, source, original, name } = mapping;\n    if (!source) {\n        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null);\n    }\n    const s = source;\n    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name);\n}\n\nexport { GenMapping, addMapping, addSegment, allMappings, fromMap, maybeAddMapping, maybeAddSegment, setSourceContent, toDecodedMap, toEncodedMap };\n//# sourceMappingURL=gen-mapping.mjs.map\n","import { AnyMap, originalPositionFor } from '@jridgewell/trace-mapping';\nimport {\n  GenMapping,\n  maybeAddMapping,\n  toDecodedMap,\n  toEncodedMap,\n  setSourceContent,\n} from '@jridgewell/gen-mapping';\n\nimport type { TraceMap, SectionedSourceMapInput } from '@jridgewell/trace-mapping';\nexport type { TraceMap, SectionedSourceMapInput };\n\nimport type { Mapping, EncodedSourceMap, DecodedSourceMap } from '@jridgewell/gen-mapping';\nexport type { Mapping, EncodedSourceMap, DecodedSourceMap };\n\nexport class SourceMapConsumer {\n  private declare _map: TraceMap;\n  declare file: TraceMap['file'];\n  declare names: TraceMap['names'];\n  declare sourceRoot: TraceMap['sourceRoot'];\n  declare sources: TraceMap['sources'];\n  declare sourcesContent: TraceMap['sourcesContent'];\n\n  constructor(map: ConstructorParameters<typeof AnyMap>[0], mapUrl: Parameters<typeof AnyMap>[1]) {\n    const trace = (this._map = new AnyMap(map, mapUrl));\n\n    this.file = trace.file;\n    this.names = trace.names;\n    this.sourceRoot = trace.sourceRoot;\n    this.sources = trace.resolvedSources;\n    this.sourcesContent = trace.sourcesContent;\n  }\n\n  originalPositionFor(\n    needle: Parameters<typeof originalPositionFor>[1],\n  ): ReturnType<typeof originalPositionFor> {\n    return originalPositionFor(this._map, needle);\n  }\n\n  destroy() {\n    // noop.\n  }\n}\n\nexport class SourceMapGenerator {\n  private declare _map: GenMapping;\n\n  constructor(opts: ConstructorParameters<typeof GenMapping>[0]) {\n    this._map = new GenMapping(opts);\n  }\n\n  addMapping(mapping: Parameters<typeof maybeAddMapping>[1]): ReturnType<typeof maybeAddMapping> {\n    maybeAddMapping(this._map, mapping);\n  }\n\n  setSourceContent(\n    source: Parameters<typeof setSourceContent>[1],\n    content: Parameters<typeof setSourceContent>[2],\n  ): ReturnType<typeof setSourceContent> {\n    setSourceContent(this._map, source, content);\n  }\n\n  toJSON(): ReturnType<typeof toEncodedMap> {\n    return toEncodedMap(this._map);\n  }\n\n  toDecodedMap(): ReturnType<typeof toDecodedMap> {\n    return toDecodedMap(this._map);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}