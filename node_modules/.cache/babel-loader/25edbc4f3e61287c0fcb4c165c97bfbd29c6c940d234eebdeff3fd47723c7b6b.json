{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _objectSpread = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _objectWithoutProperties = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/objectWithoutProperties.js\").default;\nvar _excluded = [\"dependencyType\", \"plugins\"];\nvar Factory = require(\"enhanced-resolve\").ResolverFactory;\nvar _require = require(\"tapable\"),\n  HookMap = _require.HookMap,\n  SyncHook = _require.SyncHook,\n  SyncWaterfallHook = _require.SyncWaterfallHook;\nvar _require2 = require(\"./util/cleverMerge\"),\n  cachedCleverMerge = _require2.cachedCleverMerge,\n  removeOperations = _require2.removeOperations,\n  resolveByProperty = _require2.resolveByProperty;\n\n/** @typedef {import(\"enhanced-resolve\").ResolveOptions} ResolveOptions */\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n/** @typedef {import(\"../declarations/WebpackOptions\").ResolveOptions} WebpackResolveOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").ResolvePluginInstance} ResolvePluginInstance */\n\n/** @typedef {WebpackResolveOptions & {dependencyType?: string, resolveToContext?: boolean }} ResolveOptionsWithDependencyType */\n/**\n * @typedef {Object} WithOptions\n * @property {function(Partial<ResolveOptionsWithDependencyType>): ResolverWithOptions} withOptions create a resolver with additional/different options\n */\n\n/** @typedef {Resolver & WithOptions} ResolverWithOptions */\n\n// need to be hoisted on module level for caching identity\nvar EMPTY_RESOLVE_OPTIONS = {};\n\n/**\n * @param {ResolveOptionsWithDependencyType} resolveOptionsWithDepType enhanced options\n * @returns {ResolveOptions} merged options\n */\nvar convertToResolveOptions = function convertToResolveOptions(resolveOptionsWithDepType) {\n  var dependencyType = resolveOptionsWithDepType.dependencyType,\n    plugins = resolveOptionsWithDepType.plugins,\n    remaining = _objectWithoutProperties(resolveOptionsWithDepType, _excluded);\n\n  // check type compat\n  /** @type {Partial<ResolveOptions>} */\n  var partialOptions = _objectSpread(_objectSpread({}, remaining), {}, {\n    plugins: plugins && /** @type {ResolvePluginInstance[]} */\n    plugins.filter(function (item) {\n      return item !== \"...\";\n    })\n  });\n  if (!partialOptions.fileSystem) {\n    throw new Error(\"fileSystem is missing in resolveOptions, but it's required for enhanced-resolve\");\n  }\n  // These weird types validate that we checked all non-optional properties\n  var options = /** @type {Partial<ResolveOptions> & Pick<ResolveOptions, \"fileSystem\">} */\n  partialOptions;\n  return removeOperations(resolveByProperty(options, \"byDependency\", dependencyType));\n};\n\n/**\n * @typedef {Object} ResolverCache\n * @property {WeakMap<Object, ResolverWithOptions>} direct\n * @property {Map<string, ResolverWithOptions>} stringified\n */\n\nmodule.exports = /*#__PURE__*/function () {\n  function ResolverFactory() {\n    _classCallCheck(this, ResolverFactory);\n    this.hooks = Object.freeze({\n      /** @type {HookMap<SyncWaterfallHook<[ResolveOptionsWithDependencyType]>>} */\n      resolveOptions: new HookMap(function () {\n        return new SyncWaterfallHook([\"resolveOptions\"]);\n      }),\n      /** @type {HookMap<SyncHook<[Resolver, ResolveOptions, ResolveOptionsWithDependencyType]>>} */\n      resolver: new HookMap(function () {\n        return new SyncHook([\"resolver\", \"resolveOptions\", \"userResolveOptions\"]);\n      })\n    });\n    /** @type {Map<string, ResolverCache>} */\n    this.cache = new Map();\n  }\n\n  /**\n   * @param {string} type type of resolver\n   * @param {ResolveOptionsWithDependencyType=} resolveOptions options\n   * @returns {ResolverWithOptions} the resolver\n   */\n  _createClass(ResolverFactory, [{\n    key: \"get\",\n    value: function get(type) {\n      var resolveOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EMPTY_RESOLVE_OPTIONS;\n      var typedCaches = this.cache.get(type);\n      if (!typedCaches) {\n        typedCaches = {\n          direct: new WeakMap(),\n          stringified: new Map()\n        };\n        this.cache.set(type, typedCaches);\n      }\n      var cachedResolver = typedCaches.direct.get(resolveOptions);\n      if (cachedResolver) {\n        return cachedResolver;\n      }\n      var ident = JSON.stringify(resolveOptions);\n      var resolver = typedCaches.stringified.get(ident);\n      if (resolver) {\n        typedCaches.direct.set(resolveOptions, resolver);\n        return resolver;\n      }\n      var newResolver = this._create(type, resolveOptions);\n      typedCaches.direct.set(resolveOptions, newResolver);\n      typedCaches.stringified.set(ident, newResolver);\n      return newResolver;\n    }\n\n    /**\n     * @param {string} type type of resolver\n     * @param {ResolveOptionsWithDependencyType} resolveOptionsWithDepType options\n     * @returns {ResolverWithOptions} the resolver\n     */\n  }, {\n    key: \"_create\",\n    value: function _create(type, resolveOptionsWithDepType) {\n      var _this = this;\n      /** @type {ResolveOptionsWithDependencyType} */\n      var originalResolveOptions = _objectSpread({}, resolveOptionsWithDepType);\n      var resolveOptions = convertToResolveOptions(this.hooks.resolveOptions.for(type).call(resolveOptionsWithDepType));\n      var resolver = /** @type {ResolverWithOptions} */\n      Factory.createResolver(resolveOptions);\n      if (!resolver) {\n        throw new Error(\"No resolver created\");\n      }\n      /** @type {WeakMap<Partial<ResolveOptionsWithDependencyType>, ResolverWithOptions>} */\n      var childCache = new WeakMap();\n      resolver.withOptions = function (options) {\n        var cacheEntry = childCache.get(options);\n        if (cacheEntry !== undefined) return cacheEntry;\n        var mergedOptions = cachedCleverMerge(originalResolveOptions, options);\n        var resolver = _this.get(type, mergedOptions);\n        childCache.set(options, resolver);\n        return resolver;\n      };\n      this.hooks.resolver.for(type).call(resolver, resolveOptions, originalResolveOptions);\n      return resolver;\n    }\n  }]);\n  return ResolverFactory;\n}();","map":{"version":3,"names":["Factory","require","ResolverFactory","HookMap","SyncHook","SyncWaterfallHook","cachedCleverMerge","removeOperations","resolveByProperty","EMPTY_RESOLVE_OPTIONS","convertToResolveOptions","resolveOptionsWithDepType","dependencyType","plugins","remaining","partialOptions","filter","item","fileSystem","Error","options","module","exports","hooks","Object","freeze","resolveOptions","resolver","cache","Map","type","typedCaches","get","direct","WeakMap","stringified","set","cachedResolver","ident","JSON","stringify","newResolver","_create","originalResolveOptions","for","call","createResolver","childCache","withOptions","cacheEntry","undefined","mergedOptions"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/ResolverFactory.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Factory = require(\"enhanced-resolve\").ResolverFactory;\nconst { HookMap, SyncHook, SyncWaterfallHook } = require(\"tapable\");\nconst {\n\tcachedCleverMerge,\n\tremoveOperations,\n\tresolveByProperty\n} = require(\"./util/cleverMerge\");\n\n/** @typedef {import(\"enhanced-resolve\").ResolveOptions} ResolveOptions */\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n/** @typedef {import(\"../declarations/WebpackOptions\").ResolveOptions} WebpackResolveOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").ResolvePluginInstance} ResolvePluginInstance */\n\n/** @typedef {WebpackResolveOptions & {dependencyType?: string, resolveToContext?: boolean }} ResolveOptionsWithDependencyType */\n/**\n * @typedef {Object} WithOptions\n * @property {function(Partial<ResolveOptionsWithDependencyType>): ResolverWithOptions} withOptions create a resolver with additional/different options\n */\n\n/** @typedef {Resolver & WithOptions} ResolverWithOptions */\n\n// need to be hoisted on module level for caching identity\nconst EMPTY_RESOLVE_OPTIONS = {};\n\n/**\n * @param {ResolveOptionsWithDependencyType} resolveOptionsWithDepType enhanced options\n * @returns {ResolveOptions} merged options\n */\nconst convertToResolveOptions = resolveOptionsWithDepType => {\n\tconst { dependencyType, plugins, ...remaining } = resolveOptionsWithDepType;\n\n\t// check type compat\n\t/** @type {Partial<ResolveOptions>} */\n\tconst partialOptions = {\n\t\t...remaining,\n\t\tplugins:\n\t\t\tplugins &&\n\t\t\t/** @type {ResolvePluginInstance[]} */ (\n\t\t\t\tplugins.filter(item => item !== \"...\")\n\t\t\t)\n\t};\n\n\tif (!partialOptions.fileSystem) {\n\t\tthrow new Error(\n\t\t\t\"fileSystem is missing in resolveOptions, but it's required for enhanced-resolve\"\n\t\t);\n\t}\n\t// These weird types validate that we checked all non-optional properties\n\tconst options =\n\t\t/** @type {Partial<ResolveOptions> & Pick<ResolveOptions, \"fileSystem\">} */ (\n\t\t\tpartialOptions\n\t\t);\n\n\treturn removeOperations(\n\t\tresolveByProperty(options, \"byDependency\", dependencyType)\n\t);\n};\n\n/**\n * @typedef {Object} ResolverCache\n * @property {WeakMap<Object, ResolverWithOptions>} direct\n * @property {Map<string, ResolverWithOptions>} stringified\n */\n\nmodule.exports = class ResolverFactory {\n\tconstructor() {\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {HookMap<SyncWaterfallHook<[ResolveOptionsWithDependencyType]>>} */\n\t\t\tresolveOptions: new HookMap(\n\t\t\t\t() => new SyncWaterfallHook([\"resolveOptions\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncHook<[Resolver, ResolveOptions, ResolveOptionsWithDependencyType]>>} */\n\t\t\tresolver: new HookMap(\n\t\t\t\t() => new SyncHook([\"resolver\", \"resolveOptions\", \"userResolveOptions\"])\n\t\t\t)\n\t\t});\n\t\t/** @type {Map<string, ResolverCache>} */\n\t\tthis.cache = new Map();\n\t}\n\n\t/**\n\t * @param {string} type type of resolver\n\t * @param {ResolveOptionsWithDependencyType=} resolveOptions options\n\t * @returns {ResolverWithOptions} the resolver\n\t */\n\tget(type, resolveOptions = EMPTY_RESOLVE_OPTIONS) {\n\t\tlet typedCaches = this.cache.get(type);\n\t\tif (!typedCaches) {\n\t\t\ttypedCaches = {\n\t\t\t\tdirect: new WeakMap(),\n\t\t\t\tstringified: new Map()\n\t\t\t};\n\t\t\tthis.cache.set(type, typedCaches);\n\t\t}\n\t\tconst cachedResolver = typedCaches.direct.get(resolveOptions);\n\t\tif (cachedResolver) {\n\t\t\treturn cachedResolver;\n\t\t}\n\t\tconst ident = JSON.stringify(resolveOptions);\n\t\tconst resolver = typedCaches.stringified.get(ident);\n\t\tif (resolver) {\n\t\t\ttypedCaches.direct.set(resolveOptions, resolver);\n\t\t\treturn resolver;\n\t\t}\n\t\tconst newResolver = this._create(type, resolveOptions);\n\t\ttypedCaches.direct.set(resolveOptions, newResolver);\n\t\ttypedCaches.stringified.set(ident, newResolver);\n\t\treturn newResolver;\n\t}\n\n\t/**\n\t * @param {string} type type of resolver\n\t * @param {ResolveOptionsWithDependencyType} resolveOptionsWithDepType options\n\t * @returns {ResolverWithOptions} the resolver\n\t */\n\t_create(type, resolveOptionsWithDepType) {\n\t\t/** @type {ResolveOptionsWithDependencyType} */\n\t\tconst originalResolveOptions = { ...resolveOptionsWithDepType };\n\n\t\tconst resolveOptions = convertToResolveOptions(\n\t\t\tthis.hooks.resolveOptions.for(type).call(resolveOptionsWithDepType)\n\t\t);\n\t\tconst resolver = /** @type {ResolverWithOptions} */ (\n\t\t\tFactory.createResolver(resolveOptions)\n\t\t);\n\t\tif (!resolver) {\n\t\t\tthrow new Error(\"No resolver created\");\n\t\t}\n\t\t/** @type {WeakMap<Partial<ResolveOptionsWithDependencyType>, ResolverWithOptions>} */\n\t\tconst childCache = new WeakMap();\n\t\tresolver.withOptions = options => {\n\t\t\tconst cacheEntry = childCache.get(options);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tconst mergedOptions = cachedCleverMerge(originalResolveOptions, options);\n\t\t\tconst resolver = this.get(type, mergedOptions);\n\t\t\tchildCache.set(options, resolver);\n\t\t\treturn resolver;\n\t\t};\n\t\tthis.hooks.resolver\n\t\t\t.for(type)\n\t\t\t.call(resolver, resolveOptions, originalResolveOptions);\n\t\treturn resolver;\n\t}\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAAC;AAAA;AAAA;AAAA;AAAA;AAEb,IAAMA,OAAO,GAAGC,OAAO,CAAC,kBAAkB,CAAC,CAACC,eAAe;AAC3D,eAAiDD,OAAO,CAAC,SAAS,CAAC;EAA3DE,OAAO,YAAPA,OAAO;EAAEC,QAAQ,YAARA,QAAQ;EAAEC,iBAAiB,YAAjBA,iBAAiB;AAC5C,gBAIIJ,OAAO,CAAC,oBAAoB,CAAC;EAHhCK,iBAAiB,aAAjBA,iBAAiB;EACjBC,gBAAgB,aAAhBA,gBAAgB;EAChBC,iBAAiB,aAAjBA,iBAAiB;;AAGlB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,IAAMC,qBAAqB,GAAG,CAAC,CAAC;;AAEhC;AACA;AACA;AACA;AACA,IAAMC,uBAAuB,GAAG,SAA1BA,uBAAuB,CAAGC,yBAAyB,EAAI;EAC5D,IAAQC,cAAc,GAA4BD,yBAAyB,CAAnEC,cAAc;IAAEC,OAAO,GAAmBF,yBAAyB,CAAnDE,OAAO;IAAKC,SAAS,4BAAKH,yBAAyB;;EAE3E;EACA;EACA,IAAMI,cAAc,mCAChBD,SAAS;IACZD,OAAO,EACNA,OAAO,IACP;IACCA,OAAO,CAACG,MAAM,CAAC,UAAAC,IAAI;MAAA,OAAIA,IAAI,KAAK,KAAK;IAAA;EACrC,EACF;EAED,IAAI,CAACF,cAAc,CAACG,UAAU,EAAE;IAC/B,MAAM,IAAIC,KAAK,CACd,iFAAiF,CACjF;EACF;EACA;EACA,IAAMC,OAAO,GACZ;EACCL,cACA;EAEF,OAAOR,gBAAgB,CACtBC,iBAAiB,CAACY,OAAO,EAAE,cAAc,EAAER,cAAc,CAAC,CAC1D;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEAS,MAAM,CAACC,OAAO;EACb,2BAAc;IAAA;IACb,IAAI,CAACC,KAAK,GAAGC,MAAM,CAACC,MAAM,CAAC;MAC1B;MACAC,cAAc,EAAE,IAAIvB,OAAO,CAC1B;QAAA,OAAM,IAAIE,iBAAiB,CAAC,CAAC,gBAAgB,CAAC,CAAC;MAAA,EAC/C;MACD;MACAsB,QAAQ,EAAE,IAAIxB,OAAO,CACpB;QAAA,OAAM,IAAIC,QAAQ,CAAC,CAAC,UAAU,EAAE,gBAAgB,EAAE,oBAAoB,CAAC,CAAC;MAAA;IAE1E,CAAC,CAAC;IACF;IACA,IAAI,CAACwB,KAAK,GAAG,IAAIC,GAAG,EAAE;EACvB;;EAEA;AACD;AACA;AACA;AACA;EAJC;IAAA;IAAA,OAKA,aAAIC,IAAI,EAA0C;MAAA,IAAxCJ,cAAc,uEAAGjB,qBAAqB;MAC/C,IAAIsB,WAAW,GAAG,IAAI,CAACH,KAAK,CAACI,GAAG,CAACF,IAAI,CAAC;MACtC,IAAI,CAACC,WAAW,EAAE;QACjBA,WAAW,GAAG;UACbE,MAAM,EAAE,IAAIC,OAAO,EAAE;UACrBC,WAAW,EAAE,IAAIN,GAAG;QACrB,CAAC;QACD,IAAI,CAACD,KAAK,CAACQ,GAAG,CAACN,IAAI,EAAEC,WAAW,CAAC;MAClC;MACA,IAAMM,cAAc,GAAGN,WAAW,CAACE,MAAM,CAACD,GAAG,CAACN,cAAc,CAAC;MAC7D,IAAIW,cAAc,EAAE;QACnB,OAAOA,cAAc;MACtB;MACA,IAAMC,KAAK,GAAGC,IAAI,CAACC,SAAS,CAACd,cAAc,CAAC;MAC5C,IAAMC,QAAQ,GAAGI,WAAW,CAACI,WAAW,CAACH,GAAG,CAACM,KAAK,CAAC;MACnD,IAAIX,QAAQ,EAAE;QACbI,WAAW,CAACE,MAAM,CAACG,GAAG,CAACV,cAAc,EAAEC,QAAQ,CAAC;QAChD,OAAOA,QAAQ;MAChB;MACA,IAAMc,WAAW,GAAG,IAAI,CAACC,OAAO,CAACZ,IAAI,EAAEJ,cAAc,CAAC;MACtDK,WAAW,CAACE,MAAM,CAACG,GAAG,CAACV,cAAc,EAAEe,WAAW,CAAC;MACnDV,WAAW,CAACI,WAAW,CAACC,GAAG,CAACE,KAAK,EAAEG,WAAW,CAAC;MAC/C,OAAOA,WAAW;IACnB;;IAEA;AACD;AACA;AACA;AACA;EAJC;IAAA;IAAA,OAKA,iBAAQX,IAAI,EAAEnB,yBAAyB,EAAE;MAAA;MACxC;MACA,IAAMgC,sBAAsB,qBAAQhC,yBAAyB,CAAE;MAE/D,IAAMe,cAAc,GAAGhB,uBAAuB,CAC7C,IAAI,CAACa,KAAK,CAACG,cAAc,CAACkB,GAAG,CAACd,IAAI,CAAC,CAACe,IAAI,CAAClC,yBAAyB,CAAC,CACnE;MACD,IAAMgB,QAAQ,GAAG;MAChB3B,OAAO,CAAC8C,cAAc,CAACpB,cAAc,CACrC;MACD,IAAI,CAACC,QAAQ,EAAE;QACd,MAAM,IAAIR,KAAK,CAAC,qBAAqB,CAAC;MACvC;MACA;MACA,IAAM4B,UAAU,GAAG,IAAIb,OAAO,EAAE;MAChCP,QAAQ,CAACqB,WAAW,GAAG,UAAA5B,OAAO,EAAI;QACjC,IAAM6B,UAAU,GAAGF,UAAU,CAACf,GAAG,CAACZ,OAAO,CAAC;QAC1C,IAAI6B,UAAU,KAAKC,SAAS,EAAE,OAAOD,UAAU;QAC/C,IAAME,aAAa,GAAG7C,iBAAiB,CAACqC,sBAAsB,EAAEvB,OAAO,CAAC;QACxE,IAAMO,QAAQ,GAAG,KAAI,CAACK,GAAG,CAACF,IAAI,EAAEqB,aAAa,CAAC;QAC9CJ,UAAU,CAACX,GAAG,CAAChB,OAAO,EAAEO,QAAQ,CAAC;QACjC,OAAOA,QAAQ;MAChB,CAAC;MACD,IAAI,CAACJ,KAAK,CAACI,QAAQ,CACjBiB,GAAG,CAACd,IAAI,CAAC,CACTe,IAAI,CAAClB,QAAQ,EAAED,cAAc,EAAEiB,sBAAsB,CAAC;MACxD,OAAOhB,QAAQ;IAChB;EAAC;EAAA;AAAA,GACD"},"metadata":{},"sourceType":"script","externalDependencies":[]}