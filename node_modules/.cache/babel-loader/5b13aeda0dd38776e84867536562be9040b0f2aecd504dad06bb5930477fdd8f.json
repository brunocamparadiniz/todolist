{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar asyncLib = require(\"neo-async\");\nvar EntryDependency = require(\"./dependencies/EntryDependency\");\nvar _require = require(\"./util/IterableHelpers\"),\n  someInIterable = _require.someInIterable;\nvar _require2 = require(\"./util/comparators\"),\n  compareModulesById = _require2.compareModulesById;\nvar _require3 = require(\"./util/fs\"),\n  dirname = _require3.dirname,\n  mkdirp = _require3.mkdirp;\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/**\n * @typedef {Object} ManifestModuleData\n * @property {string | number} id\n * @property {Object} buildMeta\n * @property {boolean | string[]} exports\n */\nvar LibManifestPlugin = /*#__PURE__*/function () {\n  function LibManifestPlugin(options) {\n    _classCallCheck(this, LibManifestPlugin);\n    this.options = options;\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  _createClass(LibManifestPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this = this;\n      compiler.hooks.emit.tapAsync(\"LibManifestPlugin\", function (compilation, callback) {\n        var moduleGraph = compilation.moduleGraph;\n        asyncLib.forEach(Array.from(compilation.chunks), function (chunk, callback) {\n          if (!chunk.canBeInitial()) {\n            callback();\n            return;\n          }\n          var chunkGraph = compilation.chunkGraph;\n          var targetPath = compilation.getPath(_this.options.path, {\n            chunk: chunk\n          });\n          var name = _this.options.name && compilation.getPath(_this.options.name, {\n            chunk: chunk\n          });\n          var content = Object.create(null);\n          var _iterator = _createForOfIteratorHelper(chunkGraph.getOrderedChunkModulesIterable(chunk, compareModulesById(chunkGraph))),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _module = _step.value;\n              if (_this.options.entryOnly && !someInIterable(moduleGraph.getIncomingConnections(_module), function (c) {\n                return c.dependency instanceof EntryDependency;\n              })) {\n                continue;\n              }\n              var ident = _module.libIdent({\n                context: _this.options.context || compiler.options.context,\n                associatedObjectForCache: compiler.root\n              });\n              if (ident) {\n                var exportsInfo = moduleGraph.getExportsInfo(_module);\n                var providedExports = exportsInfo.getProvidedExports();\n                /** @type {ManifestModuleData} */\n                var data = {\n                  id: chunkGraph.getModuleId(_module),\n                  buildMeta: _module.buildMeta,\n                  exports: Array.isArray(providedExports) ? providedExports : undefined\n                };\n                content[ident] = data;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          var manifest = {\n            name: name,\n            type: _this.options.type,\n            content: content\n          };\n          // Apply formatting to content if format flag is true;\n          var manifestContent = _this.options.format ? JSON.stringify(manifest, null, 2) : JSON.stringify(manifest);\n          var buffer = Buffer.from(manifestContent, \"utf8\");\n          mkdirp(compiler.intermediateFileSystem, dirname(compiler.intermediateFileSystem, targetPath), function (err) {\n            if (err) return callback(err);\n            compiler.intermediateFileSystem.writeFile(targetPath, buffer, callback);\n          });\n        }, callback);\n      });\n    }\n  }]);\n  return LibManifestPlugin;\n}();\nmodule.exports = LibManifestPlugin;","map":{"version":3,"names":["asyncLib","require","EntryDependency","someInIterable","compareModulesById","dirname","mkdirp","LibManifestPlugin","options","compiler","hooks","emit","tapAsync","compilation","callback","moduleGraph","forEach","Array","from","chunks","chunk","canBeInitial","chunkGraph","targetPath","getPath","path","name","content","Object","create","getOrderedChunkModulesIterable","module","entryOnly","getIncomingConnections","c","dependency","ident","libIdent","context","associatedObjectForCache","root","exportsInfo","getExportsInfo","providedExports","getProvidedExports","data","id","getModuleId","buildMeta","exports","isArray","undefined","manifest","type","manifestContent","format","JSON","stringify","buffer","Buffer","intermediateFileSystem","err","writeFile"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/LibManifestPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst EntryDependency = require(\"./dependencies/EntryDependency\");\nconst { someInIterable } = require(\"./util/IterableHelpers\");\nconst { compareModulesById } = require(\"./util/comparators\");\nconst { dirname, mkdirp } = require(\"./util/fs\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/**\n * @typedef {Object} ManifestModuleData\n * @property {string | number} id\n * @property {Object} buildMeta\n * @property {boolean | string[]} exports\n */\n\nclass LibManifestPlugin {\n\tconstructor(options) {\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.emit.tapAsync(\n\t\t\t\"LibManifestPlugin\",\n\t\t\t(compilation, callback) => {\n\t\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\t\tasyncLib.forEach(\n\t\t\t\t\tArray.from(compilation.chunks),\n\t\t\t\t\t(chunk, callback) => {\n\t\t\t\t\t\tif (!chunk.canBeInitial()) {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\t\tconst targetPath = compilation.getPath(this.options.path, {\n\t\t\t\t\t\t\tchunk\n\t\t\t\t\t\t});\n\t\t\t\t\t\tconst name =\n\t\t\t\t\t\t\tthis.options.name &&\n\t\t\t\t\t\t\tcompilation.getPath(this.options.name, {\n\t\t\t\t\t\t\t\tchunk\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\tconst content = Object.create(null);\n\t\t\t\t\t\tfor (const module of chunkGraph.getOrderedChunkModulesIterable(\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tcompareModulesById(chunkGraph)\n\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tthis.options.entryOnly &&\n\t\t\t\t\t\t\t\t!someInIterable(\n\t\t\t\t\t\t\t\t\tmoduleGraph.getIncomingConnections(module),\n\t\t\t\t\t\t\t\t\tc => c.dependency instanceof EntryDependency\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst ident = module.libIdent({\n\t\t\t\t\t\t\t\tcontext: this.options.context || compiler.options.context,\n\t\t\t\t\t\t\t\tassociatedObjectForCache: compiler.root\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (ident) {\n\t\t\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\t\t\tconst providedExports = exportsInfo.getProvidedExports();\n\t\t\t\t\t\t\t\t/** @type {ManifestModuleData} */\n\t\t\t\t\t\t\t\tconst data = {\n\t\t\t\t\t\t\t\t\tid: chunkGraph.getModuleId(module),\n\t\t\t\t\t\t\t\t\tbuildMeta: module.buildMeta,\n\t\t\t\t\t\t\t\t\texports: Array.isArray(providedExports)\n\t\t\t\t\t\t\t\t\t\t? providedExports\n\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tcontent[ident] = data;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst manifest = {\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\ttype: this.options.type,\n\t\t\t\t\t\t\tcontent\n\t\t\t\t\t\t};\n\t\t\t\t\t\t// Apply formatting to content if format flag is true;\n\t\t\t\t\t\tconst manifestContent = this.options.format\n\t\t\t\t\t\t\t? JSON.stringify(manifest, null, 2)\n\t\t\t\t\t\t\t: JSON.stringify(manifest);\n\t\t\t\t\t\tconst buffer = Buffer.from(manifestContent, \"utf8\");\n\t\t\t\t\t\tmkdirp(\n\t\t\t\t\t\t\tcompiler.intermediateFileSystem,\n\t\t\t\t\t\t\tdirname(compiler.intermediateFileSystem, targetPath),\n\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\tcompiler.intermediateFileSystem.writeFile(\n\t\t\t\t\t\t\t\t\ttargetPath,\n\t\t\t\t\t\t\t\t\tbuffer,\n\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\tcallback\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = LibManifestPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}