{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar fs = require(\"fs\");\nvar path = require(\"path\");\n\n// macOS, Linux, and Windows all rely on these errors\nvar EXPECTED_ERRORS = new Set([\"EINVAL\", \"ENOENT\"]);\n\n// On Windows there is also this error in some cases\nif (process.platform === \"win32\") EXPECTED_ERRORS.add(\"UNKNOWN\");\nvar LinkResolver = /*#__PURE__*/function () {\n  function LinkResolver() {\n    _classCallCheck(this, LinkResolver);\n    this.cache = new Map();\n  }\n\n  /**\n   * @param {string} file path to file or directory\n   * @returns {string[]} array of file and all symlinks contributed in the resolving process (first item is the resolved file)\n   */\n  _createClass(LinkResolver, [{\n    key: \"resolve\",\n    value: function resolve(file) {\n      var cacheEntry = this.cache.get(file);\n      if (cacheEntry !== undefined) {\n        return cacheEntry;\n      }\n      var parent = path.dirname(file);\n      if (parent === file) {\n        // At root of filesystem there can't be a link\n        var result = Object.freeze([file]);\n        this.cache.set(file, result);\n        return result;\n      }\n      // resolve the parent directory to find links there and get the real path\n      var parentResolved = this.resolve(parent);\n      var realFile = file;\n\n      // is the parent directory really somewhere else?\n      if (parentResolved[0] !== parent) {\n        // get the real location of file\n        var basename = path.basename(file);\n        realFile = path.resolve(parentResolved[0], basename);\n      }\n      // try to read the link content\n      try {\n        var linkContent = fs.readlinkSync(realFile);\n\n        // resolve the link content relative to the parent directory\n        var resolvedLink = path.resolve(parentResolved[0], linkContent);\n\n        // recursive resolve the link content for more links in the structure\n        var linkResolved = this.resolve(resolvedLink);\n\n        // merge parent and link resolve results\n        var _result;\n        if (linkResolved.length > 1 && parentResolved.length > 1) {\n          // when both contain links we need to duplicate them with a Set\n          var resultSet = new Set(linkResolved);\n          // add the link\n          resultSet.add(realFile);\n          // add all symlinks of the parent\n          for (var i = 1; i < parentResolved.length; i++) {\n            resultSet.add(parentResolved[i]);\n          }\n          _result = Object.freeze(Array.from(resultSet));\n        } else if (parentResolved.length > 1) {\n          // we have links in the parent but not for the link content location\n          _result = parentResolved.slice();\n          _result[0] = linkResolved[0];\n          // add the link\n          _result.push(realFile);\n          Object.freeze(_result);\n        } else if (linkResolved.length > 1) {\n          // we can return the link content location result\n          _result = linkResolved.slice();\n          // add the link\n          _result.push(realFile);\n          Object.freeze(_result);\n        } else {\n          // neither link content location nor parent have links\n          // this link is the only link here\n          _result = Object.freeze([\n          // the resolve real location\n          linkResolved[0],\n          // add the link\n          realFile]);\n        }\n        this.cache.set(file, _result);\n        return _result;\n      } catch (e) {\n        if (!EXPECTED_ERRORS.has(e.code)) {\n          throw e;\n        }\n        // no link\n        var _result2 = parentResolved.slice();\n        _result2[0] = realFile;\n        Object.freeze(_result2);\n        this.cache.set(file, _result2);\n        return _result2;\n      }\n    }\n  }]);\n  return LinkResolver;\n}();\nmodule.exports = LinkResolver;","map":{"version":3,"names":["fs","require","path","EXPECTED_ERRORS","Set","process","platform","add","LinkResolver","cache","Map","file","cacheEntry","get","undefined","parent","dirname","result","Object","freeze","set","parentResolved","resolve","realFile","basename","linkContent","readlinkSync","resolvedLink","linkResolved","length","resultSet","i","Array","from","slice","push","e","has","code","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/watchpack/lib/LinkResolver.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\n// macOS, Linux, and Windows all rely on these errors\nconst EXPECTED_ERRORS = new Set([\"EINVAL\", \"ENOENT\"]);\n\n// On Windows there is also this error in some cases\nif (process.platform === \"win32\") EXPECTED_ERRORS.add(\"UNKNOWN\");\n\nclass LinkResolver {\n\tconstructor() {\n\t\tthis.cache = new Map();\n\t}\n\n\t/**\n\t * @param {string} file path to file or directory\n\t * @returns {string[]} array of file and all symlinks contributed in the resolving process (first item is the resolved file)\n\t */\n\tresolve(file) {\n\t\tconst cacheEntry = this.cache.get(file);\n\t\tif (cacheEntry !== undefined) {\n\t\t\treturn cacheEntry;\n\t\t}\n\t\tconst parent = path.dirname(file);\n\t\tif (parent === file) {\n\t\t\t// At root of filesystem there can't be a link\n\t\t\tconst result = Object.freeze([file]);\n\t\t\tthis.cache.set(file, result);\n\t\t\treturn result;\n\t\t}\n\t\t// resolve the parent directory to find links there and get the real path\n\t\tconst parentResolved = this.resolve(parent);\n\t\tlet realFile = file;\n\n\t\t// is the parent directory really somewhere else?\n\t\tif (parentResolved[0] !== parent) {\n\t\t\t// get the real location of file\n\t\t\tconst basename = path.basename(file);\n\t\t\trealFile = path.resolve(parentResolved[0], basename);\n\t\t}\n\t\t// try to read the link content\n\t\ttry {\n\t\t\tconst linkContent = fs.readlinkSync(realFile);\n\n\t\t\t// resolve the link content relative to the parent directory\n\t\t\tconst resolvedLink = path.resolve(parentResolved[0], linkContent);\n\n\t\t\t// recursive resolve the link content for more links in the structure\n\t\t\tconst linkResolved = this.resolve(resolvedLink);\n\n\t\t\t// merge parent and link resolve results\n\t\t\tlet result;\n\t\t\tif (linkResolved.length > 1 && parentResolved.length > 1) {\n\t\t\t\t// when both contain links we need to duplicate them with a Set\n\t\t\t\tconst resultSet = new Set(linkResolved);\n\t\t\t\t// add the link\n\t\t\t\tresultSet.add(realFile);\n\t\t\t\t// add all symlinks of the parent\n\t\t\t\tfor (let i = 1; i < parentResolved.length; i++) {\n\t\t\t\t\tresultSet.add(parentResolved[i]);\n\t\t\t\t}\n\t\t\t\tresult = Object.freeze(Array.from(resultSet));\n\t\t\t} else if (parentResolved.length > 1) {\n\t\t\t\t// we have links in the parent but not for the link content location\n\t\t\t\tresult = parentResolved.slice();\n\t\t\t\tresult[0] = linkResolved[0];\n\t\t\t\t// add the link\n\t\t\t\tresult.push(realFile);\n\t\t\t\tObject.freeze(result);\n\t\t\t} else if (linkResolved.length > 1) {\n\t\t\t\t// we can return the link content location result\n\t\t\t\tresult = linkResolved.slice();\n\t\t\t\t// add the link\n\t\t\t\tresult.push(realFile);\n\t\t\t\tObject.freeze(result);\n\t\t\t} else {\n\t\t\t\t// neither link content location nor parent have links\n\t\t\t\t// this link is the only link here\n\t\t\t\tresult = Object.freeze([\n\t\t\t\t\t// the resolve real location\n\t\t\t\t\tlinkResolved[0],\n\t\t\t\t\t// add the link\n\t\t\t\t\trealFile\n\t\t\t\t]);\n\t\t\t}\n\t\t\tthis.cache.set(file, result);\n\t\t\treturn result;\n\t\t} catch (e) {\n\t\t\tif (!EXPECTED_ERRORS.has(e.code)) {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\t// no link\n\t\t\tconst result = parentResolved.slice();\n\t\t\tresult[0] = realFile;\n\t\t\tObject.freeze(result);\n\t\t\tthis.cache.set(file, result);\n\t\t\treturn result;\n\t\t}\n\t}\n}\nmodule.exports = LinkResolver;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}