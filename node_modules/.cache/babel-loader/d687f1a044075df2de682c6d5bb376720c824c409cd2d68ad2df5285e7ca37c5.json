{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar CachedConstDependency = require(\"./dependencies/CachedConstDependency\");\nvar ConstDependency = require(\"./dependencies/ConstDependency\");\nvar _require = require(\"./javascript/JavascriptParserHelpers\"),\n  evaluateToString = _require.evaluateToString;\nvar _require2 = require(\"./util/identifier\"),\n  parseResource = _require2.parseResource;\n\n/** @typedef {import(\"estree\").Expression} ExpressionNode */\n/** @typedef {import(\"estree\").Super} SuperNode */\n/** @typedef {import(\"./Compiler\")} Compiler */\n\nvar collectDeclaration = function collectDeclaration(declarations, pattern) {\n  var stack = [pattern];\n  while (stack.length > 0) {\n    var node = stack.pop();\n    switch (node.type) {\n      case \"Identifier\":\n        declarations.add(node.name);\n        break;\n      case \"ArrayPattern\":\n        var _iterator = _createForOfIteratorHelper(node.elements),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var element = _step.value;\n            if (element) {\n              stack.push(element);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        break;\n      case \"AssignmentPattern\":\n        stack.push(node.left);\n        break;\n      case \"ObjectPattern\":\n        var _iterator2 = _createForOfIteratorHelper(node.properties),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var property = _step2.value;\n            stack.push(property.value);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        break;\n      case \"RestElement\":\n        stack.push(node.argument);\n        break;\n    }\n  }\n};\nvar getHoistedDeclarations = function getHoistedDeclarations(branch, includeFunctionDeclarations) {\n  var declarations = new Set();\n  var stack = [branch];\n  while (stack.length > 0) {\n    var node = stack.pop();\n    // Some node could be `null` or `undefined`.\n    if (!node) continue;\n    switch (node.type) {\n      // Walk through control statements to look for hoisted declarations.\n      // Some branches are skipped since they do not allow declarations.\n      case \"BlockStatement\":\n        var _iterator3 = _createForOfIteratorHelper(node.body),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var stmt = _step3.value;\n            stack.push(stmt);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        break;\n      case \"IfStatement\":\n        stack.push(node.consequent);\n        stack.push(node.alternate);\n        break;\n      case \"ForStatement\":\n        stack.push(node.init);\n        stack.push(node.body);\n        break;\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        stack.push(node.left);\n        stack.push(node.body);\n        break;\n      case \"DoWhileStatement\":\n      case \"WhileStatement\":\n      case \"LabeledStatement\":\n        stack.push(node.body);\n        break;\n      case \"SwitchStatement\":\n        var _iterator4 = _createForOfIteratorHelper(node.cases),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var cs = _step4.value;\n            var _iterator5 = _createForOfIteratorHelper(cs.consequent),\n              _step5;\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                var consequent = _step5.value;\n                stack.push(consequent);\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n        break;\n      case \"TryStatement\":\n        stack.push(node.block);\n        if (node.handler) {\n          stack.push(node.handler.body);\n        }\n        stack.push(node.finalizer);\n        break;\n      case \"FunctionDeclaration\":\n        if (includeFunctionDeclarations) {\n          collectDeclaration(declarations, node.id);\n        }\n        break;\n      case \"VariableDeclaration\":\n        if (node.kind === \"var\") {\n          var _iterator6 = _createForOfIteratorHelper(node.declarations),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var decl = _step6.value;\n              collectDeclaration(declarations, decl.id);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n        break;\n    }\n  }\n  return Array.from(declarations);\n};\nvar ConstPlugin = /*#__PURE__*/function () {\n  function ConstPlugin() {\n    _classCallCheck(this, ConstPlugin);\n  }\n  _createClass(ConstPlugin, [{\n    key: \"apply\",\n    value:\n    /**\n     * Apply the plugin\n     * @param {Compiler} compiler the compiler instance\n     * @returns {void}\n     */\n    function apply(compiler) {\n      var cachedParseResource = parseResource.bindCache(compiler.root);\n      compiler.hooks.compilation.tap(\"ConstPlugin\", function (compilation, _ref) {\n        var normalModuleFactory = _ref.normalModuleFactory;\n        compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n        compilation.dependencyTemplates.set(CachedConstDependency, new CachedConstDependency.Template());\n        var handler = function handler(parser) {\n          parser.hooks.statementIf.tap(\"ConstPlugin\", function (statement) {\n            if (parser.scope.isAsmJs) return;\n            var param = parser.evaluateExpression(statement.test);\n            var bool = param.asBool();\n            if (typeof bool === \"boolean\") {\n              if (!param.couldHaveSideEffects()) {\n                var dep = new ConstDependency(\"\".concat(bool), param.range);\n                dep.loc = statement.loc;\n                parser.state.module.addPresentationalDependency(dep);\n              } else {\n                parser.walkExpression(statement.test);\n              }\n              var branchToRemove = bool ? statement.alternate : statement.consequent;\n              if (branchToRemove) {\n                // Before removing the dead branch, the hoisted declarations\n                // must be collected.\n                //\n                // Given the following code:\n                //\n                //     if (true) f() else g()\n                //     if (false) {\n                //       function f() {}\n                //       const g = function g() {}\n                //       if (someTest) {\n                //         let a = 1\n                //         var x, {y, z} = obj\n                //       }\n                //     } else {\n                //       …\n                //     }\n                //\n                // the generated code is:\n                //\n                //     if (true) f() else {}\n                //     if (false) {\n                //       var f, x, y, z;   (in loose mode)\n                //       var x, y, z;      (in strict mode)\n                //     } else {\n                //       …\n                //     }\n                //\n                // NOTE: When code runs in strict mode, `var` declarations\n                // are hoisted but `function` declarations don't.\n                //\n                var declarations;\n                if (parser.scope.isStrict) {\n                  // If the code runs in strict mode, variable declarations\n                  // using `var` must be hoisted.\n                  declarations = getHoistedDeclarations(branchToRemove, false);\n                } else {\n                  // Otherwise, collect all hoisted declaration.\n                  declarations = getHoistedDeclarations(branchToRemove, true);\n                }\n                var replacement;\n                if (declarations.length > 0) {\n                  replacement = \"{ var \".concat(declarations.join(\", \"), \"; }\");\n                } else {\n                  replacement = \"{}\";\n                }\n                var _dep = new ConstDependency(replacement, branchToRemove.range);\n                _dep.loc = branchToRemove.loc;\n                parser.state.module.addPresentationalDependency(_dep);\n              }\n              return bool;\n            }\n          });\n          parser.hooks.expressionConditionalOperator.tap(\"ConstPlugin\", function (expression) {\n            if (parser.scope.isAsmJs) return;\n            var param = parser.evaluateExpression(expression.test);\n            var bool = param.asBool();\n            if (typeof bool === \"boolean\") {\n              if (!param.couldHaveSideEffects()) {\n                var _dep2 = new ConstDependency(\" \".concat(bool), param.range);\n                _dep2.loc = expression.loc;\n                parser.state.module.addPresentationalDependency(_dep2);\n              } else {\n                parser.walkExpression(expression.test);\n              }\n              // Expressions do not hoist.\n              // It is safe to remove the dead branch.\n              //\n              // Given the following code:\n              //\n              //   false ? someExpression() : otherExpression();\n              //\n              // the generated code is:\n              //\n              //   false ? 0 : otherExpression();\n              //\n              var branchToRemove = bool ? expression.alternate : expression.consequent;\n              var dep = new ConstDependency(\"0\", branchToRemove.range);\n              dep.loc = branchToRemove.loc;\n              parser.state.module.addPresentationalDependency(dep);\n              return bool;\n            }\n          });\n          parser.hooks.expressionLogicalOperator.tap(\"ConstPlugin\", function (expression) {\n            if (parser.scope.isAsmJs) return;\n            if (expression.operator === \"&&\" || expression.operator === \"||\") {\n              var param = parser.evaluateExpression(expression.left);\n              var bool = param.asBool();\n              if (typeof bool === \"boolean\") {\n                // Expressions do not hoist.\n                // It is safe to remove the dead branch.\n                //\n                // ------------------------------------------\n                //\n                // Given the following code:\n                //\n                //   falsyExpression() && someExpression();\n                //\n                // the generated code is:\n                //\n                //   falsyExpression() && false;\n                //\n                // ------------------------------------------\n                //\n                // Given the following code:\n                //\n                //   truthyExpression() && someExpression();\n                //\n                // the generated code is:\n                //\n                //   true && someExpression();\n                //\n                // ------------------------------------------\n                //\n                // Given the following code:\n                //\n                //   truthyExpression() || someExpression();\n                //\n                // the generated code is:\n                //\n                //   truthyExpression() || false;\n                //\n                // ------------------------------------------\n                //\n                // Given the following code:\n                //\n                //   falsyExpression() || someExpression();\n                //\n                // the generated code is:\n                //\n                //   false && someExpression();\n                //\n                var keepRight = expression.operator === \"&&\" && bool || expression.operator === \"||\" && !bool;\n                if (!param.couldHaveSideEffects() && (param.isBoolean() || keepRight)) {\n                  // for case like\n                  //\n                  //   return'development'===process.env.NODE_ENV&&'foo'\n                  //\n                  // we need a space before the bool to prevent result like\n                  //\n                  //   returnfalse&&'foo'\n                  //\n                  var dep = new ConstDependency(\" \".concat(bool), param.range);\n                  dep.loc = expression.loc;\n                  parser.state.module.addPresentationalDependency(dep);\n                } else {\n                  parser.walkExpression(expression.left);\n                }\n                if (!keepRight) {\n                  var _dep3 = new ConstDependency(\"0\", expression.right.range);\n                  _dep3.loc = expression.loc;\n                  parser.state.module.addPresentationalDependency(_dep3);\n                }\n                return keepRight;\n              }\n            } else if (expression.operator === \"??\") {\n              var _param = parser.evaluateExpression(expression.left);\n              var _keepRight = _param.asNullish();\n              if (typeof _keepRight === \"boolean\") {\n                // ------------------------------------------\n                //\n                // Given the following code:\n                //\n                //   nonNullish ?? someExpression();\n                //\n                // the generated code is:\n                //\n                //   nonNullish ?? 0;\n                //\n                // ------------------------------------------\n                //\n                // Given the following code:\n                //\n                //   nullish ?? someExpression();\n                //\n                // the generated code is:\n                //\n                //   null ?? someExpression();\n                //\n                if (!_param.couldHaveSideEffects() && _keepRight) {\n                  // cspell:word returnnull\n                  // for case like\n                  //\n                  //   return('development'===process.env.NODE_ENV&&null)??'foo'\n                  //\n                  // we need a space before the bool to prevent result like\n                  //\n                  //   returnnull??'foo'\n                  //\n                  var _dep4 = new ConstDependency(\" null\", _param.range);\n                  _dep4.loc = expression.loc;\n                  parser.state.module.addPresentationalDependency(_dep4);\n                } else {\n                  var _dep5 = new ConstDependency(\"0\", expression.right.range);\n                  _dep5.loc = expression.loc;\n                  parser.state.module.addPresentationalDependency(_dep5);\n                  parser.walkExpression(expression.left);\n                }\n                return _keepRight;\n              }\n            }\n          });\n          parser.hooks.optionalChaining.tap(\"ConstPlugin\", function (expr) {\n            /** @type {ExpressionNode[]} */\n            var optionalExpressionsStack = [];\n            /** @type {ExpressionNode|SuperNode} */\n            var next = expr.expression;\n            while (next.type === \"MemberExpression\" || next.type === \"CallExpression\") {\n              if (next.type === \"MemberExpression\") {\n                if (next.optional) {\n                  // SuperNode can not be optional\n                  optionalExpressionsStack.push( /** @type {ExpressionNode} */next.object);\n                }\n                next = next.object;\n              } else {\n                if (next.optional) {\n                  // SuperNode can not be optional\n                  optionalExpressionsStack.push( /** @type {ExpressionNode} */next.callee);\n                }\n                next = next.callee;\n              }\n            }\n            while (optionalExpressionsStack.length) {\n              var expression = optionalExpressionsStack.pop();\n              var evaluated = parser.evaluateExpression(expression);\n              if (evaluated.asNullish()) {\n                // ------------------------------------------\n                //\n                // Given the following code:\n                //\n                //   nullishMemberChain?.a.b();\n                //\n                // the generated code is:\n                //\n                //   undefined;\n                //\n                // ------------------------------------------\n                //\n                var dep = new ConstDependency(\" undefined\", expr.range);\n                dep.loc = expr.loc;\n                parser.state.module.addPresentationalDependency(dep);\n                return true;\n              }\n            }\n          });\n          parser.hooks.evaluateIdentifier.for(\"__resourceQuery\").tap(\"ConstPlugin\", function (expr) {\n            if (parser.scope.isAsmJs) return;\n            if (!parser.state.module) return;\n            return evaluateToString(cachedParseResource(parser.state.module.resource).query)(expr);\n          });\n          parser.hooks.expression.for(\"__resourceQuery\").tap(\"ConstPlugin\", function (expr) {\n            if (parser.scope.isAsmJs) return;\n            if (!parser.state.module) return;\n            var dep = new CachedConstDependency(JSON.stringify(cachedParseResource(parser.state.module.resource).query), expr.range, \"__resourceQuery\");\n            dep.loc = expr.loc;\n            parser.state.module.addPresentationalDependency(dep);\n            return true;\n          });\n          parser.hooks.evaluateIdentifier.for(\"__resourceFragment\").tap(\"ConstPlugin\", function (expr) {\n            if (parser.scope.isAsmJs) return;\n            if (!parser.state.module) return;\n            return evaluateToString(cachedParseResource(parser.state.module.resource).fragment)(expr);\n          });\n          parser.hooks.expression.for(\"__resourceFragment\").tap(\"ConstPlugin\", function (expr) {\n            if (parser.scope.isAsmJs) return;\n            if (!parser.state.module) return;\n            var dep = new CachedConstDependency(JSON.stringify(cachedParseResource(parser.state.module.resource).fragment), expr.range, \"__resourceFragment\");\n            dep.loc = expr.loc;\n            parser.state.module.addPresentationalDependency(dep);\n            return true;\n          });\n        };\n        normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"ConstPlugin\", handler);\n        normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"ConstPlugin\", handler);\n        normalModuleFactory.hooks.parser.for(\"javascript/esm\").tap(\"ConstPlugin\", handler);\n      });\n    }\n  }]);\n  return ConstPlugin;\n}();\nmodule.exports = ConstPlugin;","map":{"version":3,"names":["CachedConstDependency","require","ConstDependency","evaluateToString","parseResource","collectDeclaration","declarations","pattern","stack","length","node","pop","type","add","name","elements","element","push","left","properties","property","value","argument","getHoistedDeclarations","branch","includeFunctionDeclarations","Set","body","stmt","consequent","alternate","init","cases","cs","block","handler","finalizer","id","kind","decl","Array","from","ConstPlugin","compiler","cachedParseResource","bindCache","root","hooks","compilation","tap","normalModuleFactory","dependencyTemplates","set","Template","parser","statementIf","statement","scope","isAsmJs","param","evaluateExpression","test","bool","asBool","couldHaveSideEffects","dep","range","loc","state","module","addPresentationalDependency","walkExpression","branchToRemove","isStrict","replacement","join","expressionConditionalOperator","expression","expressionLogicalOperator","operator","keepRight","isBoolean","right","asNullish","optionalChaining","expr","optionalExpressionsStack","next","optional","object","callee","evaluated","evaluateIdentifier","for","resource","query","JSON","stringify","fragment","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/ConstPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst CachedConstDependency = require(\"./dependencies/CachedConstDependency\");\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst { evaluateToString } = require(\"./javascript/JavascriptParserHelpers\");\nconst { parseResource } = require(\"./util/identifier\");\n\n/** @typedef {import(\"estree\").Expression} ExpressionNode */\n/** @typedef {import(\"estree\").Super} SuperNode */\n/** @typedef {import(\"./Compiler\")} Compiler */\n\nconst collectDeclaration = (declarations, pattern) => {\n\tconst stack = [pattern];\n\twhile (stack.length > 0) {\n\t\tconst node = stack.pop();\n\t\tswitch (node.type) {\n\t\t\tcase \"Identifier\":\n\t\t\t\tdeclarations.add(node.name);\n\t\t\t\tbreak;\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tfor (const element of node.elements) {\n\t\t\t\t\tif (element) {\n\t\t\t\t\t\tstack.push(element);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tstack.push(node.left);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tfor (const property of node.properties) {\n\t\t\t\t\tstack.push(property.value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tstack.push(node.argument);\n\t\t\t\tbreak;\n\t\t}\n\t}\n};\n\nconst getHoistedDeclarations = (branch, includeFunctionDeclarations) => {\n\tconst declarations = new Set();\n\tconst stack = [branch];\n\twhile (stack.length > 0) {\n\t\tconst node = stack.pop();\n\t\t// Some node could be `null` or `undefined`.\n\t\tif (!node) continue;\n\t\tswitch (node.type) {\n\t\t\t// Walk through control statements to look for hoisted declarations.\n\t\t\t// Some branches are skipped since they do not allow declarations.\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tfor (const stmt of node.body) {\n\t\t\t\t\tstack.push(stmt);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tstack.push(node.consequent);\n\t\t\t\tstack.push(node.alternate);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tstack.push(node.init);\n\t\t\t\tstack.push(node.body);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tstack.push(node.left);\n\t\t\t\tstack.push(node.body);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\tcase \"WhileStatement\":\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tstack.push(node.body);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tfor (const cs of node.cases) {\n\t\t\t\t\tfor (const consequent of cs.consequent) {\n\t\t\t\t\t\tstack.push(consequent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tstack.push(node.block);\n\t\t\t\tif (node.handler) {\n\t\t\t\t\tstack.push(node.handler.body);\n\t\t\t\t}\n\t\t\t\tstack.push(node.finalizer);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tif (includeFunctionDeclarations) {\n\t\t\t\t\tcollectDeclaration(declarations, node.id);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tif (node.kind === \"var\") {\n\t\t\t\t\tfor (const decl of node.declarations) {\n\t\t\t\t\t\tcollectDeclaration(declarations, decl.id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn Array.from(declarations);\n};\n\nclass ConstPlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst cachedParseResource = parseResource.bindCache(compiler.root);\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"ConstPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tConstDependency,\n\t\t\t\t\tnew ConstDependency.Template()\n\t\t\t\t);\n\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tCachedConstDependency,\n\t\t\t\t\tnew CachedConstDependency.Template()\n\t\t\t\t);\n\n\t\t\t\tconst handler = parser => {\n\t\t\t\t\tparser.hooks.statementIf.tap(\"ConstPlugin\", statement => {\n\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\tconst param = parser.evaluateExpression(statement.test);\n\t\t\t\t\t\tconst bool = param.asBool();\n\t\t\t\t\t\tif (typeof bool === \"boolean\") {\n\t\t\t\t\t\t\tif (!param.couldHaveSideEffects()) {\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(`${bool}`, param.range);\n\t\t\t\t\t\t\t\tdep.loc = statement.loc;\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparser.walkExpression(statement.test);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst branchToRemove = bool\n\t\t\t\t\t\t\t\t? statement.alternate\n\t\t\t\t\t\t\t\t: statement.consequent;\n\t\t\t\t\t\t\tif (branchToRemove) {\n\t\t\t\t\t\t\t\t// Before removing the dead branch, the hoisted declarations\n\t\t\t\t\t\t\t\t// must be collected.\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//     if (true) f() else g()\n\t\t\t\t\t\t\t\t//     if (false) {\n\t\t\t\t\t\t\t\t//       function f() {}\n\t\t\t\t\t\t\t\t//       const g = function g() {}\n\t\t\t\t\t\t\t\t//       if (someTest) {\n\t\t\t\t\t\t\t\t//         let a = 1\n\t\t\t\t\t\t\t\t//         var x, {y, z} = obj\n\t\t\t\t\t\t\t\t//       }\n\t\t\t\t\t\t\t\t//     } else {\n\t\t\t\t\t\t\t\t//       …\n\t\t\t\t\t\t\t\t//     }\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//     if (true) f() else {}\n\t\t\t\t\t\t\t\t//     if (false) {\n\t\t\t\t\t\t\t\t//       var f, x, y, z;   (in loose mode)\n\t\t\t\t\t\t\t\t//       var x, y, z;      (in strict mode)\n\t\t\t\t\t\t\t\t//     } else {\n\t\t\t\t\t\t\t\t//       …\n\t\t\t\t\t\t\t\t//     }\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// NOTE: When code runs in strict mode, `var` declarations\n\t\t\t\t\t\t\t\t// are hoisted but `function` declarations don't.\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tlet declarations;\n\t\t\t\t\t\t\t\tif (parser.scope.isStrict) {\n\t\t\t\t\t\t\t\t\t// If the code runs in strict mode, variable declarations\n\t\t\t\t\t\t\t\t\t// using `var` must be hoisted.\n\t\t\t\t\t\t\t\t\tdeclarations = getHoistedDeclarations(branchToRemove, false);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Otherwise, collect all hoisted declaration.\n\t\t\t\t\t\t\t\t\tdeclarations = getHoistedDeclarations(branchToRemove, true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet replacement;\n\t\t\t\t\t\t\t\tif (declarations.length > 0) {\n\t\t\t\t\t\t\t\t\treplacement = `{ var ${declarations.join(\", \")}; }`;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treplacement = \"{}\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\treplacement,\n\t\t\t\t\t\t\t\t\tbranchToRemove.range\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdep.loc = branchToRemove.loc;\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn bool;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.expressionConditionalOperator.tap(\n\t\t\t\t\t\t\"ConstPlugin\",\n\t\t\t\t\t\texpression => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tconst param = parser.evaluateExpression(expression.test);\n\t\t\t\t\t\t\tconst bool = param.asBool();\n\t\t\t\t\t\t\tif (typeof bool === \"boolean\") {\n\t\t\t\t\t\t\t\tif (!param.couldHaveSideEffects()) {\n\t\t\t\t\t\t\t\t\tconst dep = new ConstDependency(` ${bool}`, param.range);\n\t\t\t\t\t\t\t\t\tdep.loc = expression.loc;\n\t\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tparser.walkExpression(expression.test);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Expressions do not hoist.\n\t\t\t\t\t\t\t\t// It is safe to remove the dead branch.\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//   false ? someExpression() : otherExpression();\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//   false ? 0 : otherExpression();\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tconst branchToRemove = bool\n\t\t\t\t\t\t\t\t\t? expression.alternate\n\t\t\t\t\t\t\t\t\t: expression.consequent;\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\"0\", branchToRemove.range);\n\t\t\t\t\t\t\t\tdep.loc = branchToRemove.loc;\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\treturn bool;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tparser.hooks.expressionLogicalOperator.tap(\n\t\t\t\t\t\t\"ConstPlugin\",\n\t\t\t\t\t\texpression => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\texpression.operator === \"&&\" ||\n\t\t\t\t\t\t\t\texpression.operator === \"||\"\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst param = parser.evaluateExpression(expression.left);\n\t\t\t\t\t\t\t\tconst bool = param.asBool();\n\t\t\t\t\t\t\t\tif (typeof bool === \"boolean\") {\n\t\t\t\t\t\t\t\t\t// Expressions do not hoist.\n\t\t\t\t\t\t\t\t\t// It is safe to remove the dead branch.\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   falsyExpression() && someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   falsyExpression() && false;\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   truthyExpression() && someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   true && someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   truthyExpression() || someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   truthyExpression() || false;\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   falsyExpression() || someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   false && someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\tconst keepRight =\n\t\t\t\t\t\t\t\t\t\t(expression.operator === \"&&\" && bool) ||\n\t\t\t\t\t\t\t\t\t\t(expression.operator === \"||\" && !bool);\n\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!param.couldHaveSideEffects() &&\n\t\t\t\t\t\t\t\t\t\t(param.isBoolean() || keepRight)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t// for case like\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t//   return'development'===process.env.NODE_ENV&&'foo'\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t// we need a space before the bool to prevent result like\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t//   returnfalse&&'foo'\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\tconst dep = new ConstDependency(` ${bool}`, param.range);\n\t\t\t\t\t\t\t\t\t\tdep.loc = expression.loc;\n\t\t\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tparser.walkExpression(expression.left);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!keepRight) {\n\t\t\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t\t\t\"0\",\n\t\t\t\t\t\t\t\t\t\t\texpression.right.range\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tdep.loc = expression.loc;\n\t\t\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn keepRight;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (expression.operator === \"??\") {\n\t\t\t\t\t\t\t\tconst param = parser.evaluateExpression(expression.left);\n\t\t\t\t\t\t\t\tconst keepRight = param.asNullish();\n\t\t\t\t\t\t\t\tif (typeof keepRight === \"boolean\") {\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   nonNullish ?? someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   nonNullish ?? 0;\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   nullish ?? someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   null ?? someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\tif (!param.couldHaveSideEffects() && keepRight) {\n\t\t\t\t\t\t\t\t\t\t// cspell:word returnnull\n\t\t\t\t\t\t\t\t\t\t// for case like\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t//   return('development'===process.env.NODE_ENV&&null)??'foo'\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t// we need a space before the bool to prevent result like\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t//   returnnull??'foo'\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\" null\", param.range);\n\t\t\t\t\t\t\t\t\t\tdep.loc = expression.loc;\n\t\t\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t\t\t\"0\",\n\t\t\t\t\t\t\t\t\t\t\texpression.right.range\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tdep.loc = expression.loc;\n\t\t\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\t\t\tparser.walkExpression(expression.left);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn keepRight;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tparser.hooks.optionalChaining.tap(\"ConstPlugin\", expr => {\n\t\t\t\t\t\t/** @type {ExpressionNode[]} */\n\t\t\t\t\t\tconst optionalExpressionsStack = [];\n\t\t\t\t\t\t/** @type {ExpressionNode|SuperNode} */\n\t\t\t\t\t\tlet next = expr.expression;\n\n\t\t\t\t\t\twhile (\n\t\t\t\t\t\t\tnext.type === \"MemberExpression\" ||\n\t\t\t\t\t\t\tnext.type === \"CallExpression\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif (next.type === \"MemberExpression\") {\n\t\t\t\t\t\t\t\tif (next.optional) {\n\t\t\t\t\t\t\t\t\t// SuperNode can not be optional\n\t\t\t\t\t\t\t\t\toptionalExpressionsStack.push(\n\t\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (next.object)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnext = next.object;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (next.optional) {\n\t\t\t\t\t\t\t\t\t// SuperNode can not be optional\n\t\t\t\t\t\t\t\t\toptionalExpressionsStack.push(\n\t\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (next.callee)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnext = next.callee;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile (optionalExpressionsStack.length) {\n\t\t\t\t\t\t\tconst expression = optionalExpressionsStack.pop();\n\t\t\t\t\t\t\tconst evaluated = parser.evaluateExpression(expression);\n\n\t\t\t\t\t\t\tif (evaluated.asNullish()) {\n\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//   nullishMemberChain?.a.b();\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//   undefined;\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\" undefined\", expr.range);\n\t\t\t\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t.for(\"__resourceQuery\")\n\t\t\t\t\t\t.tap(\"ConstPlugin\", expr => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tif (!parser.state.module) return;\n\t\t\t\t\t\t\treturn evaluateToString(\n\t\t\t\t\t\t\t\tcachedParseResource(parser.state.module.resource).query\n\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.expression\n\t\t\t\t\t\t.for(\"__resourceQuery\")\n\t\t\t\t\t\t.tap(\"ConstPlugin\", expr => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tif (!parser.state.module) return;\n\t\t\t\t\t\t\tconst dep = new CachedConstDependency(\n\t\t\t\t\t\t\t\tJSON.stringify(\n\t\t\t\t\t\t\t\t\tcachedParseResource(parser.state.module.resource).query\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\texpr.range,\n\t\t\t\t\t\t\t\t\"__resourceQuery\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t.for(\"__resourceFragment\")\n\t\t\t\t\t\t.tap(\"ConstPlugin\", expr => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tif (!parser.state.module) return;\n\t\t\t\t\t\t\treturn evaluateToString(\n\t\t\t\t\t\t\t\tcachedParseResource(parser.state.module.resource).fragment\n\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.expression\n\t\t\t\t\t\t.for(\"__resourceFragment\")\n\t\t\t\t\t\t.tap(\"ConstPlugin\", expr => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tif (!parser.state.module) return;\n\t\t\t\t\t\t\tconst dep = new CachedConstDependency(\n\t\t\t\t\t\t\t\tJSON.stringify(\n\t\t\t\t\t\t\t\t\tcachedParseResource(parser.state.module.resource).fragment\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\texpr.range,\n\t\t\t\t\t\t\t\t\"__resourceFragment\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/auto\")\n\t\t\t\t\t.tap(\"ConstPlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/dynamic\")\n\t\t\t\t\t.tap(\"ConstPlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/esm\")\n\t\t\t\t\t.tap(\"ConstPlugin\", handler);\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = ConstPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}