{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _inherits = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _require = require(\"./helpers/getFromStreamChunks\"),\n  getMap = _require.getMap,\n  getSourceAndMap = _require.getSourceAndMap;\nvar _streamChunks = require(\"./helpers/streamChunks\");\nvar Source = require(\"./Source\");\nvar splitIntoLines = require(\"./helpers/splitIntoLines\");\n\n// since v8 7.0, Array.prototype.sort is stable\nvar hasStableSort = typeof process === \"object\" && process.versions && typeof process.versions.v8 === \"string\" && !/^[0-6]\\./.test(process.versions.v8);\n\n// This is larger than max string length\nvar MAX_SOURCE_POSITION = 0x20000000;\nvar Replacement = /*#__PURE__*/_createClass(function Replacement(start, end, content, name) {\n  _classCallCheck(this, Replacement);\n  this.start = start;\n  this.end = end;\n  this.content = content;\n  this.name = name;\n  if (!hasStableSort) {\n    this.index = -1;\n  }\n});\nvar ReplaceSource = /*#__PURE__*/function (_Source) {\n  _inherits(ReplaceSource, _Source);\n  var _super = _createSuper(ReplaceSource);\n  function ReplaceSource(source, name) {\n    var _this;\n    _classCallCheck(this, ReplaceSource);\n    _this = _super.call(this);\n    _this._source = source;\n    _this._name = name;\n    /** @type {Replacement[]} */\n    _this._replacements = [];\n    _this._isSorted = true;\n    return _this;\n  }\n  _createClass(ReplaceSource, [{\n    key: \"getName\",\n    value: function getName() {\n      return this._name;\n    }\n  }, {\n    key: \"getReplacements\",\n    value: function getReplacements() {\n      this._sortReplacements();\n      return this._replacements;\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(start, end, newValue, name) {\n      if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + typeof newValue);\n      this._replacements.push(new Replacement(start, end, newValue, name));\n      this._isSorted = false;\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(pos, newValue, name) {\n      if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + typeof newValue + \": \" + newValue);\n      this._replacements.push(new Replacement(pos, pos - 1, newValue, name));\n      this._isSorted = false;\n    }\n  }, {\n    key: \"source\",\n    value: function source() {\n      if (this._replacements.length === 0) {\n        return this._source.source();\n      }\n      var current = this._source.source();\n      var pos = 0;\n      var result = [];\n      this._sortReplacements();\n      var _iterator = _createForOfIteratorHelper(this._replacements),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var replacement = _step.value;\n          var start = Math.floor(replacement.start);\n          var end = Math.floor(replacement.end + 1);\n          if (pos < start) {\n            var offset = start - pos;\n            result.push(current.slice(0, offset));\n            current = current.slice(offset);\n            pos = start;\n          }\n          result.push(replacement.content);\n          if (pos < end) {\n            var _offset = end - pos;\n            current = current.slice(_offset);\n            pos = end;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      result.push(current);\n      return result.join(\"\");\n    }\n  }, {\n    key: \"map\",\n    value: function map(options) {\n      if (this._replacements.length === 0) {\n        return this._source.map(options);\n      }\n      return getMap(this, options);\n    }\n  }, {\n    key: \"sourceAndMap\",\n    value: function sourceAndMap(options) {\n      if (this._replacements.length === 0) {\n        return this._source.sourceAndMap(options);\n      }\n      return getSourceAndMap(this, options);\n    }\n  }, {\n    key: \"original\",\n    value: function original() {\n      return this._source;\n    }\n  }, {\n    key: \"_sortReplacements\",\n    value: function _sortReplacements() {\n      if (this._isSorted) return;\n      if (hasStableSort) {\n        this._replacements.sort(function (a, b) {\n          var diff1 = a.start - b.start;\n          if (diff1 !== 0) return diff1;\n          var diff2 = a.end - b.end;\n          if (diff2 !== 0) return diff2;\n          return 0;\n        });\n      } else {\n        this._replacements.forEach(function (repl, i) {\n          return repl.index = i;\n        });\n        this._replacements.sort(function (a, b) {\n          var diff1 = a.start - b.start;\n          if (diff1 !== 0) return diff1;\n          var diff2 = a.end - b.end;\n          if (diff2 !== 0) return diff2;\n          return a.index - b.index;\n        });\n      }\n      this._isSorted = true;\n    }\n  }, {\n    key: \"streamChunks\",\n    value: function streamChunks(options, onChunk, onSource, onName) {\n      this._sortReplacements();\n      var repls = this._replacements;\n      var pos = 0;\n      var i = 0;\n      var replacmentEnd = -1;\n      var nextReplacement = i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;\n      var generatedLineOffset = 0;\n      var generatedColumnOffset = 0;\n      var generatedColumnOffsetLine = 0;\n      var sourceContents = [];\n      var nameMapping = new Map();\n      var nameIndexMapping = [];\n      var checkOriginalContent = function checkOriginalContent(sourceIndex, line, column, expectedChunk) {\n        var content = sourceIndex < sourceContents.length ? sourceContents[sourceIndex] : undefined;\n        if (content === undefined) return false;\n        if (typeof content === \"string\") {\n          content = splitIntoLines(content);\n          sourceContents[sourceIndex] = content;\n        }\n        var contentLine = line <= content.length ? content[line - 1] : null;\n        if (contentLine === null) return false;\n        return contentLine.slice(column, column + expectedChunk.length) === expectedChunk;\n      };\n      var _streamChunks2 = _streamChunks(this._source, Object.assign({}, options, {\n          finalSource: false\n        }), function (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) {\n          var chunkPos = 0;\n          var endPos = pos + chunk.length;\n\n          // Skip over when it has been replaced\n          if (replacmentEnd > pos) {\n            // Skip over the whole chunk\n            if (replacmentEnd >= endPos) {\n              var _line = generatedLine + generatedLineOffset;\n              if (chunk.endsWith(\"\\n\")) {\n                generatedLineOffset--;\n                if (generatedColumnOffsetLine === _line) {\n                  // undo exiting corrections form the current line\n                  generatedColumnOffset += generatedColumn;\n                }\n              } else if (generatedColumnOffsetLine === _line) {\n                generatedColumnOffset -= chunk.length;\n              } else {\n                generatedColumnOffset = -chunk.length;\n                generatedColumnOffsetLine = _line;\n              }\n              pos = endPos;\n              return;\n            }\n\n            // Partially skip over chunk\n            chunkPos = replacmentEnd - pos;\n            if (checkOriginalContent(sourceIndex, originalLine, originalColumn, chunk.slice(0, chunkPos))) {\n              originalColumn += chunkPos;\n            }\n            pos += chunkPos;\n            var _line2 = generatedLine + generatedLineOffset;\n            if (generatedColumnOffsetLine === _line2) {\n              generatedColumnOffset -= chunkPos;\n            } else {\n              generatedColumnOffset = -chunkPos;\n              generatedColumnOffsetLine = _line2;\n            }\n            generatedColumn += chunkPos;\n          }\n\n          // Is a replacement in the chunk?\n          if (nextReplacement < endPos) {\n            do {\n              var _line3 = generatedLine + generatedLineOffset;\n              if (nextReplacement > pos) {\n                // Emit chunk until replacement\n                var _offset2 = nextReplacement - pos;\n                var chunkSlice = chunk.slice(chunkPos, chunkPos + _offset2);\n                onChunk(chunkSlice, _line3, generatedColumn + (_line3 === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex]);\n                generatedColumn += _offset2;\n                chunkPos += _offset2;\n                pos = nextReplacement;\n                if (checkOriginalContent(sourceIndex, originalLine, originalColumn, chunkSlice)) {\n                  originalColumn += chunkSlice.length;\n                }\n              }\n\n              // Insert replacement content splitted into chunks by lines\n              var _repls$i = repls[i],\n                content = _repls$i.content,\n                name = _repls$i.name;\n              var _matches = splitIntoLines(content);\n              var replacementNameIndex = nameIndex;\n              if (sourceIndex >= 0 && name) {\n                var globalIndex = nameMapping.get(name);\n                if (globalIndex === undefined) {\n                  globalIndex = nameMapping.size;\n                  nameMapping.set(name, globalIndex);\n                  onName(globalIndex, name);\n                }\n                replacementNameIndex = globalIndex;\n              }\n              for (var m = 0; m < _matches.length; m++) {\n                var contentLine = _matches[m];\n                onChunk(contentLine, _line3, generatedColumn + (_line3 === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, replacementNameIndex);\n\n                // Only the first chunk has name assigned\n                replacementNameIndex = -1;\n                if (m === _matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n                  if (generatedColumnOffsetLine === _line3) {\n                    generatedColumnOffset += contentLine.length;\n                  } else {\n                    generatedColumnOffset = contentLine.length;\n                    generatedColumnOffsetLine = _line3;\n                  }\n                } else {\n                  generatedLineOffset++;\n                  _line3++;\n                  generatedColumnOffset = -generatedColumn;\n                  generatedColumnOffsetLine = _line3;\n                }\n              }\n\n              // Remove replaced content by settings this variable\n              replacmentEnd = Math.max(replacmentEnd, Math.floor(repls[i].end + 1));\n\n              // Move to next replacment\n              i++;\n              nextReplacement = i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;\n\n              // Skip over when it has been replaced\n              var offset = chunk.length - endPos + replacmentEnd - chunkPos;\n              if (offset > 0) {\n                // Skip over whole chunk\n                if (replacmentEnd >= endPos) {\n                  var _line4 = generatedLine + generatedLineOffset;\n                  if (chunk.endsWith(\"\\n\")) {\n                    generatedLineOffset--;\n                    if (generatedColumnOffsetLine === _line4) {\n                      // undo exiting corrections form the current line\n                      generatedColumnOffset += generatedColumn;\n                    }\n                  } else if (generatedColumnOffsetLine === _line4) {\n                    generatedColumnOffset -= chunk.length - chunkPos;\n                  } else {\n                    generatedColumnOffset = chunkPos - chunk.length;\n                    generatedColumnOffsetLine = _line4;\n                  }\n                  pos = endPos;\n                  return;\n                }\n\n                // Partially skip over chunk\n                var _line5 = generatedLine + generatedLineOffset;\n                if (checkOriginalContent(sourceIndex, originalLine, originalColumn, chunk.slice(chunkPos, chunkPos + offset))) {\n                  originalColumn += offset;\n                }\n                chunkPos += offset;\n                pos += offset;\n                if (generatedColumnOffsetLine === _line5) {\n                  generatedColumnOffset -= offset;\n                } else {\n                  generatedColumnOffset = -offset;\n                  generatedColumnOffsetLine = _line5;\n                }\n                generatedColumn += offset;\n              }\n            } while (nextReplacement < endPos);\n          }\n\n          // Emit remaining chunk\n          if (chunkPos < chunk.length) {\n            var _chunkSlice = chunkPos === 0 ? chunk : chunk.slice(chunkPos);\n            var _line6 = generatedLine + generatedLineOffset;\n            onChunk(_chunkSlice, _line6, generatedColumn + (_line6 === generatedColumnOffsetLine ? generatedColumnOffset : 0), sourceIndex, originalLine, originalColumn, nameIndex < 0 ? -1 : nameIndexMapping[nameIndex]);\n          }\n          pos = endPos;\n        }, function (sourceIndex, source, sourceContent) {\n          while (sourceContents.length < sourceIndex) sourceContents.push(undefined);\n          sourceContents[sourceIndex] = sourceContent;\n          onSource(sourceIndex, source, sourceContent);\n        }, function (nameIndex, name) {\n          var globalIndex = nameMapping.get(name);\n          if (globalIndex === undefined) {\n            globalIndex = nameMapping.size;\n            nameMapping.set(name, globalIndex);\n            onName(globalIndex, name);\n          }\n          nameIndexMapping[nameIndex] = globalIndex;\n        }),\n        generatedLine = _streamChunks2.generatedLine,\n        generatedColumn = _streamChunks2.generatedColumn;\n\n      // Handle remaining replacements\n      var remainer = \"\";\n      for (; i < repls.length; i++) {\n        remainer += repls[i].content;\n      }\n\n      // Insert remaining replacements content splitted into chunks by lines\n      var line = generatedLine + generatedLineOffset;\n      var matches = splitIntoLines(remainer);\n      for (var m = 0; m < matches.length; m++) {\n        var contentLine = matches[m];\n        onChunk(contentLine, line, generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0), -1, -1, -1, -1);\n        if (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n          if (generatedColumnOffsetLine === line) {\n            generatedColumnOffset += contentLine.length;\n          } else {\n            generatedColumnOffset = contentLine.length;\n            generatedColumnOffsetLine = line;\n          }\n        } else {\n          generatedLineOffset++;\n          line++;\n          generatedColumnOffset = -generatedColumn;\n          generatedColumnOffsetLine = line;\n        }\n      }\n      return {\n        generatedLine: line,\n        generatedColumn: generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0)\n      };\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      this._sortReplacements();\n      hash.update(\"ReplaceSource\");\n      this._source.updateHash(hash);\n      hash.update(this._name || \"\");\n      var _iterator2 = _createForOfIteratorHelper(this._replacements),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var repl = _step2.value;\n          hash.update(\"\".concat(repl.start).concat(repl.end).concat(repl.content).concat(repl.name));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }]);\n  return ReplaceSource;\n}(Source);\nmodule.exports = ReplaceSource;","map":{"version":3,"names":["require","getMap","getSourceAndMap","streamChunks","Source","splitIntoLines","hasStableSort","process","versions","v8","test","MAX_SOURCE_POSITION","Replacement","start","end","content","name","index","ReplaceSource","source","_source","_name","_replacements","_isSorted","_sortReplacements","newValue","Error","push","pos","length","current","result","replacement","Math","floor","offset","slice","join","options","map","sourceAndMap","sort","a","b","diff1","diff2","forEach","repl","i","onChunk","onSource","onName","repls","replacmentEnd","nextReplacement","generatedLineOffset","generatedColumnOffset","generatedColumnOffsetLine","sourceContents","nameMapping","Map","nameIndexMapping","checkOriginalContent","sourceIndex","line","column","expectedChunk","undefined","contentLine","Object","assign","finalSource","chunk","generatedLine","generatedColumn","originalLine","originalColumn","nameIndex","chunkPos","endPos","endsWith","chunkSlice","matches","replacementNameIndex","globalIndex","get","size","set","m","max","sourceContent","remainer","hash","update","updateHash","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack-sources/lib/ReplaceSource.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\nconst streamChunks = require(\"./helpers/streamChunks\");\nconst Source = require(\"./Source\");\nconst splitIntoLines = require(\"./helpers/splitIntoLines\");\n\n// since v8 7.0, Array.prototype.sort is stable\nconst hasStableSort =\n\ttypeof process === \"object\" &&\n\tprocess.versions &&\n\ttypeof process.versions.v8 === \"string\" &&\n\t!/^[0-6]\\./.test(process.versions.v8);\n\n// This is larger than max string length\nconst MAX_SOURCE_POSITION = 0x20000000;\n\nclass Replacement {\n\tconstructor(start, end, content, name) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.content = content;\n\t\tthis.name = name;\n\t\tif (!hasStableSort) {\n\t\t\tthis.index = -1;\n\t\t}\n\t}\n}\n\nclass ReplaceSource extends Source {\n\tconstructor(source, name) {\n\t\tsuper();\n\t\tthis._source = source;\n\t\tthis._name = name;\n\t\t/** @type {Replacement[]} */\n\t\tthis._replacements = [];\n\t\tthis._isSorted = true;\n\t}\n\n\tgetName() {\n\t\treturn this._name;\n\t}\n\n\tgetReplacements() {\n\t\tthis._sortReplacements();\n\t\treturn this._replacements;\n\t}\n\n\treplace(start, end, newValue, name) {\n\t\tif (typeof newValue !== \"string\")\n\t\t\tthrow new Error(\n\t\t\t\t\"insertion must be a string, but is a \" + typeof newValue\n\t\t\t);\n\t\tthis._replacements.push(new Replacement(start, end, newValue, name));\n\t\tthis._isSorted = false;\n\t}\n\n\tinsert(pos, newValue, name) {\n\t\tif (typeof newValue !== \"string\")\n\t\t\tthrow new Error(\n\t\t\t\t\"insertion must be a string, but is a \" +\n\t\t\t\t\ttypeof newValue +\n\t\t\t\t\t\": \" +\n\t\t\t\t\tnewValue\n\t\t\t);\n\t\tthis._replacements.push(new Replacement(pos, pos - 1, newValue, name));\n\t\tthis._isSorted = false;\n\t}\n\n\tsource() {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.source();\n\t\t}\n\t\tlet current = this._source.source();\n\t\tlet pos = 0;\n\t\tconst result = [];\n\n\t\tthis._sortReplacements();\n\t\tfor (const replacement of this._replacements) {\n\t\t\tconst start = Math.floor(replacement.start);\n\t\t\tconst end = Math.floor(replacement.end + 1);\n\t\t\tif (pos < start) {\n\t\t\t\tconst offset = start - pos;\n\t\t\t\tresult.push(current.slice(0, offset));\n\t\t\t\tcurrent = current.slice(offset);\n\t\t\t\tpos = start;\n\t\t\t}\n\t\t\tresult.push(replacement.content);\n\t\t\tif (pos < end) {\n\t\t\t\tconst offset = end - pos;\n\t\t\t\tcurrent = current.slice(offset);\n\t\t\t\tpos = end;\n\t\t\t}\n\t\t}\n\t\tresult.push(current);\n\t\treturn result.join(\"\");\n\t}\n\n\tmap(options) {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.map(options);\n\t\t}\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.sourceAndMap(options);\n\t\t}\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\toriginal() {\n\t\treturn this._source;\n\t}\n\n\t_sortReplacements() {\n\t\tif (this._isSorted) return;\n\t\tif (hasStableSort) {\n\t\t\tthis._replacements.sort(function (a, b) {\n\t\t\t\tconst diff1 = a.start - b.start;\n\t\t\t\tif (diff1 !== 0) return diff1;\n\t\t\t\tconst diff2 = a.end - b.end;\n\t\t\t\tif (diff2 !== 0) return diff2;\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t} else {\n\t\t\tthis._replacements.forEach((repl, i) => (repl.index = i));\n\t\t\tthis._replacements.sort(function (a, b) {\n\t\t\t\tconst diff1 = a.start - b.start;\n\t\t\t\tif (diff1 !== 0) return diff1;\n\t\t\t\tconst diff2 = a.end - b.end;\n\t\t\t\tif (diff2 !== 0) return diff2;\n\t\t\t\treturn a.index - b.index;\n\t\t\t});\n\t\t}\n\t\tthis._isSorted = true;\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tthis._sortReplacements();\n\t\tconst repls = this._replacements;\n\t\tlet pos = 0;\n\t\tlet i = 0;\n\t\tlet replacmentEnd = -1;\n\t\tlet nextReplacement =\n\t\t\ti < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;\n\t\tlet generatedLineOffset = 0;\n\t\tlet generatedColumnOffset = 0;\n\t\tlet generatedColumnOffsetLine = 0;\n\t\tconst sourceContents = [];\n\t\tconst nameMapping = new Map();\n\t\tconst nameIndexMapping = [];\n\t\tconst checkOriginalContent = (sourceIndex, line, column, expectedChunk) => {\n\t\t\tlet content =\n\t\t\t\tsourceIndex < sourceContents.length\n\t\t\t\t\t? sourceContents[sourceIndex]\n\t\t\t\t\t: undefined;\n\t\t\tif (content === undefined) return false;\n\t\t\tif (typeof content === \"string\") {\n\t\t\t\tcontent = splitIntoLines(content);\n\t\t\t\tsourceContents[sourceIndex] = content;\n\t\t\t}\n\t\t\tconst contentLine = line <= content.length ? content[line - 1] : null;\n\t\t\tif (contentLine === null) return false;\n\t\t\treturn (\n\t\t\t\tcontentLine.slice(column, column + expectedChunk.length) ===\n\t\t\t\texpectedChunk\n\t\t\t);\n\t\t};\n\t\tlet { generatedLine, generatedColumn } = streamChunks(\n\t\t\tthis._source,\n\t\t\tObject.assign({}, options, { finalSource: false }),\n\t\t\t(\n\t\t\t\tchunk,\n\t\t\t\tgeneratedLine,\n\t\t\t\tgeneratedColumn,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\tnameIndex\n\t\t\t) => {\n\t\t\t\tlet chunkPos = 0;\n\t\t\t\tlet endPos = pos + chunk.length;\n\n\t\t\t\t// Skip over when it has been replaced\n\t\t\t\tif (replacmentEnd > pos) {\n\t\t\t\t\t// Skip over the whole chunk\n\t\t\t\t\tif (replacmentEnd >= endPos) {\n\t\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\tif (chunk.endsWith(\"\\n\")) {\n\t\t\t\t\t\t\tgeneratedLineOffset--;\n\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t// undo exiting corrections form the current line\n\t\t\t\t\t\t\t\tgeneratedColumnOffset += generatedColumn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\tgeneratedColumnOffset -= chunk.length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgeneratedColumnOffset = -chunk.length;\n\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos = endPos;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Partially skip over chunk\n\t\t\t\t\tchunkPos = replacmentEnd - pos;\n\t\t\t\t\tif (\n\t\t\t\t\t\tcheckOriginalContent(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\tchunk.slice(0, chunkPos)\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\toriginalColumn += chunkPos;\n\t\t\t\t\t}\n\t\t\t\t\tpos += chunkPos;\n\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\tgeneratedColumnOffset -= chunkPos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgeneratedColumnOffset = -chunkPos;\n\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t}\n\t\t\t\t\tgeneratedColumn += chunkPos;\n\t\t\t\t}\n\n\t\t\t\t// Is a replacement in the chunk?\n\t\t\t\tif (nextReplacement < endPos) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tlet line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\tif (nextReplacement > pos) {\n\t\t\t\t\t\t\t// Emit chunk until replacement\n\t\t\t\t\t\t\tconst offset = nextReplacement - pos;\n\t\t\t\t\t\t\tconst chunkSlice = chunk.slice(chunkPos, chunkPos + offset);\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tchunkSlice,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tgeneratedColumn +\n\t\t\t\t\t\t\t\t\t(line === generatedColumnOffsetLine\n\t\t\t\t\t\t\t\t\t\t? generatedColumnOffset\n\t\t\t\t\t\t\t\t\t\t: 0),\n\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\tnameIndex < 0 || nameIndex >= nameIndexMapping.length\n\t\t\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t\t\t: nameIndexMapping[nameIndex]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tgeneratedColumn += offset;\n\t\t\t\t\t\t\tchunkPos += offset;\n\t\t\t\t\t\t\tpos = nextReplacement;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcheckOriginalContent(\n\t\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\t\tchunkSlice\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\toriginalColumn += chunkSlice.length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Insert replacement content splitted into chunks by lines\n\t\t\t\t\t\tconst { content, name } = repls[i];\n\t\t\t\t\t\tlet matches = splitIntoLines(content);\n\t\t\t\t\t\tlet replacementNameIndex = nameIndex;\n\t\t\t\t\t\tif (sourceIndex >= 0 && name) {\n\t\t\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\t\t\tglobalIndex = nameMapping.size;\n\t\t\t\t\t\t\t\tnameMapping.set(name, globalIndex);\n\t\t\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treplacementNameIndex = globalIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let m = 0; m < matches.length; m++) {\n\t\t\t\t\t\t\tconst contentLine = matches[m];\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tcontentLine,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tgeneratedColumn +\n\t\t\t\t\t\t\t\t\t(line === generatedColumnOffsetLine\n\t\t\t\t\t\t\t\t\t\t? generatedColumnOffset\n\t\t\t\t\t\t\t\t\t\t: 0),\n\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\treplacementNameIndex\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Only the first chunk has name assigned\n\t\t\t\t\t\t\treplacementNameIndex = -1;\n\n\t\t\t\t\t\t\tif (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n\t\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset += contentLine.length;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset = contentLine.length;\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgeneratedLineOffset++;\n\t\t\t\t\t\t\t\tline++;\n\t\t\t\t\t\t\t\tgeneratedColumnOffset = -generatedColumn;\n\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Remove replaced content by settings this variable\n\t\t\t\t\t\treplacmentEnd = Math.max(\n\t\t\t\t\t\t\treplacmentEnd,\n\t\t\t\t\t\t\tMath.floor(repls[i].end + 1)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Move to next replacment\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tnextReplacement =\n\t\t\t\t\t\t\ti < repls.length\n\t\t\t\t\t\t\t\t? Math.floor(repls[i].start)\n\t\t\t\t\t\t\t\t: MAX_SOURCE_POSITION;\n\n\t\t\t\t\t\t// Skip over when it has been replaced\n\t\t\t\t\t\tconst offset = chunk.length - endPos + replacmentEnd - chunkPos;\n\t\t\t\t\t\tif (offset > 0) {\n\t\t\t\t\t\t\t// Skip over whole chunk\n\t\t\t\t\t\t\tif (replacmentEnd >= endPos) {\n\t\t\t\t\t\t\t\tlet line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\t\t\tif (chunk.endsWith(\"\\n\")) {\n\t\t\t\t\t\t\t\t\tgeneratedLineOffset--;\n\t\t\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t\t\t// undo exiting corrections form the current line\n\t\t\t\t\t\t\t\t\t\tgeneratedColumnOffset += generatedColumn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset -= chunk.length - chunkPos;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffset = chunkPos - chunk.length;\n\t\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpos = endPos;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Partially skip over chunk\n\t\t\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcheckOriginalContent(\n\t\t\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\t\tchunk.slice(chunkPos, chunkPos + offset)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\toriginalColumn += offset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunkPos += offset;\n\t\t\t\t\t\t\tpos += offset;\n\t\t\t\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\t\t\t\tgeneratedColumnOffset -= offset;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgeneratedColumnOffset = -offset;\n\t\t\t\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgeneratedColumn += offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (nextReplacement < endPos);\n\t\t\t\t}\n\n\t\t\t\t// Emit remaining chunk\n\t\t\t\tif (chunkPos < chunk.length) {\n\t\t\t\t\tconst chunkSlice = chunkPos === 0 ? chunk : chunk.slice(chunkPos);\n\t\t\t\t\tconst line = generatedLine + generatedLineOffset;\n\t\t\t\t\tonChunk(\n\t\t\t\t\t\tchunkSlice,\n\t\t\t\t\t\tline,\n\t\t\t\t\t\tgeneratedColumn +\n\t\t\t\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0),\n\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\tnameIndex < 0 ? -1 : nameIndexMapping[nameIndex]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tpos = endPos;\n\t\t\t},\n\t\t\t(sourceIndex, source, sourceContent) => {\n\t\t\t\twhile (sourceContents.length < sourceIndex)\n\t\t\t\t\tsourceContents.push(undefined);\n\t\t\t\tsourceContents[sourceIndex] = sourceContent;\n\t\t\t\tonSource(sourceIndex, source, sourceContent);\n\t\t\t},\n\t\t\t(nameIndex, name) => {\n\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\tglobalIndex = nameMapping.size;\n\t\t\t\t\tnameMapping.set(name, globalIndex);\n\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t}\n\t\t\t\tnameIndexMapping[nameIndex] = globalIndex;\n\t\t\t}\n\t\t);\n\n\t\t// Handle remaining replacements\n\t\tlet remainer = \"\";\n\t\tfor (; i < repls.length; i++) {\n\t\t\tremainer += repls[i].content;\n\t\t}\n\n\t\t// Insert remaining replacements content splitted into chunks by lines\n\t\tlet line = generatedLine + generatedLineOffset;\n\t\tlet matches = splitIntoLines(remainer);\n\t\tfor (let m = 0; m < matches.length; m++) {\n\t\t\tconst contentLine = matches[m];\n\t\t\tonChunk(\n\t\t\t\tcontentLine,\n\t\t\t\tline,\n\t\t\t\tgeneratedColumn +\n\t\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0),\n\t\t\t\t-1,\n\t\t\t\t-1,\n\t\t\t\t-1,\n\t\t\t\t-1\n\t\t\t);\n\n\t\t\tif (m === matches.length - 1 && !contentLine.endsWith(\"\\n\")) {\n\t\t\t\tif (generatedColumnOffsetLine === line) {\n\t\t\t\t\tgeneratedColumnOffset += contentLine.length;\n\t\t\t\t} else {\n\t\t\t\t\tgeneratedColumnOffset = contentLine.length;\n\t\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgeneratedLineOffset++;\n\t\t\t\tline++;\n\t\t\t\tgeneratedColumnOffset = -generatedColumn;\n\t\t\t\tgeneratedColumnOffsetLine = line;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tgeneratedLine: line,\n\t\t\tgeneratedColumn:\n\t\t\t\tgeneratedColumn +\n\t\t\t\t(line === generatedColumnOffsetLine ? generatedColumnOffset : 0)\n\t\t};\n\t}\n\n\tupdateHash(hash) {\n\t\tthis._sortReplacements();\n\t\thash.update(\"ReplaceSource\");\n\t\tthis._source.updateHash(hash);\n\t\thash.update(this._name || \"\");\n\t\tfor (const repl of this._replacements) {\n\t\t\thash.update(`${repl.start}${repl.end}${repl.content}${repl.name}`);\n\t\t}\n\t}\n}\n\nmodule.exports = ReplaceSource;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}