{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar path = require(\"path\");\nvar WINDOWS_ABS_PATH_REGEXP = /^[a-zA-Z]:[\\\\/]/;\nvar SEGMENTS_SPLIT_REGEXP = /([|!])/;\nvar WINDOWS_PATH_SEPARATOR_REGEXP = /\\\\/g;\n\n/**\n * @typedef {Object} MakeRelativePathsCache\n * @property {Map<string, Map<string, string>>=} relativePaths\n */\n\nvar relativePathToRequest = function relativePathToRequest(relativePath) {\n  if (relativePath === \"\") return \"./.\";\n  if (relativePath === \"..\") return \"../.\";\n  if (relativePath.startsWith(\"../\")) return relativePath;\n  return \"./\".concat(relativePath);\n};\n\n/**\n * @param {string} context context for relative path\n * @param {string} maybeAbsolutePath path to make relative\n * @returns {string} relative path in request style\n */\nvar absoluteToRequest = function absoluteToRequest(context, maybeAbsolutePath) {\n  if (maybeAbsolutePath[0] === \"/\") {\n    if (maybeAbsolutePath.length > 1 && maybeAbsolutePath[maybeAbsolutePath.length - 1] === \"/\") {\n      // this 'path' is actually a regexp generated by dynamic requires.\n      // Don't treat it as an absolute path.\n      return maybeAbsolutePath;\n    }\n    var querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n    var resource = querySplitPos === -1 ? maybeAbsolutePath : maybeAbsolutePath.slice(0, querySplitPos);\n    resource = relativePathToRequest(path.posix.relative(context, resource));\n    return querySplitPos === -1 ? resource : resource + maybeAbsolutePath.slice(querySplitPos);\n  }\n  if (WINDOWS_ABS_PATH_REGEXP.test(maybeAbsolutePath)) {\n    var _querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n    var _resource = _querySplitPos === -1 ? maybeAbsolutePath : maybeAbsolutePath.slice(0, _querySplitPos);\n    _resource = path.win32.relative(context, _resource);\n    if (!WINDOWS_ABS_PATH_REGEXP.test(_resource)) {\n      _resource = relativePathToRequest(_resource.replace(WINDOWS_PATH_SEPARATOR_REGEXP, \"/\"));\n    }\n    return _querySplitPos === -1 ? _resource : _resource + maybeAbsolutePath.slice(_querySplitPos);\n  }\n\n  // not an absolute path\n  return maybeAbsolutePath;\n};\n\n/**\n * @param {string} context context for relative path\n * @param {string} relativePath path\n * @returns {string} absolute path\n */\nvar requestToAbsolute = function requestToAbsolute(context, relativePath) {\n  if (relativePath.startsWith(\"./\") || relativePath.startsWith(\"../\")) return path.join(context, relativePath);\n  return relativePath;\n};\nvar makeCacheable = function makeCacheable(realFn) {\n  /** @type {WeakMap<object, Map<string, ParsedResource>>} */\n  var cache = new WeakMap();\n  var getCache = function getCache(associatedObjectForCache) {\n    var entry = cache.get(associatedObjectForCache);\n    if (entry !== undefined) return entry;\n    /** @type {Map<string, ParsedResource>} */\n    var map = new Map();\n    cache.set(associatedObjectForCache, map);\n    return map;\n  };\n\n  /**\n   * @param {string} str the path with query and fragment\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {ParsedResource} parsed parts\n   */\n  var fn = function fn(str, associatedObjectForCache) {\n    if (!associatedObjectForCache) return realFn(str);\n    var cache = getCache(associatedObjectForCache);\n    var entry = cache.get(str);\n    if (entry !== undefined) return entry;\n    var result = realFn(str);\n    cache.set(str, result);\n    return result;\n  };\n  fn.bindCache = function (associatedObjectForCache) {\n    var cache = getCache(associatedObjectForCache);\n    return function (str) {\n      var entry = cache.get(str);\n      if (entry !== undefined) return entry;\n      var result = realFn(str);\n      cache.set(str, result);\n      return result;\n    };\n  };\n  return fn;\n};\nvar makeCacheableWithContext = function makeCacheableWithContext(fn) {\n  /** @type {WeakMap<object, Map<string, Map<string, string>>>} */\n  var cache = new WeakMap();\n\n  /**\n   * @param {string} context context used to create relative path\n   * @param {string} identifier identifier used to create relative path\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {string} the returned relative path\n   */\n  var cachedFn = function cachedFn(context, identifier, associatedObjectForCache) {\n    if (!associatedObjectForCache) return fn(context, identifier);\n    var innerCache = cache.get(associatedObjectForCache);\n    if (innerCache === undefined) {\n      innerCache = new Map();\n      cache.set(associatedObjectForCache, innerCache);\n    }\n    var cachedResult;\n    var innerSubCache = innerCache.get(context);\n    if (innerSubCache === undefined) {\n      innerCache.set(context, innerSubCache = new Map());\n    } else {\n      cachedResult = innerSubCache.get(identifier);\n    }\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    } else {\n      var result = fn(context, identifier);\n      innerSubCache.set(identifier, result);\n      return result;\n    }\n  };\n\n  /**\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {function(string, string): string} cached function\n   */\n  cachedFn.bindCache = function (associatedObjectForCache) {\n    var innerCache;\n    if (associatedObjectForCache) {\n      innerCache = cache.get(associatedObjectForCache);\n      if (innerCache === undefined) {\n        innerCache = new Map();\n        cache.set(associatedObjectForCache, innerCache);\n      }\n    } else {\n      innerCache = new Map();\n    }\n\n    /**\n     * @param {string} context context used to create relative path\n     * @param {string} identifier identifier used to create relative path\n     * @returns {string} the returned relative path\n     */\n    var boundFn = function boundFn(context, identifier) {\n      var cachedResult;\n      var innerSubCache = innerCache.get(context);\n      if (innerSubCache === undefined) {\n        innerCache.set(context, innerSubCache = new Map());\n      } else {\n        cachedResult = innerSubCache.get(identifier);\n      }\n      if (cachedResult !== undefined) {\n        return cachedResult;\n      } else {\n        var result = fn(context, identifier);\n        innerSubCache.set(identifier, result);\n        return result;\n      }\n    };\n    return boundFn;\n  };\n\n  /**\n   * @param {string} context context used to create relative path\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {function(string): string} cached function\n   */\n  cachedFn.bindContextCache = function (context, associatedObjectForCache) {\n    var innerSubCache;\n    if (associatedObjectForCache) {\n      var innerCache = cache.get(associatedObjectForCache);\n      if (innerCache === undefined) {\n        innerCache = new Map();\n        cache.set(associatedObjectForCache, innerCache);\n      }\n      innerSubCache = innerCache.get(context);\n      if (innerSubCache === undefined) {\n        innerCache.set(context, innerSubCache = new Map());\n      }\n    } else {\n      innerSubCache = new Map();\n    }\n\n    /**\n     * @param {string} identifier identifier used to create relative path\n     * @returns {string} the returned relative path\n     */\n    var boundFn = function boundFn(identifier) {\n      var cachedResult = innerSubCache.get(identifier);\n      if (cachedResult !== undefined) {\n        return cachedResult;\n      } else {\n        var result = fn(context, identifier);\n        innerSubCache.set(identifier, result);\n        return result;\n      }\n    };\n    return boundFn;\n  };\n  return cachedFn;\n};\n\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\nvar _makePathsRelative = function _makePathsRelative(context, identifier) {\n  return identifier.split(SEGMENTS_SPLIT_REGEXP).map(function (str) {\n    return absoluteToRequest(context, str);\n  }).join(\"\");\n};\nexports.makePathsRelative = makeCacheableWithContext(_makePathsRelative);\n\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\nvar _makePathsAbsolute = function _makePathsAbsolute(context, identifier) {\n  return identifier.split(SEGMENTS_SPLIT_REGEXP).map(function (str) {\n    return requestToAbsolute(context, str);\n  }).join(\"\");\n};\nexports.makePathsAbsolute = makeCacheableWithContext(_makePathsAbsolute);\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string may containing absolute paths, query string, etc.\n * @returns {string} a new request string avoiding absolute paths when possible\n */\nvar _contextify = function _contextify(context, request) {\n  return request.split(\"!\").map(function (r) {\n    return absoluteToRequest(context, r);\n  }).join(\"!\");\n};\nvar contextify = makeCacheableWithContext(_contextify);\nexports.contextify = contextify;\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string\n * @returns {string} a new request string using absolute paths when possible\n */\nvar _absolutify = function _absolutify(context, request) {\n  return request.split(\"!\").map(function (r) {\n    return requestToAbsolute(context, r);\n  }).join(\"!\");\n};\nvar absolutify = makeCacheableWithContext(_absolutify);\nexports.absolutify = absolutify;\nvar PATH_QUERY_FRAGMENT_REGEXP = /^((?:\\0.|[^?#\\0])*)(\\?(?:\\0.|[^#\\0])*)?(#.*)?$/;\nvar PATH_QUERY_REGEXP = /^((?:\\0.|[^?\\0])*)(\\?.*)?$/;\n\n/** @typedef {{ resource: string, path: string, query: string, fragment: string }} ParsedResource */\n/** @typedef {{ resource: string, path: string, query: string }} ParsedResourceWithoutFragment */\n\n/**\n * @param {string} str the path with query and fragment\n * @returns {ParsedResource} parsed parts\n */\nvar _parseResource = function _parseResource(str) {\n  var match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);\n  return {\n    resource: str,\n    path: match[1].replace(/\\0(.)/g, \"$1\"),\n    query: match[2] ? match[2].replace(/\\0(.)/g, \"$1\") : \"\",\n    fragment: match[3] || \"\"\n  };\n};\nexports.parseResource = makeCacheable(_parseResource);\n\n/**\n * Parse resource, skips fragment part\n * @param {string} str the path with query and fragment\n * @returns {ParsedResourceWithoutFragment} parsed parts\n */\nvar _parseResourceWithoutFragment = function _parseResourceWithoutFragment(str) {\n  var match = PATH_QUERY_REGEXP.exec(str);\n  return {\n    resource: str,\n    path: match[1].replace(/\\0(.)/g, \"$1\"),\n    query: match[2] ? match[2].replace(/\\0(.)/g, \"$1\") : \"\"\n  };\n};\nexports.parseResourceWithoutFragment = makeCacheable(_parseResourceWithoutFragment);\n\n/**\n * @param {string} filename the filename which should be undone\n * @param {string} outputPath the output path that is restored (only relevant when filename contains \"..\")\n * @param {boolean} enforceRelative true returns ./ for empty paths\n * @returns {string} repeated ../ to leave the directory of the provided filename to be back on output dir\n */\nexports.getUndoPath = function (filename, outputPath, enforceRelative) {\n  var depth = -1;\n  var append = \"\";\n  outputPath = outputPath.replace(/[\\\\/]$/, \"\");\n  var _iterator = _createForOfIteratorHelper(filename.split(/[/\\\\]+/)),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var part = _step.value;\n      if (part === \"..\") {\n        if (depth > -1) {\n          depth--;\n        } else {\n          var i = outputPath.lastIndexOf(\"/\");\n          var j = outputPath.lastIndexOf(\"\\\\\");\n          var pos = i < 0 ? j : j < 0 ? i : Math.max(i, j);\n          if (pos < 0) return outputPath + \"/\";\n          append = outputPath.slice(pos + 1) + \"/\" + append;\n          outputPath = outputPath.slice(0, pos);\n        }\n      } else if (part !== \".\") {\n        depth++;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return depth > 0 ? \"\".concat(\"../\".repeat(depth)).concat(append) : enforceRelative ? \"./\".concat(append) : append;\n};","map":{"version":3,"names":["path","require","WINDOWS_ABS_PATH_REGEXP","SEGMENTS_SPLIT_REGEXP","WINDOWS_PATH_SEPARATOR_REGEXP","relativePathToRequest","relativePath","startsWith","absoluteToRequest","context","maybeAbsolutePath","length","querySplitPos","indexOf","resource","slice","posix","relative","test","win32","replace","requestToAbsolute","join","makeCacheable","realFn","cache","WeakMap","getCache","associatedObjectForCache","entry","get","undefined","map","Map","set","fn","str","result","bindCache","makeCacheableWithContext","cachedFn","identifier","innerCache","cachedResult","innerSubCache","boundFn","bindContextCache","_makePathsRelative","split","exports","makePathsRelative","_makePathsAbsolute","makePathsAbsolute","_contextify","request","r","contextify","_absolutify","absolutify","PATH_QUERY_FRAGMENT_REGEXP","PATH_QUERY_REGEXP","_parseResource","match","exec","query","fragment","parseResource","_parseResourceWithoutFragment","parseResourceWithoutFragment","getUndoPath","filename","outputPath","enforceRelative","depth","append","part","i","lastIndexOf","j","pos","Math","max","repeat"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/util/identifier.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\n\nconst WINDOWS_ABS_PATH_REGEXP = /^[a-zA-Z]:[\\\\/]/;\nconst SEGMENTS_SPLIT_REGEXP = /([|!])/;\nconst WINDOWS_PATH_SEPARATOR_REGEXP = /\\\\/g;\n\n/**\n * @typedef {Object} MakeRelativePathsCache\n * @property {Map<string, Map<string, string>>=} relativePaths\n */\n\nconst relativePathToRequest = relativePath => {\n\tif (relativePath === \"\") return \"./.\";\n\tif (relativePath === \"..\") return \"../.\";\n\tif (relativePath.startsWith(\"../\")) return relativePath;\n\treturn `./${relativePath}`;\n};\n\n/**\n * @param {string} context context for relative path\n * @param {string} maybeAbsolutePath path to make relative\n * @returns {string} relative path in request style\n */\nconst absoluteToRequest = (context, maybeAbsolutePath) => {\n\tif (maybeAbsolutePath[0] === \"/\") {\n\t\tif (\n\t\t\tmaybeAbsolutePath.length > 1 &&\n\t\t\tmaybeAbsolutePath[maybeAbsolutePath.length - 1] === \"/\"\n\t\t) {\n\t\t\t// this 'path' is actually a regexp generated by dynamic requires.\n\t\t\t// Don't treat it as an absolute path.\n\t\t\treturn maybeAbsolutePath;\n\t\t}\n\n\t\tconst querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n\t\tlet resource =\n\t\t\tquerySplitPos === -1\n\t\t\t\t? maybeAbsolutePath\n\t\t\t\t: maybeAbsolutePath.slice(0, querySplitPos);\n\t\tresource = relativePathToRequest(path.posix.relative(context, resource));\n\t\treturn querySplitPos === -1\n\t\t\t? resource\n\t\t\t: resource + maybeAbsolutePath.slice(querySplitPos);\n\t}\n\n\tif (WINDOWS_ABS_PATH_REGEXP.test(maybeAbsolutePath)) {\n\t\tconst querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n\t\tlet resource =\n\t\t\tquerySplitPos === -1\n\t\t\t\t? maybeAbsolutePath\n\t\t\t\t: maybeAbsolutePath.slice(0, querySplitPos);\n\t\tresource = path.win32.relative(context, resource);\n\t\tif (!WINDOWS_ABS_PATH_REGEXP.test(resource)) {\n\t\t\tresource = relativePathToRequest(\n\t\t\t\tresource.replace(WINDOWS_PATH_SEPARATOR_REGEXP, \"/\")\n\t\t\t);\n\t\t}\n\t\treturn querySplitPos === -1\n\t\t\t? resource\n\t\t\t: resource + maybeAbsolutePath.slice(querySplitPos);\n\t}\n\n\t// not an absolute path\n\treturn maybeAbsolutePath;\n};\n\n/**\n * @param {string} context context for relative path\n * @param {string} relativePath path\n * @returns {string} absolute path\n */\nconst requestToAbsolute = (context, relativePath) => {\n\tif (relativePath.startsWith(\"./\") || relativePath.startsWith(\"../\"))\n\t\treturn path.join(context, relativePath);\n\treturn relativePath;\n};\n\nconst makeCacheable = realFn => {\n\t/** @type {WeakMap<object, Map<string, ParsedResource>>} */\n\tconst cache = new WeakMap();\n\n\tconst getCache = associatedObjectForCache => {\n\t\tconst entry = cache.get(associatedObjectForCache);\n\t\tif (entry !== undefined) return entry;\n\t\t/** @type {Map<string, ParsedResource>} */\n\t\tconst map = new Map();\n\t\tcache.set(associatedObjectForCache, map);\n\t\treturn map;\n\t};\n\n\t/**\n\t * @param {string} str the path with query and fragment\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {ParsedResource} parsed parts\n\t */\n\tconst fn = (str, associatedObjectForCache) => {\n\t\tif (!associatedObjectForCache) return realFn(str);\n\t\tconst cache = getCache(associatedObjectForCache);\n\t\tconst entry = cache.get(str);\n\t\tif (entry !== undefined) return entry;\n\t\tconst result = realFn(str);\n\t\tcache.set(str, result);\n\t\treturn result;\n\t};\n\n\tfn.bindCache = associatedObjectForCache => {\n\t\tconst cache = getCache(associatedObjectForCache);\n\t\treturn str => {\n\t\t\tconst entry = cache.get(str);\n\t\t\tif (entry !== undefined) return entry;\n\t\t\tconst result = realFn(str);\n\t\t\tcache.set(str, result);\n\t\t\treturn result;\n\t\t};\n\t};\n\n\treturn fn;\n};\n\nconst makeCacheableWithContext = fn => {\n\t/** @type {WeakMap<object, Map<string, Map<string, string>>>} */\n\tconst cache = new WeakMap();\n\n\t/**\n\t * @param {string} context context used to create relative path\n\t * @param {string} identifier identifier used to create relative path\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {string} the returned relative path\n\t */\n\tconst cachedFn = (context, identifier, associatedObjectForCache) => {\n\t\tif (!associatedObjectForCache) return fn(context, identifier);\n\n\t\tlet innerCache = cache.get(associatedObjectForCache);\n\t\tif (innerCache === undefined) {\n\t\t\tinnerCache = new Map();\n\t\t\tcache.set(associatedObjectForCache, innerCache);\n\t\t}\n\n\t\tlet cachedResult;\n\t\tlet innerSubCache = innerCache.get(context);\n\t\tif (innerSubCache === undefined) {\n\t\t\tinnerCache.set(context, (innerSubCache = new Map()));\n\t\t} else {\n\t\t\tcachedResult = innerSubCache.get(identifier);\n\t\t}\n\n\t\tif (cachedResult !== undefined) {\n\t\t\treturn cachedResult;\n\t\t} else {\n\t\t\tconst result = fn(context, identifier);\n\t\t\tinnerSubCache.set(identifier, result);\n\t\t\treturn result;\n\t\t}\n\t};\n\n\t/**\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {function(string, string): string} cached function\n\t */\n\tcachedFn.bindCache = associatedObjectForCache => {\n\t\tlet innerCache;\n\t\tif (associatedObjectForCache) {\n\t\t\tinnerCache = cache.get(associatedObjectForCache);\n\t\t\tif (innerCache === undefined) {\n\t\t\t\tinnerCache = new Map();\n\t\t\t\tcache.set(associatedObjectForCache, innerCache);\n\t\t\t}\n\t\t} else {\n\t\t\tinnerCache = new Map();\n\t\t}\n\n\t\t/**\n\t\t * @param {string} context context used to create relative path\n\t\t * @param {string} identifier identifier used to create relative path\n\t\t * @returns {string} the returned relative path\n\t\t */\n\t\tconst boundFn = (context, identifier) => {\n\t\t\tlet cachedResult;\n\t\t\tlet innerSubCache = innerCache.get(context);\n\t\t\tif (innerSubCache === undefined) {\n\t\t\t\tinnerCache.set(context, (innerSubCache = new Map()));\n\t\t\t} else {\n\t\t\t\tcachedResult = innerSubCache.get(identifier);\n\t\t\t}\n\n\t\t\tif (cachedResult !== undefined) {\n\t\t\t\treturn cachedResult;\n\t\t\t} else {\n\t\t\t\tconst result = fn(context, identifier);\n\t\t\t\tinnerSubCache.set(identifier, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\n\t\treturn boundFn;\n\t};\n\n\t/**\n\t * @param {string} context context used to create relative path\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {function(string): string} cached function\n\t */\n\tcachedFn.bindContextCache = (context, associatedObjectForCache) => {\n\t\tlet innerSubCache;\n\t\tif (associatedObjectForCache) {\n\t\t\tlet innerCache = cache.get(associatedObjectForCache);\n\t\t\tif (innerCache === undefined) {\n\t\t\t\tinnerCache = new Map();\n\t\t\t\tcache.set(associatedObjectForCache, innerCache);\n\t\t\t}\n\n\t\t\tinnerSubCache = innerCache.get(context);\n\t\t\tif (innerSubCache === undefined) {\n\t\t\t\tinnerCache.set(context, (innerSubCache = new Map()));\n\t\t\t}\n\t\t} else {\n\t\t\tinnerSubCache = new Map();\n\t\t}\n\n\t\t/**\n\t\t * @param {string} identifier identifier used to create relative path\n\t\t * @returns {string} the returned relative path\n\t\t */\n\t\tconst boundFn = identifier => {\n\t\t\tconst cachedResult = innerSubCache.get(identifier);\n\t\t\tif (cachedResult !== undefined) {\n\t\t\t\treturn cachedResult;\n\t\t\t} else {\n\t\t\t\tconst result = fn(context, identifier);\n\t\t\t\tinnerSubCache.set(identifier, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\n\t\treturn boundFn;\n\t};\n\n\treturn cachedFn;\n};\n\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\nconst _makePathsRelative = (context, identifier) => {\n\treturn identifier\n\t\t.split(SEGMENTS_SPLIT_REGEXP)\n\t\t.map(str => absoluteToRequest(context, str))\n\t\t.join(\"\");\n};\n\nexports.makePathsRelative = makeCacheableWithContext(_makePathsRelative);\n\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\nconst _makePathsAbsolute = (context, identifier) => {\n\treturn identifier\n\t\t.split(SEGMENTS_SPLIT_REGEXP)\n\t\t.map(str => requestToAbsolute(context, str))\n\t\t.join(\"\");\n};\n\nexports.makePathsAbsolute = makeCacheableWithContext(_makePathsAbsolute);\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string may containing absolute paths, query string, etc.\n * @returns {string} a new request string avoiding absolute paths when possible\n */\nconst _contextify = (context, request) => {\n\treturn request\n\t\t.split(\"!\")\n\t\t.map(r => absoluteToRequest(context, r))\n\t\t.join(\"!\");\n};\n\nconst contextify = makeCacheableWithContext(_contextify);\nexports.contextify = contextify;\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string\n * @returns {string} a new request string using absolute paths when possible\n */\nconst _absolutify = (context, request) => {\n\treturn request\n\t\t.split(\"!\")\n\t\t.map(r => requestToAbsolute(context, r))\n\t\t.join(\"!\");\n};\n\nconst absolutify = makeCacheableWithContext(_absolutify);\nexports.absolutify = absolutify;\n\nconst PATH_QUERY_FRAGMENT_REGEXP =\n\t/^((?:\\0.|[^?#\\0])*)(\\?(?:\\0.|[^#\\0])*)?(#.*)?$/;\nconst PATH_QUERY_REGEXP = /^((?:\\0.|[^?\\0])*)(\\?.*)?$/;\n\n/** @typedef {{ resource: string, path: string, query: string, fragment: string }} ParsedResource */\n/** @typedef {{ resource: string, path: string, query: string }} ParsedResourceWithoutFragment */\n\n/**\n * @param {string} str the path with query and fragment\n * @returns {ParsedResource} parsed parts\n */\nconst _parseResource = str => {\n\tconst match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);\n\treturn {\n\t\tresource: str,\n\t\tpath: match[1].replace(/\\0(.)/g, \"$1\"),\n\t\tquery: match[2] ? match[2].replace(/\\0(.)/g, \"$1\") : \"\",\n\t\tfragment: match[3] || \"\"\n\t};\n};\nexports.parseResource = makeCacheable(_parseResource);\n\n/**\n * Parse resource, skips fragment part\n * @param {string} str the path with query and fragment\n * @returns {ParsedResourceWithoutFragment} parsed parts\n */\nconst _parseResourceWithoutFragment = str => {\n\tconst match = PATH_QUERY_REGEXP.exec(str);\n\treturn {\n\t\tresource: str,\n\t\tpath: match[1].replace(/\\0(.)/g, \"$1\"),\n\t\tquery: match[2] ? match[2].replace(/\\0(.)/g, \"$1\") : \"\"\n\t};\n};\nexports.parseResourceWithoutFragment = makeCacheable(\n\t_parseResourceWithoutFragment\n);\n\n/**\n * @param {string} filename the filename which should be undone\n * @param {string} outputPath the output path that is restored (only relevant when filename contains \"..\")\n * @param {boolean} enforceRelative true returns ./ for empty paths\n * @returns {string} repeated ../ to leave the directory of the provided filename to be back on output dir\n */\nexports.getUndoPath = (filename, outputPath, enforceRelative) => {\n\tlet depth = -1;\n\tlet append = \"\";\n\toutputPath = outputPath.replace(/[\\\\/]$/, \"\");\n\tfor (const part of filename.split(/[/\\\\]+/)) {\n\t\tif (part === \"..\") {\n\t\t\tif (depth > -1) {\n\t\t\t\tdepth--;\n\t\t\t} else {\n\t\t\t\tconst i = outputPath.lastIndexOf(\"/\");\n\t\t\t\tconst j = outputPath.lastIndexOf(\"\\\\\");\n\t\t\t\tconst pos = i < 0 ? j : j < 0 ? i : Math.max(i, j);\n\t\t\t\tif (pos < 0) return outputPath + \"/\";\n\t\t\t\tappend = outputPath.slice(pos + 1) + \"/\" + append;\n\t\t\t\toutputPath = outputPath.slice(0, pos);\n\t\t\t}\n\t\t} else if (part !== \".\") {\n\t\t\tdepth++;\n\t\t}\n\t}\n\treturn depth > 0\n\t\t? `${\"../\".repeat(depth)}${append}`\n\t\t: enforceRelative\n\t\t? `./${append}`\n\t\t: append;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}