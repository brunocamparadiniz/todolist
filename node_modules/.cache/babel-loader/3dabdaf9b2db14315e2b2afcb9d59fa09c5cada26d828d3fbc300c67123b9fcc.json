{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar asyncLib = require(\"neo-async\");\nvar _require = require(\"tapable\"),\n  SyncHook = _require.SyncHook,\n  MultiHook = _require.MultiHook;\nvar ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\nvar MultiStats = require(\"./MultiStats\");\nvar MultiWatching = require(\"./MultiWatching\");\nvar ArrayQueue = require(\"./util/ArrayQueue\");\n\n/** @template T @typedef {import(\"tapable\").AsyncSeriesHook<T>} AsyncSeriesHook<T> */\n/** @template T @template R @typedef {import(\"tapable\").SyncBailHook<T, R>} SyncBailHook<T, R> */\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Stats\")} Stats */\n/** @typedef {import(\"./Watching\")} Watching */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n/**\n * @callback RunWithDependenciesHandler\n * @param {Compiler} compiler\n * @param {Callback<MultiStats>} callback\n */\n\n/**\n * @typedef {Object} MultiCompilerOptions\n * @property {number=} parallelism how many Compilers are allows to run at the same time in parallel\n */\n\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   * @param {Compiler[] | Record<string, Compiler>} compilers child compilers\n   * @param {MultiCompilerOptions} options options\n   */\n  function MultiCompiler(compilers, options) {\n    var _this = this;\n    _classCallCheck(this, MultiCompiler);\n    if (!Array.isArray(compilers)) {\n      compilers = Object.keys(compilers).map(function (name) {\n        compilers[name].name = name;\n        return compilers[name];\n      });\n    }\n    this.hooks = Object.freeze({\n      /** @type {SyncHook<[MultiStats]>} */\n      done: new SyncHook([\"stats\"]),\n      /** @type {MultiHook<SyncHook<[string | null, number]>>} */\n      invalid: new MultiHook(compilers.map(function (c) {\n        return c.hooks.invalid;\n      })),\n      /** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n      run: new MultiHook(compilers.map(function (c) {\n        return c.hooks.run;\n      })),\n      /** @type {SyncHook<[]>} */\n      watchClose: new SyncHook([]),\n      /** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n      watchRun: new MultiHook(compilers.map(function (c) {\n        return c.hooks.watchRun;\n      })),\n      /** @type {MultiHook<SyncBailHook<[string, string, any[]], true>>} */\n      infrastructureLog: new MultiHook(compilers.map(function (c) {\n        return c.hooks.infrastructureLog;\n      }))\n    });\n    this.compilers = compilers;\n    /** @type {MultiCompilerOptions} */\n    this._options = {\n      parallelism: options.parallelism || Infinity\n    };\n    /** @type {WeakMap<Compiler, string[]>} */\n    this.dependencies = new WeakMap();\n    this.running = false;\n\n    /** @type {Stats[]} */\n    var compilerStats = this.compilers.map(function () {\n      return null;\n    });\n    var doneCompilers = 0;\n    var _loop = function _loop() {\n      var compiler = _this.compilers[index];\n      var compilerIndex = index;\n      var compilerDone = false;\n      compiler.hooks.done.tap(\"MultiCompiler\", function (stats) {\n        if (!compilerDone) {\n          compilerDone = true;\n          doneCompilers++;\n        }\n        compilerStats[compilerIndex] = stats;\n        if (doneCompilers === _this.compilers.length) {\n          _this.hooks.done.call(new MultiStats(compilerStats));\n        }\n      });\n      compiler.hooks.invalid.tap(\"MultiCompiler\", function () {\n        if (compilerDone) {\n          compilerDone = false;\n          doneCompilers--;\n        }\n      });\n    };\n    for (var index = 0; index < this.compilers.length; index++) {\n      _loop();\n    }\n  }\n  _createClass(MultiCompiler, [{\n    key: \"options\",\n    get: function get() {\n      return Object.assign(this.compilers.map(function (c) {\n        return c.options;\n      }), this._options);\n    }\n  }, {\n    key: \"outputPath\",\n    get: function get() {\n      var commonPath = this.compilers[0].outputPath;\n      var _iterator = _createForOfIteratorHelper(this.compilers),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var compiler = _step.value;\n          while (compiler.outputPath.indexOf(commonPath) !== 0 && /[/\\\\]/.test(commonPath)) {\n            commonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n      return commonPath;\n    }\n  }, {\n    key: \"inputFileSystem\",\n    get: function get() {\n      throw new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n    },\n    set:\n    /**\n     * @param {InputFileSystem} value the new input file system\n     */\n    function set(value) {\n      var _iterator2 = _createForOfIteratorHelper(this.compilers),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var compiler = _step2.value;\n          compiler.inputFileSystem = value;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n\n    /**\n     * @param {OutputFileSystem} value the new output file system\n     */\n  }, {\n    key: \"outputFileSystem\",\n    get: function get() {\n      throw new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n    },\n    set: function set(value) {\n      var _iterator3 = _createForOfIteratorHelper(this.compilers),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var compiler = _step3.value;\n          compiler.outputFileSystem = value;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n\n    /**\n     * @param {WatchFileSystem} value the new watch file system\n     */\n  }, {\n    key: \"watchFileSystem\",\n    get: function get() {\n      throw new Error(\"Cannot read watchFileSystem of a MultiCompiler\");\n    },\n    set: function set(value) {\n      var _iterator4 = _createForOfIteratorHelper(this.compilers),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var compiler = _step4.value;\n          compiler.watchFileSystem = value;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n\n    /**\n     * @param {IntermediateFileSystem} value the new intermediate file system\n     */\n  }, {\n    key: \"intermediateFileSystem\",\n    get: function get() {\n      throw new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n    },\n    set: function set(value) {\n      var _iterator5 = _createForOfIteratorHelper(this.compilers),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var compiler = _step5.value;\n          compiler.intermediateFileSystem = value;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  }, {\n    key: \"getInfrastructureLogger\",\n    value: function getInfrastructureLogger(name) {\n      return this.compilers[0].getInfrastructureLogger(name);\n    }\n\n    /**\n     * @param {Compiler} compiler the child compiler\n     * @param {string[]} dependencies its dependencies\n     * @returns {void}\n     */\n  }, {\n    key: \"setDependencies\",\n    value: function setDependencies(compiler, dependencies) {\n      this.dependencies.set(compiler, dependencies);\n    }\n\n    /**\n     * @param {Callback<MultiStats>} callback signals when the validation is complete\n     * @returns {boolean} true if the dependencies are valid\n     */\n  }, {\n    key: \"validateDependencies\",\n    value: function validateDependencies(callback) {\n      var _this2 = this;\n      /** @type {Set<{source: Compiler, target: Compiler}>} */\n      var edges = new Set();\n      /** @type {string[]} */\n      var missing = [];\n      var targetFound = function targetFound(compiler) {\n        var _iterator6 = _createForOfIteratorHelper(edges),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var edge = _step6.value;\n            if (edge.target === compiler) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n        return false;\n      };\n      var sortEdges = function sortEdges(e1, e2) {\n        return e1.source.name.localeCompare(e2.source.name) || e1.target.name.localeCompare(e2.target.name);\n      };\n      var _iterator7 = _createForOfIteratorHelper(this.compilers),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var source = _step7.value;\n          var dependencies = this.dependencies.get(source);\n          if (dependencies) {\n            var _iterator9 = _createForOfIteratorHelper(dependencies),\n              _step9;\n            try {\n              var _loop2 = function _loop2() {\n                var dep = _step9.value;\n                var target = _this2.compilers.find(function (c) {\n                  return c.name === dep;\n                });\n                if (!target) {\n                  missing.push(dep);\n                } else {\n                  edges.add({\n                    source: source,\n                    target: target\n                  });\n                }\n              };\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                _loop2();\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n          }\n        }\n        /** @type {string[]} */\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      var errors = missing.map(function (m) {\n        return \"Compiler dependency `\".concat(m, \"` not found.\");\n      });\n      var stack = this.compilers.filter(function (c) {\n        return !targetFound(c);\n      });\n      while (stack.length > 0) {\n        var current = stack.pop();\n        var _iterator8 = _createForOfIteratorHelper(edges),\n          _step8;\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var edge = _step8.value;\n            if (edge.source === current) {\n              edges.delete(edge);\n              var target = edge.target;\n              if (!targetFound(target)) {\n                stack.push(target);\n              }\n            }\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n      }\n      if (edges.size > 0) {\n        /** @type {string[]} */\n        var lines = Array.from(edges).sort(sortEdges).map(function (edge) {\n          return \"\".concat(edge.source.name, \" -> \").concat(edge.target.name);\n        });\n        lines.unshift(\"Circular dependency found in compiler dependencies.\");\n        errors.unshift(lines.join(\"\\n\"));\n      }\n      if (errors.length > 0) {\n        var message = errors.join(\"\\n\");\n        callback(new Error(message));\n        return false;\n      }\n      return true;\n    }\n\n    // TODO webpack 6 remove\n    /**\n     * @deprecated This method should have been private\n     * @param {Compiler[]} compilers the child compilers\n     * @param {RunWithDependenciesHandler} fn a handler to run for each compiler\n     * @param {Callback<MultiStats>} callback the compiler's handler\n     * @returns {void}\n     */\n  }, {\n    key: \"runWithDependencies\",\n    value: function runWithDependencies(compilers, fn, callback) {\n      var _this3 = this;\n      var fulfilledNames = new Set();\n      var remainingCompilers = compilers;\n      var isDependencyFulfilled = function isDependencyFulfilled(d) {\n        return fulfilledNames.has(d);\n      };\n      var getReadyCompilers = function getReadyCompilers() {\n        var readyCompilers = [];\n        var list = remainingCompilers;\n        remainingCompilers = [];\n        var _iterator10 = _createForOfIteratorHelper(list),\n          _step10;\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var c = _step10.value;\n            var dependencies = _this3.dependencies.get(c);\n            var ready = !dependencies || dependencies.every(isDependencyFulfilled);\n            if (ready) {\n              readyCompilers.push(c);\n            } else {\n              remainingCompilers.push(c);\n            }\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n        return readyCompilers;\n      };\n      var runCompilers = function runCompilers(callback) {\n        if (remainingCompilers.length === 0) return callback();\n        asyncLib.map(getReadyCompilers(), function (compiler, callback) {\n          fn(compiler, function (err) {\n            if (err) return callback(err);\n            fulfilledNames.add(compiler.name);\n            runCompilers(callback);\n          });\n        }, callback);\n      };\n      runCompilers(callback);\n    }\n\n    /**\n     * @template SetupResult\n     * @param {function(Compiler, number, Callback<Stats>, function(): boolean, function(): void, function(): void): SetupResult} setup setup a single compiler\n     * @param {function(Compiler, SetupResult, Callback<Stats>): void} run run/continue a single compiler\n     * @param {Callback<MultiStats>} callback callback when all compilers are done, result includes Stats of all changed compilers\n     * @returns {SetupResult[]} result of setup\n     */\n  }, {\n    key: \"_runGraph\",\n    value: function _runGraph(setup, run, callback) {\n      /** @typedef {{ compiler: Compiler, setupResult: SetupResult, result: Stats, state: \"pending\" | \"blocked\" | \"queued\" | \"starting\" | \"running\" | \"running-outdated\" | \"done\", children: Node[], parents: Node[] }} Node */\n\n      // State transitions for nodes:\n      // -> blocked (initial)\n      // blocked -> starting [running++] (when all parents done)\n      // queued -> starting [running++] (when processing the queue)\n      // starting -> running (when run has been called)\n      // running -> done [running--] (when compilation is done)\n      // done -> pending (when invalidated from file change)\n      // pending -> blocked [add to queue] (when invalidated from aggregated changes)\n      // done -> blocked [add to queue] (when invalidated, from parent invalidation)\n      // running -> running-outdated (when invalidated, either from change or parent invalidation)\n      // running-outdated -> blocked [running--] (when compilation is done)\n\n      /** @type {Node[]} */\n      var nodes = this.compilers.map(function (compiler) {\n        return {\n          compiler: compiler,\n          setupResult: undefined,\n          result: undefined,\n          state: \"blocked\",\n          children: [],\n          parents: []\n        };\n      });\n      /** @type {Map<string, Node>} */\n      var compilerToNode = new Map();\n      var _iterator11 = _createForOfIteratorHelper(nodes),\n        _step11;\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var node = _step11.value;\n          compilerToNode.set(node.compiler.name, node);\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n      var _iterator12 = _createForOfIteratorHelper(nodes),\n        _step12;\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var _node2 = _step12.value;\n          var dependencies = this.dependencies.get(_node2.compiler);\n          if (!dependencies) continue;\n          var _iterator18 = _createForOfIteratorHelper(dependencies),\n            _step18;\n          try {\n            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n              var dep = _step18.value;\n              var parent = compilerToNode.get(dep);\n              _node2.parents.push(parent);\n              parent.children.push(_node2);\n            }\n          } catch (err) {\n            _iterator18.e(err);\n          } finally {\n            _iterator18.f();\n          }\n        }\n        /** @type {ArrayQueue<Node>} */\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n      var queue = new ArrayQueue();\n      var _iterator13 = _createForOfIteratorHelper(nodes),\n        _step13;\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var _node3 = _step13.value;\n          if (_node3.parents.length === 0) {\n            _node3.state = \"queued\";\n            queue.enqueue(_node3);\n          }\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n      var errored = false;\n      var running = 0;\n      var parallelism = this._options.parallelism;\n      /**\n       * @param {Node} node node\n       * @param {Error=} err error\n       * @param {Stats=} stats result\n       * @returns {void}\n       */\n      var nodeDone = function nodeDone(node, err, stats) {\n        if (errored) return;\n        if (err) {\n          errored = true;\n          return asyncLib.each(nodes, function (node, callback) {\n            if (node.compiler.watching) {\n              node.compiler.watching.close(callback);\n            } else {\n              callback();\n            }\n          }, function () {\n            return callback(err);\n          });\n        }\n        node.result = stats;\n        running--;\n        if (node.state === \"running\") {\n          node.state = \"done\";\n          var _iterator14 = _createForOfIteratorHelper(node.children),\n            _step14;\n          try {\n            for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n              var child = _step14.value;\n              if (child.state === \"blocked\") queue.enqueue(child);\n            }\n          } catch (err) {\n            _iterator14.e(err);\n          } finally {\n            _iterator14.f();\n          }\n        } else if (node.state === \"running-outdated\") {\n          node.state = \"blocked\";\n          queue.enqueue(node);\n        }\n        processQueue();\n      };\n      /**\n       * @param {Node} node node\n       * @returns {void}\n       */\n      var nodeInvalidFromParent = function nodeInvalidFromParent(node) {\n        if (node.state === \"done\") {\n          node.state = \"blocked\";\n        } else if (node.state === \"running\") {\n          node.state = \"running-outdated\";\n        }\n        var _iterator15 = _createForOfIteratorHelper(node.children),\n          _step15;\n        try {\n          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n            var child = _step15.value;\n            nodeInvalidFromParent(child);\n          }\n        } catch (err) {\n          _iterator15.e(err);\n        } finally {\n          _iterator15.f();\n        }\n      };\n      /**\n       * @param {Node} node node\n       * @returns {void}\n       */\n      var nodeInvalid = function nodeInvalid(node) {\n        if (node.state === \"done\") {\n          node.state = \"pending\";\n        } else if (node.state === \"running\") {\n          node.state = \"running-outdated\";\n        }\n        var _iterator16 = _createForOfIteratorHelper(node.children),\n          _step16;\n        try {\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            var child = _step16.value;\n            nodeInvalidFromParent(child);\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n      };\n      /**\n       * @param {Node} node node\n       * @returns {void}\n       */\n      var nodeChange = function nodeChange(node) {\n        nodeInvalid(node);\n        if (node.state === \"pending\") {\n          node.state = \"blocked\";\n        }\n        if (node.state === \"blocked\") {\n          queue.enqueue(node);\n          processQueue();\n        }\n      };\n      var setupResults = [];\n      nodes.forEach(function (node, i) {\n        setupResults.push(node.setupResult = setup(node.compiler, i, nodeDone.bind(null, node), function () {\n          return node.state !== \"starting\" && node.state !== \"running\";\n        }, function () {\n          return nodeChange(node);\n        }, function () {\n          return nodeInvalid(node);\n        }));\n      });\n      var processing = true;\n      var processQueue = function processQueue() {\n        if (processing) return;\n        processing = true;\n        process.nextTick(processQueueWorker);\n      };\n      var processQueueWorker = function processQueueWorker() {\n        while (running < parallelism && queue.length > 0 && !errored) {\n          var node = queue.dequeue();\n          if (node.state === \"queued\" || node.state === \"blocked\" && node.parents.every(function (p) {\n            return p.state === \"done\";\n          })) {\n            running++;\n            node.state = \"starting\";\n            run(node.compiler, node.setupResult, nodeDone.bind(null, node));\n            node.state = \"running\";\n          }\n        }\n        processing = false;\n        if (!errored && running === 0 && nodes.every(function (node) {\n          return node.state === \"done\";\n        })) {\n          var stats = [];\n          var _iterator17 = _createForOfIteratorHelper(nodes),\n            _step17;\n          try {\n            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n              var _node = _step17.value;\n              var result = _node.result;\n              if (result) {\n                _node.result = undefined;\n                stats.push(result);\n              }\n            }\n          } catch (err) {\n            _iterator17.e(err);\n          } finally {\n            _iterator17.f();\n          }\n          if (stats.length > 0) {\n            callback(null, new MultiStats(stats));\n          }\n        }\n      };\n      processQueueWorker();\n      return setupResults;\n    }\n\n    /**\n     * @param {WatchOptions|WatchOptions[]} watchOptions the watcher's options\n     * @param {Callback<MultiStats>} handler signals when the call finishes\n     * @returns {MultiWatching} a compiler watcher\n     */\n  }, {\n    key: \"watch\",\n    value: function watch(watchOptions, handler) {\n      if (this.running) {\n        return handler(new ConcurrentCompilationError());\n      }\n      this.running = true;\n      if (this.validateDependencies(handler)) {\n        var watchings = this._runGraph(function (compiler, idx, callback, isBlocked, setChanged, setInvalid) {\n          var watching = compiler.watch(Array.isArray(watchOptions) ? watchOptions[idx] : watchOptions, callback);\n          if (watching) {\n            watching._onInvalid = setInvalid;\n            watching._onChange = setChanged;\n            watching._isBlocked = isBlocked;\n          }\n          return watching;\n        }, function (compiler, watching, callback) {\n          if (compiler.watching !== watching) return;\n          if (!watching.running) watching.invalidate();\n        }, handler);\n        return new MultiWatching(watchings, this);\n      }\n      return new MultiWatching([], this);\n    }\n\n    /**\n     * @param {Callback<MultiStats>} callback signals when the call finishes\n     * @returns {void}\n     */\n  }, {\n    key: \"run\",\n    value: function run(callback) {\n      var _this4 = this;\n      if (this.running) {\n        return callback(new ConcurrentCompilationError());\n      }\n      this.running = true;\n      if (this.validateDependencies(callback)) {\n        this._runGraph(function () {}, function (compiler, setupResult, callback) {\n          return compiler.run(callback);\n        }, function (err, stats) {\n          _this4.running = false;\n          if (callback !== undefined) {\n            return callback(err, stats);\n          }\n        });\n      }\n    }\n  }, {\n    key: \"purgeInputFileSystem\",\n    value: function purgeInputFileSystem() {\n      var _iterator19 = _createForOfIteratorHelper(this.compilers),\n        _step19;\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var compiler = _step19.value;\n          if (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n            compiler.inputFileSystem.purge();\n          }\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n    }\n\n    /**\n     * @param {Callback<void>} callback signals when the compiler closes\n     * @returns {void}\n     */\n  }, {\n    key: \"close\",\n    value: function close(callback) {\n      asyncLib.each(this.compilers, function (compiler, callback) {\n        compiler.close(callback);\n      }, callback);\n    }\n  }]);\n  return MultiCompiler;\n}();","map":{"version":3,"names":["asyncLib","require","SyncHook","MultiHook","ConcurrentCompilationError","MultiStats","MultiWatching","ArrayQueue","module","exports","compilers","options","Array","isArray","Object","keys","map","name","hooks","freeze","done","invalid","c","run","watchClose","watchRun","infrastructureLog","_options","parallelism","Infinity","dependencies","WeakMap","running","compilerStats","doneCompilers","compiler","index","compilerIndex","compilerDone","tap","stats","length","call","assign","commonPath","outputPath","indexOf","test","replace","Error","value","inputFileSystem","outputFileSystem","watchFileSystem","intermediateFileSystem","getInfrastructureLogger","set","callback","edges","Set","missing","targetFound","edge","target","sortEdges","e1","e2","source","localeCompare","get","dep","find","push","add","errors","m","stack","filter","current","pop","delete","size","lines","from","sort","unshift","join","message","fn","fulfilledNames","remainingCompilers","isDependencyFulfilled","d","has","getReadyCompilers","readyCompilers","list","ready","every","runCompilers","err","setup","nodes","setupResult","undefined","result","state","children","parents","compilerToNode","Map","node","parent","queue","enqueue","errored","nodeDone","each","watching","close","child","processQueue","nodeInvalidFromParent","nodeInvalid","nodeChange","setupResults","forEach","i","bind","processing","process","nextTick","processQueueWorker","dequeue","p","watchOptions","handler","validateDependencies","watchings","_runGraph","idx","isBlocked","setChanged","setInvalid","watch","_onInvalid","_onChange","_isBlocked","invalidate","purge"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/MultiCompiler.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { SyncHook, MultiHook } = require(\"tapable\");\n\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\nconst MultiStats = require(\"./MultiStats\");\nconst MultiWatching = require(\"./MultiWatching\");\nconst ArrayQueue = require(\"./util/ArrayQueue\");\n\n/** @template T @typedef {import(\"tapable\").AsyncSeriesHook<T>} AsyncSeriesHook<T> */\n/** @template T @template R @typedef {import(\"tapable\").SyncBailHook<T, R>} SyncBailHook<T, R> */\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Stats\")} Stats */\n/** @typedef {import(\"./Watching\")} Watching */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n/**\n * @callback RunWithDependenciesHandler\n * @param {Compiler} compiler\n * @param {Callback<MultiStats>} callback\n */\n\n/**\n * @typedef {Object} MultiCompilerOptions\n * @property {number=} parallelism how many Compilers are allows to run at the same time in parallel\n */\n\nmodule.exports = class MultiCompiler {\n\t/**\n\t * @param {Compiler[] | Record<string, Compiler>} compilers child compilers\n\t * @param {MultiCompilerOptions} options options\n\t */\n\tconstructor(compilers, options) {\n\t\tif (!Array.isArray(compilers)) {\n\t\t\tcompilers = Object.keys(compilers).map(name => {\n\t\t\t\tcompilers[name].name = name;\n\t\t\t\treturn compilers[name];\n\t\t\t});\n\t\t}\n\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {SyncHook<[MultiStats]>} */\n\t\t\tdone: new SyncHook([\"stats\"]),\n\t\t\t/** @type {MultiHook<SyncHook<[string | null, number]>>} */\n\t\t\tinvalid: new MultiHook(compilers.map(c => c.hooks.invalid)),\n\t\t\t/** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n\t\t\trun: new MultiHook(compilers.map(c => c.hooks.run)),\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\twatchClose: new SyncHook([]),\n\t\t\t/** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n\t\t\twatchRun: new MultiHook(compilers.map(c => c.hooks.watchRun)),\n\t\t\t/** @type {MultiHook<SyncBailHook<[string, string, any[]], true>>} */\n\t\t\tinfrastructureLog: new MultiHook(\n\t\t\t\tcompilers.map(c => c.hooks.infrastructureLog)\n\t\t\t)\n\t\t});\n\t\tthis.compilers = compilers;\n\t\t/** @type {MultiCompilerOptions} */\n\t\tthis._options = {\n\t\t\tparallelism: options.parallelism || Infinity\n\t\t};\n\t\t/** @type {WeakMap<Compiler, string[]>} */\n\t\tthis.dependencies = new WeakMap();\n\t\tthis.running = false;\n\n\t\t/** @type {Stats[]} */\n\t\tconst compilerStats = this.compilers.map(() => null);\n\t\tlet doneCompilers = 0;\n\t\tfor (let index = 0; index < this.compilers.length; index++) {\n\t\t\tconst compiler = this.compilers[index];\n\t\t\tconst compilerIndex = index;\n\t\t\tlet compilerDone = false;\n\t\t\tcompiler.hooks.done.tap(\"MultiCompiler\", stats => {\n\t\t\t\tif (!compilerDone) {\n\t\t\t\t\tcompilerDone = true;\n\t\t\t\t\tdoneCompilers++;\n\t\t\t\t}\n\t\t\t\tcompilerStats[compilerIndex] = stats;\n\t\t\t\tif (doneCompilers === this.compilers.length) {\n\t\t\t\t\tthis.hooks.done.call(new MultiStats(compilerStats));\n\t\t\t\t}\n\t\t\t});\n\t\t\tcompiler.hooks.invalid.tap(\"MultiCompiler\", () => {\n\t\t\t\tif (compilerDone) {\n\t\t\t\t\tcompilerDone = false;\n\t\t\t\t\tdoneCompilers--;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tget options() {\n\t\treturn Object.assign(\n\t\t\tthis.compilers.map(c => c.options),\n\t\t\tthis._options\n\t\t);\n\t}\n\n\tget outputPath() {\n\t\tlet commonPath = this.compilers[0].outputPath;\n\t\tfor (const compiler of this.compilers) {\n\t\t\twhile (\n\t\t\t\tcompiler.outputPath.indexOf(commonPath) !== 0 &&\n\t\t\t\t/[/\\\\]/.test(commonPath)\n\t\t\t) {\n\t\t\t\tcommonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n\t\treturn commonPath;\n\t}\n\n\tget inputFileSystem() {\n\t\tthrow new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n\t}\n\n\tget outputFileSystem() {\n\t\tthrow new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n\t}\n\n\tget watchFileSystem() {\n\t\tthrow new Error(\"Cannot read watchFileSystem of a MultiCompiler\");\n\t}\n\n\tget intermediateFileSystem() {\n\t\tthrow new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n\t}\n\n\t/**\n\t * @param {InputFileSystem} value the new input file system\n\t */\n\tset inputFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.inputFileSystem = value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {OutputFileSystem} value the new output file system\n\t */\n\tset outputFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.outputFileSystem = value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {WatchFileSystem} value the new watch file system\n\t */\n\tset watchFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.watchFileSystem = value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {IntermediateFileSystem} value the new intermediate file system\n\t */\n\tset intermediateFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.intermediateFileSystem = value;\n\t\t}\n\t}\n\n\tgetInfrastructureLogger(name) {\n\t\treturn this.compilers[0].getInfrastructureLogger(name);\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the child compiler\n\t * @param {string[]} dependencies its dependencies\n\t * @returns {void}\n\t */\n\tsetDependencies(compiler, dependencies) {\n\t\tthis.dependencies.set(compiler, dependencies);\n\t}\n\n\t/**\n\t * @param {Callback<MultiStats>} callback signals when the validation is complete\n\t * @returns {boolean} true if the dependencies are valid\n\t */\n\tvalidateDependencies(callback) {\n\t\t/** @type {Set<{source: Compiler, target: Compiler}>} */\n\t\tconst edges = new Set();\n\t\t/** @type {string[]} */\n\t\tconst missing = [];\n\t\tconst targetFound = compiler => {\n\t\t\tfor (const edge of edges) {\n\t\t\t\tif (edge.target === compiler) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tconst sortEdges = (e1, e2) => {\n\t\t\treturn (\n\t\t\t\te1.source.name.localeCompare(e2.source.name) ||\n\t\t\t\te1.target.name.localeCompare(e2.target.name)\n\t\t\t);\n\t\t};\n\t\tfor (const source of this.compilers) {\n\t\t\tconst dependencies = this.dependencies.get(source);\n\t\t\tif (dependencies) {\n\t\t\t\tfor (const dep of dependencies) {\n\t\t\t\t\tconst target = this.compilers.find(c => c.name === dep);\n\t\t\t\t\tif (!target) {\n\t\t\t\t\t\tmissing.push(dep);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tedges.add({\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\ttarget\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/** @type {string[]} */\n\t\tconst errors = missing.map(m => `Compiler dependency \\`${m}\\` not found.`);\n\t\tconst stack = this.compilers.filter(c => !targetFound(c));\n\t\twhile (stack.length > 0) {\n\t\t\tconst current = stack.pop();\n\t\t\tfor (const edge of edges) {\n\t\t\t\tif (edge.source === current) {\n\t\t\t\t\tedges.delete(edge);\n\t\t\t\t\tconst target = edge.target;\n\t\t\t\t\tif (!targetFound(target)) {\n\t\t\t\t\t\tstack.push(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (edges.size > 0) {\n\t\t\t/** @type {string[]} */\n\t\t\tconst lines = Array.from(edges)\n\t\t\t\t.sort(sortEdges)\n\t\t\t\t.map(edge => `${edge.source.name} -> ${edge.target.name}`);\n\t\t\tlines.unshift(\"Circular dependency found in compiler dependencies.\");\n\t\t\terrors.unshift(lines.join(\"\\n\"));\n\t\t}\n\t\tif (errors.length > 0) {\n\t\t\tconst message = errors.join(\"\\n\");\n\t\t\tcallback(new Error(message));\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t// TODO webpack 6 remove\n\t/**\n\t * @deprecated This method should have been private\n\t * @param {Compiler[]} compilers the child compilers\n\t * @param {RunWithDependenciesHandler} fn a handler to run for each compiler\n\t * @param {Callback<MultiStats>} callback the compiler's handler\n\t * @returns {void}\n\t */\n\trunWithDependencies(compilers, fn, callback) {\n\t\tconst fulfilledNames = new Set();\n\t\tlet remainingCompilers = compilers;\n\t\tconst isDependencyFulfilled = d => fulfilledNames.has(d);\n\t\tconst getReadyCompilers = () => {\n\t\t\tlet readyCompilers = [];\n\t\t\tlet list = remainingCompilers;\n\t\t\tremainingCompilers = [];\n\t\t\tfor (const c of list) {\n\t\t\t\tconst dependencies = this.dependencies.get(c);\n\t\t\t\tconst ready =\n\t\t\t\t\t!dependencies || dependencies.every(isDependencyFulfilled);\n\t\t\t\tif (ready) {\n\t\t\t\t\treadyCompilers.push(c);\n\t\t\t\t} else {\n\t\t\t\t\tremainingCompilers.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn readyCompilers;\n\t\t};\n\t\tconst runCompilers = callback => {\n\t\t\tif (remainingCompilers.length === 0) return callback();\n\t\t\tasyncLib.map(\n\t\t\t\tgetReadyCompilers(),\n\t\t\t\t(compiler, callback) => {\n\t\t\t\t\tfn(compiler, err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tfulfilledNames.add(compiler.name);\n\t\t\t\t\t\trunCompilers(callback);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tcallback\n\t\t\t);\n\t\t};\n\t\trunCompilers(callback);\n\t}\n\n\t/**\n\t * @template SetupResult\n\t * @param {function(Compiler, number, Callback<Stats>, function(): boolean, function(): void, function(): void): SetupResult} setup setup a single compiler\n\t * @param {function(Compiler, SetupResult, Callback<Stats>): void} run run/continue a single compiler\n\t * @param {Callback<MultiStats>} callback callback when all compilers are done, result includes Stats of all changed compilers\n\t * @returns {SetupResult[]} result of setup\n\t */\n\t_runGraph(setup, run, callback) {\n\t\t/** @typedef {{ compiler: Compiler, setupResult: SetupResult, result: Stats, state: \"pending\" | \"blocked\" | \"queued\" | \"starting\" | \"running\" | \"running-outdated\" | \"done\", children: Node[], parents: Node[] }} Node */\n\n\t\t// State transitions for nodes:\n\t\t// -> blocked (initial)\n\t\t// blocked -> starting [running++] (when all parents done)\n\t\t// queued -> starting [running++] (when processing the queue)\n\t\t// starting -> running (when run has been called)\n\t\t// running -> done [running--] (when compilation is done)\n\t\t// done -> pending (when invalidated from file change)\n\t\t// pending -> blocked [add to queue] (when invalidated from aggregated changes)\n\t\t// done -> blocked [add to queue] (when invalidated, from parent invalidation)\n\t\t// running -> running-outdated (when invalidated, either from change or parent invalidation)\n\t\t// running-outdated -> blocked [running--] (when compilation is done)\n\n\t\t/** @type {Node[]} */\n\t\tconst nodes = this.compilers.map(compiler => ({\n\t\t\tcompiler,\n\t\t\tsetupResult: undefined,\n\t\t\tresult: undefined,\n\t\t\tstate: \"blocked\",\n\t\t\tchildren: [],\n\t\t\tparents: []\n\t\t}));\n\t\t/** @type {Map<string, Node>} */\n\t\tconst compilerToNode = new Map();\n\t\tfor (const node of nodes) compilerToNode.set(node.compiler.name, node);\n\t\tfor (const node of nodes) {\n\t\t\tconst dependencies = this.dependencies.get(node.compiler);\n\t\t\tif (!dependencies) continue;\n\t\t\tfor (const dep of dependencies) {\n\t\t\t\tconst parent = compilerToNode.get(dep);\n\t\t\t\tnode.parents.push(parent);\n\t\t\t\tparent.children.push(node);\n\t\t\t}\n\t\t}\n\t\t/** @type {ArrayQueue<Node>} */\n\t\tconst queue = new ArrayQueue();\n\t\tfor (const node of nodes) {\n\t\t\tif (node.parents.length === 0) {\n\t\t\t\tnode.state = \"queued\";\n\t\t\t\tqueue.enqueue(node);\n\t\t\t}\n\t\t}\n\t\tlet errored = false;\n\t\tlet running = 0;\n\t\tconst parallelism = this._options.parallelism;\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @param {Error=} err error\n\t\t * @param {Stats=} stats result\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeDone = (node, err, stats) => {\n\t\t\tif (errored) return;\n\t\t\tif (err) {\n\t\t\t\terrored = true;\n\t\t\t\treturn asyncLib.each(\n\t\t\t\t\tnodes,\n\t\t\t\t\t(node, callback) => {\n\t\t\t\t\t\tif (node.compiler.watching) {\n\t\t\t\t\t\t\tnode.compiler.watching.close(callback);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => callback(err)\n\t\t\t\t);\n\t\t\t}\n\t\t\tnode.result = stats;\n\t\t\trunning--;\n\t\t\tif (node.state === \"running\") {\n\t\t\t\tnode.state = \"done\";\n\t\t\t\tfor (const child of node.children) {\n\t\t\t\t\tif (child.state === \"blocked\") queue.enqueue(child);\n\t\t\t\t}\n\t\t\t} else if (node.state === \"running-outdated\") {\n\t\t\t\tnode.state = \"blocked\";\n\t\t\t\tqueue.enqueue(node);\n\t\t\t}\n\t\t\tprocessQueue();\n\t\t};\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeInvalidFromParent = node => {\n\t\t\tif (node.state === \"done\") {\n\t\t\t\tnode.state = \"blocked\";\n\t\t\t} else if (node.state === \"running\") {\n\t\t\t\tnode.state = \"running-outdated\";\n\t\t\t}\n\t\t\tfor (const child of node.children) {\n\t\t\t\tnodeInvalidFromParent(child);\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeInvalid = node => {\n\t\t\tif (node.state === \"done\") {\n\t\t\t\tnode.state = \"pending\";\n\t\t\t} else if (node.state === \"running\") {\n\t\t\t\tnode.state = \"running-outdated\";\n\t\t\t}\n\t\t\tfor (const child of node.children) {\n\t\t\t\tnodeInvalidFromParent(child);\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeChange = node => {\n\t\t\tnodeInvalid(node);\n\t\t\tif (node.state === \"pending\") {\n\t\t\t\tnode.state = \"blocked\";\n\t\t\t}\n\t\t\tif (node.state === \"blocked\") {\n\t\t\t\tqueue.enqueue(node);\n\t\t\t\tprocessQueue();\n\t\t\t}\n\t\t};\n\n\t\tconst setupResults = [];\n\t\tnodes.forEach((node, i) => {\n\t\t\tsetupResults.push(\n\t\t\t\t(node.setupResult = setup(\n\t\t\t\t\tnode.compiler,\n\t\t\t\t\ti,\n\t\t\t\t\tnodeDone.bind(null, node),\n\t\t\t\t\t() => node.state !== \"starting\" && node.state !== \"running\",\n\t\t\t\t\t() => nodeChange(node),\n\t\t\t\t\t() => nodeInvalid(node)\n\t\t\t\t))\n\t\t\t);\n\t\t});\n\t\tlet processing = true;\n\t\tconst processQueue = () => {\n\t\t\tif (processing) return;\n\t\t\tprocessing = true;\n\t\t\tprocess.nextTick(processQueueWorker);\n\t\t};\n\t\tconst processQueueWorker = () => {\n\t\t\twhile (running < parallelism && queue.length > 0 && !errored) {\n\t\t\t\tconst node = queue.dequeue();\n\t\t\t\tif (\n\t\t\t\t\tnode.state === \"queued\" ||\n\t\t\t\t\t(node.state === \"blocked\" &&\n\t\t\t\t\t\tnode.parents.every(p => p.state === \"done\"))\n\t\t\t\t) {\n\t\t\t\t\trunning++;\n\t\t\t\t\tnode.state = \"starting\";\n\t\t\t\t\trun(node.compiler, node.setupResult, nodeDone.bind(null, node));\n\t\t\t\t\tnode.state = \"running\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessing = false;\n\t\t\tif (\n\t\t\t\t!errored &&\n\t\t\t\trunning === 0 &&\n\t\t\t\tnodes.every(node => node.state === \"done\")\n\t\t\t) {\n\t\t\t\tconst stats = [];\n\t\t\t\tfor (const node of nodes) {\n\t\t\t\t\tconst result = node.result;\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tnode.result = undefined;\n\t\t\t\t\t\tstats.push(result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (stats.length > 0) {\n\t\t\t\t\tcallback(null, new MultiStats(stats));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tprocessQueueWorker();\n\t\treturn setupResults;\n\t}\n\n\t/**\n\t * @param {WatchOptions|WatchOptions[]} watchOptions the watcher's options\n\t * @param {Callback<MultiStats>} handler signals when the call finishes\n\t * @returns {MultiWatching} a compiler watcher\n\t */\n\twatch(watchOptions, handler) {\n\t\tif (this.running) {\n\t\t\treturn handler(new ConcurrentCompilationError());\n\t\t}\n\t\tthis.running = true;\n\n\t\tif (this.validateDependencies(handler)) {\n\t\t\tconst watchings = this._runGraph(\n\t\t\t\t(compiler, idx, callback, isBlocked, setChanged, setInvalid) => {\n\t\t\t\t\tconst watching = compiler.watch(\n\t\t\t\t\t\tArray.isArray(watchOptions) ? watchOptions[idx] : watchOptions,\n\t\t\t\t\t\tcallback\n\t\t\t\t\t);\n\t\t\t\t\tif (watching) {\n\t\t\t\t\t\twatching._onInvalid = setInvalid;\n\t\t\t\t\t\twatching._onChange = setChanged;\n\t\t\t\t\t\twatching._isBlocked = isBlocked;\n\t\t\t\t\t}\n\t\t\t\t\treturn watching;\n\t\t\t\t},\n\t\t\t\t(compiler, watching, callback) => {\n\t\t\t\t\tif (compiler.watching !== watching) return;\n\t\t\t\t\tif (!watching.running) watching.invalidate();\n\t\t\t\t},\n\t\t\t\thandler\n\t\t\t);\n\t\t\treturn new MultiWatching(watchings, this);\n\t\t}\n\n\t\treturn new MultiWatching([], this);\n\t}\n\n\t/**\n\t * @param {Callback<MultiStats>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\trun(callback) {\n\t\tif (this.running) {\n\t\t\treturn callback(new ConcurrentCompilationError());\n\t\t}\n\t\tthis.running = true;\n\n\t\tif (this.validateDependencies(callback)) {\n\t\t\tthis._runGraph(\n\t\t\t\t() => {},\n\t\t\t\t(compiler, setupResult, callback) => compiler.run(callback),\n\t\t\t\t(err, stats) => {\n\t\t\t\t\tthis.running = false;\n\n\t\t\t\t\tif (callback !== undefined) {\n\t\t\t\t\t\treturn callback(err, stats);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\tpurgeInputFileSystem() {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tif (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n\t\t\t\tcompiler.inputFileSystem.purge();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the compiler closes\n\t * @returns {void}\n\t */\n\tclose(callback) {\n\t\tasyncLib.each(\n\t\t\tthis.compilers,\n\t\t\t(compiler, callback) => {\n\t\t\t\tcompiler.close(callback);\n\t\t\t},\n\t\t\tcallback\n\t\t);\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}