{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar asyncLib = require(\"neo-async\");\nvar Queue = require(\"./util/Queue\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Dependency\").ExportSpec} ExportSpec */\n/** @typedef {import(\"./Dependency\").ExportsSpec} ExportsSpec */\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"./Module\")} Module */\nvar FlagDependencyExportsPlugin = /*#__PURE__*/function () {\n  function FlagDependencyExportsPlugin() {\n    _classCallCheck(this, FlagDependencyExportsPlugin);\n  }\n  _createClass(FlagDependencyExportsPlugin, [{\n    key: \"apply\",\n    value:\n    /**\n     * Apply the plugin\n     * @param {Compiler} compiler the compiler instance\n     * @returns {void}\n     */\n    function apply(compiler) {\n      var _this = this;\n      compiler.hooks.compilation.tap(\"FlagDependencyExportsPlugin\", function (compilation) {\n        var moduleGraph = compilation.moduleGraph;\n        var cache = compilation.getCache(\"FlagDependencyExportsPlugin\");\n        compilation.hooks.finishModules.tapAsync(\"FlagDependencyExportsPlugin\", function (modules, callback) {\n          var logger = compilation.getLogger(\"webpack.FlagDependencyExportsPlugin\");\n          var statRestoredFromMemCache = 0;\n          var statRestoredFromCache = 0;\n          var statNoExports = 0;\n          var statFlaggedUncached = 0;\n          var statNotCached = 0;\n          var statQueueItemsProcessed = 0;\n          var moduleMemCaches = compilation.moduleMemCaches;\n\n          /** @type {Queue<Module>} */\n          var queue = new Queue();\n\n          // Step 1: Try to restore cached provided export info from cache\n          logger.time(\"restore cached provided exports\");\n          asyncLib.each(modules, function (module, callback) {\n            var exportsInfo = moduleGraph.getExportsInfo(module);\n            if (!module.buildMeta || !module.buildMeta.exportsType) {\n              if (exportsInfo.otherExportsInfo.provided !== null) {\n                // It's a module without declared exports\n                statNoExports++;\n                exportsInfo.setHasProvideInfo();\n                exportsInfo.setUnknownExportsProvided();\n                return callback();\n              }\n            }\n            if (typeof module.buildInfo.hash !== \"string\") {\n              statFlaggedUncached++;\n              // Enqueue uncacheable module for determining the exports\n              queue.enqueue(module);\n              exportsInfo.setHasProvideInfo();\n              return callback();\n            }\n            var memCache = moduleMemCaches && moduleMemCaches.get(module);\n            var memCacheValue = memCache && memCache.get(_this);\n            if (memCacheValue !== undefined) {\n              statRestoredFromMemCache++;\n              exportsInfo.restoreProvided(memCacheValue);\n              return callback();\n            }\n            cache.get(module.identifier(), module.buildInfo.hash, function (err, result) {\n              if (err) return callback(err);\n              if (result !== undefined) {\n                statRestoredFromCache++;\n                exportsInfo.restoreProvided(result);\n              } else {\n                statNotCached++;\n                // Without cached info enqueue module for determining the exports\n                queue.enqueue(module);\n                exportsInfo.setHasProvideInfo();\n              }\n              callback();\n            });\n          }, function (err) {\n            logger.timeEnd(\"restore cached provided exports\");\n            if (err) return callback(err);\n\n            /** @type {Set<Module>} */\n            var modulesToStore = new Set();\n\n            /** @type {Map<Module, Set<Module>>} */\n            var dependencies = new Map();\n\n            /** @type {Module} */\n            var module;\n\n            /** @type {ExportsInfo} */\n            var exportsInfo;\n\n            /** @type {Map<Dependency, ExportsSpec>} */\n            var exportsSpecsFromDependencies = new Map();\n            var cacheable = true;\n            var changed = false;\n\n            /**\n             * @param {DependenciesBlock} depBlock the dependencies block\n             * @returns {void}\n             */\n            var processDependenciesBlock = function processDependenciesBlock(depBlock) {\n              var _iterator = _createForOfIteratorHelper(depBlock.dependencies),\n                _step;\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var dep = _step.value;\n                  processDependency(dep);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              var _iterator2 = _createForOfIteratorHelper(depBlock.blocks),\n                _step2;\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var block = _step2.value;\n                  processDependenciesBlock(block);\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            };\n\n            /**\n             * @param {Dependency} dep the dependency\n             * @returns {void}\n             */\n            var processDependency = function processDependency(dep) {\n              var exportDesc = dep.getExports(moduleGraph);\n              if (!exportDesc) return;\n              exportsSpecsFromDependencies.set(dep, exportDesc);\n            };\n\n            /**\n             * @param {Dependency} dep dependency\n             * @param {ExportsSpec} exportDesc info\n             * @returns {void}\n             */\n            var processExportsSpec = function processExportsSpec(dep, exportDesc) {\n              var exports = exportDesc.exports;\n              var globalCanMangle = exportDesc.canMangle;\n              var globalFrom = exportDesc.from;\n              var globalPriority = exportDesc.priority;\n              var globalTerminalBinding = exportDesc.terminalBinding || false;\n              var exportDeps = exportDesc.dependencies;\n              if (exportDesc.hideExports) {\n                var _iterator3 = _createForOfIteratorHelper(exportDesc.hideExports),\n                  _step3;\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    var name = _step3.value;\n                    var exportInfo = exportsInfo.getExportInfo(name);\n                    exportInfo.unsetTarget(dep);\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n              }\n              if (exports === true) {\n                // unknown exports\n                if (exportsInfo.setUnknownExportsProvided(globalCanMangle, exportDesc.excludeExports, globalFrom && dep, globalFrom, globalPriority)) {\n                  changed = true;\n                }\n              } else if (Array.isArray(exports)) {\n                /**\n                 * merge in new exports\n                 * @param {ExportsInfo} exportsInfo own exports info\n                 * @param {(ExportSpec | string)[]} exports list of exports\n                 */\n                var mergeExports = function mergeExports(exportsInfo, exports) {\n                  var _iterator4 = _createForOfIteratorHelper(exports),\n                    _step4;\n                  try {\n                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                      var exportNameOrSpec = _step4.value;\n                      var _name = void 0;\n                      var canMangle = globalCanMangle;\n                      var terminalBinding = globalTerminalBinding;\n                      var _exports = undefined;\n                      var from = globalFrom;\n                      var fromExport = undefined;\n                      var priority = globalPriority;\n                      var hidden = false;\n                      if (typeof exportNameOrSpec === \"string\") {\n                        _name = exportNameOrSpec;\n                      } else {\n                        _name = exportNameOrSpec.name;\n                        if (exportNameOrSpec.canMangle !== undefined) canMangle = exportNameOrSpec.canMangle;\n                        if (exportNameOrSpec.export !== undefined) fromExport = exportNameOrSpec.export;\n                        if (exportNameOrSpec.exports !== undefined) _exports = exportNameOrSpec.exports;\n                        if (exportNameOrSpec.from !== undefined) from = exportNameOrSpec.from;\n                        if (exportNameOrSpec.priority !== undefined) priority = exportNameOrSpec.priority;\n                        if (exportNameOrSpec.terminalBinding !== undefined) terminalBinding = exportNameOrSpec.terminalBinding;\n                        if (exportNameOrSpec.hidden !== undefined) hidden = exportNameOrSpec.hidden;\n                      }\n                      var _exportInfo = exportsInfo.getExportInfo(_name);\n                      if (_exportInfo.provided === false || _exportInfo.provided === null) {\n                        _exportInfo.provided = true;\n                        changed = true;\n                      }\n                      if (_exportInfo.canMangleProvide !== false && canMangle === false) {\n                        _exportInfo.canMangleProvide = false;\n                        changed = true;\n                      }\n                      if (terminalBinding && !_exportInfo.terminalBinding) {\n                        _exportInfo.terminalBinding = true;\n                        changed = true;\n                      }\n                      if (_exports) {\n                        var nestedExportsInfo = _exportInfo.createNestedExportsInfo();\n                        mergeExports(nestedExportsInfo, _exports);\n                      }\n                      if (from && (hidden ? _exportInfo.unsetTarget(dep) : _exportInfo.setTarget(dep, from, fromExport === undefined ? [_name] : fromExport, priority))) {\n                        changed = true;\n                      }\n\n                      // Recalculate target exportsInfo\n                      var target = _exportInfo.getTarget(moduleGraph);\n                      var targetExportsInfo = undefined;\n                      if (target) {\n                        var targetModuleExportsInfo = moduleGraph.getExportsInfo(target.module);\n                        targetExportsInfo = targetModuleExportsInfo.getNestedExportsInfo(target.export);\n                        // add dependency for this module\n                        var set = dependencies.get(target.module);\n                        if (set === undefined) {\n                          dependencies.set(target.module, new Set([module]));\n                        } else {\n                          set.add(module);\n                        }\n                      }\n                      if (_exportInfo.exportsInfoOwned) {\n                        if (_exportInfo.exportsInfo.setRedirectNamedTo(targetExportsInfo)) {\n                          changed = true;\n                        }\n                      } else if (_exportInfo.exportsInfo !== targetExportsInfo) {\n                        _exportInfo.exportsInfo = targetExportsInfo;\n                        changed = true;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator4.e(err);\n                  } finally {\n                    _iterator4.f();\n                  }\n                };\n                mergeExports(exportsInfo, exports);\n              }\n              // store dependencies\n              if (exportDeps) {\n                cacheable = false;\n                var _iterator5 = _createForOfIteratorHelper(exportDeps),\n                  _step5;\n                try {\n                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                    var exportDependency = _step5.value;\n                    // add dependency for this module\n                    var set = dependencies.get(exportDependency);\n                    if (set === undefined) {\n                      dependencies.set(exportDependency, new Set([module]));\n                    } else {\n                      set.add(module);\n                    }\n                  }\n                } catch (err) {\n                  _iterator5.e(err);\n                } finally {\n                  _iterator5.f();\n                }\n              }\n            };\n            var notifyDependencies = function notifyDependencies() {\n              var deps = dependencies.get(module);\n              if (deps !== undefined) {\n                var _iterator6 = _createForOfIteratorHelper(deps),\n                  _step6;\n                try {\n                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                    var dep = _step6.value;\n                    queue.enqueue(dep);\n                  }\n                } catch (err) {\n                  _iterator6.e(err);\n                } finally {\n                  _iterator6.f();\n                }\n              }\n            };\n            logger.time(\"figure out provided exports\");\n            while (queue.length > 0) {\n              module = queue.dequeue();\n              statQueueItemsProcessed++;\n              exportsInfo = moduleGraph.getExportsInfo(module);\n              cacheable = true;\n              changed = false;\n              exportsSpecsFromDependencies.clear();\n              moduleGraph.freeze();\n              processDependenciesBlock(module);\n              moduleGraph.unfreeze();\n              var _iterator7 = _createForOfIteratorHelper(exportsSpecsFromDependencies),\n                _step7;\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var _step7$value = _slicedToArray(_step7.value, 2),\n                    dep = _step7$value[0],\n                    exportsSpec = _step7$value[1];\n                  processExportsSpec(dep, exportsSpec);\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n              if (cacheable) {\n                modulesToStore.add(module);\n              }\n              if (changed) {\n                notifyDependencies();\n              }\n            }\n            logger.timeEnd(\"figure out provided exports\");\n            logger.log(\"\".concat(Math.round(100 * (statFlaggedUncached + statNotCached) / (statRestoredFromMemCache + statRestoredFromCache + statNotCached + statFlaggedUncached + statNoExports)), \"% of exports of modules have been determined (\").concat(statNoExports, \" no declared exports, \").concat(statNotCached, \" not cached, \").concat(statFlaggedUncached, \" flagged uncacheable, \").concat(statRestoredFromCache, \" from cache, \").concat(statRestoredFromMemCache, \" from mem cache, \").concat(statQueueItemsProcessed - statNotCached - statFlaggedUncached, \" additional calculations due to dependencies)\"));\n            logger.time(\"store provided exports into cache\");\n            asyncLib.each(modulesToStore, function (module, callback) {\n              if (typeof module.buildInfo.hash !== \"string\") {\n                // not cacheable\n                return callback();\n              }\n              var cachedData = moduleGraph.getExportsInfo(module).getRestoreProvidedData();\n              var memCache = moduleMemCaches && moduleMemCaches.get(module);\n              if (memCache) {\n                memCache.set(_this, cachedData);\n              }\n              cache.store(module.identifier(), module.buildInfo.hash, cachedData, callback);\n            }, function (err) {\n              logger.timeEnd(\"store provided exports into cache\");\n              callback(err);\n            });\n          });\n        });\n\n        /** @type {WeakMap<Module, any>} */\n        var providedExportsCache = new WeakMap();\n        compilation.hooks.rebuildModule.tap(\"FlagDependencyExportsPlugin\", function (module) {\n          providedExportsCache.set(module, moduleGraph.getExportsInfo(module).getRestoreProvidedData());\n        });\n        compilation.hooks.finishRebuildingModule.tap(\"FlagDependencyExportsPlugin\", function (module) {\n          moduleGraph.getExportsInfo(module).restoreProvided(providedExportsCache.get(module));\n        });\n      });\n    }\n  }]);\n  return FlagDependencyExportsPlugin;\n}();\nmodule.exports = FlagDependencyExportsPlugin;","map":{"version":3,"names":["asyncLib","require","Queue","FlagDependencyExportsPlugin","compiler","hooks","compilation","tap","moduleGraph","cache","getCache","finishModules","tapAsync","modules","callback","logger","getLogger","statRestoredFromMemCache","statRestoredFromCache","statNoExports","statFlaggedUncached","statNotCached","statQueueItemsProcessed","moduleMemCaches","queue","time","each","module","exportsInfo","getExportsInfo","buildMeta","exportsType","otherExportsInfo","provided","setHasProvideInfo","setUnknownExportsProvided","buildInfo","hash","enqueue","memCache","get","memCacheValue","undefined","restoreProvided","identifier","err","result","timeEnd","modulesToStore","Set","dependencies","Map","exportsSpecsFromDependencies","cacheable","changed","processDependenciesBlock","depBlock","dep","processDependency","blocks","block","exportDesc","getExports","set","processExportsSpec","exports","globalCanMangle","canMangle","globalFrom","from","globalPriority","priority","globalTerminalBinding","terminalBinding","exportDeps","hideExports","name","exportInfo","getExportInfo","unsetTarget","excludeExports","Array","isArray","mergeExports","exportNameOrSpec","fromExport","hidden","export","canMangleProvide","nestedExportsInfo","createNestedExportsInfo","setTarget","target","getTarget","targetExportsInfo","targetModuleExportsInfo","getNestedExportsInfo","add","exportsInfoOwned","setRedirectNamedTo","exportDependency","notifyDependencies","deps","length","dequeue","clear","freeze","unfreeze","exportsSpec","log","Math","round","cachedData","getRestoreProvidedData","store","providedExportsCache","WeakMap","rebuildModule","finishRebuildingModule"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/FlagDependencyExportsPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst Queue = require(\"./util/Queue\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Dependency\").ExportSpec} ExportSpec */\n/** @typedef {import(\"./Dependency\").ExportsSpec} ExportsSpec */\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"./Module\")} Module */\n\nclass FlagDependencyExportsPlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"FlagDependencyExportsPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\t\tconst cache = compilation.getCache(\"FlagDependencyExportsPlugin\");\n\t\t\t\tcompilation.hooks.finishModules.tapAsync(\n\t\t\t\t\t\"FlagDependencyExportsPlugin\",\n\t\t\t\t\t(modules, callback) => {\n\t\t\t\t\t\tconst logger = compilation.getLogger(\n\t\t\t\t\t\t\t\"webpack.FlagDependencyExportsPlugin\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\tlet statRestoredFromMemCache = 0;\n\t\t\t\t\t\tlet statRestoredFromCache = 0;\n\t\t\t\t\t\tlet statNoExports = 0;\n\t\t\t\t\t\tlet statFlaggedUncached = 0;\n\t\t\t\t\t\tlet statNotCached = 0;\n\t\t\t\t\t\tlet statQueueItemsProcessed = 0;\n\n\t\t\t\t\t\tconst { moduleMemCaches } = compilation;\n\n\t\t\t\t\t\t/** @type {Queue<Module>} */\n\t\t\t\t\t\tconst queue = new Queue();\n\n\t\t\t\t\t\t// Step 1: Try to restore cached provided export info from cache\n\t\t\t\t\t\tlogger.time(\"restore cached provided exports\");\n\t\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t(module, callback) => {\n\t\t\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\t\t\tif (!module.buildMeta || !module.buildMeta.exportsType) {\n\t\t\t\t\t\t\t\t\tif (exportsInfo.otherExportsInfo.provided !== null) {\n\t\t\t\t\t\t\t\t\t\t// It's a module without declared exports\n\t\t\t\t\t\t\t\t\t\tstatNoExports++;\n\t\t\t\t\t\t\t\t\t\texportsInfo.setHasProvideInfo();\n\t\t\t\t\t\t\t\t\t\texportsInfo.setUnknownExportsProvided();\n\t\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (typeof module.buildInfo.hash !== \"string\") {\n\t\t\t\t\t\t\t\t\tstatFlaggedUncached++;\n\t\t\t\t\t\t\t\t\t// Enqueue uncacheable module for determining the exports\n\t\t\t\t\t\t\t\t\tqueue.enqueue(module);\n\t\t\t\t\t\t\t\t\texportsInfo.setHasProvideInfo();\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst memCache = moduleMemCaches && moduleMemCaches.get(module);\n\t\t\t\t\t\t\t\tconst memCacheValue = memCache && memCache.get(this);\n\t\t\t\t\t\t\t\tif (memCacheValue !== undefined) {\n\t\t\t\t\t\t\t\t\tstatRestoredFromMemCache++;\n\t\t\t\t\t\t\t\t\texportsInfo.restoreProvided(memCacheValue);\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcache.get(\n\t\t\t\t\t\t\t\t\tmodule.identifier(),\n\t\t\t\t\t\t\t\t\tmodule.buildInfo.hash,\n\t\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\t\t\t\t\t\tstatRestoredFromCache++;\n\t\t\t\t\t\t\t\t\t\t\texportsInfo.restoreProvided(result);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tstatNotCached++;\n\t\t\t\t\t\t\t\t\t\t\t// Without cached info enqueue module for determining the exports\n\t\t\t\t\t\t\t\t\t\t\tqueue.enqueue(module);\n\t\t\t\t\t\t\t\t\t\t\texportsInfo.setHasProvideInfo();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\tlogger.timeEnd(\"restore cached provided exports\");\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\t\t\t\t\tconst modulesToStore = new Set();\n\n\t\t\t\t\t\t\t\t/** @type {Map<Module, Set<Module>>} */\n\t\t\t\t\t\t\t\tconst dependencies = new Map();\n\n\t\t\t\t\t\t\t\t/** @type {Module} */\n\t\t\t\t\t\t\t\tlet module;\n\n\t\t\t\t\t\t\t\t/** @type {ExportsInfo} */\n\t\t\t\t\t\t\t\tlet exportsInfo;\n\n\t\t\t\t\t\t\t\t/** @type {Map<Dependency, ExportsSpec>} */\n\t\t\t\t\t\t\t\tconst exportsSpecsFromDependencies = new Map();\n\n\t\t\t\t\t\t\t\tlet cacheable = true;\n\t\t\t\t\t\t\t\tlet changed = false;\n\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @param {DependenciesBlock} depBlock the dependencies block\n\t\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst processDependenciesBlock = depBlock => {\n\t\t\t\t\t\t\t\t\tfor (const dep of depBlock.dependencies) {\n\t\t\t\t\t\t\t\t\t\tprocessDependency(dep);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor (const block of depBlock.blocks) {\n\t\t\t\t\t\t\t\t\t\tprocessDependenciesBlock(block);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @param {Dependency} dep the dependency\n\t\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst processDependency = dep => {\n\t\t\t\t\t\t\t\t\tconst exportDesc = dep.getExports(moduleGraph);\n\t\t\t\t\t\t\t\t\tif (!exportDesc) return;\n\t\t\t\t\t\t\t\t\texportsSpecsFromDependencies.set(dep, exportDesc);\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @param {Dependency} dep dependency\n\t\t\t\t\t\t\t\t * @param {ExportsSpec} exportDesc info\n\t\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst processExportsSpec = (dep, exportDesc) => {\n\t\t\t\t\t\t\t\t\tconst exports = exportDesc.exports;\n\t\t\t\t\t\t\t\t\tconst globalCanMangle = exportDesc.canMangle;\n\t\t\t\t\t\t\t\t\tconst globalFrom = exportDesc.from;\n\t\t\t\t\t\t\t\t\tconst globalPriority = exportDesc.priority;\n\t\t\t\t\t\t\t\t\tconst globalTerminalBinding =\n\t\t\t\t\t\t\t\t\t\texportDesc.terminalBinding || false;\n\t\t\t\t\t\t\t\t\tconst exportDeps = exportDesc.dependencies;\n\t\t\t\t\t\t\t\t\tif (exportDesc.hideExports) {\n\t\t\t\t\t\t\t\t\t\tfor (const name of exportDesc.hideExports) {\n\t\t\t\t\t\t\t\t\t\t\tconst exportInfo = exportsInfo.getExportInfo(name);\n\t\t\t\t\t\t\t\t\t\t\texportInfo.unsetTarget(dep);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (exports === true) {\n\t\t\t\t\t\t\t\t\t\t// unknown exports\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\texportsInfo.setUnknownExportsProvided(\n\t\t\t\t\t\t\t\t\t\t\t\tglobalCanMangle,\n\t\t\t\t\t\t\t\t\t\t\t\texportDesc.excludeExports,\n\t\t\t\t\t\t\t\t\t\t\t\tglobalFrom && dep,\n\t\t\t\t\t\t\t\t\t\t\t\tglobalFrom,\n\t\t\t\t\t\t\t\t\t\t\t\tglobalPriority\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (Array.isArray(exports)) {\n\t\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t\t * merge in new exports\n\t\t\t\t\t\t\t\t\t\t * @param {ExportsInfo} exportsInfo own exports info\n\t\t\t\t\t\t\t\t\t\t * @param {(ExportSpec | string)[]} exports list of exports\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\t\tconst mergeExports = (exportsInfo, exports) => {\n\t\t\t\t\t\t\t\t\t\t\tfor (const exportNameOrSpec of exports) {\n\t\t\t\t\t\t\t\t\t\t\t\tlet name;\n\t\t\t\t\t\t\t\t\t\t\t\tlet canMangle = globalCanMangle;\n\t\t\t\t\t\t\t\t\t\t\t\tlet terminalBinding = globalTerminalBinding;\n\t\t\t\t\t\t\t\t\t\t\t\tlet exports = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\tlet from = globalFrom;\n\t\t\t\t\t\t\t\t\t\t\t\tlet fromExport = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\tlet priority = globalPriority;\n\t\t\t\t\t\t\t\t\t\t\t\tlet hidden = false;\n\t\t\t\t\t\t\t\t\t\t\t\tif (typeof exportNameOrSpec === \"string\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\tname = exportNameOrSpec;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tname = exportNameOrSpec.name;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.canMangle !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcanMangle = exportNameOrSpec.canMangle;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.export !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfromExport = exportNameOrSpec.export;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.exports !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\texports = exportNameOrSpec.exports;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.from !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfrom = exportNameOrSpec.from;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.priority !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpriority = exportNameOrSpec.priority;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.terminalBinding !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tterminalBinding = exportNameOrSpec.terminalBinding;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.hidden !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thidden = exportNameOrSpec.hidden;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tconst exportInfo = exportsInfo.getExportInfo(name);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.provided === false ||\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.provided === null\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.provided = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.canMangleProvide !== false &&\n\t\t\t\t\t\t\t\t\t\t\t\t\tcanMangle === false\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.canMangleProvide = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (terminalBinding && !exportInfo.terminalBinding) {\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.terminalBinding = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (exports) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst nestedExportsInfo =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.createNestedExportsInfo();\n\t\t\t\t\t\t\t\t\t\t\t\t\tmergeExports(nestedExportsInfo, exports);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\tfrom &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t(hidden\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? exportInfo.unsetTarget(dep)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: exportInfo.setTarget(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfrom,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfromExport === undefined ? [name] : fromExport,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpriority\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  ))\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Recalculate target exportsInfo\n\t\t\t\t\t\t\t\t\t\t\t\tconst target = exportInfo.getTarget(moduleGraph);\n\t\t\t\t\t\t\t\t\t\t\t\tlet targetExportsInfo = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\tif (target) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst targetModuleExportsInfo =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph.getExportsInfo(target.module);\n\t\t\t\t\t\t\t\t\t\t\t\t\ttargetExportsInfo =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetModuleExportsInfo.getNestedExportsInfo(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget.export\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t// add dependency for this module\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst set = dependencies.get(target.module);\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (set === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdependencies.set(target.module, new Set([module]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tset.add(module);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (exportInfo.exportsInfoOwned) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.exportsInfo.setRedirectNamedTo(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetExportsInfo\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.exportsInfo !== targetExportsInfo\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.exportsInfo = targetExportsInfo;\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tmergeExports(exportsInfo, exports);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// store dependencies\n\t\t\t\t\t\t\t\t\tif (exportDeps) {\n\t\t\t\t\t\t\t\t\t\tcacheable = false;\n\t\t\t\t\t\t\t\t\t\tfor (const exportDependency of exportDeps) {\n\t\t\t\t\t\t\t\t\t\t\t// add dependency for this module\n\t\t\t\t\t\t\t\t\t\t\tconst set = dependencies.get(exportDependency);\n\t\t\t\t\t\t\t\t\t\t\tif (set === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\tdependencies.set(exportDependency, new Set([module]));\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tset.add(module);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tconst notifyDependencies = () => {\n\t\t\t\t\t\t\t\t\tconst deps = dependencies.get(module);\n\t\t\t\t\t\t\t\t\tif (deps !== undefined) {\n\t\t\t\t\t\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\t\t\t\t\t\tqueue.enqueue(dep);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tlogger.time(\"figure out provided exports\");\n\t\t\t\t\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\t\t\t\t\tmodule = queue.dequeue();\n\n\t\t\t\t\t\t\t\t\tstatQueueItemsProcessed++;\n\n\t\t\t\t\t\t\t\t\texportsInfo = moduleGraph.getExportsInfo(module);\n\n\t\t\t\t\t\t\t\t\tcacheable = true;\n\t\t\t\t\t\t\t\t\tchanged = false;\n\n\t\t\t\t\t\t\t\t\texportsSpecsFromDependencies.clear();\n\t\t\t\t\t\t\t\t\tmoduleGraph.freeze();\n\t\t\t\t\t\t\t\t\tprocessDependenciesBlock(module);\n\t\t\t\t\t\t\t\t\tmoduleGraph.unfreeze();\n\t\t\t\t\t\t\t\t\tfor (const [\n\t\t\t\t\t\t\t\t\t\tdep,\n\t\t\t\t\t\t\t\t\t\texportsSpec\n\t\t\t\t\t\t\t\t\t] of exportsSpecsFromDependencies) {\n\t\t\t\t\t\t\t\t\t\tprocessExportsSpec(dep, exportsSpec);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (cacheable) {\n\t\t\t\t\t\t\t\t\t\tmodulesToStore.add(module);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t\t\t\t\tnotifyDependencies();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlogger.timeEnd(\"figure out provided exports\");\n\n\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t`${Math.round(\n\t\t\t\t\t\t\t\t\t\t(100 * (statFlaggedUncached + statNotCached)) /\n\t\t\t\t\t\t\t\t\t\t\t(statRestoredFromMemCache +\n\t\t\t\t\t\t\t\t\t\t\t\tstatRestoredFromCache +\n\t\t\t\t\t\t\t\t\t\t\t\tstatNotCached +\n\t\t\t\t\t\t\t\t\t\t\t\tstatFlaggedUncached +\n\t\t\t\t\t\t\t\t\t\t\t\tstatNoExports)\n\t\t\t\t\t\t\t\t\t)}% of exports of modules have been determined (${statNoExports} no declared exports, ${statNotCached} not cached, ${statFlaggedUncached} flagged uncacheable, ${statRestoredFromCache} from cache, ${statRestoredFromMemCache} from mem cache, ${\n\t\t\t\t\t\t\t\t\t\tstatQueueItemsProcessed -\n\t\t\t\t\t\t\t\t\t\tstatNotCached -\n\t\t\t\t\t\t\t\t\t\tstatFlaggedUncached\n\t\t\t\t\t\t\t\t\t} additional calculations due to dependencies)`\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tlogger.time(\"store provided exports into cache\");\n\t\t\t\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\t\t\t\tmodulesToStore,\n\t\t\t\t\t\t\t\t\t(module, callback) => {\n\t\t\t\t\t\t\t\t\t\tif (typeof module.buildInfo.hash !== \"string\") {\n\t\t\t\t\t\t\t\t\t\t\t// not cacheable\n\t\t\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst cachedData = moduleGraph\n\t\t\t\t\t\t\t\t\t\t\t.getExportsInfo(module)\n\t\t\t\t\t\t\t\t\t\t\t.getRestoreProvidedData();\n\t\t\t\t\t\t\t\t\t\tconst memCache =\n\t\t\t\t\t\t\t\t\t\t\tmoduleMemCaches && moduleMemCaches.get(module);\n\t\t\t\t\t\t\t\t\t\tif (memCache) {\n\t\t\t\t\t\t\t\t\t\t\tmemCache.set(this, cachedData);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcache.store(\n\t\t\t\t\t\t\t\t\t\t\tmodule.identifier(),\n\t\t\t\t\t\t\t\t\t\t\tmodule.buildInfo.hash,\n\t\t\t\t\t\t\t\t\t\t\tcachedData,\n\t\t\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\t\tlogger.timeEnd(\"store provided exports into cache\");\n\t\t\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t/** @type {WeakMap<Module, any>} */\n\t\t\t\tconst providedExportsCache = new WeakMap();\n\t\t\t\tcompilation.hooks.rebuildModule.tap(\n\t\t\t\t\t\"FlagDependencyExportsPlugin\",\n\t\t\t\t\tmodule => {\n\t\t\t\t\t\tprovidedExportsCache.set(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tmoduleGraph.getExportsInfo(module).getRestoreProvidedData()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.finishRebuildingModule.tap(\n\t\t\t\t\t\"FlagDependencyExportsPlugin\",\n\t\t\t\t\tmodule => {\n\t\t\t\t\t\tmoduleGraph\n\t\t\t\t\t\t\t.getExportsInfo(module)\n\t\t\t\t\t\t\t.restoreProvided(providedExportsCache.get(module));\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = FlagDependencyExportsPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}