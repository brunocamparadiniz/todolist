{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _require = require(\"tapable\"),\n  SyncHook = _require.SyncHook,\n  AsyncSeriesHook = _require.AsyncSeriesHook;\nvar _require2 = require(\"../HookWebpackError\"),\n  makeWebpackError = _require2.makeWebpackError;\nvar WebpackError = require(\"../WebpackError\");\nvar ArrayQueue = require(\"./ArrayQueue\");\nvar QUEUED_STATE = 0;\nvar PROCESSING_STATE = 1;\nvar DONE_STATE = 2;\nvar inHandleResult = 0;\n\n/**\n * @template T\n * @callback Callback\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n */\n\n/**\n * @template T\n * @template K\n * @template R\n */\nvar AsyncQueueEntry = /*#__PURE__*/_createClass(\n/**\n * @param {T} item the item\n * @param {Callback<R>} callback the callback\n */\nfunction AsyncQueueEntry(item, callback) {\n  _classCallCheck(this, AsyncQueueEntry);\n  this.item = item;\n  /** @type {typeof QUEUED_STATE | typeof PROCESSING_STATE | typeof DONE_STATE} */\n  this.state = QUEUED_STATE;\n  this.callback = callback;\n  /** @type {Callback<R>[] | undefined} */\n  this.callbacks = undefined;\n  this.result = undefined;\n  /** @type {WebpackError | undefined} */\n  this.error = undefined;\n});\n/**\n * @template T\n * @template K\n * @template R\n */\nvar AsyncQueue = /*#__PURE__*/function () {\n  /**\n   * @param {Object} options options object\n   * @param {string=} options.name name of the queue\n   * @param {number=} options.parallelism how many items should be processed at once\n   * @param {AsyncQueue<any, any, any>=} options.parent parent queue, which will have priority over this queue and with shared parallelism\n   * @param {function(T): K=} options.getKey extract key from item\n   * @param {function(T, Callback<R>): void} options.processor async function to process items\n   */\n  function AsyncQueue(_ref) {\n    var name = _ref.name,\n      parallelism = _ref.parallelism,\n      parent = _ref.parent,\n      processor = _ref.processor,\n      getKey = _ref.getKey;\n    _classCallCheck(this, AsyncQueue);\n    this._name = name;\n    this._parallelism = parallelism || 1;\n    this._processor = processor;\n    this._getKey = getKey || /** @type {(T) => K} */function (item) {\n      return (/** @type {any} */item\n      );\n    };\n    /** @type {Map<K, AsyncQueueEntry<T, K, R>>} */\n    this._entries = new Map();\n    /** @type {ArrayQueue<AsyncQueueEntry<T, K, R>>} */\n    this._queued = new ArrayQueue();\n    /** @type {AsyncQueue<any, any, any>[]} */\n    this._children = undefined;\n    this._activeTasks = 0;\n    this._willEnsureProcessing = false;\n    this._needProcessing = false;\n    this._stopped = false;\n    this._root = parent ? parent._root : this;\n    if (parent) {\n      if (this._root._children === undefined) {\n        this._root._children = [this];\n      } else {\n        this._root._children.push(this);\n      }\n    }\n    this.hooks = {\n      /** @type {AsyncSeriesHook<[T]>} */\n      beforeAdd: new AsyncSeriesHook([\"item\"]),\n      /** @type {SyncHook<[T]>} */\n      added: new SyncHook([\"item\"]),\n      /** @type {AsyncSeriesHook<[T]>} */\n      beforeStart: new AsyncSeriesHook([\"item\"]),\n      /** @type {SyncHook<[T]>} */\n      started: new SyncHook([\"item\"]),\n      /** @type {SyncHook<[T, Error, R]>} */\n      result: new SyncHook([\"item\", \"error\", \"result\"])\n    };\n    this._ensureProcessing = this._ensureProcessing.bind(this);\n  }\n\n  /**\n   * @param {T} item an item\n   * @param {Callback<R>} callback callback function\n   * @returns {void}\n   */\n  _createClass(AsyncQueue, [{\n    key: \"add\",\n    value: function add(item, callback) {\n      var _this = this;\n      if (this._stopped) return callback(new WebpackError(\"Queue was stopped\"));\n      this.hooks.beforeAdd.callAsync(item, function (err) {\n        if (err) {\n          callback(makeWebpackError(err, \"AsyncQueue(\".concat(_this._name, \").hooks.beforeAdd\")));\n          return;\n        }\n        var key = _this._getKey(item);\n        var entry = _this._entries.get(key);\n        if (entry !== undefined) {\n          if (entry.state === DONE_STATE) {\n            if (inHandleResult++ > 3) {\n              process.nextTick(function () {\n                return callback(entry.error, entry.result);\n              });\n            } else {\n              callback(entry.error, entry.result);\n            }\n            inHandleResult--;\n          } else if (entry.callbacks === undefined) {\n            entry.callbacks = [callback];\n          } else {\n            entry.callbacks.push(callback);\n          }\n          return;\n        }\n        var newEntry = new AsyncQueueEntry(item, callback);\n        if (_this._stopped) {\n          _this.hooks.added.call(item);\n          _this._root._activeTasks++;\n          process.nextTick(function () {\n            return _this._handleResult(newEntry, new WebpackError(\"Queue was stopped\"));\n          });\n        } else {\n          _this._entries.set(key, newEntry);\n          _this._queued.enqueue(newEntry);\n          var root = _this._root;\n          root._needProcessing = true;\n          if (root._willEnsureProcessing === false) {\n            root._willEnsureProcessing = true;\n            setImmediate(root._ensureProcessing);\n          }\n          _this.hooks.added.call(item);\n        }\n      });\n    }\n\n    /**\n     * @param {T} item an item\n     * @returns {void}\n     */\n  }, {\n    key: \"invalidate\",\n    value: function invalidate(item) {\n      var key = this._getKey(item);\n      var entry = this._entries.get(key);\n      this._entries.delete(key);\n      if (entry.state === QUEUED_STATE) {\n        this._queued.delete(entry);\n      }\n    }\n\n    /**\n     * Waits for an already started item\n     * @param {T} item an item\n     * @param {Callback<R>} callback callback function\n     * @returns {void}\n     */\n  }, {\n    key: \"waitFor\",\n    value: function waitFor(item, callback) {\n      var key = this._getKey(item);\n      var entry = this._entries.get(key);\n      if (entry === undefined) {\n        return callback(new WebpackError(\"waitFor can only be called for an already started item\"));\n      }\n      if (entry.state === DONE_STATE) {\n        process.nextTick(function () {\n          return callback(entry.error, entry.result);\n        });\n      } else if (entry.callbacks === undefined) {\n        entry.callbacks = [callback];\n      } else {\n        entry.callbacks.push(callback);\n      }\n    }\n\n    /**\n     * @returns {void}\n     */\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._stopped = true;\n      var queue = this._queued;\n      this._queued = new ArrayQueue();\n      var root = this._root;\n      var _iterator = _createForOfIteratorHelper(queue),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var entry = _step.value;\n          this._entries.delete(this._getKey(entry.item));\n          root._activeTasks++;\n          this._handleResult(entry, new WebpackError(\"Queue was stopped\"));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    /**\n     * @returns {void}\n     */\n  }, {\n    key: \"increaseParallelism\",\n    value: function increaseParallelism() {\n      var root = this._root;\n      root._parallelism++;\n      /* istanbul ignore next */\n      if (root._willEnsureProcessing === false && root._needProcessing) {\n        root._willEnsureProcessing = true;\n        setImmediate(root._ensureProcessing);\n      }\n    }\n\n    /**\n     * @returns {void}\n     */\n  }, {\n    key: \"decreaseParallelism\",\n    value: function decreaseParallelism() {\n      var root = this._root;\n      root._parallelism--;\n    }\n\n    /**\n     * @param {T} item an item\n     * @returns {boolean} true, if the item is currently being processed\n     */\n  }, {\n    key: \"isProcessing\",\n    value: function isProcessing(item) {\n      var key = this._getKey(item);\n      var entry = this._entries.get(key);\n      return entry !== undefined && entry.state === PROCESSING_STATE;\n    }\n\n    /**\n     * @param {T} item an item\n     * @returns {boolean} true, if the item is currently queued\n     */\n  }, {\n    key: \"isQueued\",\n    value: function isQueued(item) {\n      var key = this._getKey(item);\n      var entry = this._entries.get(key);\n      return entry !== undefined && entry.state === QUEUED_STATE;\n    }\n\n    /**\n     * @param {T} item an item\n     * @returns {boolean} true, if the item is currently queued\n     */\n  }, {\n    key: \"isDone\",\n    value: function isDone(item) {\n      var key = this._getKey(item);\n      var entry = this._entries.get(key);\n      return entry !== undefined && entry.state === DONE_STATE;\n    }\n\n    /**\n     * @returns {void}\n     */\n  }, {\n    key: \"_ensureProcessing\",\n    value: function _ensureProcessing() {\n      while (this._activeTasks < this._parallelism) {\n        var entry = this._queued.dequeue();\n        if (entry === undefined) break;\n        this._activeTasks++;\n        entry.state = PROCESSING_STATE;\n        this._startProcessing(entry);\n      }\n      this._willEnsureProcessing = false;\n      if (this._queued.length > 0) return;\n      if (this._children !== undefined) {\n        var _iterator2 = _createForOfIteratorHelper(this._children),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var child = _step2.value;\n            while (this._activeTasks < this._parallelism) {\n              var _entry = child._queued.dequeue();\n              if (_entry === undefined) break;\n              this._activeTasks++;\n              _entry.state = PROCESSING_STATE;\n              child._startProcessing(_entry);\n            }\n            if (child._queued.length > 0) return;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      if (!this._willEnsureProcessing) this._needProcessing = false;\n    }\n\n    /**\n     * @param {AsyncQueueEntry<T, K, R>} entry the entry\n     * @returns {void}\n     */\n  }, {\n    key: \"_startProcessing\",\n    value: function _startProcessing(entry) {\n      var _this2 = this;\n      this.hooks.beforeStart.callAsync(entry.item, function (err) {\n        if (err) {\n          _this2._handleResult(entry, makeWebpackError(err, \"AsyncQueue(\".concat(_this2._name, \").hooks.beforeStart\")));\n          return;\n        }\n        var inCallback = false;\n        try {\n          _this2._processor(entry.item, function (e, r) {\n            inCallback = true;\n            _this2._handleResult(entry, e, r);\n          });\n        } catch (err) {\n          if (inCallback) throw err;\n          _this2._handleResult(entry, err, null);\n        }\n        _this2.hooks.started.call(entry.item);\n      });\n    }\n\n    /**\n     * @param {AsyncQueueEntry<T, K, R>} entry the entry\n     * @param {WebpackError=} err error, if any\n     * @param {R=} result result, if any\n     * @returns {void}\n     */\n  }, {\n    key: \"_handleResult\",\n    value: function _handleResult(entry, err, result) {\n      var _this3 = this;\n      this.hooks.result.callAsync(entry.item, err, result, function (hookError) {\n        var error = hookError ? makeWebpackError(hookError, \"AsyncQueue(\".concat(_this3._name, \").hooks.result\")) : err;\n        var callback = entry.callback;\n        var callbacks = entry.callbacks;\n        entry.state = DONE_STATE;\n        entry.callback = undefined;\n        entry.callbacks = undefined;\n        entry.result = result;\n        entry.error = error;\n        var root = _this3._root;\n        root._activeTasks--;\n        if (root._willEnsureProcessing === false && root._needProcessing) {\n          root._willEnsureProcessing = true;\n          setImmediate(root._ensureProcessing);\n        }\n        if (inHandleResult++ > 3) {\n          process.nextTick(function () {\n            callback(error, result);\n            if (callbacks !== undefined) {\n              var _iterator3 = _createForOfIteratorHelper(callbacks),\n                _step3;\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  var _callback = _step3.value;\n                  _callback(error, result);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            }\n          });\n        } else {\n          callback(error, result);\n          if (callbacks !== undefined) {\n            var _iterator4 = _createForOfIteratorHelper(callbacks),\n              _step4;\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var _callback2 = _step4.value;\n                _callback2(error, result);\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n          }\n        }\n        inHandleResult--;\n      });\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._entries.clear();\n      this._queued.clear();\n      this._activeTasks = 0;\n      this._willEnsureProcessing = false;\n      this._needProcessing = false;\n      this._stopped = false;\n    }\n  }]);\n  return AsyncQueue;\n}();\nmodule.exports = AsyncQueue;","map":{"version":3,"names":["require","SyncHook","AsyncSeriesHook","makeWebpackError","WebpackError","ArrayQueue","QUEUED_STATE","PROCESSING_STATE","DONE_STATE","inHandleResult","AsyncQueueEntry","item","callback","state","callbacks","undefined","result","error","AsyncQueue","name","parallelism","parent","processor","getKey","_name","_parallelism","_processor","_getKey","_entries","Map","_queued","_children","_activeTasks","_willEnsureProcessing","_needProcessing","_stopped","_root","push","hooks","beforeAdd","added","beforeStart","started","_ensureProcessing","bind","callAsync","err","key","entry","get","process","nextTick","newEntry","call","_handleResult","set","enqueue","root","setImmediate","delete","queue","dequeue","_startProcessing","length","child","inCallback","e","r","hookError","clear","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/util/AsyncQueue.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { SyncHook, AsyncSeriesHook } = require(\"tapable\");\nconst { makeWebpackError } = require(\"../HookWebpackError\");\nconst WebpackError = require(\"../WebpackError\");\nconst ArrayQueue = require(\"./ArrayQueue\");\n\nconst QUEUED_STATE = 0;\nconst PROCESSING_STATE = 1;\nconst DONE_STATE = 2;\n\nlet inHandleResult = 0;\n\n/**\n * @template T\n * @callback Callback\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n */\n\n/**\n * @template T\n * @template K\n * @template R\n */\nclass AsyncQueueEntry {\n\t/**\n\t * @param {T} item the item\n\t * @param {Callback<R>} callback the callback\n\t */\n\tconstructor(item, callback) {\n\t\tthis.item = item;\n\t\t/** @type {typeof QUEUED_STATE | typeof PROCESSING_STATE | typeof DONE_STATE} */\n\t\tthis.state = QUEUED_STATE;\n\t\tthis.callback = callback;\n\t\t/** @type {Callback<R>[] | undefined} */\n\t\tthis.callbacks = undefined;\n\t\tthis.result = undefined;\n\t\t/** @type {WebpackError | undefined} */\n\t\tthis.error = undefined;\n\t}\n}\n\n/**\n * @template T\n * @template K\n * @template R\n */\nclass AsyncQueue {\n\t/**\n\t * @param {Object} options options object\n\t * @param {string=} options.name name of the queue\n\t * @param {number=} options.parallelism how many items should be processed at once\n\t * @param {AsyncQueue<any, any, any>=} options.parent parent queue, which will have priority over this queue and with shared parallelism\n\t * @param {function(T): K=} options.getKey extract key from item\n\t * @param {function(T, Callback<R>): void} options.processor async function to process items\n\t */\n\tconstructor({ name, parallelism, parent, processor, getKey }) {\n\t\tthis._name = name;\n\t\tthis._parallelism = parallelism || 1;\n\t\tthis._processor = processor;\n\t\tthis._getKey =\n\t\t\tgetKey || /** @type {(T) => K} */ (item => /** @type {any} */ (item));\n\t\t/** @type {Map<K, AsyncQueueEntry<T, K, R>>} */\n\t\tthis._entries = new Map();\n\t\t/** @type {ArrayQueue<AsyncQueueEntry<T, K, R>>} */\n\t\tthis._queued = new ArrayQueue();\n\t\t/** @type {AsyncQueue<any, any, any>[]} */\n\t\tthis._children = undefined;\n\t\tthis._activeTasks = 0;\n\t\tthis._willEnsureProcessing = false;\n\t\tthis._needProcessing = false;\n\t\tthis._stopped = false;\n\t\tthis._root = parent ? parent._root : this;\n\t\tif (parent) {\n\t\t\tif (this._root._children === undefined) {\n\t\t\t\tthis._root._children = [this];\n\t\t\t} else {\n\t\t\t\tthis._root._children.push(this);\n\t\t\t}\n\t\t}\n\n\t\tthis.hooks = {\n\t\t\t/** @type {AsyncSeriesHook<[T]>} */\n\t\t\tbeforeAdd: new AsyncSeriesHook([\"item\"]),\n\t\t\t/** @type {SyncHook<[T]>} */\n\t\t\tadded: new SyncHook([\"item\"]),\n\t\t\t/** @type {AsyncSeriesHook<[T]>} */\n\t\t\tbeforeStart: new AsyncSeriesHook([\"item\"]),\n\t\t\t/** @type {SyncHook<[T]>} */\n\t\t\tstarted: new SyncHook([\"item\"]),\n\t\t\t/** @type {SyncHook<[T, Error, R]>} */\n\t\t\tresult: new SyncHook([\"item\", \"error\", \"result\"])\n\t\t};\n\n\t\tthis._ensureProcessing = this._ensureProcessing.bind(this);\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @param {Callback<R>} callback callback function\n\t * @returns {void}\n\t */\n\tadd(item, callback) {\n\t\tif (this._stopped) return callback(new WebpackError(\"Queue was stopped\"));\n\t\tthis.hooks.beforeAdd.callAsync(item, err => {\n\t\t\tif (err) {\n\t\t\t\tcallback(\n\t\t\t\t\tmakeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeAdd`)\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst key = this._getKey(item);\n\t\t\tconst entry = this._entries.get(key);\n\t\t\tif (entry !== undefined) {\n\t\t\t\tif (entry.state === DONE_STATE) {\n\t\t\t\t\tif (inHandleResult++ > 3) {\n\t\t\t\t\t\tprocess.nextTick(() => callback(entry.error, entry.result));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback(entry.error, entry.result);\n\t\t\t\t\t}\n\t\t\t\t\tinHandleResult--;\n\t\t\t\t} else if (entry.callbacks === undefined) {\n\t\t\t\t\tentry.callbacks = [callback];\n\t\t\t\t} else {\n\t\t\t\t\tentry.callbacks.push(callback);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst newEntry = new AsyncQueueEntry(item, callback);\n\t\t\tif (this._stopped) {\n\t\t\t\tthis.hooks.added.call(item);\n\t\t\t\tthis._root._activeTasks++;\n\t\t\t\tprocess.nextTick(() =>\n\t\t\t\t\tthis._handleResult(newEntry, new WebpackError(\"Queue was stopped\"))\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis._entries.set(key, newEntry);\n\t\t\t\tthis._queued.enqueue(newEntry);\n\t\t\t\tconst root = this._root;\n\t\t\t\troot._needProcessing = true;\n\t\t\t\tif (root._willEnsureProcessing === false) {\n\t\t\t\t\troot._willEnsureProcessing = true;\n\t\t\t\t\tsetImmediate(root._ensureProcessing);\n\t\t\t\t}\n\t\t\t\tthis.hooks.added.call(item);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {void}\n\t */\n\tinvalidate(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\tthis._entries.delete(key);\n\t\tif (entry.state === QUEUED_STATE) {\n\t\t\tthis._queued.delete(entry);\n\t\t}\n\t}\n\n\t/**\n\t * Waits for an already started item\n\t * @param {T} item an item\n\t * @param {Callback<R>} callback callback function\n\t * @returns {void}\n\t */\n\twaitFor(item, callback) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\tif (entry === undefined) {\n\t\t\treturn callback(\n\t\t\t\tnew WebpackError(\n\t\t\t\t\t\"waitFor can only be called for an already started item\"\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\tif (entry.state === DONE_STATE) {\n\t\t\tprocess.nextTick(() => callback(entry.error, entry.result));\n\t\t} else if (entry.callbacks === undefined) {\n\t\t\tentry.callbacks = [callback];\n\t\t} else {\n\t\t\tentry.callbacks.push(callback);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tstop() {\n\t\tthis._stopped = true;\n\t\tconst queue = this._queued;\n\t\tthis._queued = new ArrayQueue();\n\t\tconst root = this._root;\n\t\tfor (const entry of queue) {\n\t\t\tthis._entries.delete(this._getKey(entry.item));\n\t\t\troot._activeTasks++;\n\t\t\tthis._handleResult(entry, new WebpackError(\"Queue was stopped\"));\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tincreaseParallelism() {\n\t\tconst root = this._root;\n\t\troot._parallelism++;\n\t\t/* istanbul ignore next */\n\t\tif (root._willEnsureProcessing === false && root._needProcessing) {\n\t\t\troot._willEnsureProcessing = true;\n\t\t\tsetImmediate(root._ensureProcessing);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tdecreaseParallelism() {\n\t\tconst root = this._root;\n\t\troot._parallelism--;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {boolean} true, if the item is currently being processed\n\t */\n\tisProcessing(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\treturn entry !== undefined && entry.state === PROCESSING_STATE;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {boolean} true, if the item is currently queued\n\t */\n\tisQueued(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\treturn entry !== undefined && entry.state === QUEUED_STATE;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {boolean} true, if the item is currently queued\n\t */\n\tisDone(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\treturn entry !== undefined && entry.state === DONE_STATE;\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\t_ensureProcessing() {\n\t\twhile (this._activeTasks < this._parallelism) {\n\t\t\tconst entry = this._queued.dequeue();\n\t\t\tif (entry === undefined) break;\n\t\t\tthis._activeTasks++;\n\t\t\tentry.state = PROCESSING_STATE;\n\t\t\tthis._startProcessing(entry);\n\t\t}\n\t\tthis._willEnsureProcessing = false;\n\t\tif (this._queued.length > 0) return;\n\t\tif (this._children !== undefined) {\n\t\t\tfor (const child of this._children) {\n\t\t\t\twhile (this._activeTasks < this._parallelism) {\n\t\t\t\t\tconst entry = child._queued.dequeue();\n\t\t\t\t\tif (entry === undefined) break;\n\t\t\t\t\tthis._activeTasks++;\n\t\t\t\t\tentry.state = PROCESSING_STATE;\n\t\t\t\t\tchild._startProcessing(entry);\n\t\t\t\t}\n\t\t\t\tif (child._queued.length > 0) return;\n\t\t\t}\n\t\t}\n\t\tif (!this._willEnsureProcessing) this._needProcessing = false;\n\t}\n\n\t/**\n\t * @param {AsyncQueueEntry<T, K, R>} entry the entry\n\t * @returns {void}\n\t */\n\t_startProcessing(entry) {\n\t\tthis.hooks.beforeStart.callAsync(entry.item, err => {\n\t\t\tif (err) {\n\t\t\t\tthis._handleResult(\n\t\t\t\t\tentry,\n\t\t\t\t\tmakeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeStart`)\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet inCallback = false;\n\t\t\ttry {\n\t\t\t\tthis._processor(entry.item, (e, r) => {\n\t\t\t\t\tinCallback = true;\n\t\t\t\t\tthis._handleResult(entry, e, r);\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\tif (inCallback) throw err;\n\t\t\t\tthis._handleResult(entry, err, null);\n\t\t\t}\n\t\t\tthis.hooks.started.call(entry.item);\n\t\t});\n\t}\n\n\t/**\n\t * @param {AsyncQueueEntry<T, K, R>} entry the entry\n\t * @param {WebpackError=} err error, if any\n\t * @param {R=} result result, if any\n\t * @returns {void}\n\t */\n\t_handleResult(entry, err, result) {\n\t\tthis.hooks.result.callAsync(entry.item, err, result, hookError => {\n\t\t\tconst error = hookError\n\t\t\t\t? makeWebpackError(hookError, `AsyncQueue(${this._name}).hooks.result`)\n\t\t\t\t: err;\n\n\t\t\tconst callback = entry.callback;\n\t\t\tconst callbacks = entry.callbacks;\n\t\t\tentry.state = DONE_STATE;\n\t\t\tentry.callback = undefined;\n\t\t\tentry.callbacks = undefined;\n\t\t\tentry.result = result;\n\t\t\tentry.error = error;\n\n\t\t\tconst root = this._root;\n\t\t\troot._activeTasks--;\n\t\t\tif (root._willEnsureProcessing === false && root._needProcessing) {\n\t\t\t\troot._willEnsureProcessing = true;\n\t\t\t\tsetImmediate(root._ensureProcessing);\n\t\t\t}\n\n\t\t\tif (inHandleResult++ > 3) {\n\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\tcallback(error, result);\n\t\t\t\t\tif (callbacks !== undefined) {\n\t\t\t\t\t\tfor (const callback of callbacks) {\n\t\t\t\t\t\t\tcallback(error, result);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcallback(error, result);\n\t\t\t\tif (callbacks !== undefined) {\n\t\t\t\t\tfor (const callback of callbacks) {\n\t\t\t\t\t\tcallback(error, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tinHandleResult--;\n\t\t});\n\t}\n\n\tclear() {\n\t\tthis._entries.clear();\n\t\tthis._queued.clear();\n\t\tthis._activeTasks = 0;\n\t\tthis._willEnsureProcessing = false;\n\t\tthis._needProcessing = false;\n\t\tthis._stopped = false;\n\t}\n}\n\nmodule.exports = AsyncQueue;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}