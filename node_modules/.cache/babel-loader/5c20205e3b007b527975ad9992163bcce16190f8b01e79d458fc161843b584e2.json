{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _require = require(\"webpack-sources\"),\n  RawSource = _require.RawSource;\nvar Generator = require(\"../Generator\");\nvar WebAssemblyUtils = require(\"./WebAssemblyUtils\");\nvar t = require(\"@webassemblyjs/ast\");\nvar _require2 = require(\"@webassemblyjs/ast\"),\n  moduleContextFromModuleAST = _require2.moduleContextFromModuleAST;\nvar _require3 = require(\"@webassemblyjs/wasm-edit\"),\n  editWithAST = _require3.editWithAST,\n  addWithAST = _require3.addWithAST;\nvar _require4 = require(\"@webassemblyjs/wasm-parser\"),\n  decode = _require4.decode;\nvar WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../DependencyTemplates\")} DependencyTemplates */\n/** @typedef {import(\"../Generator\").GenerateContext} GenerateContext */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n/** @typedef {import(\"./WebAssemblyUtils\").UsedWasmDependency} UsedWasmDependency */\n\n/**\n * @typedef {(ArrayBuffer) => ArrayBuffer} ArrayBufferTransform\n */\n\n/**\n * @template T\n * @param {Function[]} fns transforms\n * @returns {Function} composed transform\n */\nvar compose = function compose() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n  return fns.reduce(function (prevFn, nextFn) {\n    return function (value) {\n      return nextFn(prevFn(value));\n    };\n  }, function (value) {\n    return value;\n  });\n};\n\n/**\n * Removes the start instruction\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\nvar removeStartFunc = function removeStartFunc(state) {\n  return function (bin) {\n    return editWithAST(state.ast, bin, {\n      Start: function Start(path) {\n        path.remove();\n      }\n    });\n  };\n};\n\n/**\n * Get imported globals\n *\n * @param {Object} ast Module's AST\n * @returns {Array<t.ModuleImport>} - nodes\n */\nvar getImportedGlobals = function getImportedGlobals(ast) {\n  var importedGlobals = [];\n  t.traverse(ast, {\n    ModuleImport: function ModuleImport(_ref) {\n      var node = _ref.node;\n      if (t.isGlobalType(node.descr)) {\n        importedGlobals.push(node);\n      }\n    }\n  });\n  return importedGlobals;\n};\n\n/**\n * Get the count for imported func\n *\n * @param {Object} ast Module's AST\n * @returns {Number} - count\n */\nvar getCountImportedFunc = function getCountImportedFunc(ast) {\n  var count = 0;\n  t.traverse(ast, {\n    ModuleImport: function ModuleImport(_ref2) {\n      var node = _ref2.node;\n      if (t.isFuncImportDescr(node.descr)) {\n        count++;\n      }\n    }\n  });\n  return count;\n};\n\n/**\n * Get next type index\n *\n * @param {Object} ast Module's AST\n * @returns {t.Index} - index\n */\nvar getNextTypeIndex = function getNextTypeIndex(ast) {\n  var typeSectionMetadata = t.getSectionMetadata(ast, \"type\");\n  if (typeSectionMetadata === undefined) {\n    return t.indexLiteral(0);\n  }\n  return t.indexLiteral(typeSectionMetadata.vectorOfSize.value);\n};\n\n/**\n * Get next func index\n *\n * The Func section metadata provide informations for implemented funcs\n * in order to have the correct index we shift the index by number of external\n * functions.\n *\n * @param {Object} ast Module's AST\n * @param {Number} countImportedFunc number of imported funcs\n * @returns {t.Index} - index\n */\nvar getNextFuncIndex = function getNextFuncIndex(ast, countImportedFunc) {\n  var funcSectionMetadata = t.getSectionMetadata(ast, \"func\");\n  if (funcSectionMetadata === undefined) {\n    return t.indexLiteral(0 + countImportedFunc);\n  }\n  var vectorOfSize = funcSectionMetadata.vectorOfSize.value;\n  return t.indexLiteral(vectorOfSize + countImportedFunc);\n};\n\n/**\n * Creates an init instruction for a global type\n * @param {t.GlobalType} globalType the global type\n * @returns {t.Instruction} init expression\n */\nvar createDefaultInitForGlobal = function createDefaultInitForGlobal(globalType) {\n  if (globalType.valtype[0] === \"i\") {\n    // create NumberLiteral global initializer\n    return t.objectInstruction(\"const\", globalType.valtype, [t.numberLiteralFromRaw(66)]);\n  } else if (globalType.valtype[0] === \"f\") {\n    // create FloatLiteral global initializer\n    return t.objectInstruction(\"const\", globalType.valtype, [t.floatLiteral(66, false, false, \"66\")]);\n  } else {\n    throw new Error(\"unknown type: \" + globalType.valtype);\n  }\n};\n\n/**\n * Rewrite the import globals:\n * - removes the ModuleImport instruction\n * - injects at the same offset a mutable global of the same type\n *\n * Since the imported globals are before the other global declarations, our\n * indices will be preserved.\n *\n * Note that globals will become mutable.\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\nvar rewriteImportedGlobals = function rewriteImportedGlobals(state) {\n  return function (bin) {\n    var additionalInitCode = state.additionalInitCode;\n    var newGlobals = [];\n    bin = editWithAST(state.ast, bin, {\n      ModuleImport: function ModuleImport(path) {\n        if (t.isGlobalType(path.node.descr)) {\n          var globalType = path.node.descr;\n          globalType.mutability = \"var\";\n          var init = [createDefaultInitForGlobal(globalType), t.instruction(\"end\")];\n          newGlobals.push(t.global(globalType, init));\n          path.remove();\n        }\n      },\n      // in order to preserve non-imported global's order we need to re-inject\n      // those as well\n      Global: function Global(path) {\n        var node = path.node;\n        var _node$init = _slicedToArray(node.init, 1),\n          init = _node$init[0];\n        if (init.id === \"get_global\") {\n          node.globalType.mutability = \"var\";\n          var initialGlobalIdx = init.args[0];\n          node.init = [createDefaultInitForGlobal(node.globalType), t.instruction(\"end\")];\n          additionalInitCode.push(\n          /**\n           * get_global in global initializer only works for imported globals.\n           * They have the same indices as the init params, so use the\n           * same index.\n           */\n          t.instruction(\"get_local\", [initialGlobalIdx]), t.instruction(\"set_global\", [t.indexLiteral(newGlobals.length)]));\n        }\n        newGlobals.push(node);\n        path.remove();\n      }\n    });\n\n    // Add global declaration instructions\n    return addWithAST(state.ast, bin, newGlobals);\n  };\n};\n\n/**\n * Rewrite the export names\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Module} state.module Module\n * @param {ModuleGraph} state.moduleGraph module graph\n * @param {Set<string>} state.externalExports Module\n * @param {RuntimeSpec} state.runtime runtime\n * @returns {ArrayBufferTransform} transform\n */\nvar rewriteExportNames = function rewriteExportNames(_ref3) {\n  var ast = _ref3.ast,\n    moduleGraph = _ref3.moduleGraph,\n    module = _ref3.module,\n    externalExports = _ref3.externalExports,\n    runtime = _ref3.runtime;\n  return function (bin) {\n    return editWithAST(ast, bin, {\n      ModuleExport: function ModuleExport(path) {\n        var isExternal = externalExports.has(path.node.name);\n        if (isExternal) {\n          path.remove();\n          return;\n        }\n        var usedName = moduleGraph.getExportsInfo(module).getUsedName(path.node.name, runtime);\n        if (!usedName) {\n          path.remove();\n          return;\n        }\n        path.node.name = usedName;\n      }\n    });\n  };\n};\n\n/**\n * Mangle import names and modules\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Map<string, UsedWasmDependency>} state.usedDependencyMap mappings to mangle names\n * @returns {ArrayBufferTransform} transform\n */\nvar rewriteImports = function rewriteImports(_ref4) {\n  var ast = _ref4.ast,\n    usedDependencyMap = _ref4.usedDependencyMap;\n  return function (bin) {\n    return editWithAST(ast, bin, {\n      ModuleImport: function ModuleImport(path) {\n        var result = usedDependencyMap.get(path.node.module + \":\" + path.node.name);\n        if (result !== undefined) {\n          path.node.module = result.module;\n          path.node.name = result.name;\n        }\n      }\n    });\n  };\n};\n\n/**\n * Add an init function.\n *\n * The init function fills the globals given input arguments.\n *\n * @param {Object} state transformation state\n * @param {Object} state.ast Module's ast\n * @param {t.Identifier} state.initFuncId identifier of the init function\n * @param {t.Index} state.startAtFuncOffset index of the start function\n * @param {t.ModuleImport[]} state.importedGlobals list of imported globals\n * @param {t.Instruction[]} state.additionalInitCode list of addition instructions for the init function\n * @param {t.Index} state.nextFuncIndex index of the next function\n * @param {t.Index} state.nextTypeIndex index of the next type\n * @returns {ArrayBufferTransform} transform\n */\nvar addInitFunction = function addInitFunction(_ref5) {\n  var ast = _ref5.ast,\n    initFuncId = _ref5.initFuncId,\n    startAtFuncOffset = _ref5.startAtFuncOffset,\n    importedGlobals = _ref5.importedGlobals,\n    additionalInitCode = _ref5.additionalInitCode,\n    nextFuncIndex = _ref5.nextFuncIndex,\n    nextTypeIndex = _ref5.nextTypeIndex;\n  return function (bin) {\n    var funcParams = importedGlobals.map(function (importedGlobal) {\n      // used for debugging\n      var id = t.identifier(\"\".concat(importedGlobal.module, \".\").concat(importedGlobal.name));\n      return t.funcParam(importedGlobal.descr.valtype, id);\n    });\n    var funcBody = [];\n    importedGlobals.forEach(function (importedGlobal, index) {\n      var args = [t.indexLiteral(index)];\n      var body = [t.instruction(\"get_local\", args), t.instruction(\"set_global\", args)];\n      funcBody.push.apply(funcBody, body);\n    });\n    if (typeof startAtFuncOffset === \"number\") {\n      funcBody.push(t.callInstruction(t.numberLiteralFromRaw(startAtFuncOffset)));\n    }\n    var _iterator = _createForOfIteratorHelper(additionalInitCode),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var instr = _step.value;\n        funcBody.push(instr);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    funcBody.push(t.instruction(\"end\"));\n    var funcResults = [];\n\n    // Code section\n    var funcSignature = t.signature(funcParams, funcResults);\n    var func = t.func(initFuncId, funcSignature, funcBody);\n\n    // Type section\n    var functype = t.typeInstruction(undefined, funcSignature);\n\n    // Func section\n    var funcindex = t.indexInFuncSection(nextTypeIndex);\n\n    // Export section\n    var moduleExport = t.moduleExport(initFuncId.value, t.moduleExportDescr(\"Func\", nextFuncIndex));\n    return addWithAST(ast, bin, [func, moduleExport, funcindex, functype]);\n  };\n};\n\n/**\n * Extract mangle mappings from module\n * @param {ModuleGraph} moduleGraph module graph\n * @param {Module} module current module\n * @param {boolean} mangle mangle imports\n * @returns {Map<string, UsedWasmDependency>} mappings to mangled names\n */\nvar getUsedDependencyMap = function getUsedDependencyMap(moduleGraph, module, mangle) {\n  /** @type {Map<string, UsedWasmDependency>} */\n  var map = new Map();\n  var _iterator2 = _createForOfIteratorHelper(WebAssemblyUtils.getUsedDependencies(moduleGraph, module, mangle)),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var usedDep = _step2.value;\n      var dep = usedDep.dependency;\n      var request = dep.request;\n      var exportName = dep.name;\n      map.set(request + \":\" + exportName, usedDep);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return map;\n};\nvar TYPES = new Set([\"webassembly\"]);\nvar WebAssemblyGenerator = /*#__PURE__*/function (_Generator) {\n  _inherits(WebAssemblyGenerator, _Generator);\n  var _super = _createSuper(WebAssemblyGenerator);\n  function WebAssemblyGenerator(options) {\n    var _this;\n    _classCallCheck(this, WebAssemblyGenerator);\n    _this = _super.call(this);\n    _this.options = options;\n    return _this;\n  }\n\n  /**\n   * @param {NormalModule} module fresh module\n   * @returns {Set<string>} available types (do not mutate)\n   */\n  _createClass(WebAssemblyGenerator, [{\n    key: \"getTypes\",\n    value: function getTypes(module) {\n      return TYPES;\n    }\n\n    /**\n     * @param {NormalModule} module the module\n     * @param {string=} type source type\n     * @returns {number} estimate size of the module\n     */\n  }, {\n    key: \"getSize\",\n    value: function getSize(module, type) {\n      var originalSource = module.originalSource();\n      if (!originalSource) {\n        return 0;\n      }\n      return originalSource.size();\n    }\n\n    /**\n     * @param {NormalModule} module module for which the code should be generated\n     * @param {GenerateContext} generateContext context for generate\n     * @returns {Source} generated code\n     */\n  }, {\n    key: \"generate\",\n    value: function generate(module, _ref6) {\n      var moduleGraph = _ref6.moduleGraph,\n        runtime = _ref6.runtime;\n      var bin = module.originalSource().source();\n      var initFuncId = t.identifier(\"\");\n\n      // parse it\n      var ast = decode(bin, {\n        ignoreDataSection: true,\n        ignoreCodeSection: true,\n        ignoreCustomNameSection: true\n      });\n      var moduleContext = moduleContextFromModuleAST(ast.body[0]);\n      var importedGlobals = getImportedGlobals(ast);\n      var countImportedFunc = getCountImportedFunc(ast);\n      var startAtFuncOffset = moduleContext.getStart();\n      var nextFuncIndex = getNextFuncIndex(ast, countImportedFunc);\n      var nextTypeIndex = getNextTypeIndex(ast);\n      var usedDependencyMap = getUsedDependencyMap(moduleGraph, module, this.options.mangleImports);\n      var externalExports = new Set(module.dependencies.filter(function (d) {\n        return d instanceof WebAssemblyExportImportedDependency;\n      }).map(function (d) {\n        var wasmDep = /** @type {WebAssemblyExportImportedDependency} */\n        d;\n        return wasmDep.exportName;\n      }));\n\n      /** @type {t.Instruction[]} */\n      var additionalInitCode = [];\n      var transform = compose(rewriteExportNames({\n        ast: ast,\n        moduleGraph: moduleGraph,\n        module: module,\n        externalExports: externalExports,\n        runtime: runtime\n      }), removeStartFunc({\n        ast: ast\n      }), rewriteImportedGlobals({\n        ast: ast,\n        additionalInitCode: additionalInitCode\n      }), rewriteImports({\n        ast: ast,\n        usedDependencyMap: usedDependencyMap\n      }), addInitFunction({\n        ast: ast,\n        initFuncId: initFuncId,\n        importedGlobals: importedGlobals,\n        additionalInitCode: additionalInitCode,\n        startAtFuncOffset: startAtFuncOffset,\n        nextFuncIndex: nextFuncIndex,\n        nextTypeIndex: nextTypeIndex\n      }));\n      var newBin = transform(bin);\n      var newBuf = Buffer.from(newBin);\n      return new RawSource(newBuf);\n    }\n  }]);\n  return WebAssemblyGenerator;\n}(Generator);\nmodule.exports = WebAssemblyGenerator;","map":{"version":3,"names":["require","RawSource","Generator","WebAssemblyUtils","t","moduleContextFromModuleAST","editWithAST","addWithAST","decode","WebAssemblyExportImportedDependency","compose","fns","reduce","prevFn","nextFn","value","removeStartFunc","state","bin","ast","Start","path","remove","getImportedGlobals","importedGlobals","traverse","ModuleImport","node","isGlobalType","descr","push","getCountImportedFunc","count","isFuncImportDescr","getNextTypeIndex","typeSectionMetadata","getSectionMetadata","undefined","indexLiteral","vectorOfSize","getNextFuncIndex","countImportedFunc","funcSectionMetadata","createDefaultInitForGlobal","globalType","valtype","objectInstruction","numberLiteralFromRaw","floatLiteral","Error","rewriteImportedGlobals","additionalInitCode","newGlobals","mutability","init","instruction","global","Global","id","initialGlobalIdx","args","length","rewriteExportNames","moduleGraph","module","externalExports","runtime","ModuleExport","isExternal","has","name","usedName","getExportsInfo","getUsedName","rewriteImports","usedDependencyMap","result","get","addInitFunction","initFuncId","startAtFuncOffset","nextFuncIndex","nextTypeIndex","funcParams","map","importedGlobal","identifier","funcParam","funcBody","forEach","index","body","callInstruction","instr","funcResults","funcSignature","signature","func","functype","typeInstruction","funcindex","indexInFuncSection","moduleExport","moduleExportDescr","getUsedDependencyMap","mangle","Map","getUsedDependencies","usedDep","dep","dependency","request","exportName","set","TYPES","Set","WebAssemblyGenerator","options","type","originalSource","size","source","ignoreDataSection","ignoreCodeSection","ignoreCustomNameSection","moduleContext","getStart","mangleImports","dependencies","filter","d","wasmDep","transform","newBin","newBuf","Buffer","from","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/wasm-sync/WebAssemblyGenerator.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { RawSource } = require(\"webpack-sources\");\nconst Generator = require(\"../Generator\");\nconst WebAssemblyUtils = require(\"./WebAssemblyUtils\");\n\nconst t = require(\"@webassemblyjs/ast\");\nconst { moduleContextFromModuleAST } = require(\"@webassemblyjs/ast\");\nconst { editWithAST, addWithAST } = require(\"@webassemblyjs/wasm-edit\");\nconst { decode } = require(\"@webassemblyjs/wasm-parser\");\n\nconst WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../DependencyTemplates\")} DependencyTemplates */\n/** @typedef {import(\"../Generator\").GenerateContext} GenerateContext */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n/** @typedef {import(\"./WebAssemblyUtils\").UsedWasmDependency} UsedWasmDependency */\n\n/**\n * @typedef {(ArrayBuffer) => ArrayBuffer} ArrayBufferTransform\n */\n\n/**\n * @template T\n * @param {Function[]} fns transforms\n * @returns {Function} composed transform\n */\nconst compose = (...fns) => {\n\treturn fns.reduce(\n\t\t(prevFn, nextFn) => {\n\t\t\treturn value => nextFn(prevFn(value));\n\t\t},\n\t\tvalue => value\n\t);\n};\n\n/**\n * Removes the start instruction\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\nconst removeStartFunc = state => bin => {\n\treturn editWithAST(state.ast, bin, {\n\t\tStart(path) {\n\t\t\tpath.remove();\n\t\t}\n\t});\n};\n\n/**\n * Get imported globals\n *\n * @param {Object} ast Module's AST\n * @returns {Array<t.ModuleImport>} - nodes\n */\nconst getImportedGlobals = ast => {\n\tconst importedGlobals = [];\n\n\tt.traverse(ast, {\n\t\tModuleImport({ node }) {\n\t\t\tif (t.isGlobalType(node.descr)) {\n\t\t\t\timportedGlobals.push(node);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn importedGlobals;\n};\n\n/**\n * Get the count for imported func\n *\n * @param {Object} ast Module's AST\n * @returns {Number} - count\n */\nconst getCountImportedFunc = ast => {\n\tlet count = 0;\n\n\tt.traverse(ast, {\n\t\tModuleImport({ node }) {\n\t\t\tif (t.isFuncImportDescr(node.descr)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn count;\n};\n\n/**\n * Get next type index\n *\n * @param {Object} ast Module's AST\n * @returns {t.Index} - index\n */\nconst getNextTypeIndex = ast => {\n\tconst typeSectionMetadata = t.getSectionMetadata(ast, \"type\");\n\n\tif (typeSectionMetadata === undefined) {\n\t\treturn t.indexLiteral(0);\n\t}\n\n\treturn t.indexLiteral(typeSectionMetadata.vectorOfSize.value);\n};\n\n/**\n * Get next func index\n *\n * The Func section metadata provide informations for implemented funcs\n * in order to have the correct index we shift the index by number of external\n * functions.\n *\n * @param {Object} ast Module's AST\n * @param {Number} countImportedFunc number of imported funcs\n * @returns {t.Index} - index\n */\nconst getNextFuncIndex = (ast, countImportedFunc) => {\n\tconst funcSectionMetadata = t.getSectionMetadata(ast, \"func\");\n\n\tif (funcSectionMetadata === undefined) {\n\t\treturn t.indexLiteral(0 + countImportedFunc);\n\t}\n\n\tconst vectorOfSize = funcSectionMetadata.vectorOfSize.value;\n\n\treturn t.indexLiteral(vectorOfSize + countImportedFunc);\n};\n\n/**\n * Creates an init instruction for a global type\n * @param {t.GlobalType} globalType the global type\n * @returns {t.Instruction} init expression\n */\nconst createDefaultInitForGlobal = globalType => {\n\tif (globalType.valtype[0] === \"i\") {\n\t\t// create NumberLiteral global initializer\n\t\treturn t.objectInstruction(\"const\", globalType.valtype, [\n\t\t\tt.numberLiteralFromRaw(66)\n\t\t]);\n\t} else if (globalType.valtype[0] === \"f\") {\n\t\t// create FloatLiteral global initializer\n\t\treturn t.objectInstruction(\"const\", globalType.valtype, [\n\t\t\tt.floatLiteral(66, false, false, \"66\")\n\t\t]);\n\t} else {\n\t\tthrow new Error(\"unknown type: \" + globalType.valtype);\n\t}\n};\n\n/**\n * Rewrite the import globals:\n * - removes the ModuleImport instruction\n * - injects at the same offset a mutable global of the same type\n *\n * Since the imported globals are before the other global declarations, our\n * indices will be preserved.\n *\n * Note that globals will become mutable.\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\nconst rewriteImportedGlobals = state => bin => {\n\tconst additionalInitCode = state.additionalInitCode;\n\tconst newGlobals = [];\n\n\tbin = editWithAST(state.ast, bin, {\n\t\tModuleImport(path) {\n\t\t\tif (t.isGlobalType(path.node.descr)) {\n\t\t\t\tconst globalType = path.node.descr;\n\n\t\t\t\tglobalType.mutability = \"var\";\n\n\t\t\t\tconst init = [\n\t\t\t\t\tcreateDefaultInitForGlobal(globalType),\n\t\t\t\t\tt.instruction(\"end\")\n\t\t\t\t];\n\n\t\t\t\tnewGlobals.push(t.global(globalType, init));\n\n\t\t\t\tpath.remove();\n\t\t\t}\n\t\t},\n\n\t\t// in order to preserve non-imported global's order we need to re-inject\n\t\t// those as well\n\t\tGlobal(path) {\n\t\t\tconst { node } = path;\n\t\t\tconst [init] = node.init;\n\n\t\t\tif (init.id === \"get_global\") {\n\t\t\t\tnode.globalType.mutability = \"var\";\n\n\t\t\t\tconst initialGlobalIdx = init.args[0];\n\n\t\t\t\tnode.init = [\n\t\t\t\t\tcreateDefaultInitForGlobal(node.globalType),\n\t\t\t\t\tt.instruction(\"end\")\n\t\t\t\t];\n\n\t\t\t\tadditionalInitCode.push(\n\t\t\t\t\t/**\n\t\t\t\t\t * get_global in global initializer only works for imported globals.\n\t\t\t\t\t * They have the same indices as the init params, so use the\n\t\t\t\t\t * same index.\n\t\t\t\t\t */\n\t\t\t\t\tt.instruction(\"get_local\", [initialGlobalIdx]),\n\t\t\t\t\tt.instruction(\"set_global\", [t.indexLiteral(newGlobals.length)])\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tnewGlobals.push(node);\n\n\t\t\tpath.remove();\n\t\t}\n\t});\n\n\t// Add global declaration instructions\n\treturn addWithAST(state.ast, bin, newGlobals);\n};\n\n/**\n * Rewrite the export names\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Module} state.module Module\n * @param {ModuleGraph} state.moduleGraph module graph\n * @param {Set<string>} state.externalExports Module\n * @param {RuntimeSpec} state.runtime runtime\n * @returns {ArrayBufferTransform} transform\n */\nconst rewriteExportNames =\n\t({ ast, moduleGraph, module, externalExports, runtime }) =>\n\tbin => {\n\t\treturn editWithAST(ast, bin, {\n\t\t\tModuleExport(path) {\n\t\t\t\tconst isExternal = externalExports.has(path.node.name);\n\t\t\t\tif (isExternal) {\n\t\t\t\t\tpath.remove();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst usedName = moduleGraph\n\t\t\t\t\t.getExportsInfo(module)\n\t\t\t\t\t.getUsedName(path.node.name, runtime);\n\t\t\t\tif (!usedName) {\n\t\t\t\t\tpath.remove();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpath.node.name = usedName;\n\t\t\t}\n\t\t});\n\t};\n\n/**\n * Mangle import names and modules\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Map<string, UsedWasmDependency>} state.usedDependencyMap mappings to mangle names\n * @returns {ArrayBufferTransform} transform\n */\nconst rewriteImports =\n\t({ ast, usedDependencyMap }) =>\n\tbin => {\n\t\treturn editWithAST(ast, bin, {\n\t\t\tModuleImport(path) {\n\t\t\t\tconst result = usedDependencyMap.get(\n\t\t\t\t\tpath.node.module + \":\" + path.node.name\n\t\t\t\t);\n\n\t\t\t\tif (result !== undefined) {\n\t\t\t\t\tpath.node.module = result.module;\n\t\t\t\t\tpath.node.name = result.name;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n/**\n * Add an init function.\n *\n * The init function fills the globals given input arguments.\n *\n * @param {Object} state transformation state\n * @param {Object} state.ast Module's ast\n * @param {t.Identifier} state.initFuncId identifier of the init function\n * @param {t.Index} state.startAtFuncOffset index of the start function\n * @param {t.ModuleImport[]} state.importedGlobals list of imported globals\n * @param {t.Instruction[]} state.additionalInitCode list of addition instructions for the init function\n * @param {t.Index} state.nextFuncIndex index of the next function\n * @param {t.Index} state.nextTypeIndex index of the next type\n * @returns {ArrayBufferTransform} transform\n */\nconst addInitFunction =\n\t({\n\t\tast,\n\t\tinitFuncId,\n\t\tstartAtFuncOffset,\n\t\timportedGlobals,\n\t\tadditionalInitCode,\n\t\tnextFuncIndex,\n\t\tnextTypeIndex\n\t}) =>\n\tbin => {\n\t\tconst funcParams = importedGlobals.map(importedGlobal => {\n\t\t\t// used for debugging\n\t\t\tconst id = t.identifier(\n\t\t\t\t`${importedGlobal.module}.${importedGlobal.name}`\n\t\t\t);\n\n\t\t\treturn t.funcParam(importedGlobal.descr.valtype, id);\n\t\t});\n\n\t\tconst funcBody = [];\n\t\timportedGlobals.forEach((importedGlobal, index) => {\n\t\t\tconst args = [t.indexLiteral(index)];\n\t\t\tconst body = [\n\t\t\t\tt.instruction(\"get_local\", args),\n\t\t\t\tt.instruction(\"set_global\", args)\n\t\t\t];\n\n\t\t\tfuncBody.push(...body);\n\t\t});\n\n\t\tif (typeof startAtFuncOffset === \"number\") {\n\t\t\tfuncBody.push(\n\t\t\t\tt.callInstruction(t.numberLiteralFromRaw(startAtFuncOffset))\n\t\t\t);\n\t\t}\n\n\t\tfor (const instr of additionalInitCode) {\n\t\t\tfuncBody.push(instr);\n\t\t}\n\n\t\tfuncBody.push(t.instruction(\"end\"));\n\n\t\tconst funcResults = [];\n\n\t\t// Code section\n\t\tconst funcSignature = t.signature(funcParams, funcResults);\n\t\tconst func = t.func(initFuncId, funcSignature, funcBody);\n\n\t\t// Type section\n\t\tconst functype = t.typeInstruction(undefined, funcSignature);\n\n\t\t// Func section\n\t\tconst funcindex = t.indexInFuncSection(nextTypeIndex);\n\n\t\t// Export section\n\t\tconst moduleExport = t.moduleExport(\n\t\t\tinitFuncId.value,\n\t\t\tt.moduleExportDescr(\"Func\", nextFuncIndex)\n\t\t);\n\n\t\treturn addWithAST(ast, bin, [func, moduleExport, funcindex, functype]);\n\t};\n\n/**\n * Extract mangle mappings from module\n * @param {ModuleGraph} moduleGraph module graph\n * @param {Module} module current module\n * @param {boolean} mangle mangle imports\n * @returns {Map<string, UsedWasmDependency>} mappings to mangled names\n */\nconst getUsedDependencyMap = (moduleGraph, module, mangle) => {\n\t/** @type {Map<string, UsedWasmDependency>} */\n\tconst map = new Map();\n\tfor (const usedDep of WebAssemblyUtils.getUsedDependencies(\n\t\tmoduleGraph,\n\t\tmodule,\n\t\tmangle\n\t)) {\n\t\tconst dep = usedDep.dependency;\n\t\tconst request = dep.request;\n\t\tconst exportName = dep.name;\n\t\tmap.set(request + \":\" + exportName, usedDep);\n\t}\n\treturn map;\n};\n\nconst TYPES = new Set([\"webassembly\"]);\n\nclass WebAssemblyGenerator extends Generator {\n\tconstructor(options) {\n\t\tsuper();\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * @param {NormalModule} module fresh module\n\t * @returns {Set<string>} available types (do not mutate)\n\t */\n\tgetTypes(module) {\n\t\treturn TYPES;\n\t}\n\n\t/**\n\t * @param {NormalModule} module the module\n\t * @param {string=} type source type\n\t * @returns {number} estimate size of the module\n\t */\n\tgetSize(module, type) {\n\t\tconst originalSource = module.originalSource();\n\t\tif (!originalSource) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn originalSource.size();\n\t}\n\n\t/**\n\t * @param {NormalModule} module module for which the code should be generated\n\t * @param {GenerateContext} generateContext context for generate\n\t * @returns {Source} generated code\n\t */\n\tgenerate(module, { moduleGraph, runtime }) {\n\t\tconst bin = module.originalSource().source();\n\n\t\tconst initFuncId = t.identifier(\"\");\n\n\t\t// parse it\n\t\tconst ast = decode(bin, {\n\t\t\tignoreDataSection: true,\n\t\t\tignoreCodeSection: true,\n\t\t\tignoreCustomNameSection: true\n\t\t});\n\n\t\tconst moduleContext = moduleContextFromModuleAST(ast.body[0]);\n\n\t\tconst importedGlobals = getImportedGlobals(ast);\n\t\tconst countImportedFunc = getCountImportedFunc(ast);\n\t\tconst startAtFuncOffset = moduleContext.getStart();\n\t\tconst nextFuncIndex = getNextFuncIndex(ast, countImportedFunc);\n\t\tconst nextTypeIndex = getNextTypeIndex(ast);\n\n\t\tconst usedDependencyMap = getUsedDependencyMap(\n\t\t\tmoduleGraph,\n\t\t\tmodule,\n\t\t\tthis.options.mangleImports\n\t\t);\n\t\tconst externalExports = new Set(\n\t\t\tmodule.dependencies\n\t\t\t\t.filter(d => d instanceof WebAssemblyExportImportedDependency)\n\t\t\t\t.map(d => {\n\t\t\t\t\tconst wasmDep = /** @type {WebAssemblyExportImportedDependency} */ (\n\t\t\t\t\t\td\n\t\t\t\t\t);\n\t\t\t\t\treturn wasmDep.exportName;\n\t\t\t\t})\n\t\t);\n\n\t\t/** @type {t.Instruction[]} */\n\t\tconst additionalInitCode = [];\n\n\t\tconst transform = compose(\n\t\t\trewriteExportNames({\n\t\t\t\tast,\n\t\t\t\tmoduleGraph,\n\t\t\t\tmodule,\n\t\t\t\texternalExports,\n\t\t\t\truntime\n\t\t\t}),\n\n\t\t\tremoveStartFunc({ ast }),\n\n\t\t\trewriteImportedGlobals({ ast, additionalInitCode }),\n\n\t\t\trewriteImports({\n\t\t\t\tast,\n\t\t\t\tusedDependencyMap\n\t\t\t}),\n\n\t\t\taddInitFunction({\n\t\t\t\tast,\n\t\t\t\tinitFuncId,\n\t\t\t\timportedGlobals,\n\t\t\t\tadditionalInitCode,\n\t\t\t\tstartAtFuncOffset,\n\t\t\t\tnextFuncIndex,\n\t\t\t\tnextTypeIndex\n\t\t\t})\n\t\t);\n\n\t\tconst newBin = transform(bin);\n\n\t\tconst newBuf = Buffer.from(newBin);\n\n\t\treturn new RawSource(newBuf);\n\t}\n}\n\nmodule.exports = WebAssemblyGenerator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}