{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _asyncToGenerator = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _require = require(\"tapable\"),\n  SyncBailHook = _require.SyncBailHook;\nvar _require2 = require(\"webpack-sources\"),\n  RawSource = _require2.RawSource,\n  CachedSource = _require2.CachedSource,\n  CompatSource = _require2.CompatSource;\nvar Compilation = require(\"../Compilation\");\nvar WebpackError = require(\"../WebpackError\");\nvar _require3 = require(\"../util/comparators\"),\n  compareSelect = _require3.compareSelect,\n  compareStrings = _require3.compareStrings;\nvar createHash = require(\"../util/createHash\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nvar EMPTY_SET = new Set();\nvar addToList = function addToList(itemOrItems, list) {\n  if (Array.isArray(itemOrItems)) {\n    var _iterator = _createForOfIteratorHelper(itemOrItems),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n        list.add(item);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else if (itemOrItems) {\n    list.add(itemOrItems);\n  }\n};\n\n/**\n * @template T\n * @param {T[]} input list\n * @param {function(T): Buffer} fn map function\n * @returns {Buffer[]} buffers without duplicates\n */\nvar mapAndDeduplicateBuffers = function mapAndDeduplicateBuffers(input, fn) {\n  // Buffer.equals compares size first so this should be efficient enough\n  // If it becomes a performance problem we can use a map and group by size\n  // instead of looping over all assets.\n  var result = [];\n  var _iterator2 = _createForOfIteratorHelper(input),\n    _step2;\n  try {\n    outer: for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var value = _step2.value;\n      var buf = fn(value);\n      var _iterator3 = _createForOfIteratorHelper(result),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var other = _step3.value;\n          if (buf.equals(other)) continue outer;\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      result.push(buf);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return result;\n};\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nvar quoteMeta = function quoteMeta(str) {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\nvar cachedSourceMap = new WeakMap();\nvar toCachedSource = function toCachedSource(source) {\n  if (source instanceof CachedSource) {\n    return source;\n  }\n  var entry = cachedSourceMap.get(source);\n  if (entry !== undefined) return entry;\n  var newSource = new CachedSource(CompatSource.from(source));\n  cachedSourceMap.set(source, newSource);\n  return newSource;\n};\n\n/**\n * @typedef {Object} AssetInfoForRealContentHash\n * @property {string} name\n * @property {AssetInfo} info\n * @property {Source} source\n * @property {RawSource | undefined} newSource\n * @property {RawSource | undefined} newSourceWithoutOwn\n * @property {string} content\n * @property {Set<string>} ownHashes\n * @property {Promise} contentComputePromise\n * @property {Promise} contentComputeWithoutOwnPromise\n * @property {Set<string>} referencedHashes\n * @property {Set<string>} hashes\n */\n\n/**\n * @typedef {Object} CompilationHooks\n * @property {SyncBailHook<[Buffer[], string], string>} updateHash\n */\n\n/** @type {WeakMap<Compilation, CompilationHooks>} */\nvar compilationHooksMap = new WeakMap();\nvar RealContentHashPlugin = /*#__PURE__*/function () {\n  function RealContentHashPlugin(_ref) {\n    var hashFunction = _ref.hashFunction,\n      hashDigest = _ref.hashDigest;\n    _classCallCheck(this, RealContentHashPlugin);\n    this._hashFunction = hashFunction;\n    this._hashDigest = hashDigest;\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  _createClass(RealContentHashPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this = this;\n      compiler.hooks.compilation.tap(\"RealContentHashPlugin\", function (compilation) {\n        var cacheAnalyse = compilation.getCache(\"RealContentHashPlugin|analyse\");\n        var cacheGenerate = compilation.getCache(\"RealContentHashPlugin|generate\");\n        var hooks = RealContentHashPlugin.getCompilationHooks(compilation);\n        compilation.hooks.processAssets.tapPromise({\n          name: \"RealContentHashPlugin\",\n          stage: Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH\n        }, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n          var assets, assetsWithInfo, hashToAssets, _iterator4, _step4, _step4$value, source, info, name, cachedSource, content, hashes, data, _iterator11, _step11, hash, list, hashRegExp, getDependencies, hashInfo, hashesInOrder, _iterator9, _step9, _loop, _ret, hashToNewHash, getEtag, computeNewContent, computeNewContentWithoutOwn, comparator, _iterator10, _step10, _loop2;\n          return _regeneratorRuntime().wrap(function _callee5$(_context7) {\n            while (1) switch (_context7.prev = _context7.next) {\n              case 0:\n                assets = compilation.getAssets();\n                /** @type {AssetInfoForRealContentHash[]} */\n                assetsWithInfo = [];\n                hashToAssets = new Map();\n                _iterator4 = _createForOfIteratorHelper(assets);\n                try {\n                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                    _step4$value = _step4.value, source = _step4$value.source, info = _step4$value.info, name = _step4$value.name;\n                    cachedSource = toCachedSource(source);\n                    content = cachedSource.source();\n                    /** @type {Set<string>} */\n                    hashes = new Set();\n                    addToList(info.contenthash, hashes);\n                    data = {\n                      name: name,\n                      info: info,\n                      source: cachedSource,\n                      /** @type {RawSource | undefined} */\n                      newSource: undefined,\n                      /** @type {RawSource | undefined} */\n                      newSourceWithoutOwn: undefined,\n                      content: content,\n                      /** @type {Set<string>} */\n                      ownHashes: undefined,\n                      contentComputePromise: undefined,\n                      contentComputeWithoutOwnPromise: undefined,\n                      /** @type {Set<string>} */\n                      referencedHashes: undefined,\n                      hashes: hashes\n                    };\n                    assetsWithInfo.push(data);\n                    _iterator11 = _createForOfIteratorHelper(hashes);\n                    try {\n                      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                        hash = _step11.value;\n                        list = hashToAssets.get(hash);\n                        if (list === undefined) {\n                          hashToAssets.set(hash, [data]);\n                        } else {\n                          list.push(data);\n                        }\n                      }\n                    } catch (err) {\n                      _iterator11.e(err);\n                    } finally {\n                      _iterator11.f();\n                    }\n                  }\n                } catch (err) {\n                  _iterator4.e(err);\n                } finally {\n                  _iterator4.f();\n                }\n                if (!(hashToAssets.size === 0)) {\n                  _context7.next = 7;\n                  break;\n                }\n                return _context7.abrupt(\"return\");\n              case 7:\n                hashRegExp = new RegExp(Array.from(hashToAssets.keys(), quoteMeta).join(\"|\"), \"g\");\n                _context7.next = 10;\n                return Promise.all(assetsWithInfo.map( /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(asset) {\n                    var name, source, content, hashes, etag, _yield$cacheAnalyse$p, _yield$cacheAnalyse$p2;\n                    return _regeneratorRuntime().wrap(function _callee$(_context) {\n                      while (1) switch (_context.prev = _context.next) {\n                        case 0:\n                          name = asset.name, source = asset.source, content = asset.content, hashes = asset.hashes;\n                          if (!Buffer.isBuffer(content)) {\n                            _context.next = 5;\n                            break;\n                          }\n                          asset.referencedHashes = EMPTY_SET;\n                          asset.ownHashes = EMPTY_SET;\n                          return _context.abrupt(\"return\");\n                        case 5:\n                          etag = cacheAnalyse.mergeEtags(cacheAnalyse.getLazyHashedEtag(source), Array.from(hashes).join(\"|\"));\n                          _context.next = 8;\n                          return cacheAnalyse.providePromise(name, etag, function () {\n                            var referencedHashes = new Set();\n                            var ownHashes = new Set();\n                            var inContent = content.match(hashRegExp);\n                            if (inContent) {\n                              var _iterator5 = _createForOfIteratorHelper(inContent),\n                                _step5;\n                              try {\n                                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                                  var hash = _step5.value;\n                                  if (hashes.has(hash)) {\n                                    ownHashes.add(hash);\n                                    continue;\n                                  }\n                                  referencedHashes.add(hash);\n                                }\n                              } catch (err) {\n                                _iterator5.e(err);\n                              } finally {\n                                _iterator5.f();\n                              }\n                            }\n                            return [referencedHashes, ownHashes];\n                          });\n                        case 8:\n                          _yield$cacheAnalyse$p = _context.sent;\n                          _yield$cacheAnalyse$p2 = _slicedToArray(_yield$cacheAnalyse$p, 2);\n                          asset.referencedHashes = _yield$cacheAnalyse$p2[0];\n                          asset.ownHashes = _yield$cacheAnalyse$p2[1];\n                        case 12:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }, _callee);\n                  }));\n                  return function (_x) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }()));\n              case 10:\n                getDependencies = function getDependencies(hash) {\n                  var assets = hashToAssets.get(hash);\n                  if (!assets) {\n                    var referencingAssets = assetsWithInfo.filter(function (asset) {\n                      return asset.referencedHashes.has(hash);\n                    });\n                    var err = new WebpackError(\"RealContentHashPlugin\\nSome kind of unexpected caching problem occurred.\\nAn asset was cached with a reference to another asset (\".concat(hash, \") that's not in the compilation anymore.\\nEither the asset was incorrectly cached, or the referenced asset should also be restored from cache.\\nReferenced by:\\n\").concat(referencingAssets.map(function (a) {\n                      var match = new RegExp(\".{0,20}\".concat(quoteMeta(hash), \".{0,20}\")).exec(a.content);\n                      return \" - \".concat(a.name, \": ...\").concat(match ? match[0] : \"???\", \"...\");\n                    }).join(\"\\n\")));\n                    compilation.errors.push(err);\n                    return undefined;\n                  }\n                  var hashes = new Set();\n                  var _iterator6 = _createForOfIteratorHelper(assets),\n                    _step6;\n                  try {\n                    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                      var _step6$value = _step6.value,\n                        referencedHashes = _step6$value.referencedHashes,\n                        ownHashes = _step6$value.ownHashes;\n                      if (!ownHashes.has(hash)) {\n                        var _iterator7 = _createForOfIteratorHelper(ownHashes),\n                          _step7;\n                        try {\n                          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                            var _hash = _step7.value;\n                            hashes.add(_hash);\n                          }\n                        } catch (err) {\n                          _iterator7.e(err);\n                        } finally {\n                          _iterator7.f();\n                        }\n                      }\n                      var _iterator8 = _createForOfIteratorHelper(referencedHashes),\n                        _step8;\n                      try {\n                        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                          var _hash2 = _step8.value;\n                          hashes.add(_hash2);\n                        }\n                      } catch (err) {\n                        _iterator8.e(err);\n                      } finally {\n                        _iterator8.f();\n                      }\n                    }\n                  } catch (err) {\n                    _iterator6.e(err);\n                  } finally {\n                    _iterator6.f();\n                  }\n                  return hashes;\n                };\n                hashInfo = function hashInfo(hash) {\n                  var assets = hashToAssets.get(hash);\n                  return \"\".concat(hash, \" (\").concat(Array.from(assets, function (a) {\n                    return a.name;\n                  }), \")\");\n                };\n                hashesInOrder = new Set();\n                _iterator9 = _createForOfIteratorHelper(hashToAssets.keys());\n                _context7.prev = 14;\n                _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n                  var hash, add;\n                  return _regeneratorRuntime().wrap(function _loop$(_context5) {\n                    while (1) switch (_context5.prev = _context5.next) {\n                      case 0:\n                        hash = _step9.value;\n                        add = function add(hash, stack) {\n                          var deps = getDependencies(hash);\n                          if (!deps) return;\n                          stack.add(hash);\n                          var _iterator12 = _createForOfIteratorHelper(deps),\n                            _step12;\n                          try {\n                            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                              var dep = _step12.value;\n                              if (hashesInOrder.has(dep)) continue;\n                              if (stack.has(dep)) {\n                                throw new Error(\"Circular hash dependency \".concat(Array.from(stack, hashInfo).join(\" -> \"), \" -> \").concat(hashInfo(dep)));\n                              }\n                              add(dep, stack);\n                            }\n                          } catch (err) {\n                            _iterator12.e(err);\n                          } finally {\n                            _iterator12.f();\n                          }\n                          hashesInOrder.add(hash);\n                          stack.delete(hash);\n                        };\n                        if (!hashesInOrder.has(hash)) {\n                          _context5.next = 4;\n                          break;\n                        }\n                        return _context5.abrupt(\"return\", \"continue\");\n                      case 4:\n                        add(hash, new Set());\n                      case 5:\n                      case \"end\":\n                        return _context5.stop();\n                    }\n                  }, _loop);\n                });\n                _iterator9.s();\n              case 17:\n                if ((_step9 = _iterator9.n()).done) {\n                  _context7.next = 24;\n                  break;\n                }\n                return _context7.delegateYield(_loop(), \"t0\", 19);\n              case 19:\n                _ret = _context7.t0;\n                if (!(_ret === \"continue\")) {\n                  _context7.next = 22;\n                  break;\n                }\n                return _context7.abrupt(\"continue\", 22);\n              case 22:\n                _context7.next = 17;\n                break;\n              case 24:\n                _context7.next = 29;\n                break;\n              case 26:\n                _context7.prev = 26;\n                _context7.t1 = _context7[\"catch\"](14);\n                _iterator9.e(_context7.t1);\n              case 29:\n                _context7.prev = 29;\n                _iterator9.f();\n                return _context7.finish(29);\n              case 32:\n                hashToNewHash = new Map();\n                getEtag = function getEtag(asset) {\n                  return cacheGenerate.mergeEtags(cacheGenerate.getLazyHashedEtag(asset.source), Array.from(asset.referencedHashes, function (hash) {\n                    return hashToNewHash.get(hash);\n                  }).join(\"|\"));\n                };\n                computeNewContent = function computeNewContent(asset) {\n                  if (asset.contentComputePromise) return asset.contentComputePromise;\n                  return asset.contentComputePromise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                    var identifier, etag;\n                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                      while (1) switch (_context2.prev = _context2.next) {\n                        case 0:\n                          if (!(asset.ownHashes.size > 0 || Array.from(asset.referencedHashes).some(function (hash) {\n                            return hashToNewHash.get(hash) !== hash;\n                          }))) {\n                            _context2.next = 6;\n                            break;\n                          }\n                          identifier = asset.name;\n                          etag = getEtag(asset);\n                          _context2.next = 5;\n                          return cacheGenerate.providePromise(identifier, etag, function () {\n                            var newContent = asset.content.replace(hashRegExp, function (hash) {\n                              return hashToNewHash.get(hash);\n                            });\n                            return new RawSource(newContent);\n                          });\n                        case 5:\n                          asset.newSource = _context2.sent;\n                        case 6:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }, _callee2);\n                  }))();\n                };\n                computeNewContentWithoutOwn = function computeNewContentWithoutOwn(asset) {\n                  if (asset.contentComputeWithoutOwnPromise) return asset.contentComputeWithoutOwnPromise;\n                  return asset.contentComputeWithoutOwnPromise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                    var identifier, etag;\n                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                      while (1) switch (_context3.prev = _context3.next) {\n                        case 0:\n                          if (!(asset.ownHashes.size > 0 || Array.from(asset.referencedHashes).some(function (hash) {\n                            return hashToNewHash.get(hash) !== hash;\n                          }))) {\n                            _context3.next = 6;\n                            break;\n                          }\n                          identifier = asset.name + \"|without-own\";\n                          etag = getEtag(asset);\n                          _context3.next = 5;\n                          return cacheGenerate.providePromise(identifier, etag, function () {\n                            var newContent = asset.content.replace(hashRegExp, function (hash) {\n                              if (asset.ownHashes.has(hash)) {\n                                return \"\";\n                              }\n                              return hashToNewHash.get(hash);\n                            });\n                            return new RawSource(newContent);\n                          });\n                        case 5:\n                          asset.newSourceWithoutOwn = _context3.sent;\n                        case 6:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }, _callee3);\n                  }))();\n                };\n                comparator = compareSelect(function (a) {\n                  return a.name;\n                }, compareStrings);\n                _iterator10 = _createForOfIteratorHelper(hashesInOrder);\n                _context7.prev = 38;\n                _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {\n                  var oldHash, assets, hash, assetsContent, newHash, _iterator13, _step13, _content, digest;\n                  return _regeneratorRuntime().wrap(function _loop2$(_context6) {\n                    while (1) switch (_context6.prev = _context6.next) {\n                      case 0:\n                        oldHash = _step10.value;\n                        assets = hashToAssets.get(oldHash);\n                        assets.sort(comparator);\n                        hash = createHash(_this._hashFunction);\n                        _context6.next = 6;\n                        return Promise.all(assets.map(function (asset) {\n                          return asset.ownHashes.has(oldHash) ? computeNewContentWithoutOwn(asset) : computeNewContent(asset);\n                        }));\n                      case 6:\n                        assetsContent = mapAndDeduplicateBuffers(assets, function (asset) {\n                          if (asset.ownHashes.has(oldHash)) {\n                            return asset.newSourceWithoutOwn ? asset.newSourceWithoutOwn.buffer() : asset.source.buffer();\n                          } else {\n                            return asset.newSource ? asset.newSource.buffer() : asset.source.buffer();\n                          }\n                        });\n                        newHash = hooks.updateHash.call(assetsContent, oldHash);\n                        if (!newHash) {\n                          _iterator13 = _createForOfIteratorHelper(assetsContent);\n                          try {\n                            for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                              _content = _step13.value;\n                              hash.update(_content);\n                            }\n                          } catch (err) {\n                            _iterator13.e(err);\n                          } finally {\n                            _iterator13.f();\n                          }\n                          digest = hash.digest(_this._hashDigest);\n                          newHash = /** @type {string} */digest.slice(0, oldHash.length);\n                        }\n                        hashToNewHash.set(oldHash, newHash);\n                      case 10:\n                      case \"end\":\n                        return _context6.stop();\n                    }\n                  }, _loop2);\n                });\n                _iterator10.s();\n              case 41:\n                if ((_step10 = _iterator10.n()).done) {\n                  _context7.next = 45;\n                  break;\n                }\n                return _context7.delegateYield(_loop2(), \"t2\", 43);\n              case 43:\n                _context7.next = 41;\n                break;\n              case 45:\n                _context7.next = 50;\n                break;\n              case 47:\n                _context7.prev = 47;\n                _context7.t3 = _context7[\"catch\"](38);\n                _iterator10.e(_context7.t3);\n              case 50:\n                _context7.prev = 50;\n                _iterator10.f();\n                return _context7.finish(50);\n              case 53:\n                _context7.next = 55;\n                return Promise.all(assetsWithInfo.map( /*#__PURE__*/function () {\n                  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(asset) {\n                    var newName, infoUpdate, hash;\n                    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                      while (1) switch (_context4.prev = _context4.next) {\n                        case 0:\n                          _context4.next = 2;\n                          return computeNewContent(asset);\n                        case 2:\n                          newName = asset.name.replace(hashRegExp, function (hash) {\n                            return hashToNewHash.get(hash);\n                          });\n                          infoUpdate = {};\n                          hash = asset.info.contenthash;\n                          infoUpdate.contenthash = Array.isArray(hash) ? hash.map(function (hash) {\n                            return hashToNewHash.get(hash);\n                          }) : hashToNewHash.get(hash);\n                          if (asset.newSource !== undefined) {\n                            compilation.updateAsset(asset.name, asset.newSource, infoUpdate);\n                          } else {\n                            compilation.updateAsset(asset.name, asset.source, infoUpdate);\n                          }\n                          if (asset.name !== newName) {\n                            compilation.renameAsset(asset.name, newName);\n                          }\n                        case 8:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }, _callee4);\n                  }));\n                  return function (_x2) {\n                    return _ref6.apply(this, arguments);\n                  };\n                }()));\n              case 55:\n              case \"end\":\n                return _context7.stop();\n            }\n          }, _callee5, null, [[14, 26, 29, 32], [38, 47, 50, 53]]);\n        })));\n      });\n    }\n  }], [{\n    key: \"getCompilationHooks\",\n    value:\n    /**\n     * @param {Compilation} compilation the compilation\n     * @returns {CompilationHooks} the attached hooks\n     */\n    function getCompilationHooks(compilation) {\n      if (!(compilation instanceof Compilation)) {\n        throw new TypeError(\"The 'compilation' argument must be an instance of Compilation\");\n      }\n      var hooks = compilationHooksMap.get(compilation);\n      if (hooks === undefined) {\n        hooks = {\n          updateHash: new SyncBailHook([\"content\", \"oldHash\"])\n        };\n        compilationHooksMap.set(compilation, hooks);\n      }\n      return hooks;\n    }\n  }]);\n  return RealContentHashPlugin;\n}();\nmodule.exports = RealContentHashPlugin;","map":{"version":3,"names":["require","SyncBailHook","RawSource","CachedSource","CompatSource","Compilation","WebpackError","compareSelect","compareStrings","createHash","EMPTY_SET","Set","addToList","itemOrItems","list","Array","isArray","item","add","mapAndDeduplicateBuffers","input","fn","result","outer","value","buf","other","equals","push","quoteMeta","str","replace","cachedSourceMap","WeakMap","toCachedSource","source","entry","get","undefined","newSource","from","set","compilationHooksMap","RealContentHashPlugin","hashFunction","hashDigest","_hashFunction","_hashDigest","compiler","hooks","compilation","tap","cacheAnalyse","getCache","cacheGenerate","getCompilationHooks","processAssets","tapPromise","name","stage","PROCESS_ASSETS_STAGE_OPTIMIZE_HASH","assets","getAssets","assetsWithInfo","hashToAssets","Map","info","cachedSource","content","hashes","contenthash","data","newSourceWithoutOwn","ownHashes","contentComputePromise","contentComputeWithoutOwnPromise","referencedHashes","hash","size","hashRegExp","RegExp","keys","join","Promise","all","map","asset","Buffer","isBuffer","etag","mergeEtags","getLazyHashedEtag","providePromise","inContent","match","has","getDependencies","referencingAssets","filter","err","a","exec","errors","hashInfo","hashesInOrder","stack","deps","dep","Error","delete","hashToNewHash","getEtag","computeNewContent","some","identifier","newContent","computeNewContentWithoutOwn","comparator","oldHash","sort","assetsContent","buffer","newHash","updateHash","call","update","digest","slice","length","newName","infoUpdate","updateAsset","renameAsset","TypeError","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/optimize/RealContentHashPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { SyncBailHook } = require(\"tapable\");\nconst { RawSource, CachedSource, CompatSource } = require(\"webpack-sources\");\nconst Compilation = require(\"../Compilation\");\nconst WebpackError = require(\"../WebpackError\");\nconst { compareSelect, compareStrings } = require(\"../util/comparators\");\nconst createHash = require(\"../util/createHash\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst EMPTY_SET = new Set();\n\nconst addToList = (itemOrItems, list) => {\n\tif (Array.isArray(itemOrItems)) {\n\t\tfor (const item of itemOrItems) {\n\t\t\tlist.add(item);\n\t\t}\n\t} else if (itemOrItems) {\n\t\tlist.add(itemOrItems);\n\t}\n};\n\n/**\n * @template T\n * @param {T[]} input list\n * @param {function(T): Buffer} fn map function\n * @returns {Buffer[]} buffers without duplicates\n */\nconst mapAndDeduplicateBuffers = (input, fn) => {\n\t// Buffer.equals compares size first so this should be efficient enough\n\t// If it becomes a performance problem we can use a map and group by size\n\t// instead of looping over all assets.\n\tconst result = [];\n\touter: for (const value of input) {\n\t\tconst buf = fn(value);\n\t\tfor (const other of result) {\n\t\t\tif (buf.equals(other)) continue outer;\n\t\t}\n\t\tresult.push(buf);\n\t}\n\treturn result;\n};\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quoteMeta = str => {\n\treturn str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\nconst cachedSourceMap = new WeakMap();\n\nconst toCachedSource = source => {\n\tif (source instanceof CachedSource) {\n\t\treturn source;\n\t}\n\tconst entry = cachedSourceMap.get(source);\n\tif (entry !== undefined) return entry;\n\tconst newSource = new CachedSource(CompatSource.from(source));\n\tcachedSourceMap.set(source, newSource);\n\treturn newSource;\n};\n\n/**\n * @typedef {Object} AssetInfoForRealContentHash\n * @property {string} name\n * @property {AssetInfo} info\n * @property {Source} source\n * @property {RawSource | undefined} newSource\n * @property {RawSource | undefined} newSourceWithoutOwn\n * @property {string} content\n * @property {Set<string>} ownHashes\n * @property {Promise} contentComputePromise\n * @property {Promise} contentComputeWithoutOwnPromise\n * @property {Set<string>} referencedHashes\n * @property {Set<string>} hashes\n */\n\n/**\n * @typedef {Object} CompilationHooks\n * @property {SyncBailHook<[Buffer[], string], string>} updateHash\n */\n\n/** @type {WeakMap<Compilation, CompilationHooks>} */\nconst compilationHooksMap = new WeakMap();\n\nclass RealContentHashPlugin {\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @returns {CompilationHooks} the attached hooks\n\t */\n\tstatic getCompilationHooks(compilation) {\n\t\tif (!(compilation instanceof Compilation)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t\"The 'compilation' argument must be an instance of Compilation\"\n\t\t\t);\n\t\t}\n\t\tlet hooks = compilationHooksMap.get(compilation);\n\t\tif (hooks === undefined) {\n\t\t\thooks = {\n\t\t\t\tupdateHash: new SyncBailHook([\"content\", \"oldHash\"])\n\t\t\t};\n\t\t\tcompilationHooksMap.set(compilation, hooks);\n\t\t}\n\t\treturn hooks;\n\t}\n\n\tconstructor({ hashFunction, hashDigest }) {\n\t\tthis._hashFunction = hashFunction;\n\t\tthis._hashDigest = hashDigest;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"RealContentHashPlugin\", compilation => {\n\t\t\tconst cacheAnalyse = compilation.getCache(\n\t\t\t\t\"RealContentHashPlugin|analyse\"\n\t\t\t);\n\t\t\tconst cacheGenerate = compilation.getCache(\n\t\t\t\t\"RealContentHashPlugin|generate\"\n\t\t\t);\n\t\t\tconst hooks = RealContentHashPlugin.getCompilationHooks(compilation);\n\t\t\tcompilation.hooks.processAssets.tapPromise(\n\t\t\t\t{\n\t\t\t\t\tname: \"RealContentHashPlugin\",\n\t\t\t\t\tstage: Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH\n\t\t\t\t},\n\t\t\t\tasync () => {\n\t\t\t\t\tconst assets = compilation.getAssets();\n\t\t\t\t\t/** @type {AssetInfoForRealContentHash[]} */\n\t\t\t\t\tconst assetsWithInfo = [];\n\t\t\t\t\tconst hashToAssets = new Map();\n\t\t\t\t\tfor (const { source, info, name } of assets) {\n\t\t\t\t\t\tconst cachedSource = toCachedSource(source);\n\t\t\t\t\t\tconst content = cachedSource.source();\n\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\tconst hashes = new Set();\n\t\t\t\t\t\taddToList(info.contenthash, hashes);\n\t\t\t\t\t\tconst data = {\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\tsource: cachedSource,\n\t\t\t\t\t\t\t/** @type {RawSource | undefined} */\n\t\t\t\t\t\t\tnewSource: undefined,\n\t\t\t\t\t\t\t/** @type {RawSource | undefined} */\n\t\t\t\t\t\t\tnewSourceWithoutOwn: undefined,\n\t\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\townHashes: undefined,\n\t\t\t\t\t\t\tcontentComputePromise: undefined,\n\t\t\t\t\t\t\tcontentComputeWithoutOwnPromise: undefined,\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\treferencedHashes: undefined,\n\t\t\t\t\t\t\thashes\n\t\t\t\t\t\t};\n\t\t\t\t\t\tassetsWithInfo.push(data);\n\t\t\t\t\t\tfor (const hash of hashes) {\n\t\t\t\t\t\t\tconst list = hashToAssets.get(hash);\n\t\t\t\t\t\t\tif (list === undefined) {\n\t\t\t\t\t\t\t\thashToAssets.set(hash, [data]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlist.push(data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (hashToAssets.size === 0) return;\n\t\t\t\t\tconst hashRegExp = new RegExp(\n\t\t\t\t\t\tArray.from(hashToAssets.keys(), quoteMeta).join(\"|\"),\n\t\t\t\t\t\t\"g\"\n\t\t\t\t\t);\n\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\tassetsWithInfo.map(async asset => {\n\t\t\t\t\t\t\tconst { name, source, content, hashes } = asset;\n\t\t\t\t\t\t\tif (Buffer.isBuffer(content)) {\n\t\t\t\t\t\t\t\tasset.referencedHashes = EMPTY_SET;\n\t\t\t\t\t\t\t\tasset.ownHashes = EMPTY_SET;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst etag = cacheAnalyse.mergeEtags(\n\t\t\t\t\t\t\t\tcacheAnalyse.getLazyHashedEtag(source),\n\t\t\t\t\t\t\t\tArray.from(hashes).join(\"|\")\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t[asset.referencedHashes, asset.ownHashes] =\n\t\t\t\t\t\t\t\tawait cacheAnalyse.providePromise(name, etag, () => {\n\t\t\t\t\t\t\t\t\tconst referencedHashes = new Set();\n\t\t\t\t\t\t\t\t\tlet ownHashes = new Set();\n\t\t\t\t\t\t\t\t\tconst inContent = content.match(hashRegExp);\n\t\t\t\t\t\t\t\t\tif (inContent) {\n\t\t\t\t\t\t\t\t\t\tfor (const hash of inContent) {\n\t\t\t\t\t\t\t\t\t\t\tif (hashes.has(hash)) {\n\t\t\t\t\t\t\t\t\t\t\t\townHashes.add(hash);\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treferencedHashes.add(hash);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn [referencedHashes, ownHashes];\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t\tconst getDependencies = hash => {\n\t\t\t\t\t\tconst assets = hashToAssets.get(hash);\n\t\t\t\t\t\tif (!assets) {\n\t\t\t\t\t\t\tconst referencingAssets = assetsWithInfo.filter(asset =>\n\t\t\t\t\t\t\t\tasset.referencedHashes.has(hash)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst err = new WebpackError(`RealContentHashPlugin\nSome kind of unexpected caching problem occurred.\nAn asset was cached with a reference to another asset (${hash}) that's not in the compilation anymore.\nEither the asset was incorrectly cached, or the referenced asset should also be restored from cache.\nReferenced by:\n${referencingAssets\n\t.map(a => {\n\t\tconst match = new RegExp(`.{0,20}${quoteMeta(hash)}.{0,20}`).exec(\n\t\t\ta.content\n\t\t);\n\t\treturn ` - ${a.name}: ...${match ? match[0] : \"???\"}...`;\n\t})\n\t.join(\"\\n\")}`);\n\t\t\t\t\t\t\tcompilation.errors.push(err);\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst hashes = new Set();\n\t\t\t\t\t\tfor (const { referencedHashes, ownHashes } of assets) {\n\t\t\t\t\t\t\tif (!ownHashes.has(hash)) {\n\t\t\t\t\t\t\t\tfor (const hash of ownHashes) {\n\t\t\t\t\t\t\t\t\thashes.add(hash);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const hash of referencedHashes) {\n\t\t\t\t\t\t\t\thashes.add(hash);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn hashes;\n\t\t\t\t\t};\n\t\t\t\t\tconst hashInfo = hash => {\n\t\t\t\t\t\tconst assets = hashToAssets.get(hash);\n\t\t\t\t\t\treturn `${hash} (${Array.from(assets, a => a.name)})`;\n\t\t\t\t\t};\n\t\t\t\t\tconst hashesInOrder = new Set();\n\t\t\t\t\tfor (const hash of hashToAssets.keys()) {\n\t\t\t\t\t\tconst add = (hash, stack) => {\n\t\t\t\t\t\t\tconst deps = getDependencies(hash);\n\t\t\t\t\t\t\tif (!deps) return;\n\t\t\t\t\t\t\tstack.add(hash);\n\t\t\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\t\t\tif (hashesInOrder.has(dep)) continue;\n\t\t\t\t\t\t\t\tif (stack.has(dep)) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t`Circular hash dependency ${Array.from(\n\t\t\t\t\t\t\t\t\t\t\tstack,\n\t\t\t\t\t\t\t\t\t\t\thashInfo\n\t\t\t\t\t\t\t\t\t\t).join(\" -> \")} -> ${hashInfo(dep)}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tadd(dep, stack);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thashesInOrder.add(hash);\n\t\t\t\t\t\t\tstack.delete(hash);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (hashesInOrder.has(hash)) continue;\n\t\t\t\t\t\tadd(hash, new Set());\n\t\t\t\t\t}\n\t\t\t\t\tconst hashToNewHash = new Map();\n\t\t\t\t\tconst getEtag = asset =>\n\t\t\t\t\t\tcacheGenerate.mergeEtags(\n\t\t\t\t\t\t\tcacheGenerate.getLazyHashedEtag(asset.source),\n\t\t\t\t\t\t\tArray.from(asset.referencedHashes, hash =>\n\t\t\t\t\t\t\t\thashToNewHash.get(hash)\n\t\t\t\t\t\t\t).join(\"|\")\n\t\t\t\t\t\t);\n\t\t\t\t\tconst computeNewContent = asset => {\n\t\t\t\t\t\tif (asset.contentComputePromise) return asset.contentComputePromise;\n\t\t\t\t\t\treturn (asset.contentComputePromise = (async () => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tasset.ownHashes.size > 0 ||\n\t\t\t\t\t\t\t\tArray.from(asset.referencedHashes).some(\n\t\t\t\t\t\t\t\t\thash => hashToNewHash.get(hash) !== hash\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst identifier = asset.name;\n\t\t\t\t\t\t\t\tconst etag = getEtag(asset);\n\t\t\t\t\t\t\t\tasset.newSource = await cacheGenerate.providePromise(\n\t\t\t\t\t\t\t\t\tidentifier,\n\t\t\t\t\t\t\t\t\tetag,\n\t\t\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\t\t\tconst newContent = asset.content.replace(hashRegExp, hash =>\n\t\t\t\t\t\t\t\t\t\t\thashToNewHash.get(hash)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn new RawSource(newContent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})());\n\t\t\t\t\t};\n\t\t\t\t\tconst computeNewContentWithoutOwn = asset => {\n\t\t\t\t\t\tif (asset.contentComputeWithoutOwnPromise)\n\t\t\t\t\t\t\treturn asset.contentComputeWithoutOwnPromise;\n\t\t\t\t\t\treturn (asset.contentComputeWithoutOwnPromise = (async () => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tasset.ownHashes.size > 0 ||\n\t\t\t\t\t\t\t\tArray.from(asset.referencedHashes).some(\n\t\t\t\t\t\t\t\t\thash => hashToNewHash.get(hash) !== hash\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst identifier = asset.name + \"|without-own\";\n\t\t\t\t\t\t\t\tconst etag = getEtag(asset);\n\t\t\t\t\t\t\t\tasset.newSourceWithoutOwn = await cacheGenerate.providePromise(\n\t\t\t\t\t\t\t\t\tidentifier,\n\t\t\t\t\t\t\t\t\tetag,\n\t\t\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\t\t\tconst newContent = asset.content.replace(\n\t\t\t\t\t\t\t\t\t\t\thashRegExp,\n\t\t\t\t\t\t\t\t\t\t\thash => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (asset.ownHashes.has(hash)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\treturn hashToNewHash.get(hash);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn new RawSource(newContent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})());\n\t\t\t\t\t};\n\t\t\t\t\tconst comparator = compareSelect(a => a.name, compareStrings);\n\t\t\t\t\tfor (const oldHash of hashesInOrder) {\n\t\t\t\t\t\tconst assets = hashToAssets.get(oldHash);\n\t\t\t\t\t\tassets.sort(comparator);\n\t\t\t\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\t\tassets.map(asset =>\n\t\t\t\t\t\t\t\tasset.ownHashes.has(oldHash)\n\t\t\t\t\t\t\t\t\t? computeNewContentWithoutOwn(asset)\n\t\t\t\t\t\t\t\t\t: computeNewContent(asset)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst assetsContent = mapAndDeduplicateBuffers(assets, asset => {\n\t\t\t\t\t\t\tif (asset.ownHashes.has(oldHash)) {\n\t\t\t\t\t\t\t\treturn asset.newSourceWithoutOwn\n\t\t\t\t\t\t\t\t\t? asset.newSourceWithoutOwn.buffer()\n\t\t\t\t\t\t\t\t\t: asset.source.buffer();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn asset.newSource\n\t\t\t\t\t\t\t\t\t? asset.newSource.buffer()\n\t\t\t\t\t\t\t\t\t: asset.source.buffer();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tlet newHash = hooks.updateHash.call(assetsContent, oldHash);\n\t\t\t\t\t\tif (!newHash) {\n\t\t\t\t\t\t\tfor (const content of assetsContent) {\n\t\t\t\t\t\t\t\thash.update(content);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst digest = hash.digest(this._hashDigest);\n\t\t\t\t\t\t\tnewHash = /** @type {string} */ (digest.slice(0, oldHash.length));\n\t\t\t\t\t\t}\n\t\t\t\t\t\thashToNewHash.set(oldHash, newHash);\n\t\t\t\t\t}\n\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\tassetsWithInfo.map(async asset => {\n\t\t\t\t\t\t\tawait computeNewContent(asset);\n\t\t\t\t\t\t\tconst newName = asset.name.replace(hashRegExp, hash =>\n\t\t\t\t\t\t\t\thashToNewHash.get(hash)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tconst infoUpdate = {};\n\t\t\t\t\t\t\tconst hash = asset.info.contenthash;\n\t\t\t\t\t\t\tinfoUpdate.contenthash = Array.isArray(hash)\n\t\t\t\t\t\t\t\t? hash.map(hash => hashToNewHash.get(hash))\n\t\t\t\t\t\t\t\t: hashToNewHash.get(hash);\n\n\t\t\t\t\t\t\tif (asset.newSource !== undefined) {\n\t\t\t\t\t\t\t\tcompilation.updateAsset(\n\t\t\t\t\t\t\t\t\tasset.name,\n\t\t\t\t\t\t\t\t\tasset.newSource,\n\t\t\t\t\t\t\t\t\tinfoUpdate\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcompilation.updateAsset(asset.name, asset.source, infoUpdate);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (asset.name !== newName) {\n\t\t\t\t\t\t\t\tcompilation.renameAsset(asset.name, newName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = RealContentHashPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}