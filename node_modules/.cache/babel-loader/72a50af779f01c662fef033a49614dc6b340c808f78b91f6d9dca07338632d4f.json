{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\nvar _require = require(\"./GraphHelpers\"),\n  connectChunkGroupParentAndChild = _require.connectChunkGroupParentAndChild;\nvar ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nvar _require2 = require(\"./util/runtime\"),\n  getEntryRuntime = _require2.getEntryRuntime,\n  mergeRuntime = _require2.mergeRuntime;\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n * @property {ChunkGroupInfo} chunkGroupInfo\n */\n\n/** @typedef {Set<Module> & { plus: Set<Module> }} ModuleSetPlus */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {RuntimeSpec} runtime the runtimes\n * @property {ModuleSetPlus} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {ModuleSetPlus[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {Set<Module>=} skippedItems modules that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<[Module, ConnectionState]>=} skippedModuleConnections referenced modules that where skipped because they were not active in this runtime\n * @property {ModuleSetPlus} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroupInfo>} children set of children chunk groups, that will be revisited when availableModules shrink\n * @property {Set<ChunkGroupInfo>} availableSources set of chunk groups that are the source for minAvailableModules\n * @property {Set<ChunkGroupInfo>} availableChildren set of chunk groups which depend on the this chunk group as availableSource\n * @property {number} preOrderIndex next pre order index\n * @property {number} postOrderIndex next post order index\n * @property {boolean} chunkLoading has a chunk loading mechanism\n * @property {boolean} asyncChunks create async chunks\n */\n\n/**\n * @typedef {Object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\nvar EMPTY_SET = /** @type {ModuleSetPlus} */new Set();\nEMPTY_SET.plus = EMPTY_SET;\n\n/**\n * @param {ModuleSetPlus} a first set\n * @param {ModuleSetPlus} b second set\n * @returns {number} cmp\n */\nvar bySetSize = function bySetSize(a, b) {\n  return b.size + b.plus.size - a.size - a.plus.size;\n};\nvar extractBlockModules = function extractBlockModules(module, moduleGraph, runtime, blockModulesMap) {\n  var blockCache;\n  var modules;\n  var arrays = [];\n  var queue = [module];\n  while (queue.length > 0) {\n    var block = queue.pop();\n    var arr = [];\n    arrays.push(arr);\n    blockModulesMap.set(block, arr);\n    var _iterator = _createForOfIteratorHelper(block.blocks),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var b = _step.value;\n        queue.push(b);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  var _iterator2 = _createForOfIteratorHelper(moduleGraph.getOutgoingConnections(module)),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var connection = _step2.value;\n      var d = connection.dependency;\n      // We skip connections without dependency\n      if (!d) continue;\n      var _m = connection.module;\n      // We skip connections without Module pointer\n      if (!_m) continue;\n      // We skip weak connections\n      if (connection.weak) continue;\n      var _state = connection.getActiveState(runtime);\n      // We skip inactive connections\n      if (_state === false) continue;\n      var _block = moduleGraph.getParentBlock(d);\n      var index = moduleGraph.getParentBlockIndex(d);\n\n      // deprecated fallback\n      if (index < 0) {\n        index = _block.dependencies.indexOf(d);\n      }\n      if (blockCache !== _block) {\n        modules = blockModulesMap.get(blockCache = _block);\n      }\n      var _i3 = index << 2;\n      modules[_i3] = _m;\n      modules[_i3 + 1] = _state;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  for (var _i = 0, _arrays = arrays; _i < _arrays.length; _i++) {\n    var _modules = _arrays[_i];\n    if (_modules.length === 0) continue;\n    var indexMap = void 0;\n    var length = 0;\n    outer: for (var j = 0; j < _modules.length; j += 2) {\n      var m = _modules[j];\n      if (m === undefined) continue;\n      var state = _modules[j + 1];\n      if (indexMap === undefined) {\n        var i = 0;\n        for (; i < length; i += 2) {\n          if (_modules[i] === m) {\n            var merged = _modules[i + 1];\n            if (merged === true) continue outer;\n            _modules[i + 1] = ModuleGraphConnection.addConnectionStates(merged, state);\n          }\n        }\n        _modules[length] = m;\n        length++;\n        _modules[length] = state;\n        length++;\n        if (length > 30) {\n          // To avoid worse case performance, we will use an index map for\n          // linear cost access, which allows to maintain O(n) complexity\n          // while keeping allocations down to a minimum\n          indexMap = new Map();\n          for (var _i2 = 0; _i2 < length; _i2 += 2) {\n            indexMap.set(_modules[_i2], _i2 + 1);\n          }\n        }\n      } else {\n        var idx = indexMap.get(m);\n        if (idx !== undefined) {\n          var _merged = _modules[idx];\n          if (_merged === true) continue outer;\n          _modules[idx] = ModuleGraphConnection.addConnectionStates(_merged, state);\n        } else {\n          _modules[length] = m;\n          length++;\n          _modules[length] = state;\n          indexMap.set(m, length);\n          length++;\n        }\n      }\n    }\n    _modules.length = length;\n  }\n};\n\n/**\n *\n * @param {Logger} logger a logger\n * @param {Compilation} compilation the compilation\n * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\nvar visitModules = function visitModules(logger, compilation, inputEntrypointsAndModules, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups) {\n  var moduleGraph = compilation.moduleGraph,\n    chunkGraph = compilation.chunkGraph,\n    moduleMemCaches = compilation.moduleMemCaches;\n  var blockModulesRuntimeMap = new Map();\n\n  /** @type {RuntimeSpec | false} */\n  var blockModulesMapRuntime = false;\n  var blockModulesMap;\n\n  /**\n   *\n   * @param {DependenciesBlock} block block\n   * @param {RuntimeSpec} runtime runtime\n   * @returns {(Module | ConnectionState)[]} block modules in flatten tuples\n   */\n  var getBlockModules = function getBlockModules(block, runtime) {\n    if (blockModulesMapRuntime !== runtime) {\n      blockModulesMap = blockModulesRuntimeMap.get(runtime);\n      if (blockModulesMap === undefined) {\n        blockModulesMap = new Map();\n        blockModulesRuntimeMap.set(runtime, blockModulesMap);\n      }\n    }\n    var blockModules = blockModulesMap.get(block);\n    if (blockModules !== undefined) return blockModules;\n    var module = /** @type {Module} */block.getRootBlock();\n    var memCache = moduleMemCaches && moduleMemCaches.get(module);\n    if (memCache !== undefined) {\n      var map = memCache.provide(\"bundleChunkGraph.blockModules\", runtime, function () {\n        logger.time(\"visitModules: prepare\");\n        var map = new Map();\n        extractBlockModules(module, moduleGraph, runtime, map);\n        logger.timeAggregate(\"visitModules: prepare\");\n        return map;\n      });\n      var _iterator3 = _createForOfIteratorHelper(map),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n            _block2 = _step3$value[0],\n            _blockModules = _step3$value[1];\n          blockModulesMap.set(_block2, _blockModules);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return map.get(block);\n    } else {\n      logger.time(\"visitModules: prepare\");\n      extractBlockModules(module, moduleGraph, runtime, blockModulesMap);\n      blockModules = blockModulesMap.get(block);\n      logger.timeAggregate(\"visitModules: prepare\");\n      return blockModules;\n    }\n  };\n  var statProcessedQueueItems = 0;\n  var statProcessedBlocks = 0;\n  var statConnectedChunkGroups = 0;\n  var statProcessedChunkGroupsForMerging = 0;\n  var statMergedAvailableModuleSets = 0;\n  var statForkedAvailableModules = 0;\n  var statForkedAvailableModulesCount = 0;\n  var statForkedAvailableModulesCountPlus = 0;\n  var statForkedMergedModulesCount = 0;\n  var statForkedMergedModulesCountPlus = 0;\n  var statForkedResultModulesCount = 0;\n  var statChunkGroupInfoUpdated = 0;\n  var statChildChunkGroupsReconnected = 0;\n  var nextChunkGroupIndex = 0;\n  var nextFreeModulePreOrderIndex = 0;\n  var nextFreeModulePostOrderIndex = 0;\n\n  /** @type {Map<DependenciesBlock, ChunkGroupInfo>} */\n  var blockChunkGroups = new Map();\n\n  /** @type {Map<string, ChunkGroupInfo>} */\n  var namedChunkGroups = new Map();\n\n  /** @type {Map<string, ChunkGroupInfo>} */\n  var namedAsyncEntrypoints = new Map();\n  var ADD_AND_ENTER_ENTRY_MODULE = 0;\n  var ADD_AND_ENTER_MODULE = 1;\n  var ENTER_MODULE = 2;\n  var PROCESS_BLOCK = 3;\n  var PROCESS_ENTRY_BLOCK = 4;\n  var LEAVE_MODULE = 5;\n\n  /** @type {QueueItem[]} */\n  var queue = [];\n\n  /** @type {Map<ChunkGroupInfo, Set<ChunkGroupInfo>>} */\n  var queueConnect = new Map();\n  /** @type {Set<ChunkGroupInfo>} */\n  var chunkGroupsForCombining = new Set();\n\n  // Fill queue with entrypoint modules\n  // Create ChunkGroupInfo for entrypoints\n  var _iterator4 = _createForOfIteratorHelper(inputEntrypointsAndModules),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _step4$value = _slicedToArray(_step4.value, 2),\n        _chunkGroup = _step4$value[0],\n        modules = _step4$value[1];\n      var runtime = getEntryRuntime(compilation, _chunkGroup.name, _chunkGroup.options);\n      /** @type {ChunkGroupInfo} */\n      var _chunkGroupInfo5 = {\n        chunkGroup: _chunkGroup,\n        runtime: runtime,\n        minAvailableModules: undefined,\n        minAvailableModulesOwned: false,\n        availableModulesToBeMerged: [],\n        skippedItems: undefined,\n        resultingAvailableModules: undefined,\n        children: undefined,\n        availableSources: undefined,\n        availableChildren: undefined,\n        preOrderIndex: 0,\n        postOrderIndex: 0,\n        chunkLoading: _chunkGroup.options.chunkLoading !== undefined ? _chunkGroup.options.chunkLoading !== false : compilation.outputOptions.chunkLoading !== false,\n        asyncChunks: _chunkGroup.options.asyncChunks !== undefined ? _chunkGroup.options.asyncChunks : compilation.outputOptions.asyncChunks !== false\n      };\n      _chunkGroup.index = nextChunkGroupIndex++;\n      if (_chunkGroup.getNumberOfParents() > 0) {\n        // minAvailableModules for child entrypoints are unknown yet, set to undefined.\n        // This means no module is added until other sets are merged into\n        // this minAvailableModules (by the parent entrypoints)\n        var skippedItems = new Set();\n        var _iterator38 = _createForOfIteratorHelper(modules),\n          _step35;\n        try {\n          for (_iterator38.s(); !(_step35 = _iterator38.n()).done;) {\n            var _module13 = _step35.value;\n            skippedItems.add(_module13);\n          }\n        } catch (err) {\n          _iterator38.e(err);\n        } finally {\n          _iterator38.f();\n        }\n        _chunkGroupInfo5.skippedItems = skippedItems;\n        chunkGroupsForCombining.add(_chunkGroupInfo5);\n      } else {\n        // The application may start here: We start with an empty list of available modules\n        _chunkGroupInfo5.minAvailableModules = EMPTY_SET;\n        var _chunk2 = _chunkGroup.getEntrypointChunk();\n        var _iterator39 = _createForOfIteratorHelper(modules),\n          _step36;\n        try {\n          for (_iterator39.s(); !(_step36 = _iterator39.n()).done;) {\n            var _module14 = _step36.value;\n            queue.push({\n              action: ADD_AND_ENTER_MODULE,\n              block: _module14,\n              module: _module14,\n              chunk: _chunk2,\n              chunkGroup: _chunkGroup,\n              chunkGroupInfo: _chunkGroupInfo5\n            });\n          }\n        } catch (err) {\n          _iterator39.e(err);\n        } finally {\n          _iterator39.f();\n        }\n      }\n      chunkGroupInfoMap.set(_chunkGroup, _chunkGroupInfo5);\n      if (_chunkGroup.name) {\n        namedChunkGroups.set(_chunkGroup.name, _chunkGroupInfo5);\n      }\n    }\n    // Fill availableSources with parent-child dependencies between entrypoints\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  var _iterator5 = _createForOfIteratorHelper(chunkGroupsForCombining),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var _chunkGroupInfo6 = _step5.value;\n      var _chunkGroup2 = _chunkGroupInfo6.chunkGroup;\n      _chunkGroupInfo6.availableSources = new Set();\n      var _iterator40 = _createForOfIteratorHelper(_chunkGroup2.parentsIterable),\n        _step37;\n      try {\n        for (_iterator40.s(); !(_step37 = _iterator40.n()).done;) {\n          var parent = _step37.value;\n          var parentChunkGroupInfo = chunkGroupInfoMap.get(parent);\n          _chunkGroupInfo6.availableSources.add(parentChunkGroupInfo);\n          if (parentChunkGroupInfo.availableChildren === undefined) {\n            parentChunkGroupInfo.availableChildren = new Set();\n          }\n          parentChunkGroupInfo.availableChildren.add(_chunkGroupInfo6);\n        }\n      } catch (err) {\n        _iterator40.e(err);\n      } finally {\n        _iterator40.f();\n      }\n    }\n    // pop() is used to read from the queue\n    // so it need to be reversed to be iterated in\n    // correct order\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  queue.reverse();\n\n  /** @type {Set<ChunkGroupInfo>} */\n  var outdatedChunkGroupInfo = new Set();\n  /** @type {Set<ChunkGroupInfo>} */\n  var chunkGroupsForMerging = new Set();\n  /** @type {QueueItem[]} */\n  var queueDelayed = [];\n\n  /** @type {[Module, ConnectionState][]} */\n  var skipConnectionBuffer = [];\n  /** @type {Module[]} */\n  var skipBuffer = [];\n  /** @type {QueueItem[]} */\n  var queueBuffer = [];\n\n  /** @type {Module} */\n  var module;\n  /** @type {Chunk} */\n  var chunk;\n  /** @type {ChunkGroup} */\n  var chunkGroup;\n  /** @type {DependenciesBlock} */\n  var block;\n  /** @type {ChunkGroupInfo} */\n  var chunkGroupInfo;\n\n  // For each async Block in graph\n  /**\n   * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n   * @returns {void}\n   */\n  var iteratorBlock = function iteratorBlock(b) {\n    // 1. We create a chunk group with single chunk in it for this Block\n    // but only once (blockChunkGroups map)\n    var cgi = blockChunkGroups.get(b);\n    /** @type {ChunkGroup} */\n    var c;\n    /** @type {Entrypoint} */\n    var entrypoint;\n    var entryOptions = b.groupOptions && b.groupOptions.entryOptions;\n    if (cgi === undefined) {\n      var chunkName = b.groupOptions && b.groupOptions.name || b.chunkName;\n      if (entryOptions) {\n        cgi = namedAsyncEntrypoints.get(chunkName);\n        if (!cgi) {\n          entrypoint = compilation.addAsyncEntrypoint(entryOptions, module, b.loc, b.request);\n          entrypoint.index = nextChunkGroupIndex++;\n          cgi = {\n            chunkGroup: entrypoint,\n            runtime: entrypoint.options.runtime || entrypoint.name,\n            minAvailableModules: EMPTY_SET,\n            minAvailableModulesOwned: false,\n            availableModulesToBeMerged: [],\n            skippedItems: undefined,\n            resultingAvailableModules: undefined,\n            children: undefined,\n            availableSources: undefined,\n            availableChildren: undefined,\n            preOrderIndex: 0,\n            postOrderIndex: 0,\n            chunkLoading: entryOptions.chunkLoading !== undefined ? entryOptions.chunkLoading !== false : chunkGroupInfo.chunkLoading,\n            asyncChunks: entryOptions.asyncChunks !== undefined ? entryOptions.asyncChunks : chunkGroupInfo.asyncChunks\n          };\n          chunkGroupInfoMap.set(entrypoint, cgi);\n          chunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n          if (chunkName) {\n            namedAsyncEntrypoints.set(chunkName, cgi);\n          }\n        } else {\n          entrypoint = /** @type {Entrypoint} */cgi.chunkGroup;\n          // TODO merge entryOptions\n          entrypoint.addOrigin(module, b.loc, b.request);\n          chunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n        }\n\n        // 2. We enqueue the DependenciesBlock for traversal\n        queueDelayed.push({\n          action: PROCESS_ENTRY_BLOCK,\n          block: b,\n          module: module,\n          chunk: entrypoint.chunks[0],\n          chunkGroup: entrypoint,\n          chunkGroupInfo: cgi\n        });\n      } else if (!chunkGroupInfo.asyncChunks || !chunkGroupInfo.chunkLoading) {\n        // Just queue the block into the current chunk group\n        queue.push({\n          action: PROCESS_BLOCK,\n          block: b,\n          module: module,\n          chunk: chunk,\n          chunkGroup: chunkGroup,\n          chunkGroupInfo: chunkGroupInfo\n        });\n      } else {\n        cgi = chunkName && namedChunkGroups.get(chunkName);\n        if (!cgi) {\n          c = compilation.addChunkInGroup(b.groupOptions || b.chunkName, module, b.loc, b.request);\n          c.index = nextChunkGroupIndex++;\n          cgi = {\n            chunkGroup: c,\n            runtime: chunkGroupInfo.runtime,\n            minAvailableModules: undefined,\n            minAvailableModulesOwned: undefined,\n            availableModulesToBeMerged: [],\n            skippedItems: undefined,\n            resultingAvailableModules: undefined,\n            children: undefined,\n            availableSources: undefined,\n            availableChildren: undefined,\n            preOrderIndex: 0,\n            postOrderIndex: 0,\n            chunkLoading: chunkGroupInfo.chunkLoading,\n            asyncChunks: chunkGroupInfo.asyncChunks\n          };\n          allCreatedChunkGroups.add(c);\n          chunkGroupInfoMap.set(c, cgi);\n          if (chunkName) {\n            namedChunkGroups.set(chunkName, cgi);\n          }\n        } else {\n          c = cgi.chunkGroup;\n          if (c.isInitial()) {\n            compilation.errors.push(new AsyncDependencyToInitialChunkError(chunkName, module, b.loc));\n            c = chunkGroup;\n          } else {\n            c.addOptions(b.groupOptions);\n          }\n          c.addOrigin(module, b.loc, b.request);\n        }\n        blockConnections.set(b, []);\n      }\n      blockChunkGroups.set(b, cgi);\n    } else if (entryOptions) {\n      entrypoint = /** @type {Entrypoint} */cgi.chunkGroup;\n    } else {\n      c = cgi.chunkGroup;\n    }\n    if (c !== undefined) {\n      // 2. We store the connection for the block\n      // to connect it later if needed\n      blockConnections.get(b).push({\n        originChunkGroupInfo: chunkGroupInfo,\n        chunkGroup: c\n      });\n\n      // 3. We enqueue the chunk group info creation/updating\n      var connectList = queueConnect.get(chunkGroupInfo);\n      if (connectList === undefined) {\n        connectList = new Set();\n        queueConnect.set(chunkGroupInfo, connectList);\n      }\n      connectList.add(cgi);\n\n      // TODO check if this really need to be done for each traversal\n      // or if it is enough when it's queued when created\n      // 4. We enqueue the DependenciesBlock for traversal\n      queueDelayed.push({\n        action: PROCESS_BLOCK,\n        block: b,\n        module: module,\n        chunk: c.chunks[0],\n        chunkGroup: c,\n        chunkGroupInfo: cgi\n      });\n    } else if (entrypoint !== undefined) {\n      chunkGroupInfo.chunkGroup.addAsyncEntrypoint(entrypoint);\n    }\n  };\n\n  /**\n   * @param {DependenciesBlock} block the block\n   * @returns {void}\n   */\n  var processBlock = function processBlock(block) {\n    statProcessedBlocks++;\n    // get prepared block info\n    var blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n    if (blockModules !== undefined) {\n      var _chunkGroupInfo = chunkGroupInfo,\n        minAvailableModules = _chunkGroupInfo.minAvailableModules;\n      // Buffer items because order need to be reversed to get indices correct\n      // Traverse all referenced modules\n      for (var i = 0; i < blockModules.length; i += 2) {\n        var refModule = /** @type {Module} */blockModules[i];\n        if (chunkGraph.isModuleInChunk(refModule, chunk)) {\n          // skip early if already connected\n          continue;\n        }\n        var activeState = /** @type {ConnectionState} */\n        blockModules[i + 1];\n        if (activeState !== true) {\n          skipConnectionBuffer.push([refModule, activeState]);\n          if (activeState === false) continue;\n        }\n        if (activeState === true && (minAvailableModules.has(refModule) || minAvailableModules.plus.has(refModule))) {\n          // already in parent chunks, skip it for now\n          skipBuffer.push(refModule);\n          continue;\n        }\n        // enqueue, then add and enter to be in the correct order\n        // this is relevant with circular dependencies\n        queueBuffer.push({\n          action: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n          block: refModule,\n          module: refModule,\n          chunk: chunk,\n          chunkGroup: chunkGroup,\n          chunkGroupInfo: chunkGroupInfo\n        });\n      }\n      // Add buffered items in reverse order\n      if (skipConnectionBuffer.length > 0) {\n        var _chunkGroupInfo2 = chunkGroupInfo,\n          skippedModuleConnections = _chunkGroupInfo2.skippedModuleConnections;\n        if (skippedModuleConnections === undefined) {\n          chunkGroupInfo.skippedModuleConnections = skippedModuleConnections = new Set();\n        }\n        for (var _i4 = skipConnectionBuffer.length - 1; _i4 >= 0; _i4--) {\n          skippedModuleConnections.add(skipConnectionBuffer[_i4]);\n        }\n        skipConnectionBuffer.length = 0;\n      }\n      if (skipBuffer.length > 0) {\n        var _chunkGroupInfo3 = chunkGroupInfo,\n          skippedItems = _chunkGroupInfo3.skippedItems;\n        if (skippedItems === undefined) {\n          chunkGroupInfo.skippedItems = skippedItems = new Set();\n        }\n        for (var _i5 = skipBuffer.length - 1; _i5 >= 0; _i5--) {\n          skippedItems.add(skipBuffer[_i5]);\n        }\n        skipBuffer.length = 0;\n      }\n      if (queueBuffer.length > 0) {\n        for (var _i6 = queueBuffer.length - 1; _i6 >= 0; _i6--) {\n          queue.push(queueBuffer[_i6]);\n        }\n        queueBuffer.length = 0;\n      }\n    }\n\n    // Traverse all Blocks\n    var _iterator6 = _createForOfIteratorHelper(block.blocks),\n      _step6;\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var b = _step6.value;\n        iteratorBlock(b);\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n    if (block.blocks.length > 0 && module !== block) {\n      blocksWithNestedBlocks.add(block);\n    }\n  };\n\n  /**\n   * @param {DependenciesBlock} block the block\n   * @returns {void}\n   */\n  var processEntryBlock = function processEntryBlock(block) {\n    statProcessedBlocks++;\n    // get prepared block info\n    var blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n    if (blockModules !== undefined) {\n      // Traverse all referenced modules\n      for (var i = 0; i < blockModules.length; i += 2) {\n        var refModule = /** @type {Module} */blockModules[i];\n        var activeState = /** @type {ConnectionState} */\n        blockModules[i + 1];\n        // enqueue, then add and enter to be in the correct order\n        // this is relevant with circular dependencies\n        queueBuffer.push({\n          action: activeState === true ? ADD_AND_ENTER_ENTRY_MODULE : PROCESS_BLOCK,\n          block: refModule,\n          module: refModule,\n          chunk: chunk,\n          chunkGroup: chunkGroup,\n          chunkGroupInfo: chunkGroupInfo\n        });\n      }\n      // Add buffered items in reverse order\n      if (queueBuffer.length > 0) {\n        for (var _i7 = queueBuffer.length - 1; _i7 >= 0; _i7--) {\n          queue.push(queueBuffer[_i7]);\n        }\n        queueBuffer.length = 0;\n      }\n    }\n\n    // Traverse all Blocks\n    var _iterator7 = _createForOfIteratorHelper(block.blocks),\n      _step7;\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var b = _step7.value;\n        iteratorBlock(b);\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n    if (block.blocks.length > 0 && module !== block) {\n      blocksWithNestedBlocks.add(block);\n    }\n  };\n  var processQueue = function processQueue() {\n    while (queue.length) {\n      statProcessedQueueItems++;\n      var queueItem = queue.pop();\n      module = queueItem.module;\n      block = queueItem.block;\n      chunk = queueItem.chunk;\n      chunkGroup = queueItem.chunkGroup;\n      chunkGroupInfo = queueItem.chunkGroupInfo;\n      switch (queueItem.action) {\n        case ADD_AND_ENTER_ENTRY_MODULE:\n          chunkGraph.connectChunkAndEntryModule(chunk, module, /** @type {Entrypoint} */chunkGroup);\n        // fallthrough\n        case ADD_AND_ENTER_MODULE:\n          {\n            if (chunkGraph.isModuleInChunk(module, chunk)) {\n              // already connected, skip it\n              break;\n            }\n            // We connect Module and Chunk\n            chunkGraph.connectChunkAndModule(chunk, module);\n          }\n        // fallthrough\n        case ENTER_MODULE:\n          {\n            var index = chunkGroup.getModulePreOrderIndex(module);\n            if (index === undefined) {\n              chunkGroup.setModulePreOrderIndex(module, chunkGroupInfo.preOrderIndex++);\n            }\n            if (moduleGraph.setPreOrderIndexIfUnset(module, nextFreeModulePreOrderIndex)) {\n              nextFreeModulePreOrderIndex++;\n            }\n\n            // reuse queueItem\n            queueItem.action = LEAVE_MODULE;\n            queue.push(queueItem);\n          }\n        // fallthrough\n        case PROCESS_BLOCK:\n          {\n            processBlock(block);\n            break;\n          }\n        case PROCESS_ENTRY_BLOCK:\n          {\n            processEntryBlock(block);\n            break;\n          }\n        case LEAVE_MODULE:\n          {\n            var _index = chunkGroup.getModulePostOrderIndex(module);\n            if (_index === undefined) {\n              chunkGroup.setModulePostOrderIndex(module, chunkGroupInfo.postOrderIndex++);\n            }\n            if (moduleGraph.setPostOrderIndexIfUnset(module, nextFreeModulePostOrderIndex)) {\n              nextFreeModulePostOrderIndex++;\n            }\n            break;\n          }\n      }\n    }\n  };\n  var calculateResultingAvailableModules = function calculateResultingAvailableModules(chunkGroupInfo) {\n    if (chunkGroupInfo.resultingAvailableModules) return chunkGroupInfo.resultingAvailableModules;\n    var minAvailableModules = chunkGroupInfo.minAvailableModules;\n\n    // Create a new Set of available modules at this point\n    // We want to be as lazy as possible. There are multiple ways doing this:\n    // Note that resultingAvailableModules is stored as \"(a) + (b)\" as it's a ModuleSetPlus\n    // - resultingAvailableModules = (modules of chunk) + (minAvailableModules + minAvailableModules.plus)\n    // - resultingAvailableModules = (minAvailableModules + modules of chunk) + (minAvailableModules.plus)\n    // We choose one depending on the size of minAvailableModules vs minAvailableModules.plus\n\n    var resultingAvailableModules;\n    if (minAvailableModules.size > minAvailableModules.plus.size) {\n      // resultingAvailableModules = (modules of chunk) + (minAvailableModules + minAvailableModules.plus)\n      resultingAvailableModules = /** @type {Set<Module> & {plus: Set<Module>}} */new Set();\n      var _iterator8 = _createForOfIteratorHelper(minAvailableModules.plus),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _module = _step8.value;\n          minAvailableModules.add(_module);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      minAvailableModules.plus = EMPTY_SET;\n      resultingAvailableModules.plus = minAvailableModules;\n      chunkGroupInfo.minAvailableModulesOwned = false;\n    } else {\n      // resultingAvailableModules = (minAvailableModules + modules of chunk) + (minAvailableModules.plus)\n      resultingAvailableModules = /** @type {Set<Module> & {plus: Set<Module>}} */\n      new Set(minAvailableModules);\n      resultingAvailableModules.plus = minAvailableModules.plus;\n    }\n\n    // add the modules from the chunk group to the set\n    var _iterator9 = _createForOfIteratorHelper(chunkGroupInfo.chunkGroup.chunks),\n      _step9;\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var _chunk = _step9.value;\n        var _iterator10 = _createForOfIteratorHelper(chunkGraph.getChunkModulesIterable(_chunk)),\n          _step10;\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var m = _step10.value;\n            resultingAvailableModules.add(m);\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n    return chunkGroupInfo.resultingAvailableModules = resultingAvailableModules;\n  };\n  var processConnectQueue = function processConnectQueue() {\n    // Figure out new parents for chunk groups\n    // to get new available modules for these children\n    var _iterator11 = _createForOfIteratorHelper(queueConnect),\n      _step11;\n    try {\n      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n        var _step11$value = _slicedToArray(_step11.value, 2),\n          _chunkGroupInfo4 = _step11$value[0],\n          targets = _step11$value[1];\n        // 1. Add new targets to the list of children\n        if (_chunkGroupInfo4.children === undefined) {\n          _chunkGroupInfo4.children = targets;\n        } else {\n          var _iterator12 = _createForOfIteratorHelper(targets),\n            _step12;\n          try {\n            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n              var target = _step12.value;\n              _chunkGroupInfo4.children.add(target);\n            }\n          } catch (err) {\n            _iterator12.e(err);\n          } finally {\n            _iterator12.f();\n          }\n        }\n\n        // 2. Calculate resulting available modules\n        var resultingAvailableModules = calculateResultingAvailableModules(_chunkGroupInfo4);\n        var runtime = _chunkGroupInfo4.runtime;\n\n        // 3. Update chunk group info\n        var _iterator13 = _createForOfIteratorHelper(targets),\n          _step13;\n        try {\n          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n            var _target = _step13.value;\n            _target.availableModulesToBeMerged.push(resultingAvailableModules);\n            chunkGroupsForMerging.add(_target);\n            var oldRuntime = _target.runtime;\n            var newRuntime = mergeRuntime(oldRuntime, runtime);\n            if (oldRuntime !== newRuntime) {\n              _target.runtime = newRuntime;\n              outdatedChunkGroupInfo.add(_target);\n            }\n          }\n        } catch (err) {\n          _iterator13.e(err);\n        } finally {\n          _iterator13.f();\n        }\n        statConnectedChunkGroups += targets.size;\n      }\n    } catch (err) {\n      _iterator11.e(err);\n    } finally {\n      _iterator11.f();\n    }\n    queueConnect.clear();\n  };\n  var processChunkGroupsForMerging = function processChunkGroupsForMerging() {\n    statProcessedChunkGroupsForMerging += chunkGroupsForMerging.size;\n\n    // Execute the merge\n    var _iterator14 = _createForOfIteratorHelper(chunkGroupsForMerging),\n      _step14;\n    try {\n      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n        var info = _step14.value;\n        var availableModulesToBeMerged = info.availableModulesToBeMerged;\n        var cachedMinAvailableModules = info.minAvailableModules;\n        statMergedAvailableModuleSets += availableModulesToBeMerged.length;\n\n        // 1. Get minimal available modules\n        // It doesn't make sense to traverse a chunk again with more available modules.\n        // This step calculates the minimal available modules and skips traversal when\n        // the list didn't shrink.\n        if (availableModulesToBeMerged.length > 1) {\n          availableModulesToBeMerged.sort(bySetSize);\n        }\n        var changed = false;\n        var _iterator15 = _createForOfIteratorHelper(availableModulesToBeMerged),\n          _step15;\n        try {\n          merge: for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n            var availableModules = _step15.value;\n            if (cachedMinAvailableModules === undefined) {\n              cachedMinAvailableModules = availableModules;\n              info.minAvailableModules = cachedMinAvailableModules;\n              info.minAvailableModulesOwned = false;\n              changed = true;\n            } else {\n              if (info.minAvailableModulesOwned) {\n                // We own it and can modify it\n                if (cachedMinAvailableModules.plus === availableModules.plus) {\n                  var _iterator16 = _createForOfIteratorHelper(cachedMinAvailableModules),\n                    _step16;\n                  try {\n                    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                      var m = _step16.value;\n                      if (!availableModules.has(m)) {\n                        cachedMinAvailableModules.delete(m);\n                        changed = true;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator16.e(err);\n                  } finally {\n                    _iterator16.f();\n                  }\n                } else {\n                  var _iterator17 = _createForOfIteratorHelper(cachedMinAvailableModules),\n                    _step17;\n                  try {\n                    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n                      var _m2 = _step17.value;\n                      if (!availableModules.has(_m2) && !availableModules.plus.has(_m2)) {\n                        cachedMinAvailableModules.delete(_m2);\n                        changed = true;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator17.e(err);\n                  } finally {\n                    _iterator17.f();\n                  }\n                  var _iterator18 = _createForOfIteratorHelper(cachedMinAvailableModules.plus),\n                    _step18;\n                  try {\n                    for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n                      var _m3 = _step18.value;\n                      if (!availableModules.has(_m3) && !availableModules.plus.has(_m3)) {\n                        // We can't remove modules from the plus part\n                        // so we need to merge plus into the normal part to allow modifying it\n                        var iterator = cachedMinAvailableModules.plus[Symbol.iterator]();\n                        // fast forward add all modules until m\n                        /** @type {IteratorResult<Module>} */\n                        var it = void 0;\n                        while (!(it = iterator.next()).done) {\n                          var _module2 = it.value;\n                          if (_module2 === _m3) break;\n                          cachedMinAvailableModules.add(_module2);\n                        }\n                        // check the remaining modules before adding\n                        while (!(it = iterator.next()).done) {\n                          var _module3 = it.value;\n                          if (availableModules.has(_module3) || availableModules.plus.has(_module3)) {\n                            cachedMinAvailableModules.add(_module3);\n                          }\n                        }\n                        cachedMinAvailableModules.plus = EMPTY_SET;\n                        changed = true;\n                        continue merge;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator18.e(err);\n                  } finally {\n                    _iterator18.f();\n                  }\n                }\n              } else if (cachedMinAvailableModules.plus === availableModules.plus) {\n                // Common and fast case when the plus part is shared\n                // We only need to care about the normal part\n                if (availableModules.size < cachedMinAvailableModules.size) {\n                  // the new availableModules is smaller so it's faster to\n                  // fork from the new availableModules\n                  statForkedAvailableModules++;\n                  statForkedAvailableModulesCount += availableModules.size;\n                  statForkedMergedModulesCount += cachedMinAvailableModules.size;\n                  // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n                  var newSet = /** @type {ModuleSetPlus} */new Set();\n                  newSet.plus = availableModules.plus;\n                  var _iterator19 = _createForOfIteratorHelper(availableModules),\n                    _step19;\n                  try {\n                    for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                      var _m4 = _step19.value;\n                      if (cachedMinAvailableModules.has(_m4)) {\n                        newSet.add(_m4);\n                      }\n                    }\n                  } catch (err) {\n                    _iterator19.e(err);\n                  } finally {\n                    _iterator19.f();\n                  }\n                  statForkedResultModulesCount += newSet.size;\n                  cachedMinAvailableModules = newSet;\n                  info.minAvailableModulesOwned = true;\n                  info.minAvailableModules = newSet;\n                  changed = true;\n                  continue merge;\n                }\n                var _iterator20 = _createForOfIteratorHelper(cachedMinAvailableModules),\n                  _step20;\n                try {\n                  for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                    var _m5 = _step20.value;\n                    if (!availableModules.has(_m5)) {\n                      // cachedMinAvailableModules need to be modified\n                      // but we don't own it\n                      statForkedAvailableModules++;\n                      statForkedAvailableModulesCount += cachedMinAvailableModules.size;\n                      statForkedMergedModulesCount += availableModules.size;\n                      // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n                      // as the plus part is equal we can just take over this one\n                      var _newSet = /** @type {ModuleSetPlus} */new Set();\n                      _newSet.plus = availableModules.plus;\n                      var _iterator21 = cachedMinAvailableModules[Symbol.iterator]();\n                      // fast forward add all modules until m\n                      /** @type {IteratorResult<Module>} */\n                      var _it = void 0;\n                      while (!(_it = _iterator21.next()).done) {\n                        var _module4 = _it.value;\n                        if (_module4 === _m5) break;\n                        _newSet.add(_module4);\n                      }\n                      // check the remaining modules before adding\n                      while (!(_it = _iterator21.next()).done) {\n                        var _module5 = _it.value;\n                        if (availableModules.has(_module5)) {\n                          _newSet.add(_module5);\n                        }\n                      }\n                      statForkedResultModulesCount += _newSet.size;\n                      cachedMinAvailableModules = _newSet;\n                      info.minAvailableModulesOwned = true;\n                      info.minAvailableModules = _newSet;\n                      changed = true;\n                      continue merge;\n                    }\n                  }\n                } catch (err) {\n                  _iterator20.e(err);\n                } finally {\n                  _iterator20.f();\n                }\n              } else {\n                var _iterator22 = _createForOfIteratorHelper(cachedMinAvailableModules),\n                  _step21;\n                try {\n                  for (_iterator22.s(); !(_step21 = _iterator22.n()).done;) {\n                    var _m6 = _step21.value;\n                    if (!availableModules.has(_m6) && !availableModules.plus.has(_m6)) {\n                      // cachedMinAvailableModules need to be modified\n                      // but we don't own it\n                      statForkedAvailableModules++;\n                      statForkedAvailableModulesCount += cachedMinAvailableModules.size;\n                      statForkedAvailableModulesCountPlus += cachedMinAvailableModules.plus.size;\n                      statForkedMergedModulesCount += availableModules.size;\n                      statForkedMergedModulesCountPlus += availableModules.plus.size;\n                      // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n                      var _newSet2 = /** @type {ModuleSetPlus} */new Set();\n                      _newSet2.plus = EMPTY_SET;\n                      var _iterator24 = cachedMinAvailableModules[Symbol.iterator]();\n                      // fast forward add all modules until m\n                      /** @type {IteratorResult<Module>} */\n                      var _it2 = void 0;\n                      while (!(_it2 = _iterator24.next()).done) {\n                        var _module6 = _it2.value;\n                        if (_module6 === _m6) break;\n                        _newSet2.add(_module6);\n                      }\n                      // check the remaining modules before adding\n                      while (!(_it2 = _iterator24.next()).done) {\n                        var _module7 = _it2.value;\n                        if (availableModules.has(_module7) || availableModules.plus.has(_module7)) {\n                          _newSet2.add(_module7);\n                        }\n                      }\n                      // also check all modules in cachedMinAvailableModules.plus\n                      var _iterator25 = _createForOfIteratorHelper(cachedMinAvailableModules.plus),\n                        _step23;\n                      try {\n                        for (_iterator25.s(); !(_step23 = _iterator25.n()).done;) {\n                          var _module8 = _step23.value;\n                          if (availableModules.has(_module8) || availableModules.plus.has(_module8)) {\n                            _newSet2.add(_module8);\n                          }\n                        }\n                      } catch (err) {\n                        _iterator25.e(err);\n                      } finally {\n                        _iterator25.f();\n                      }\n                      statForkedResultModulesCount += _newSet2.size;\n                      cachedMinAvailableModules = _newSet2;\n                      info.minAvailableModulesOwned = true;\n                      info.minAvailableModules = _newSet2;\n                      changed = true;\n                      continue merge;\n                    }\n                  }\n                } catch (err) {\n                  _iterator22.e(err);\n                } finally {\n                  _iterator22.f();\n                }\n                var _iterator23 = _createForOfIteratorHelper(cachedMinAvailableModules.plus),\n                  _step22;\n                try {\n                  for (_iterator23.s(); !(_step22 = _iterator23.n()).done;) {\n                    var _m7 = _step22.value;\n                    if (!availableModules.has(_m7) && !availableModules.plus.has(_m7)) {\n                      // cachedMinAvailableModules need to be modified\n                      // but we don't own it\n                      statForkedAvailableModules++;\n                      statForkedAvailableModulesCount += cachedMinAvailableModules.size;\n                      statForkedAvailableModulesCountPlus += cachedMinAvailableModules.plus.size;\n                      statForkedMergedModulesCount += availableModules.size;\n                      statForkedMergedModulesCountPlus += availableModules.plus.size;\n                      // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n                      // we already know that all modules directly from cachedMinAvailableModules are in availableModules too\n                      var _newSet3 = /** @type {ModuleSetPlus} */\n                      new Set(cachedMinAvailableModules);\n                      _newSet3.plus = EMPTY_SET;\n                      var _iterator26 = cachedMinAvailableModules.plus[Symbol.iterator]();\n                      // fast forward add all modules until m\n                      /** @type {IteratorResult<Module>} */\n                      var _it3 = void 0;\n                      while (!(_it3 = _iterator26.next()).done) {\n                        var _module9 = _it3.value;\n                        if (_module9 === _m7) break;\n                        _newSet3.add(_module9);\n                      }\n                      // check the remaining modules before adding\n                      while (!(_it3 = _iterator26.next()).done) {\n                        var _module10 = _it3.value;\n                        if (availableModules.has(_module10) || availableModules.plus.has(_module10)) {\n                          _newSet3.add(_module10);\n                        }\n                      }\n                      statForkedResultModulesCount += _newSet3.size;\n                      cachedMinAvailableModules = _newSet3;\n                      info.minAvailableModulesOwned = true;\n                      info.minAvailableModules = _newSet3;\n                      changed = true;\n                      continue merge;\n                    }\n                  }\n                } catch (err) {\n                  _iterator23.e(err);\n                } finally {\n                  _iterator23.f();\n                }\n              }\n            }\n          }\n        } catch (err) {\n          _iterator15.e(err);\n        } finally {\n          _iterator15.f();\n        }\n        availableModulesToBeMerged.length = 0;\n        if (changed) {\n          info.resultingAvailableModules = undefined;\n          outdatedChunkGroupInfo.add(info);\n        }\n      }\n    } catch (err) {\n      _iterator14.e(err);\n    } finally {\n      _iterator14.f();\n    }\n    chunkGroupsForMerging.clear();\n  };\n  var processChunkGroupsForCombining = function processChunkGroupsForCombining() {\n    var _iterator27 = _createForOfIteratorHelper(chunkGroupsForCombining),\n      _step24;\n    try {\n      for (_iterator27.s(); !(_step24 = _iterator27.n()).done;) {\n        var info = _step24.value;\n        var _iterator29 = _createForOfIteratorHelper(info.availableSources),\n          _step26;\n        try {\n          for (_iterator29.s(); !(_step26 = _iterator29.n()).done;) {\n            var source = _step26.value;\n            if (!source.minAvailableModules) {\n              chunkGroupsForCombining.delete(info);\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator29.e(err);\n        } finally {\n          _iterator29.f();\n        }\n      }\n    } catch (err) {\n      _iterator27.e(err);\n    } finally {\n      _iterator27.f();\n    }\n    var _iterator28 = _createForOfIteratorHelper(chunkGroupsForCombining),\n      _step25;\n    try {\n      var _loop = function _loop() {\n        var info = _step25.value;\n        var availableModules = /** @type {ModuleSetPlus} */new Set();\n        availableModules.plus = EMPTY_SET;\n        var mergeSet = function mergeSet(set) {\n          if (set.size > availableModules.plus.size) {\n            var _iterator30 = _createForOfIteratorHelper(availableModules.plus),\n              _step27;\n            try {\n              for (_iterator30.s(); !(_step27 = _iterator30.n()).done;) {\n                var item = _step27.value;\n                availableModules.add(item);\n              }\n            } catch (err) {\n              _iterator30.e(err);\n            } finally {\n              _iterator30.f();\n            }\n            availableModules.plus = set;\n          } else {\n            var _iterator31 = _createForOfIteratorHelper(set),\n              _step28;\n            try {\n              for (_iterator31.s(); !(_step28 = _iterator31.n()).done;) {\n                var _item = _step28.value;\n                availableModules.add(_item);\n              }\n            } catch (err) {\n              _iterator31.e(err);\n            } finally {\n              _iterator31.f();\n            }\n          }\n        };\n        // combine minAvailableModules from all resultingAvailableModules\n        var _iterator32 = _createForOfIteratorHelper(info.availableSources),\n          _step29;\n        try {\n          for (_iterator32.s(); !(_step29 = _iterator32.n()).done;) {\n            var _source = _step29.value;\n            var resultingAvailableModules = calculateResultingAvailableModules(_source);\n            mergeSet(resultingAvailableModules);\n            mergeSet(resultingAvailableModules.plus);\n          }\n        } catch (err) {\n          _iterator32.e(err);\n        } finally {\n          _iterator32.f();\n        }\n        info.minAvailableModules = availableModules;\n        info.minAvailableModulesOwned = false;\n        info.resultingAvailableModules = undefined;\n        outdatedChunkGroupInfo.add(info);\n      };\n      for (_iterator28.s(); !(_step25 = _iterator28.n()).done;) {\n        _loop();\n      }\n    } catch (err) {\n      _iterator28.e(err);\n    } finally {\n      _iterator28.f();\n    }\n    chunkGroupsForCombining.clear();\n  };\n  var processOutdatedChunkGroupInfo = function processOutdatedChunkGroupInfo() {\n    statChunkGroupInfoUpdated += outdatedChunkGroupInfo.size;\n    // Revisit skipped elements\n    var _iterator33 = _createForOfIteratorHelper(outdatedChunkGroupInfo),\n      _step30;\n    try {\n      for (_iterator33.s(); !(_step30 = _iterator33.n()).done;) {\n        var info = _step30.value;\n        // 1. Reconsider skipped items\n        if (info.skippedItems !== undefined) {\n          var minAvailableModules = info.minAvailableModules;\n          var _iterator34 = _createForOfIteratorHelper(info.skippedItems),\n            _step31;\n          try {\n            for (_iterator34.s(); !(_step31 = _iterator34.n()).done;) {\n              var _module11 = _step31.value;\n              if (!minAvailableModules.has(_module11) && !minAvailableModules.plus.has(_module11)) {\n                queue.push({\n                  action: ADD_AND_ENTER_MODULE,\n                  block: _module11,\n                  module: _module11,\n                  chunk: info.chunkGroup.chunks[0],\n                  chunkGroup: info.chunkGroup,\n                  chunkGroupInfo: info\n                });\n                info.skippedItems.delete(_module11);\n              }\n            }\n          } catch (err) {\n            _iterator34.e(err);\n          } finally {\n            _iterator34.f();\n          }\n        }\n\n        // 2. Reconsider skipped connections\n        if (info.skippedModuleConnections !== undefined) {\n          var _minAvailableModules = info.minAvailableModules;\n          var _iterator35 = _createForOfIteratorHelper(info.skippedModuleConnections),\n            _step32;\n          try {\n            for (_iterator35.s(); !(_step32 = _iterator35.n()).done;) {\n              var entry = _step32.value;\n              var _entry = _slicedToArray(entry, 2),\n                _module12 = _entry[0],\n                activeState = _entry[1];\n              if (activeState === false) continue;\n              if (activeState === true) {\n                info.skippedModuleConnections.delete(entry);\n              }\n              if (activeState === true && (_minAvailableModules.has(_module12) || _minAvailableModules.plus.has(_module12))) {\n                info.skippedItems.add(_module12);\n                continue;\n              }\n              queue.push({\n                action: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n                block: _module12,\n                module: _module12,\n                chunk: info.chunkGroup.chunks[0],\n                chunkGroup: info.chunkGroup,\n                chunkGroupInfo: info\n              });\n            }\n          } catch (err) {\n            _iterator35.e(err);\n          } finally {\n            _iterator35.f();\n          }\n        }\n\n        // 2. Reconsider children chunk groups\n        if (info.children !== undefined) {\n          statChildChunkGroupsReconnected += info.children.size;\n          var _iterator36 = _createForOfIteratorHelper(info.children),\n            _step33;\n          try {\n            for (_iterator36.s(); !(_step33 = _iterator36.n()).done;) {\n              var cgi = _step33.value;\n              var connectList = queueConnect.get(info);\n              if (connectList === undefined) {\n                connectList = new Set();\n                queueConnect.set(info, connectList);\n              }\n              connectList.add(cgi);\n            }\n          } catch (err) {\n            _iterator36.e(err);\n          } finally {\n            _iterator36.f();\n          }\n        }\n\n        // 3. Reconsider chunk groups for combining\n        if (info.availableChildren !== undefined) {\n          var _iterator37 = _createForOfIteratorHelper(info.availableChildren),\n            _step34;\n          try {\n            for (_iterator37.s(); !(_step34 = _iterator37.n()).done;) {\n              var _cgi = _step34.value;\n              chunkGroupsForCombining.add(_cgi);\n            }\n          } catch (err) {\n            _iterator37.e(err);\n          } finally {\n            _iterator37.f();\n          }\n        }\n      }\n    } catch (err) {\n      _iterator33.e(err);\n    } finally {\n      _iterator33.f();\n    }\n    outdatedChunkGroupInfo.clear();\n  };\n\n  // Iterative traversal of the Module graph\n  // Recursive would be simpler to write but could result in Stack Overflows\n  while (queue.length || queueConnect.size) {\n    logger.time(\"visitModules: visiting\");\n    processQueue();\n    logger.timeAggregateEnd(\"visitModules: prepare\");\n    logger.timeEnd(\"visitModules: visiting\");\n    if (chunkGroupsForCombining.size > 0) {\n      logger.time(\"visitModules: combine available modules\");\n      processChunkGroupsForCombining();\n      logger.timeEnd(\"visitModules: combine available modules\");\n    }\n    if (queueConnect.size > 0) {\n      logger.time(\"visitModules: calculating available modules\");\n      processConnectQueue();\n      logger.timeEnd(\"visitModules: calculating available modules\");\n      if (chunkGroupsForMerging.size > 0) {\n        logger.time(\"visitModules: merging available modules\");\n        processChunkGroupsForMerging();\n        logger.timeEnd(\"visitModules: merging available modules\");\n      }\n    }\n    if (outdatedChunkGroupInfo.size > 0) {\n      logger.time(\"visitModules: check modules for revisit\");\n      processOutdatedChunkGroupInfo();\n      logger.timeEnd(\"visitModules: check modules for revisit\");\n    }\n\n    // Run queueDelayed when all items of the queue are processed\n    // This is important to get the global indexing correct\n    // Async blocks should be processed after all sync blocks are processed\n    if (queue.length === 0) {\n      var tempQueue = queue;\n      queue = queueDelayed.reverse();\n      queueDelayed = tempQueue;\n    }\n  }\n  logger.log(\"\".concat(statProcessedQueueItems, \" queue items processed (\").concat(statProcessedBlocks, \" blocks)\"));\n  logger.log(\"\".concat(statConnectedChunkGroups, \" chunk groups connected\"));\n  logger.log(\"\".concat(statProcessedChunkGroupsForMerging, \" chunk groups processed for merging (\").concat(statMergedAvailableModuleSets, \" module sets, \").concat(statForkedAvailableModules, \" forked, \").concat(statForkedAvailableModulesCount, \" + \").concat(statForkedAvailableModulesCountPlus, \" modules forked, \").concat(statForkedMergedModulesCount, \" + \").concat(statForkedMergedModulesCountPlus, \" modules merged into fork, \").concat(statForkedResultModulesCount, \" resulting modules)\"));\n  logger.log(\"\".concat(statChunkGroupInfoUpdated, \" chunk group info updated (\").concat(statChildChunkGroupsReconnected, \" already connected chunk groups reconnected)\"));\n};\n\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\nvar connectChunkGroups = function connectChunkGroups(compilation, blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap) {\n  var chunkGraph = compilation.chunkGraph;\n\n  /**\n   * Helper function to check if all modules of a chunk are available\n   *\n   * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n   * @param {ModuleSetPlus} availableModules the comparator set\n   * @returns {boolean} return true if all modules of a chunk are available\n   */\n  var areModulesAvailable = function areModulesAvailable(chunkGroup, availableModules) {\n    var _iterator41 = _createForOfIteratorHelper(chunkGroup.chunks),\n      _step38;\n    try {\n      for (_iterator41.s(); !(_step38 = _iterator41.n()).done;) {\n        var chunk = _step38.value;\n        var _iterator42 = _createForOfIteratorHelper(chunkGraph.getChunkModulesIterable(chunk)),\n          _step39;\n        try {\n          for (_iterator42.s(); !(_step39 = _iterator42.n()).done;) {\n            var _module15 = _step39.value;\n            if (!availableModules.has(_module15) && !availableModules.plus.has(_module15)) return false;\n          }\n        } catch (err) {\n          _iterator42.e(err);\n        } finally {\n          _iterator42.f();\n        }\n      }\n    } catch (err) {\n      _iterator41.e(err);\n    } finally {\n      _iterator41.f();\n    }\n    return true;\n  };\n\n  // For each edge in the basic chunk graph\n  var _iterator43 = _createForOfIteratorHelper(blockConnections),\n    _step40;\n  try {\n    for (_iterator43.s(); !(_step40 = _iterator43.n()).done;) {\n      var _step40$value = _slicedToArray(_step40.value, 2),\n        block = _step40$value[0],\n        connections = _step40$value[1];\n      // 1. Check if connection is needed\n      // When none of the dependencies need to be connected\n      // we can skip all of them\n      // It's not possible to filter each item so it doesn't create inconsistent\n      // connections and modules can only create one version\n      // TODO maybe decide this per runtime\n      if (\n      // TODO is this needed?\n      !blocksWithNestedBlocks.has(block) && connections.every(function (_ref) {\n        var chunkGroup = _ref.chunkGroup,\n          originChunkGroupInfo = _ref.originChunkGroupInfo;\n        return areModulesAvailable(chunkGroup, originChunkGroupInfo.resultingAvailableModules);\n      })) {\n        continue;\n      }\n\n      // 2. Foreach edge\n      for (var i = 0; i < connections.length; i++) {\n        var _connections$i = connections[i],\n          chunkGroup = _connections$i.chunkGroup,\n          originChunkGroupInfo = _connections$i.originChunkGroupInfo;\n\n        // 3. Connect block with chunk\n        chunkGraph.connectBlockAndChunkGroup(block, chunkGroup);\n\n        // 4. Connect chunk with parent\n        connectChunkGroupParentAndChild(originChunkGroupInfo.chunkGroup, chunkGroup);\n      }\n    }\n  } catch (err) {\n    _iterator43.e(err);\n  } finally {\n    _iterator43.f();\n  }\n};\n\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\nvar cleanupUnconnectedGroups = function cleanupUnconnectedGroups(compilation, allCreatedChunkGroups) {\n  var chunkGraph = compilation.chunkGraph;\n  var _iterator44 = _createForOfIteratorHelper(allCreatedChunkGroups),\n    _step41;\n  try {\n    for (_iterator44.s(); !(_step41 = _iterator44.n()).done;) {\n      var chunkGroup = _step41.value;\n      if (chunkGroup.getNumberOfParents() === 0) {\n        var _iterator45 = _createForOfIteratorHelper(chunkGroup.chunks),\n          _step42;\n        try {\n          for (_iterator45.s(); !(_step42 = _iterator45.n()).done;) {\n            var chunk = _step42.value;\n            compilation.chunks.delete(chunk);\n            chunkGraph.disconnectChunk(chunk);\n          }\n        } catch (err) {\n          _iterator45.e(err);\n        } finally {\n          _iterator45.f();\n        }\n        chunkGraph.disconnectChunkGroup(chunkGroup);\n        chunkGroup.remove();\n      }\n    }\n  } catch (err) {\n    _iterator44.e(err);\n  } finally {\n    _iterator44.f();\n  }\n};\n\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @returns {void}\n */\nvar buildChunkGraph = function buildChunkGraph(compilation, inputEntrypointsAndModules) {\n  var logger = compilation.getLogger(\"webpack.buildChunkGraph\");\n\n  // SHARED STATE\n\n  /** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */\n  var blockConnections = new Map();\n\n  /** @type {Set<ChunkGroup>} */\n  var allCreatedChunkGroups = new Set();\n\n  /** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n  var chunkGroupInfoMap = new Map();\n\n  /** @type {Set<DependenciesBlock>} */\n  var blocksWithNestedBlocks = new Set();\n\n  // PART ONE\n\n  logger.time(\"visitModules\");\n  visitModules(logger, compilation, inputEntrypointsAndModules, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups);\n  logger.timeEnd(\"visitModules\");\n\n  // PART TWO\n\n  logger.time(\"connectChunkGroups\");\n  connectChunkGroups(compilation, blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap);\n  logger.timeEnd(\"connectChunkGroups\");\n  var _iterator46 = _createForOfIteratorHelper(chunkGroupInfoMap),\n    _step43;\n  try {\n    for (_iterator46.s(); !(_step43 = _iterator46.n()).done;) {\n      var _step43$value = _slicedToArray(_step43.value, 2),\n        chunkGroup = _step43$value[0],\n        chunkGroupInfo = _step43$value[1];\n      var _iterator47 = _createForOfIteratorHelper(chunkGroup.chunks),\n        _step44;\n      try {\n        for (_iterator47.s(); !(_step44 = _iterator47.n()).done;) {\n          var chunk = _step44.value;\n          chunk.runtime = mergeRuntime(chunk.runtime, chunkGroupInfo.runtime);\n        }\n      } catch (err) {\n        _iterator47.e(err);\n      } finally {\n        _iterator47.f();\n      }\n    }\n\n    // Cleanup work\n  } catch (err) {\n    _iterator46.e(err);\n  } finally {\n    _iterator46.f();\n  }\n  logger.time(\"cleanup\");\n  cleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n  logger.timeEnd(\"cleanup\");\n};\nmodule.exports = buildChunkGraph;","map":{"version":3,"names":["AsyncDependencyToInitialChunkError","require","connectChunkGroupParentAndChild","ModuleGraphConnection","getEntryRuntime","mergeRuntime","EMPTY_SET","Set","plus","bySetSize","a","b","size","extractBlockModules","module","moduleGraph","runtime","blockModulesMap","blockCache","modules","arrays","queue","length","block","pop","arr","push","set","blocks","getOutgoingConnections","connection","d","dependency","m","weak","state","getActiveState","getParentBlock","index","getParentBlockIndex","dependencies","indexOf","get","i","indexMap","outer","j","undefined","merged","addConnectionStates","Map","idx","visitModules","logger","compilation","inputEntrypointsAndModules","chunkGroupInfoMap","blockConnections","blocksWithNestedBlocks","allCreatedChunkGroups","chunkGraph","moduleMemCaches","blockModulesRuntimeMap","blockModulesMapRuntime","getBlockModules","blockModules","getRootBlock","memCache","map","provide","time","timeAggregate","statProcessedQueueItems","statProcessedBlocks","statConnectedChunkGroups","statProcessedChunkGroupsForMerging","statMergedAvailableModuleSets","statForkedAvailableModules","statForkedAvailableModulesCount","statForkedAvailableModulesCountPlus","statForkedMergedModulesCount","statForkedMergedModulesCountPlus","statForkedResultModulesCount","statChunkGroupInfoUpdated","statChildChunkGroupsReconnected","nextChunkGroupIndex","nextFreeModulePreOrderIndex","nextFreeModulePostOrderIndex","blockChunkGroups","namedChunkGroups","namedAsyncEntrypoints","ADD_AND_ENTER_ENTRY_MODULE","ADD_AND_ENTER_MODULE","ENTER_MODULE","PROCESS_BLOCK","PROCESS_ENTRY_BLOCK","LEAVE_MODULE","queueConnect","chunkGroupsForCombining","chunkGroup","name","options","chunkGroupInfo","minAvailableModules","minAvailableModulesOwned","availableModulesToBeMerged","skippedItems","resultingAvailableModules","children","availableSources","availableChildren","preOrderIndex","postOrderIndex","chunkLoading","outputOptions","asyncChunks","getNumberOfParents","add","chunk","getEntrypointChunk","action","parentsIterable","parent","parentChunkGroupInfo","reverse","outdatedChunkGroupInfo","chunkGroupsForMerging","queueDelayed","skipConnectionBuffer","skipBuffer","queueBuffer","iteratorBlock","cgi","c","entrypoint","entryOptions","groupOptions","chunkName","addAsyncEntrypoint","loc","request","connectBlockAndChunkGroup","addOrigin","chunks","addChunkInGroup","isInitial","errors","addOptions","originChunkGroupInfo","connectList","processBlock","refModule","isModuleInChunk","activeState","has","skippedModuleConnections","processEntryBlock","processQueue","queueItem","connectChunkAndEntryModule","connectChunkAndModule","getModulePreOrderIndex","setModulePreOrderIndex","setPreOrderIndexIfUnset","getModulePostOrderIndex","setModulePostOrderIndex","setPostOrderIndexIfUnset","calculateResultingAvailableModules","getChunkModulesIterable","processConnectQueue","targets","target","oldRuntime","newRuntime","clear","processChunkGroupsForMerging","info","cachedMinAvailableModules","sort","changed","merge","availableModules","delete","iterator","Symbol","it","next","done","value","newSet","processChunkGroupsForCombining","source","mergeSet","item","processOutdatedChunkGroupInfo","entry","timeAggregateEnd","timeEnd","tempQueue","log","connectChunkGroups","areModulesAvailable","connections","every","cleanupUnconnectedGroups","disconnectChunk","disconnectChunkGroup","remove","buildChunkGraph","getLogger","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/buildChunkGraph.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\nconst { connectChunkGroupParentAndChild } = require(\"./GraphHelpers\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst { getEntryRuntime, mergeRuntime } = require(\"./util/runtime\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n * @property {ChunkGroupInfo} chunkGroupInfo\n */\n\n/** @typedef {Set<Module> & { plus: Set<Module> }} ModuleSetPlus */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {RuntimeSpec} runtime the runtimes\n * @property {ModuleSetPlus} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {ModuleSetPlus[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {Set<Module>=} skippedItems modules that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<[Module, ConnectionState]>=} skippedModuleConnections referenced modules that where skipped because they were not active in this runtime\n * @property {ModuleSetPlus} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroupInfo>} children set of children chunk groups, that will be revisited when availableModules shrink\n * @property {Set<ChunkGroupInfo>} availableSources set of chunk groups that are the source for minAvailableModules\n * @property {Set<ChunkGroupInfo>} availableChildren set of chunk groups which depend on the this chunk group as availableSource\n * @property {number} preOrderIndex next pre order index\n * @property {number} postOrderIndex next post order index\n * @property {boolean} chunkLoading has a chunk loading mechanism\n * @property {boolean} asyncChunks create async chunks\n */\n\n/**\n * @typedef {Object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\nconst EMPTY_SET = /** @type {ModuleSetPlus} */ (new Set());\nEMPTY_SET.plus = EMPTY_SET;\n\n/**\n * @param {ModuleSetPlus} a first set\n * @param {ModuleSetPlus} b second set\n * @returns {number} cmp\n */\nconst bySetSize = (a, b) => {\n\treturn b.size + b.plus.size - a.size - a.plus.size;\n};\n\nconst extractBlockModules = (module, moduleGraph, runtime, blockModulesMap) => {\n\tlet blockCache;\n\tlet modules;\n\n\tconst arrays = [];\n\n\tconst queue = [module];\n\twhile (queue.length > 0) {\n\t\tconst block = queue.pop();\n\t\tconst arr = [];\n\t\tarrays.push(arr);\n\t\tblockModulesMap.set(block, arr);\n\t\tfor (const b of block.blocks) {\n\t\t\tqueue.push(b);\n\t\t}\n\t}\n\n\tfor (const connection of moduleGraph.getOutgoingConnections(module)) {\n\t\tconst d = connection.dependency;\n\t\t// We skip connections without dependency\n\t\tif (!d) continue;\n\t\tconst m = connection.module;\n\t\t// We skip connections without Module pointer\n\t\tif (!m) continue;\n\t\t// We skip weak connections\n\t\tif (connection.weak) continue;\n\t\tconst state = connection.getActiveState(runtime);\n\t\t// We skip inactive connections\n\t\tif (state === false) continue;\n\n\t\tconst block = moduleGraph.getParentBlock(d);\n\t\tlet index = moduleGraph.getParentBlockIndex(d);\n\n\t\t// deprecated fallback\n\t\tif (index < 0) {\n\t\t\tindex = block.dependencies.indexOf(d);\n\t\t}\n\n\t\tif (blockCache !== block) {\n\t\t\tmodules = blockModulesMap.get((blockCache = block));\n\t\t}\n\n\t\tconst i = index << 2;\n\t\tmodules[i] = m;\n\t\tmodules[i + 1] = state;\n\t}\n\n\tfor (const modules of arrays) {\n\t\tif (modules.length === 0) continue;\n\t\tlet indexMap;\n\t\tlet length = 0;\n\t\touter: for (let j = 0; j < modules.length; j += 2) {\n\t\t\tconst m = modules[j];\n\t\t\tif (m === undefined) continue;\n\t\t\tconst state = modules[j + 1];\n\t\t\tif (indexMap === undefined) {\n\t\t\t\tlet i = 0;\n\t\t\t\tfor (; i < length; i += 2) {\n\t\t\t\t\tif (modules[i] === m) {\n\t\t\t\t\t\tconst merged = modules[i + 1];\n\t\t\t\t\t\tif (merged === true) continue outer;\n\t\t\t\t\t\tmodules[i + 1] = ModuleGraphConnection.addConnectionStates(\n\t\t\t\t\t\t\tmerged,\n\t\t\t\t\t\t\tstate\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmodules[length] = m;\n\t\t\t\tlength++;\n\t\t\t\tmodules[length] = state;\n\t\t\t\tlength++;\n\t\t\t\tif (length > 30) {\n\t\t\t\t\t// To avoid worse case performance, we will use an index map for\n\t\t\t\t\t// linear cost access, which allows to maintain O(n) complexity\n\t\t\t\t\t// while keeping allocations down to a minimum\n\t\t\t\t\tindexMap = new Map();\n\t\t\t\t\tfor (let i = 0; i < length; i += 2) {\n\t\t\t\t\t\tindexMap.set(modules[i], i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst idx = indexMap.get(m);\n\t\t\t\tif (idx !== undefined) {\n\t\t\t\t\tconst merged = modules[idx];\n\t\t\t\t\tif (merged === true) continue outer;\n\t\t\t\t\tmodules[idx] = ModuleGraphConnection.addConnectionStates(\n\t\t\t\t\t\tmerged,\n\t\t\t\t\t\tstate\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tmodules[length] = m;\n\t\t\t\t\tlength++;\n\t\t\t\t\tmodules[length] = state;\n\t\t\t\t\tindexMap.set(m, length);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmodules.length = length;\n\t}\n};\n\n/**\n *\n * @param {Logger} logger a logger\n * @param {Compilation} compilation the compilation\n * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\nconst visitModules = (\n\tlogger,\n\tcompilation,\n\tinputEntrypointsAndModules,\n\tchunkGroupInfoMap,\n\tblockConnections,\n\tblocksWithNestedBlocks,\n\tallCreatedChunkGroups\n) => {\n\tconst { moduleGraph, chunkGraph, moduleMemCaches } = compilation;\n\n\tconst blockModulesRuntimeMap = new Map();\n\n\t/** @type {RuntimeSpec | false} */\n\tlet blockModulesMapRuntime = false;\n\tlet blockModulesMap;\n\n\t/**\n\t *\n\t * @param {DependenciesBlock} block block\n\t * @param {RuntimeSpec} runtime runtime\n\t * @returns {(Module | ConnectionState)[]} block modules in flatten tuples\n\t */\n\tconst getBlockModules = (block, runtime) => {\n\t\tif (blockModulesMapRuntime !== runtime) {\n\t\t\tblockModulesMap = blockModulesRuntimeMap.get(runtime);\n\t\t\tif (blockModulesMap === undefined) {\n\t\t\t\tblockModulesMap = new Map();\n\t\t\t\tblockModulesRuntimeMap.set(runtime, blockModulesMap);\n\t\t\t}\n\t\t}\n\t\tlet blockModules = blockModulesMap.get(block);\n\t\tif (blockModules !== undefined) return blockModules;\n\t\tconst module = /** @type {Module} */ (block.getRootBlock());\n\t\tconst memCache = moduleMemCaches && moduleMemCaches.get(module);\n\t\tif (memCache !== undefined) {\n\t\t\tconst map = memCache.provide(\n\t\t\t\t\"bundleChunkGraph.blockModules\",\n\t\t\t\truntime,\n\t\t\t\t() => {\n\t\t\t\t\tlogger.time(\"visitModules: prepare\");\n\t\t\t\t\tconst map = new Map();\n\t\t\t\t\textractBlockModules(module, moduleGraph, runtime, map);\n\t\t\t\t\tlogger.timeAggregate(\"visitModules: prepare\");\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\t\t\t);\n\t\t\tfor (const [block, blockModules] of map)\n\t\t\t\tblockModulesMap.set(block, blockModules);\n\t\t\treturn map.get(block);\n\t\t} else {\n\t\t\tlogger.time(\"visitModules: prepare\");\n\t\t\textractBlockModules(module, moduleGraph, runtime, blockModulesMap);\n\t\t\tblockModules = blockModulesMap.get(block);\n\t\t\tlogger.timeAggregate(\"visitModules: prepare\");\n\t\t\treturn blockModules;\n\t\t}\n\t};\n\n\tlet statProcessedQueueItems = 0;\n\tlet statProcessedBlocks = 0;\n\tlet statConnectedChunkGroups = 0;\n\tlet statProcessedChunkGroupsForMerging = 0;\n\tlet statMergedAvailableModuleSets = 0;\n\tlet statForkedAvailableModules = 0;\n\tlet statForkedAvailableModulesCount = 0;\n\tlet statForkedAvailableModulesCountPlus = 0;\n\tlet statForkedMergedModulesCount = 0;\n\tlet statForkedMergedModulesCountPlus = 0;\n\tlet statForkedResultModulesCount = 0;\n\tlet statChunkGroupInfoUpdated = 0;\n\tlet statChildChunkGroupsReconnected = 0;\n\n\tlet nextChunkGroupIndex = 0;\n\tlet nextFreeModulePreOrderIndex = 0;\n\tlet nextFreeModulePostOrderIndex = 0;\n\n\t/** @type {Map<DependenciesBlock, ChunkGroupInfo>} */\n\tconst blockChunkGroups = new Map();\n\n\t/** @type {Map<string, ChunkGroupInfo>} */\n\tconst namedChunkGroups = new Map();\n\n\t/** @type {Map<string, ChunkGroupInfo>} */\n\tconst namedAsyncEntrypoints = new Map();\n\n\tconst ADD_AND_ENTER_ENTRY_MODULE = 0;\n\tconst ADD_AND_ENTER_MODULE = 1;\n\tconst ENTER_MODULE = 2;\n\tconst PROCESS_BLOCK = 3;\n\tconst PROCESS_ENTRY_BLOCK = 4;\n\tconst LEAVE_MODULE = 5;\n\n\t/** @type {QueueItem[]} */\n\tlet queue = [];\n\n\t/** @type {Map<ChunkGroupInfo, Set<ChunkGroupInfo>>} */\n\tconst queueConnect = new Map();\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst chunkGroupsForCombining = new Set();\n\n\t// Fill queue with entrypoint modules\n\t// Create ChunkGroupInfo for entrypoints\n\tfor (const [chunkGroup, modules] of inputEntrypointsAndModules) {\n\t\tconst runtime = getEntryRuntime(\n\t\t\tcompilation,\n\t\t\tchunkGroup.name,\n\t\t\tchunkGroup.options\n\t\t);\n\t\t/** @type {ChunkGroupInfo} */\n\t\tconst chunkGroupInfo = {\n\t\t\tchunkGroup,\n\t\t\truntime,\n\t\t\tminAvailableModules: undefined,\n\t\t\tminAvailableModulesOwned: false,\n\t\t\tavailableModulesToBeMerged: [],\n\t\t\tskippedItems: undefined,\n\t\t\tresultingAvailableModules: undefined,\n\t\t\tchildren: undefined,\n\t\t\tavailableSources: undefined,\n\t\t\tavailableChildren: undefined,\n\t\t\tpreOrderIndex: 0,\n\t\t\tpostOrderIndex: 0,\n\t\t\tchunkLoading:\n\t\t\t\tchunkGroup.options.chunkLoading !== undefined\n\t\t\t\t\t? chunkGroup.options.chunkLoading !== false\n\t\t\t\t\t: compilation.outputOptions.chunkLoading !== false,\n\t\t\tasyncChunks:\n\t\t\t\tchunkGroup.options.asyncChunks !== undefined\n\t\t\t\t\t? chunkGroup.options.asyncChunks\n\t\t\t\t\t: compilation.outputOptions.asyncChunks !== false\n\t\t};\n\t\tchunkGroup.index = nextChunkGroupIndex++;\n\t\tif (chunkGroup.getNumberOfParents() > 0) {\n\t\t\t// minAvailableModules for child entrypoints are unknown yet, set to undefined.\n\t\t\t// This means no module is added until other sets are merged into\n\t\t\t// this minAvailableModules (by the parent entrypoints)\n\t\t\tconst skippedItems = new Set();\n\t\t\tfor (const module of modules) {\n\t\t\t\tskippedItems.add(module);\n\t\t\t}\n\t\t\tchunkGroupInfo.skippedItems = skippedItems;\n\t\t\tchunkGroupsForCombining.add(chunkGroupInfo);\n\t\t} else {\n\t\t\t// The application may start here: We start with an empty list of available modules\n\t\t\tchunkGroupInfo.minAvailableModules = EMPTY_SET;\n\t\t\tconst chunk = chunkGroup.getEntrypointChunk();\n\t\t\tfor (const module of modules) {\n\t\t\t\tqueue.push({\n\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\tblock: module,\n\t\t\t\t\tmodule,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tchunkGroupInfoMap.set(chunkGroup, chunkGroupInfo);\n\t\tif (chunkGroup.name) {\n\t\t\tnamedChunkGroups.set(chunkGroup.name, chunkGroupInfo);\n\t\t}\n\t}\n\t// Fill availableSources with parent-child dependencies between entrypoints\n\tfor (const chunkGroupInfo of chunkGroupsForCombining) {\n\t\tconst { chunkGroup } = chunkGroupInfo;\n\t\tchunkGroupInfo.availableSources = new Set();\n\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\tconst parentChunkGroupInfo = chunkGroupInfoMap.get(parent);\n\t\t\tchunkGroupInfo.availableSources.add(parentChunkGroupInfo);\n\t\t\tif (parentChunkGroupInfo.availableChildren === undefined) {\n\t\t\t\tparentChunkGroupInfo.availableChildren = new Set();\n\t\t\t}\n\t\t\tparentChunkGroupInfo.availableChildren.add(chunkGroupInfo);\n\t\t}\n\t}\n\t// pop() is used to read from the queue\n\t// so it need to be reversed to be iterated in\n\t// correct order\n\tqueue.reverse();\n\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst outdatedChunkGroupInfo = new Set();\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst chunkGroupsForMerging = new Set();\n\t/** @type {QueueItem[]} */\n\tlet queueDelayed = [];\n\n\t/** @type {[Module, ConnectionState][]} */\n\tconst skipConnectionBuffer = [];\n\t/** @type {Module[]} */\n\tconst skipBuffer = [];\n\t/** @type {QueueItem[]} */\n\tconst queueBuffer = [];\n\n\t/** @type {Module} */\n\tlet module;\n\t/** @type {Chunk} */\n\tlet chunk;\n\t/** @type {ChunkGroup} */\n\tlet chunkGroup;\n\t/** @type {DependenciesBlock} */\n\tlet block;\n\t/** @type {ChunkGroupInfo} */\n\tlet chunkGroupInfo;\n\n\t// For each async Block in graph\n\t/**\n\t * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n\t * @returns {void}\n\t */\n\tconst iteratorBlock = b => {\n\t\t// 1. We create a chunk group with single chunk in it for this Block\n\t\t// but only once (blockChunkGroups map)\n\t\tlet cgi = blockChunkGroups.get(b);\n\t\t/** @type {ChunkGroup} */\n\t\tlet c;\n\t\t/** @type {Entrypoint} */\n\t\tlet entrypoint;\n\t\tconst entryOptions = b.groupOptions && b.groupOptions.entryOptions;\n\t\tif (cgi === undefined) {\n\t\t\tconst chunkName = (b.groupOptions && b.groupOptions.name) || b.chunkName;\n\t\t\tif (entryOptions) {\n\t\t\t\tcgi = namedAsyncEntrypoints.get(chunkName);\n\t\t\t\tif (!cgi) {\n\t\t\t\t\tentrypoint = compilation.addAsyncEntrypoint(\n\t\t\t\t\t\tentryOptions,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tb.loc,\n\t\t\t\t\t\tb.request\n\t\t\t\t\t);\n\t\t\t\t\tentrypoint.index = nextChunkGroupIndex++;\n\t\t\t\t\tcgi = {\n\t\t\t\t\t\tchunkGroup: entrypoint,\n\t\t\t\t\t\truntime: entrypoint.options.runtime || entrypoint.name,\n\t\t\t\t\t\tminAvailableModules: EMPTY_SET,\n\t\t\t\t\t\tminAvailableModulesOwned: false,\n\t\t\t\t\t\tavailableModulesToBeMerged: [],\n\t\t\t\t\t\tskippedItems: undefined,\n\t\t\t\t\t\tresultingAvailableModules: undefined,\n\t\t\t\t\t\tchildren: undefined,\n\t\t\t\t\t\tavailableSources: undefined,\n\t\t\t\t\t\tavailableChildren: undefined,\n\t\t\t\t\t\tpreOrderIndex: 0,\n\t\t\t\t\t\tpostOrderIndex: 0,\n\t\t\t\t\t\tchunkLoading:\n\t\t\t\t\t\t\tentryOptions.chunkLoading !== undefined\n\t\t\t\t\t\t\t\t? entryOptions.chunkLoading !== false\n\t\t\t\t\t\t\t\t: chunkGroupInfo.chunkLoading,\n\t\t\t\t\t\tasyncChunks:\n\t\t\t\t\t\t\tentryOptions.asyncChunks !== undefined\n\t\t\t\t\t\t\t\t? entryOptions.asyncChunks\n\t\t\t\t\t\t\t\t: chunkGroupInfo.asyncChunks\n\t\t\t\t\t};\n\t\t\t\t\tchunkGroupInfoMap.set(entrypoint, cgi);\n\n\t\t\t\t\tchunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\tnamedAsyncEntrypoints.set(chunkName, cgi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tentrypoint = /** @type {Entrypoint} */ (cgi.chunkGroup);\n\t\t\t\t\t// TODO merge entryOptions\n\t\t\t\t\tentrypoint.addOrigin(module, b.loc, b.request);\n\t\t\t\t\tchunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n\t\t\t\t}\n\n\t\t\t\t// 2. We enqueue the DependenciesBlock for traversal\n\t\t\t\tqueueDelayed.push({\n\t\t\t\t\taction: PROCESS_ENTRY_BLOCK,\n\t\t\t\t\tblock: b,\n\t\t\t\t\tmodule: module,\n\t\t\t\t\tchunk: entrypoint.chunks[0],\n\t\t\t\t\tchunkGroup: entrypoint,\n\t\t\t\t\tchunkGroupInfo: cgi\n\t\t\t\t});\n\t\t\t} else if (!chunkGroupInfo.asyncChunks || !chunkGroupInfo.chunkLoading) {\n\t\t\t\t// Just queue the block into the current chunk group\n\t\t\t\tqueue.push({\n\t\t\t\t\taction: PROCESS_BLOCK,\n\t\t\t\t\tblock: b,\n\t\t\t\t\tmodule: module,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcgi = chunkName && namedChunkGroups.get(chunkName);\n\t\t\t\tif (!cgi) {\n\t\t\t\t\tc = compilation.addChunkInGroup(\n\t\t\t\t\t\tb.groupOptions || b.chunkName,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tb.loc,\n\t\t\t\t\t\tb.request\n\t\t\t\t\t);\n\t\t\t\t\tc.index = nextChunkGroupIndex++;\n\t\t\t\t\tcgi = {\n\t\t\t\t\t\tchunkGroup: c,\n\t\t\t\t\t\truntime: chunkGroupInfo.runtime,\n\t\t\t\t\t\tminAvailableModules: undefined,\n\t\t\t\t\t\tminAvailableModulesOwned: undefined,\n\t\t\t\t\t\tavailableModulesToBeMerged: [],\n\t\t\t\t\t\tskippedItems: undefined,\n\t\t\t\t\t\tresultingAvailableModules: undefined,\n\t\t\t\t\t\tchildren: undefined,\n\t\t\t\t\t\tavailableSources: undefined,\n\t\t\t\t\t\tavailableChildren: undefined,\n\t\t\t\t\t\tpreOrderIndex: 0,\n\t\t\t\t\t\tpostOrderIndex: 0,\n\t\t\t\t\t\tchunkLoading: chunkGroupInfo.chunkLoading,\n\t\t\t\t\t\tasyncChunks: chunkGroupInfo.asyncChunks\n\t\t\t\t\t};\n\t\t\t\t\tallCreatedChunkGroups.add(c);\n\t\t\t\t\tchunkGroupInfoMap.set(c, cgi);\n\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\tnamedChunkGroups.set(chunkName, cgi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tc = cgi.chunkGroup;\n\t\t\t\t\tif (c.isInitial()) {\n\t\t\t\t\t\tcompilation.errors.push(\n\t\t\t\t\t\t\tnew AsyncDependencyToInitialChunkError(chunkName, module, b.loc)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tc = chunkGroup;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc.addOptions(b.groupOptions);\n\t\t\t\t\t}\n\t\t\t\t\tc.addOrigin(module, b.loc, b.request);\n\t\t\t\t}\n\t\t\t\tblockConnections.set(b, []);\n\t\t\t}\n\t\t\tblockChunkGroups.set(b, cgi);\n\t\t} else if (entryOptions) {\n\t\t\tentrypoint = /** @type {Entrypoint} */ (cgi.chunkGroup);\n\t\t} else {\n\t\t\tc = cgi.chunkGroup;\n\t\t}\n\n\t\tif (c !== undefined) {\n\t\t\t// 2. We store the connection for the block\n\t\t\t// to connect it later if needed\n\t\t\tblockConnections.get(b).push({\n\t\t\t\toriginChunkGroupInfo: chunkGroupInfo,\n\t\t\t\tchunkGroup: c\n\t\t\t});\n\n\t\t\t// 3. We enqueue the chunk group info creation/updating\n\t\t\tlet connectList = queueConnect.get(chunkGroupInfo);\n\t\t\tif (connectList === undefined) {\n\t\t\t\tconnectList = new Set();\n\t\t\t\tqueueConnect.set(chunkGroupInfo, connectList);\n\t\t\t}\n\t\t\tconnectList.add(cgi);\n\n\t\t\t// TODO check if this really need to be done for each traversal\n\t\t\t// or if it is enough when it's queued when created\n\t\t\t// 4. We enqueue the DependenciesBlock for traversal\n\t\t\tqueueDelayed.push({\n\t\t\t\taction: PROCESS_BLOCK,\n\t\t\t\tblock: b,\n\t\t\t\tmodule: module,\n\t\t\t\tchunk: c.chunks[0],\n\t\t\t\tchunkGroup: c,\n\t\t\t\tchunkGroupInfo: cgi\n\t\t\t});\n\t\t} else if (entrypoint !== undefined) {\n\t\t\tchunkGroupInfo.chunkGroup.addAsyncEntrypoint(entrypoint);\n\t\t}\n\t};\n\n\t/**\n\t * @param {DependenciesBlock} block the block\n\t * @returns {void}\n\t */\n\tconst processBlock = block => {\n\t\tstatProcessedBlocks++;\n\t\t// get prepared block info\n\t\tconst blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n\n\t\tif (blockModules !== undefined) {\n\t\t\tconst { minAvailableModules } = chunkGroupInfo;\n\t\t\t// Buffer items because order need to be reversed to get indices correct\n\t\t\t// Traverse all referenced modules\n\t\t\tfor (let i = 0; i < blockModules.length; i += 2) {\n\t\t\t\tconst refModule = /** @type {Module} */ (blockModules[i]);\n\t\t\t\tif (chunkGraph.isModuleInChunk(refModule, chunk)) {\n\t\t\t\t\t// skip early if already connected\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst activeState = /** @type {ConnectionState} */ (\n\t\t\t\t\tblockModules[i + 1]\n\t\t\t\t);\n\t\t\t\tif (activeState !== true) {\n\t\t\t\t\tskipConnectionBuffer.push([refModule, activeState]);\n\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tactiveState === true &&\n\t\t\t\t\t(minAvailableModules.has(refModule) ||\n\t\t\t\t\t\tminAvailableModules.plus.has(refModule))\n\t\t\t\t) {\n\t\t\t\t\t// already in parent chunks, skip it for now\n\t\t\t\t\tskipBuffer.push(refModule);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// enqueue, then add and enter to be in the correct order\n\t\t\t\t// this is relevant with circular dependencies\n\t\t\t\tqueueBuffer.push({\n\t\t\t\t\taction: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n\t\t\t\t\tblock: refModule,\n\t\t\t\t\tmodule: refModule,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Add buffered items in reverse order\n\t\t\tif (skipConnectionBuffer.length > 0) {\n\t\t\t\tlet { skippedModuleConnections } = chunkGroupInfo;\n\t\t\t\tif (skippedModuleConnections === undefined) {\n\t\t\t\t\tchunkGroupInfo.skippedModuleConnections = skippedModuleConnections =\n\t\t\t\t\t\tnew Set();\n\t\t\t\t}\n\t\t\t\tfor (let i = skipConnectionBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\tskippedModuleConnections.add(skipConnectionBuffer[i]);\n\t\t\t\t}\n\t\t\t\tskipConnectionBuffer.length = 0;\n\t\t\t}\n\t\t\tif (skipBuffer.length > 0) {\n\t\t\t\tlet { skippedItems } = chunkGroupInfo;\n\t\t\t\tif (skippedItems === undefined) {\n\t\t\t\t\tchunkGroupInfo.skippedItems = skippedItems = new Set();\n\t\t\t\t}\n\t\t\t\tfor (let i = skipBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\tskippedItems.add(skipBuffer[i]);\n\t\t\t\t}\n\t\t\t\tskipBuffer.length = 0;\n\t\t\t}\n\t\t\tif (queueBuffer.length > 0) {\n\t\t\t\tfor (let i = queueBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\tqueue.push(queueBuffer[i]);\n\t\t\t\t}\n\t\t\t\tqueueBuffer.length = 0;\n\t\t\t}\n\t\t}\n\n\t\t// Traverse all Blocks\n\t\tfor (const b of block.blocks) {\n\t\t\titeratorBlock(b);\n\t\t}\n\n\t\tif (block.blocks.length > 0 && module !== block) {\n\t\t\tblocksWithNestedBlocks.add(block);\n\t\t}\n\t};\n\n\t/**\n\t * @param {DependenciesBlock} block the block\n\t * @returns {void}\n\t */\n\tconst processEntryBlock = block => {\n\t\tstatProcessedBlocks++;\n\t\t// get prepared block info\n\t\tconst blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n\n\t\tif (blockModules !== undefined) {\n\t\t\t// Traverse all referenced modules\n\t\t\tfor (let i = 0; i < blockModules.length; i += 2) {\n\t\t\t\tconst refModule = /** @type {Module} */ (blockModules[i]);\n\t\t\t\tconst activeState = /** @type {ConnectionState} */ (\n\t\t\t\t\tblockModules[i + 1]\n\t\t\t\t);\n\t\t\t\t// enqueue, then add and enter to be in the correct order\n\t\t\t\t// this is relevant with circular dependencies\n\t\t\t\tqueueBuffer.push({\n\t\t\t\t\taction:\n\t\t\t\t\t\tactiveState === true ? ADD_AND_ENTER_ENTRY_MODULE : PROCESS_BLOCK,\n\t\t\t\t\tblock: refModule,\n\t\t\t\t\tmodule: refModule,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Add buffered items in reverse order\n\t\t\tif (queueBuffer.length > 0) {\n\t\t\t\tfor (let i = queueBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\tqueue.push(queueBuffer[i]);\n\t\t\t\t}\n\t\t\t\tqueueBuffer.length = 0;\n\t\t\t}\n\t\t}\n\n\t\t// Traverse all Blocks\n\t\tfor (const b of block.blocks) {\n\t\t\titeratorBlock(b);\n\t\t}\n\n\t\tif (block.blocks.length > 0 && module !== block) {\n\t\t\tblocksWithNestedBlocks.add(block);\n\t\t}\n\t};\n\n\tconst processQueue = () => {\n\t\twhile (queue.length) {\n\t\t\tstatProcessedQueueItems++;\n\t\t\tconst queueItem = queue.pop();\n\t\t\tmodule = queueItem.module;\n\t\t\tblock = queueItem.block;\n\t\t\tchunk = queueItem.chunk;\n\t\t\tchunkGroup = queueItem.chunkGroup;\n\t\t\tchunkGroupInfo = queueItem.chunkGroupInfo;\n\n\t\t\tswitch (queueItem.action) {\n\t\t\t\tcase ADD_AND_ENTER_ENTRY_MODULE:\n\t\t\t\t\tchunkGraph.connectChunkAndEntryModule(\n\t\t\t\t\t\tchunk,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t/** @type {Entrypoint} */ (chunkGroup)\n\t\t\t\t\t);\n\t\t\t\t// fallthrough\n\t\t\t\tcase ADD_AND_ENTER_MODULE: {\n\t\t\t\t\tif (chunkGraph.isModuleInChunk(module, chunk)) {\n\t\t\t\t\t\t// already connected, skip it\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// We connect Module and Chunk\n\t\t\t\t\tchunkGraph.connectChunkAndModule(chunk, module);\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase ENTER_MODULE: {\n\t\t\t\t\tconst index = chunkGroup.getModulePreOrderIndex(module);\n\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\tchunkGroup.setModulePreOrderIndex(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tchunkGroupInfo.preOrderIndex++\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tmoduleGraph.setPreOrderIndexIfUnset(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tnextFreeModulePreOrderIndex\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tnextFreeModulePreOrderIndex++;\n\t\t\t\t\t}\n\n\t\t\t\t\t// reuse queueItem\n\t\t\t\t\tqueueItem.action = LEAVE_MODULE;\n\t\t\t\t\tqueue.push(queueItem);\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase PROCESS_BLOCK: {\n\t\t\t\t\tprocessBlock(block);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase PROCESS_ENTRY_BLOCK: {\n\t\t\t\t\tprocessEntryBlock(block);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase LEAVE_MODULE: {\n\t\t\t\t\tconst index = chunkGroup.getModulePostOrderIndex(module);\n\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\tchunkGroup.setModulePostOrderIndex(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tchunkGroupInfo.postOrderIndex++\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tmoduleGraph.setPostOrderIndexIfUnset(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tnextFreeModulePostOrderIndex\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tnextFreeModulePostOrderIndex++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tconst calculateResultingAvailableModules = chunkGroupInfo => {\n\t\tif (chunkGroupInfo.resultingAvailableModules)\n\t\t\treturn chunkGroupInfo.resultingAvailableModules;\n\n\t\tconst minAvailableModules = chunkGroupInfo.minAvailableModules;\n\n\t\t// Create a new Set of available modules at this point\n\t\t// We want to be as lazy as possible. There are multiple ways doing this:\n\t\t// Note that resultingAvailableModules is stored as \"(a) + (b)\" as it's a ModuleSetPlus\n\t\t// - resultingAvailableModules = (modules of chunk) + (minAvailableModules + minAvailableModules.plus)\n\t\t// - resultingAvailableModules = (minAvailableModules + modules of chunk) + (minAvailableModules.plus)\n\t\t// We choose one depending on the size of minAvailableModules vs minAvailableModules.plus\n\n\t\tlet resultingAvailableModules;\n\t\tif (minAvailableModules.size > minAvailableModules.plus.size) {\n\t\t\t// resultingAvailableModules = (modules of chunk) + (minAvailableModules + minAvailableModules.plus)\n\t\t\tresultingAvailableModules =\n\t\t\t\t/** @type {Set<Module> & {plus: Set<Module>}} */ (new Set());\n\t\t\tfor (const module of minAvailableModules.plus)\n\t\t\t\tminAvailableModules.add(module);\n\t\t\tminAvailableModules.plus = EMPTY_SET;\n\t\t\tresultingAvailableModules.plus = minAvailableModules;\n\t\t\tchunkGroupInfo.minAvailableModulesOwned = false;\n\t\t} else {\n\t\t\t// resultingAvailableModules = (minAvailableModules + modules of chunk) + (minAvailableModules.plus)\n\t\t\tresultingAvailableModules =\n\t\t\t\t/** @type {Set<Module> & {plus: Set<Module>}} */ (\n\t\t\t\t\tnew Set(minAvailableModules)\n\t\t\t\t);\n\t\t\tresultingAvailableModules.plus = minAvailableModules.plus;\n\t\t}\n\n\t\t// add the modules from the chunk group to the set\n\t\tfor (const chunk of chunkGroupInfo.chunkGroup.chunks) {\n\t\t\tfor (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\tresultingAvailableModules.add(m);\n\t\t\t}\n\t\t}\n\t\treturn (chunkGroupInfo.resultingAvailableModules =\n\t\t\tresultingAvailableModules);\n\t};\n\n\tconst processConnectQueue = () => {\n\t\t// Figure out new parents for chunk groups\n\t\t// to get new available modules for these children\n\t\tfor (const [chunkGroupInfo, targets] of queueConnect) {\n\t\t\t// 1. Add new targets to the list of children\n\t\t\tif (chunkGroupInfo.children === undefined) {\n\t\t\t\tchunkGroupInfo.children = targets;\n\t\t\t} else {\n\t\t\t\tfor (const target of targets) {\n\t\t\t\t\tchunkGroupInfo.children.add(target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 2. Calculate resulting available modules\n\t\t\tconst resultingAvailableModules =\n\t\t\t\tcalculateResultingAvailableModules(chunkGroupInfo);\n\n\t\t\tconst runtime = chunkGroupInfo.runtime;\n\n\t\t\t// 3. Update chunk group info\n\t\t\tfor (const target of targets) {\n\t\t\t\ttarget.availableModulesToBeMerged.push(resultingAvailableModules);\n\t\t\t\tchunkGroupsForMerging.add(target);\n\t\t\t\tconst oldRuntime = target.runtime;\n\t\t\t\tconst newRuntime = mergeRuntime(oldRuntime, runtime);\n\t\t\t\tif (oldRuntime !== newRuntime) {\n\t\t\t\t\ttarget.runtime = newRuntime;\n\t\t\t\t\toutdatedChunkGroupInfo.add(target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatConnectedChunkGroups += targets.size;\n\t\t}\n\t\tqueueConnect.clear();\n\t};\n\n\tconst processChunkGroupsForMerging = () => {\n\t\tstatProcessedChunkGroupsForMerging += chunkGroupsForMerging.size;\n\n\t\t// Execute the merge\n\t\tfor (const info of chunkGroupsForMerging) {\n\t\t\tconst availableModulesToBeMerged = info.availableModulesToBeMerged;\n\t\t\tlet cachedMinAvailableModules = info.minAvailableModules;\n\n\t\t\tstatMergedAvailableModuleSets += availableModulesToBeMerged.length;\n\n\t\t\t// 1. Get minimal available modules\n\t\t\t// It doesn't make sense to traverse a chunk again with more available modules.\n\t\t\t// This step calculates the minimal available modules and skips traversal when\n\t\t\t// the list didn't shrink.\n\t\t\tif (availableModulesToBeMerged.length > 1) {\n\t\t\t\tavailableModulesToBeMerged.sort(bySetSize);\n\t\t\t}\n\t\t\tlet changed = false;\n\t\t\tmerge: for (const availableModules of availableModulesToBeMerged) {\n\t\t\t\tif (cachedMinAvailableModules === undefined) {\n\t\t\t\t\tcachedMinAvailableModules = availableModules;\n\t\t\t\t\tinfo.minAvailableModules = cachedMinAvailableModules;\n\t\t\t\t\tinfo.minAvailableModulesOwned = false;\n\t\t\t\t\tchanged = true;\n\t\t\t\t} else {\n\t\t\t\t\tif (info.minAvailableModulesOwned) {\n\t\t\t\t\t\t// We own it and can modify it\n\t\t\t\t\t\tif (cachedMinAvailableModules.plus === availableModules.plus) {\n\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\t\tif (!availableModules.has(m)) {\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.delete(m);\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\t\tif (!availableModules.has(m) && !availableModules.plus.has(m)) {\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.delete(m);\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules.plus) {\n\t\t\t\t\t\t\t\tif (!availableModules.has(m) && !availableModules.plus.has(m)) {\n\t\t\t\t\t\t\t\t\t// We can't remove modules from the plus part\n\t\t\t\t\t\t\t\t\t// so we need to merge plus into the normal part to allow modifying it\n\t\t\t\t\t\t\t\t\tconst iterator =\n\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus[Symbol.iterator]();\n\t\t\t\t\t\t\t\t\t// fast forward add all modules until m\n\t\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\n\t\t\t\t\t\t\t\t\tlet it;\n\t\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\t\tif (module === m) break;\n\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.add(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// check the remaining modules before adding\n\t\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tavailableModules.has(module) ||\n\t\t\t\t\t\t\t\t\t\t\tavailableModules.plus.has(module)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.add(module);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus = EMPTY_SET;\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\tcontinue merge;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (cachedMinAvailableModules.plus === availableModules.plus) {\n\t\t\t\t\t\t// Common and fast case when the plus part is shared\n\t\t\t\t\t\t// We only need to care about the normal part\n\t\t\t\t\t\tif (availableModules.size < cachedMinAvailableModules.size) {\n\t\t\t\t\t\t\t// the new availableModules is smaller so it's faster to\n\t\t\t\t\t\t\t// fork from the new availableModules\n\t\t\t\t\t\t\tstatForkedAvailableModules++;\n\t\t\t\t\t\t\tstatForkedAvailableModulesCount += availableModules.size;\n\t\t\t\t\t\t\tstatForkedMergedModulesCount += cachedMinAvailableModules.size;\n\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\t\t\t\t\t\t\tconst newSet = /** @type {ModuleSetPlus} */ (new Set());\n\t\t\t\t\t\t\tnewSet.plus = availableModules.plus;\n\t\t\t\t\t\t\tfor (const m of availableModules) {\n\t\t\t\t\t\t\t\tif (cachedMinAvailableModules.has(m)) {\n\t\t\t\t\t\t\t\t\tnewSet.add(m);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstatForkedResultModulesCount += newSet.size;\n\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\n\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\n\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tcontinue merge;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\tif (!availableModules.has(m)) {\n\t\t\t\t\t\t\t\t// cachedMinAvailableModules need to be modified\n\t\t\t\t\t\t\t\t// but we don't own it\n\t\t\t\t\t\t\t\tstatForkedAvailableModules++;\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCount +=\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.size;\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCount += availableModules.size;\n\t\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\t\t\t\t\t\t\t\t// as the plus part is equal we can just take over this one\n\t\t\t\t\t\t\t\tconst newSet = /** @type {ModuleSetPlus} */ (new Set());\n\t\t\t\t\t\t\t\tnewSet.plus = availableModules.plus;\n\t\t\t\t\t\t\t\tconst iterator = cachedMinAvailableModules[Symbol.iterator]();\n\t\t\t\t\t\t\t\t// fast forward add all modules until m\n\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\n\t\t\t\t\t\t\t\tlet it;\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\tif (module === m) break;\n\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// check the remaining modules before adding\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\tif (availableModules.has(module)) {\n\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstatForkedResultModulesCount += newSet.size;\n\t\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\n\t\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\n\t\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\tcontinue merge;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\tif (!availableModules.has(m) && !availableModules.plus.has(m)) {\n\t\t\t\t\t\t\t\t// cachedMinAvailableModules need to be modified\n\t\t\t\t\t\t\t\t// but we don't own it\n\t\t\t\t\t\t\t\tstatForkedAvailableModules++;\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCount +=\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.size;\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCountPlus +=\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus.size;\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCount += availableModules.size;\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCountPlus += availableModules.plus.size;\n\t\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\t\t\t\t\t\t\t\tconst newSet = /** @type {ModuleSetPlus} */ (new Set());\n\t\t\t\t\t\t\t\tnewSet.plus = EMPTY_SET;\n\t\t\t\t\t\t\t\tconst iterator = cachedMinAvailableModules[Symbol.iterator]();\n\t\t\t\t\t\t\t\t// fast forward add all modules until m\n\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\n\t\t\t\t\t\t\t\tlet it;\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\tif (module === m) break;\n\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// check the remaining modules before adding\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tavailableModules.has(module) ||\n\t\t\t\t\t\t\t\t\t\tavailableModules.plus.has(module)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// also check all modules in cachedMinAvailableModules.plus\n\t\t\t\t\t\t\t\tfor (const module of cachedMinAvailableModules.plus) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tavailableModules.has(module) ||\n\t\t\t\t\t\t\t\t\t\tavailableModules.plus.has(module)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstatForkedResultModulesCount += newSet.size;\n\t\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\n\t\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\n\t\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\tcontinue merge;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const m of cachedMinAvailableModules.plus) {\n\t\t\t\t\t\t\tif (!availableModules.has(m) && !availableModules.plus.has(m)) {\n\t\t\t\t\t\t\t\t// cachedMinAvailableModules need to be modified\n\t\t\t\t\t\t\t\t// but we don't own it\n\t\t\t\t\t\t\t\tstatForkedAvailableModules++;\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCount +=\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.size;\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCountPlus +=\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus.size;\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCount += availableModules.size;\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCountPlus += availableModules.plus.size;\n\t\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\t\t\t\t\t\t\t\t// we already know that all modules directly from cachedMinAvailableModules are in availableModules too\n\t\t\t\t\t\t\t\tconst newSet = /** @type {ModuleSetPlus} */ (\n\t\t\t\t\t\t\t\t\tnew Set(cachedMinAvailableModules)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tnewSet.plus = EMPTY_SET;\n\t\t\t\t\t\t\t\tconst iterator =\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus[Symbol.iterator]();\n\t\t\t\t\t\t\t\t// fast forward add all modules until m\n\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\n\t\t\t\t\t\t\t\tlet it;\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\tif (module === m) break;\n\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// check the remaining modules before adding\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tavailableModules.has(module) ||\n\t\t\t\t\t\t\t\t\t\tavailableModules.plus.has(module)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstatForkedResultModulesCount += newSet.size;\n\t\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\n\t\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\n\t\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\tcontinue merge;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tavailableModulesToBeMerged.length = 0;\n\t\t\tif (changed) {\n\t\t\t\tinfo.resultingAvailableModules = undefined;\n\t\t\t\toutdatedChunkGroupInfo.add(info);\n\t\t\t}\n\t\t}\n\t\tchunkGroupsForMerging.clear();\n\t};\n\n\tconst processChunkGroupsForCombining = () => {\n\t\tfor (const info of chunkGroupsForCombining) {\n\t\t\tfor (const source of info.availableSources) {\n\t\t\t\tif (!source.minAvailableModules) {\n\t\t\t\t\tchunkGroupsForCombining.delete(info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const info of chunkGroupsForCombining) {\n\t\t\tconst availableModules = /** @type {ModuleSetPlus} */ (new Set());\n\t\t\tavailableModules.plus = EMPTY_SET;\n\t\t\tconst mergeSet = set => {\n\t\t\t\tif (set.size > availableModules.plus.size) {\n\t\t\t\t\tfor (const item of availableModules.plus) availableModules.add(item);\n\t\t\t\t\tavailableModules.plus = set;\n\t\t\t\t} else {\n\t\t\t\t\tfor (const item of set) availableModules.add(item);\n\t\t\t\t}\n\t\t\t};\n\t\t\t// combine minAvailableModules from all resultingAvailableModules\n\t\t\tfor (const source of info.availableSources) {\n\t\t\t\tconst resultingAvailableModules =\n\t\t\t\t\tcalculateResultingAvailableModules(source);\n\t\t\t\tmergeSet(resultingAvailableModules);\n\t\t\t\tmergeSet(resultingAvailableModules.plus);\n\t\t\t}\n\t\t\tinfo.minAvailableModules = availableModules;\n\t\t\tinfo.minAvailableModulesOwned = false;\n\t\t\tinfo.resultingAvailableModules = undefined;\n\t\t\toutdatedChunkGroupInfo.add(info);\n\t\t}\n\t\tchunkGroupsForCombining.clear();\n\t};\n\n\tconst processOutdatedChunkGroupInfo = () => {\n\t\tstatChunkGroupInfoUpdated += outdatedChunkGroupInfo.size;\n\t\t// Revisit skipped elements\n\t\tfor (const info of outdatedChunkGroupInfo) {\n\t\t\t// 1. Reconsider skipped items\n\t\t\tif (info.skippedItems !== undefined) {\n\t\t\t\tconst { minAvailableModules } = info;\n\t\t\t\tfor (const module of info.skippedItems) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!minAvailableModules.has(module) &&\n\t\t\t\t\t\t!minAvailableModules.plus.has(module)\n\t\t\t\t\t) {\n\t\t\t\t\t\tqueue.push({\n\t\t\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\t\t\tblock: module,\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tchunk: info.chunkGroup.chunks[0],\n\t\t\t\t\t\t\tchunkGroup: info.chunkGroup,\n\t\t\t\t\t\t\tchunkGroupInfo: info\n\t\t\t\t\t\t});\n\t\t\t\t\t\tinfo.skippedItems.delete(module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 2. Reconsider skipped connections\n\t\t\tif (info.skippedModuleConnections !== undefined) {\n\t\t\t\tconst { minAvailableModules } = info;\n\t\t\t\tfor (const entry of info.skippedModuleConnections) {\n\t\t\t\t\tconst [module, activeState] = entry;\n\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t\tif (activeState === true) {\n\t\t\t\t\t\tinfo.skippedModuleConnections.delete(entry);\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tactiveState === true &&\n\t\t\t\t\t\t(minAvailableModules.has(module) ||\n\t\t\t\t\t\t\tminAvailableModules.plus.has(module))\n\t\t\t\t\t) {\n\t\t\t\t\t\tinfo.skippedItems.add(module);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\taction: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n\t\t\t\t\t\tblock: module,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tchunk: info.chunkGroup.chunks[0],\n\t\t\t\t\t\tchunkGroup: info.chunkGroup,\n\t\t\t\t\t\tchunkGroupInfo: info\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 2. Reconsider children chunk groups\n\t\t\tif (info.children !== undefined) {\n\t\t\t\tstatChildChunkGroupsReconnected += info.children.size;\n\t\t\t\tfor (const cgi of info.children) {\n\t\t\t\t\tlet connectList = queueConnect.get(info);\n\t\t\t\t\tif (connectList === undefined) {\n\t\t\t\t\t\tconnectList = new Set();\n\t\t\t\t\t\tqueueConnect.set(info, connectList);\n\t\t\t\t\t}\n\t\t\t\t\tconnectList.add(cgi);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 3. Reconsider chunk groups for combining\n\t\t\tif (info.availableChildren !== undefined) {\n\t\t\t\tfor (const cgi of info.availableChildren) {\n\t\t\t\t\tchunkGroupsForCombining.add(cgi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toutdatedChunkGroupInfo.clear();\n\t};\n\n\t// Iterative traversal of the Module graph\n\t// Recursive would be simpler to write but could result in Stack Overflows\n\twhile (queue.length || queueConnect.size) {\n\t\tlogger.time(\"visitModules: visiting\");\n\t\tprocessQueue();\n\t\tlogger.timeAggregateEnd(\"visitModules: prepare\");\n\t\tlogger.timeEnd(\"visitModules: visiting\");\n\n\t\tif (chunkGroupsForCombining.size > 0) {\n\t\t\tlogger.time(\"visitModules: combine available modules\");\n\t\t\tprocessChunkGroupsForCombining();\n\t\t\tlogger.timeEnd(\"visitModules: combine available modules\");\n\t\t}\n\n\t\tif (queueConnect.size > 0) {\n\t\t\tlogger.time(\"visitModules: calculating available modules\");\n\t\t\tprocessConnectQueue();\n\t\t\tlogger.timeEnd(\"visitModules: calculating available modules\");\n\n\t\t\tif (chunkGroupsForMerging.size > 0) {\n\t\t\t\tlogger.time(\"visitModules: merging available modules\");\n\t\t\t\tprocessChunkGroupsForMerging();\n\t\t\t\tlogger.timeEnd(\"visitModules: merging available modules\");\n\t\t\t}\n\t\t}\n\n\t\tif (outdatedChunkGroupInfo.size > 0) {\n\t\t\tlogger.time(\"visitModules: check modules for revisit\");\n\t\t\tprocessOutdatedChunkGroupInfo();\n\t\t\tlogger.timeEnd(\"visitModules: check modules for revisit\");\n\t\t}\n\n\t\t// Run queueDelayed when all items of the queue are processed\n\t\t// This is important to get the global indexing correct\n\t\t// Async blocks should be processed after all sync blocks are processed\n\t\tif (queue.length === 0) {\n\t\t\tconst tempQueue = queue;\n\t\t\tqueue = queueDelayed.reverse();\n\t\t\tqueueDelayed = tempQueue;\n\t\t}\n\t}\n\n\tlogger.log(\n\t\t`${statProcessedQueueItems} queue items processed (${statProcessedBlocks} blocks)`\n\t);\n\tlogger.log(`${statConnectedChunkGroups} chunk groups connected`);\n\tlogger.log(\n\t\t`${statProcessedChunkGroupsForMerging} chunk groups processed for merging (${statMergedAvailableModuleSets} module sets, ${statForkedAvailableModules} forked, ${statForkedAvailableModulesCount} + ${statForkedAvailableModulesCountPlus} modules forked, ${statForkedMergedModulesCount} + ${statForkedMergedModulesCountPlus} modules merged into fork, ${statForkedResultModulesCount} resulting modules)`\n\t);\n\tlogger.log(\n\t\t`${statChunkGroupInfoUpdated} chunk group info updated (${statChildChunkGroupsReconnected} already connected chunk groups reconnected)`\n\t);\n};\n\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\nconst connectChunkGroups = (\n\tcompilation,\n\tblocksWithNestedBlocks,\n\tblockConnections,\n\tchunkGroupInfoMap\n) => {\n\tconst { chunkGraph } = compilation;\n\n\t/**\n\t * Helper function to check if all modules of a chunk are available\n\t *\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n\t * @param {ModuleSetPlus} availableModules the comparator set\n\t * @returns {boolean} return true if all modules of a chunk are available\n\t */\n\tconst areModulesAvailable = (chunkGroup, availableModules) => {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tfor (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\tif (!availableModules.has(module) && !availableModules.plus.has(module))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t// For each edge in the basic chunk graph\n\tfor (const [block, connections] of blockConnections) {\n\t\t// 1. Check if connection is needed\n\t\t// When none of the dependencies need to be connected\n\t\t// we can skip all of them\n\t\t// It's not possible to filter each item so it doesn't create inconsistent\n\t\t// connections and modules can only create one version\n\t\t// TODO maybe decide this per runtime\n\t\tif (\n\t\t\t// TODO is this needed?\n\t\t\t!blocksWithNestedBlocks.has(block) &&\n\t\t\tconnections.every(({ chunkGroup, originChunkGroupInfo }) =>\n\t\t\t\tareModulesAvailable(\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\toriginChunkGroupInfo.resultingAvailableModules\n\t\t\t\t)\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// 2. Foreach edge\n\t\tfor (let i = 0; i < connections.length; i++) {\n\t\t\tconst { chunkGroup, originChunkGroupInfo } = connections[i];\n\n\t\t\t// 3. Connect block with chunk\n\t\t\tchunkGraph.connectBlockAndChunkGroup(block, chunkGroup);\n\n\t\t\t// 4. Connect chunk with parent\n\t\t\tconnectChunkGroupParentAndChild(\n\t\t\t\toriginChunkGroupInfo.chunkGroup,\n\t\t\t\tchunkGroup\n\t\t\t);\n\t\t}\n\t}\n};\n\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n\tconst { chunkGraph } = compilation;\n\n\tfor (const chunkGroup of allCreatedChunkGroups) {\n\t\tif (chunkGroup.getNumberOfParents() === 0) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tcompilation.chunks.delete(chunk);\n\t\t\t\tchunkGraph.disconnectChunk(chunk);\n\t\t\t}\n\t\t\tchunkGraph.disconnectChunkGroup(chunkGroup);\n\t\t\tchunkGroup.remove();\n\t\t}\n\t}\n};\n\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @returns {void}\n */\nconst buildChunkGraph = (compilation, inputEntrypointsAndModules) => {\n\tconst logger = compilation.getLogger(\"webpack.buildChunkGraph\");\n\n\t// SHARED STATE\n\n\t/** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */\n\tconst blockConnections = new Map();\n\n\t/** @type {Set<ChunkGroup>} */\n\tconst allCreatedChunkGroups = new Set();\n\n\t/** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n\tconst chunkGroupInfoMap = new Map();\n\n\t/** @type {Set<DependenciesBlock>} */\n\tconst blocksWithNestedBlocks = new Set();\n\n\t// PART ONE\n\n\tlogger.time(\"visitModules\");\n\tvisitModules(\n\t\tlogger,\n\t\tcompilation,\n\t\tinputEntrypointsAndModules,\n\t\tchunkGroupInfoMap,\n\t\tblockConnections,\n\t\tblocksWithNestedBlocks,\n\t\tallCreatedChunkGroups\n\t);\n\tlogger.timeEnd(\"visitModules\");\n\n\t// PART TWO\n\n\tlogger.time(\"connectChunkGroups\");\n\tconnectChunkGroups(\n\t\tcompilation,\n\t\tblocksWithNestedBlocks,\n\t\tblockConnections,\n\t\tchunkGroupInfoMap\n\t);\n\tlogger.timeEnd(\"connectChunkGroups\");\n\n\tfor (const [chunkGroup, chunkGroupInfo] of chunkGroupInfoMap) {\n\t\tfor (const chunk of chunkGroup.chunks)\n\t\t\tchunk.runtime = mergeRuntime(chunk.runtime, chunkGroupInfo.runtime);\n\t}\n\n\t// Cleanup work\n\n\tlogger.time(\"cleanup\");\n\tcleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n\tlogger.timeEnd(\"cleanup\");\n};\n\nmodule.exports = buildChunkGraph;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}