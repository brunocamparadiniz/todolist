{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _require = require(\"../OptimizationStages\"),\n  STAGE_ADVANCED = _require.STAGE_ADVANCED;\nvar _require2 = require(\"../util/SetHelpers\"),\n  intersect = _require2.intersect;\nvar _require3 = require(\"../util/comparators\"),\n  compareModulesByIdentifier = _require3.compareModulesByIdentifier,\n  compareChunks = _require3.compareChunks;\nvar createSchemaValidation = require(\"../util/create-schema-validation\");\nvar identifierUtils = require(\"../util/identifier\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nvar validate = createSchemaValidation(require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.check.js\"), function () {\n  return require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\");\n}, {\n  name: \"Aggressive Splitting Plugin\",\n  baseDataPath: \"options\"\n});\nvar moveModuleBetween = function moveModuleBetween(chunkGraph, oldChunk, newChunk) {\n  return function (module) {\n    chunkGraph.disconnectChunkAndModule(oldChunk, module);\n    chunkGraph.connectChunkAndModule(newChunk, module);\n  };\n};\n\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Chunk} chunk the chunk\n * @returns {function(Module): boolean} filter for entry module\n */\nvar isNotAEntryModule = function isNotAEntryModule(chunkGraph, chunk) {\n  return function (module) {\n    return !chunkGraph.isEntryModuleInChunk(module, chunk);\n  };\n};\n\n/** @type {WeakSet<Chunk>} */\nvar recordedChunks = new WeakSet();\nvar AggressiveSplittingPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {AggressiveSplittingPluginOptions=} options options object\n   */\n  function AggressiveSplittingPlugin() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, AggressiveSplittingPlugin);\n    validate(options);\n    this.options = options;\n    if (typeof this.options.minSize !== \"number\") {\n      this.options.minSize = 30 * 1024;\n    }\n    if (typeof this.options.maxSize !== \"number\") {\n      this.options.maxSize = 50 * 1024;\n    }\n    if (typeof this.options.chunkOverhead !== \"number\") {\n      this.options.chunkOverhead = 0;\n    }\n    if (typeof this.options.entryChunkMultiplicator !== \"number\") {\n      this.options.entryChunkMultiplicator = 1;\n    }\n  }\n\n  /**\n   * @param {Chunk} chunk the chunk to test\n   * @returns {boolean} true if the chunk was recorded\n   */\n  _createClass(AggressiveSplittingPlugin, [{\n    key: \"apply\",\n    value:\n    /**\n     * Apply the plugin\n     * @param {Compiler} compiler the compiler instance\n     * @returns {void}\n     */\n    function apply(compiler) {\n      var _this = this;\n      compiler.hooks.thisCompilation.tap(\"AggressiveSplittingPlugin\", function (compilation) {\n        var needAdditionalSeal = false;\n        var newSplits;\n        var fromAggressiveSplittingSet;\n        var chunkSplitDataMap;\n        compilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", function () {\n          newSplits = [];\n          fromAggressiveSplittingSet = new Set();\n          chunkSplitDataMap = new Map();\n        });\n        compilation.hooks.optimizeChunks.tap({\n          name: \"AggressiveSplittingPlugin\",\n          stage: STAGE_ADVANCED\n        }, function (chunks) {\n          var chunkGraph = compilation.chunkGraph;\n          // Precompute stuff\n          var nameToModuleMap = new Map();\n          var moduleToNameMap = new Map();\n          var makePathsRelative = identifierUtils.makePathsRelative.bindContextCache(compiler.context, compiler.root);\n          var _iterator = _createForOfIteratorHelper(compilation.modules),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var m = _step.value;\n              var name = makePathsRelative(m.identifier());\n              nameToModuleMap.set(name, m);\n              moduleToNameMap.set(m, name);\n            }\n\n            // Check used chunk ids\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          var usedIds = new Set();\n          var _iterator2 = _createForOfIteratorHelper(chunks),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var chunk = _step2.value;\n              usedIds.add(chunk.id);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          var recordedSplits = compilation.records && compilation.records.aggressiveSplits || [];\n          var usedSplits = newSplits ? recordedSplits.concat(newSplits) : recordedSplits;\n          var minSize = _this.options.minSize;\n          var maxSize = _this.options.maxSize;\n          var applySplit = function applySplit(splitData) {\n            // Cannot split if id is already taken\n            if (splitData.id !== undefined && usedIds.has(splitData.id)) {\n              return false;\n            }\n\n            // Get module objects from names\n            var selectedModules = splitData.modules.map(function (name) {\n              return nameToModuleMap.get(name);\n            });\n\n            // Does the modules exist at all?\n            if (!selectedModules.every(Boolean)) return false;\n\n            // Check if size matches (faster than waiting for hash)\n            var size = 0;\n            var _iterator3 = _createForOfIteratorHelper(selectedModules),\n              _step3;\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var m = _step3.value;\n                size += m.size();\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n            if (size !== splitData.size) return false;\n\n            // get chunks with all modules\n            var selectedChunks = intersect(selectedModules.map(function (m) {\n              return new Set(chunkGraph.getModuleChunksIterable(m));\n            }));\n\n            // No relevant chunks found\n            if (selectedChunks.size === 0) return false;\n\n            // The found chunk is already the split or similar\n            if (selectedChunks.size === 1 && chunkGraph.getNumberOfChunkModules(Array.from(selectedChunks)[0]) === selectedModules.length) {\n              var chunk = Array.from(selectedChunks)[0];\n              if (fromAggressiveSplittingSet.has(chunk)) return false;\n              fromAggressiveSplittingSet.add(chunk);\n              chunkSplitDataMap.set(chunk, splitData);\n              return true;\n            }\n\n            // split the chunk into two parts\n            var newChunk = compilation.addChunk();\n            newChunk.chunkReason = \"aggressive splitted\";\n            var _iterator4 = _createForOfIteratorHelper(selectedChunks),\n              _step4;\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var _chunk = _step4.value;\n                selectedModules.forEach(moveModuleBetween(chunkGraph, _chunk, newChunk));\n                _chunk.split(newChunk);\n                _chunk.name = null;\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n            fromAggressiveSplittingSet.add(newChunk);\n            chunkSplitDataMap.set(newChunk, splitData);\n            if (splitData.id !== null && splitData.id !== undefined) {\n              newChunk.id = splitData.id;\n              newChunk.ids = [splitData.id];\n            }\n            return true;\n          };\n\n          // try to restore to recorded splitting\n          var changed = false;\n          for (var j = 0; j < usedSplits.length; j++) {\n            var splitData = usedSplits[j];\n            if (applySplit(splitData)) changed = true;\n          }\n\n          // for any chunk which isn't splitted yet, split it and create a new entry\n          // start with the biggest chunk\n          var cmpFn = compareChunks(chunkGraph);\n          var sortedChunks = Array.from(chunks).sort(function (a, b) {\n            var diff1 = chunkGraph.getChunkModulesSize(b) - chunkGraph.getChunkModulesSize(a);\n            if (diff1) return diff1;\n            var diff2 = chunkGraph.getNumberOfChunkModules(a) - chunkGraph.getNumberOfChunkModules(b);\n            if (diff2) return diff2;\n            return cmpFn(a, b);\n          });\n          var _iterator5 = _createForOfIteratorHelper(sortedChunks),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _chunk2 = _step5.value;\n              if (fromAggressiveSplittingSet.has(_chunk2)) continue;\n              var size = chunkGraph.getChunkModulesSize(_chunk2);\n              if (size > maxSize && chunkGraph.getNumberOfChunkModules(_chunk2) > 1) {\n                var modules = chunkGraph.getOrderedChunkModules(_chunk2, compareModulesByIdentifier).filter(isNotAEntryModule(chunkGraph, _chunk2));\n                var selectedModules = [];\n                var selectedModulesSize = 0;\n                for (var k = 0; k < modules.length; k++) {\n                  var _module = modules[k];\n                  var newSize = selectedModulesSize + _module.size();\n                  if (newSize > maxSize && selectedModulesSize >= minSize) {\n                    break;\n                  }\n                  selectedModulesSize = newSize;\n                  selectedModules.push(_module);\n                }\n                if (selectedModules.length === 0) continue;\n                var _splitData = {\n                  modules: selectedModules.map(function (m) {\n                    return moduleToNameMap.get(m);\n                  }).sort(),\n                  size: selectedModulesSize\n                };\n                if (applySplit(_splitData)) {\n                  newSplits = (newSplits || []).concat(_splitData);\n                  changed = true;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n          if (changed) return true;\n        });\n        compilation.hooks.recordHash.tap(\"AggressiveSplittingPlugin\", function (records) {\n          // 4. save made splittings to records\n          var allSplits = new Set();\n          var invalidSplits = new Set();\n\n          // Check if some splittings are invalid\n          // We remove invalid splittings and try again\n          var _iterator6 = _createForOfIteratorHelper(compilation.chunks),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var _chunk3 = _step6.value;\n              var _splitData3 = chunkSplitDataMap.get(_chunk3);\n              if (_splitData3 !== undefined) {\n                if (_splitData3.hash && _chunk3.hash !== _splitData3.hash) {\n                  // Split was successful, but hash doesn't equal\n                  // We can throw away the split since it's useless now\n                  invalidSplits.add(_splitData3);\n                }\n              }\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n          if (invalidSplits.size > 0) {\n            records.aggressiveSplits = records.aggressiveSplits.filter(function (splitData) {\n              return !invalidSplits.has(splitData);\n            });\n            needAdditionalSeal = true;\n          } else {\n            // set hash and id values on all (new) splittings\n            var _iterator7 = _createForOfIteratorHelper(compilation.chunks),\n              _step7;\n            try {\n              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                var chunk = _step7.value;\n                var _splitData2 = chunkSplitDataMap.get(chunk);\n                if (_splitData2 !== undefined) {\n                  _splitData2.hash = chunk.hash;\n                  _splitData2.id = chunk.id;\n                  allSplits.add(_splitData2);\n                  // set flag for stats\n                  recordedChunks.add(chunk);\n                }\n              }\n\n              // Also add all unused historical splits (after the used ones)\n              // They can still be used in some future compilation\n            } catch (err) {\n              _iterator7.e(err);\n            } finally {\n              _iterator7.f();\n            }\n            var recordedSplits = compilation.records && compilation.records.aggressiveSplits;\n            if (recordedSplits) {\n              var _iterator8 = _createForOfIteratorHelper(recordedSplits),\n                _step8;\n              try {\n                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                  var splitData = _step8.value;\n                  if (!invalidSplits.has(splitData)) allSplits.add(splitData);\n                }\n              } catch (err) {\n                _iterator8.e(err);\n              } finally {\n                _iterator8.f();\n              }\n            }\n\n            // record all splits\n            records.aggressiveSplits = Array.from(allSplits);\n            needAdditionalSeal = false;\n          }\n        });\n        compilation.hooks.needAdditionalSeal.tap(\"AggressiveSplittingPlugin\", function () {\n          if (needAdditionalSeal) {\n            needAdditionalSeal = false;\n            return true;\n          }\n        });\n      });\n    }\n  }], [{\n    key: \"wasChunkRecorded\",\n    value: function wasChunkRecorded(chunk) {\n      return recordedChunks.has(chunk);\n    }\n  }]);\n  return AggressiveSplittingPlugin;\n}();\nmodule.exports = AggressiveSplittingPlugin;","map":{"version":3,"names":["require","STAGE_ADVANCED","intersect","compareModulesByIdentifier","compareChunks","createSchemaValidation","identifierUtils","validate","name","baseDataPath","moveModuleBetween","chunkGraph","oldChunk","newChunk","module","disconnectChunkAndModule","connectChunkAndModule","isNotAEntryModule","chunk","isEntryModuleInChunk","recordedChunks","WeakSet","AggressiveSplittingPlugin","options","minSize","maxSize","chunkOverhead","entryChunkMultiplicator","compiler","hooks","thisCompilation","tap","compilation","needAdditionalSeal","newSplits","fromAggressiveSplittingSet","chunkSplitDataMap","optimize","Set","Map","optimizeChunks","stage","chunks","nameToModuleMap","moduleToNameMap","makePathsRelative","bindContextCache","context","root","modules","m","identifier","set","usedIds","add","id","recordedSplits","records","aggressiveSplits","usedSplits","concat","applySplit","splitData","undefined","has","selectedModules","map","get","every","Boolean","size","selectedChunks","getModuleChunksIterable","getNumberOfChunkModules","Array","from","length","addChunk","chunkReason","forEach","split","ids","changed","j","cmpFn","sortedChunks","sort","a","b","diff1","getChunkModulesSize","diff2","getOrderedChunkModules","filter","selectedModulesSize","k","newSize","push","recordHash","allSplits","invalidSplits","hash","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/optimize/AggressiveSplittingPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\nconst { intersect } = require(\"../util/SetHelpers\");\nconst {\n\tcompareModulesByIdentifier,\n\tcompareChunks\n} = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst identifierUtils = require(\"../util/identifier\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.check.js\"),\n\t() =>\n\t\trequire(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\"),\n\t{\n\t\tname: \"Aggressive Splitting Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\nconst moveModuleBetween = (chunkGraph, oldChunk, newChunk) => {\n\treturn module => {\n\t\tchunkGraph.disconnectChunkAndModule(oldChunk, module);\n\t\tchunkGraph.connectChunkAndModule(newChunk, module);\n\t};\n};\n\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Chunk} chunk the chunk\n * @returns {function(Module): boolean} filter for entry module\n */\nconst isNotAEntryModule = (chunkGraph, chunk) => {\n\treturn module => {\n\t\treturn !chunkGraph.isEntryModuleInChunk(module, chunk);\n\t};\n};\n\n/** @type {WeakSet<Chunk>} */\nconst recordedChunks = new WeakSet();\n\nclass AggressiveSplittingPlugin {\n\t/**\n\t * @param {AggressiveSplittingPluginOptions=} options options object\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\n\t\tthis.options = options;\n\t\tif (typeof this.options.minSize !== \"number\") {\n\t\t\tthis.options.minSize = 30 * 1024;\n\t\t}\n\t\tif (typeof this.options.maxSize !== \"number\") {\n\t\t\tthis.options.maxSize = 50 * 1024;\n\t\t}\n\t\tif (typeof this.options.chunkOverhead !== \"number\") {\n\t\t\tthis.options.chunkOverhead = 0;\n\t\t}\n\t\tif (typeof this.options.entryChunkMultiplicator !== \"number\") {\n\t\t\tthis.options.entryChunkMultiplicator = 1;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk to test\n\t * @returns {boolean} true if the chunk was recorded\n\t */\n\tstatic wasChunkRecorded(chunk) {\n\t\treturn recordedChunks.has(chunk);\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(\n\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tlet needAdditionalSeal = false;\n\t\t\t\tlet newSplits;\n\t\t\t\tlet fromAggressiveSplittingSet;\n\t\t\t\tlet chunkSplitDataMap;\n\t\t\t\tcompilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n\t\t\t\t\tnewSplits = [];\n\t\t\t\t\tfromAggressiveSplittingSet = new Set();\n\t\t\t\t\tchunkSplitDataMap = new Map();\n\t\t\t\t});\n\t\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"AggressiveSplittingPlugin\",\n\t\t\t\t\t\tstage: STAGE_ADVANCED\n\t\t\t\t\t},\n\t\t\t\t\tchunks => {\n\t\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\t\t// Precompute stuff\n\t\t\t\t\t\tconst nameToModuleMap = new Map();\n\t\t\t\t\t\tconst moduleToNameMap = new Map();\n\t\t\t\t\t\tconst makePathsRelative =\n\t\t\t\t\t\t\tidentifierUtils.makePathsRelative.bindContextCache(\n\t\t\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\t\t\tcompiler.root\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tfor (const m of compilation.modules) {\n\t\t\t\t\t\t\tconst name = makePathsRelative(m.identifier());\n\t\t\t\t\t\t\tnameToModuleMap.set(name, m);\n\t\t\t\t\t\t\tmoduleToNameMap.set(m, name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check used chunk ids\n\t\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tusedIds.add(chunk.id);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t(compilation.records && compilation.records.aggressiveSplits) ||\n\t\t\t\t\t\t\t[];\n\t\t\t\t\t\tconst usedSplits = newSplits\n\t\t\t\t\t\t\t? recordedSplits.concat(newSplits)\n\t\t\t\t\t\t\t: recordedSplits;\n\n\t\t\t\t\t\tconst minSize = this.options.minSize;\n\t\t\t\t\t\tconst maxSize = this.options.maxSize;\n\n\t\t\t\t\t\tconst applySplit = splitData => {\n\t\t\t\t\t\t\t// Cannot split if id is already taken\n\t\t\t\t\t\t\tif (splitData.id !== undefined && usedIds.has(splitData.id)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get module objects from names\n\t\t\t\t\t\t\tconst selectedModules = splitData.modules.map(name =>\n\t\t\t\t\t\t\t\tnameToModuleMap.get(name)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Does the modules exist at all?\n\t\t\t\t\t\t\tif (!selectedModules.every(Boolean)) return false;\n\n\t\t\t\t\t\t\t// Check if size matches (faster than waiting for hash)\n\t\t\t\t\t\t\tlet size = 0;\n\t\t\t\t\t\t\tfor (const m of selectedModules) size += m.size();\n\t\t\t\t\t\t\tif (size !== splitData.size) return false;\n\n\t\t\t\t\t\t\t// get chunks with all modules\n\t\t\t\t\t\t\tconst selectedChunks = intersect(\n\t\t\t\t\t\t\t\tselectedModules.map(\n\t\t\t\t\t\t\t\t\tm => new Set(chunkGraph.getModuleChunksIterable(m))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// No relevant chunks found\n\t\t\t\t\t\t\tif (selectedChunks.size === 0) return false;\n\n\t\t\t\t\t\t\t// The found chunk is already the split or similar\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tselectedChunks.size === 1 &&\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(\n\t\t\t\t\t\t\t\t\tArray.from(selectedChunks)[0]\n\t\t\t\t\t\t\t\t) === selectedModules.length\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst chunk = Array.from(selectedChunks)[0];\n\t\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) return false;\n\t\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(chunk);\n\t\t\t\t\t\t\t\tchunkSplitDataMap.set(chunk, splitData);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// split the chunk into two parts\n\t\t\t\t\t\t\tconst newChunk = compilation.addChunk();\n\t\t\t\t\t\t\tnewChunk.chunkReason = \"aggressive splitted\";\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tselectedModules.forEach(\n\t\t\t\t\t\t\t\t\tmoveModuleBetween(chunkGraph, chunk, newChunk)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t\t\tchunk.name = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(newChunk);\n\t\t\t\t\t\t\tchunkSplitDataMap.set(newChunk, splitData);\n\n\t\t\t\t\t\t\tif (splitData.id !== null && splitData.id !== undefined) {\n\t\t\t\t\t\t\t\tnewChunk.id = splitData.id;\n\t\t\t\t\t\t\t\tnewChunk.ids = [splitData.id];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// try to restore to recorded splitting\n\t\t\t\t\t\tlet changed = false;\n\t\t\t\t\t\tfor (let j = 0; j < usedSplits.length; j++) {\n\t\t\t\t\t\t\tconst splitData = usedSplits[j];\n\t\t\t\t\t\t\tif (applySplit(splitData)) changed = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// for any chunk which isn't splitted yet, split it and create a new entry\n\t\t\t\t\t\t// start with the biggest chunk\n\t\t\t\t\t\tconst cmpFn = compareChunks(chunkGraph);\n\t\t\t\t\t\tconst sortedChunks = Array.from(chunks).sort((a, b) => {\n\t\t\t\t\t\t\tconst diff1 =\n\t\t\t\t\t\t\t\tchunkGraph.getChunkModulesSize(b) -\n\t\t\t\t\t\t\t\tchunkGraph.getChunkModulesSize(a);\n\t\t\t\t\t\t\tif (diff1) return diff1;\n\t\t\t\t\t\t\tconst diff2 =\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(a) -\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(b);\n\t\t\t\t\t\t\tif (diff2) return diff2;\n\t\t\t\t\t\t\treturn cmpFn(a, b);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (const chunk of sortedChunks) {\n\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) continue;\n\t\t\t\t\t\t\tconst size = chunkGraph.getChunkModulesSize(chunk);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tsize > maxSize &&\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(chunk) > 1\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst modules = chunkGraph\n\t\t\t\t\t\t\t\t\t.getOrderedChunkModules(chunk, compareModulesByIdentifier)\n\t\t\t\t\t\t\t\t\t.filter(isNotAEntryModule(chunkGraph, chunk));\n\t\t\t\t\t\t\t\tconst selectedModules = [];\n\t\t\t\t\t\t\t\tlet selectedModulesSize = 0;\n\t\t\t\t\t\t\t\tfor (let k = 0; k < modules.length; k++) {\n\t\t\t\t\t\t\t\t\tconst module = modules[k];\n\t\t\t\t\t\t\t\t\tconst newSize = selectedModulesSize + module.size();\n\t\t\t\t\t\t\t\t\tif (newSize > maxSize && selectedModulesSize >= minSize) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tselectedModulesSize = newSize;\n\t\t\t\t\t\t\t\t\tselectedModules.push(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (selectedModules.length === 0) continue;\n\t\t\t\t\t\t\t\tconst splitData = {\n\t\t\t\t\t\t\t\t\tmodules: selectedModules\n\t\t\t\t\t\t\t\t\t\t.map(m => moduleToNameMap.get(m))\n\t\t\t\t\t\t\t\t\t\t.sort(),\n\t\t\t\t\t\t\t\t\tsize: selectedModulesSize\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tif (applySplit(splitData)) {\n\t\t\t\t\t\t\t\t\tnewSplits = (newSplits || []).concat(splitData);\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (changed) return true;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.recordHash.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\trecords => {\n\t\t\t\t\t\t// 4. save made splittings to records\n\t\t\t\t\t\tconst allSplits = new Set();\n\t\t\t\t\t\tconst invalidSplits = new Set();\n\n\t\t\t\t\t\t// Check if some splittings are invalid\n\t\t\t\t\t\t// We remove invalid splittings and try again\n\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\tif (splitData.hash && chunk.hash !== splitData.hash) {\n\t\t\t\t\t\t\t\t\t// Split was successful, but hash doesn't equal\n\t\t\t\t\t\t\t\t\t// We can throw away the split since it's useless now\n\t\t\t\t\t\t\t\t\tinvalidSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (invalidSplits.size > 0) {\n\t\t\t\t\t\t\trecords.aggressiveSplits = records.aggressiveSplits.filter(\n\t\t\t\t\t\t\t\tsplitData => !invalidSplits.has(splitData)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tneedAdditionalSeal = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// set hash and id values on all (new) splittings\n\t\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\t\tsplitData.hash = chunk.hash;\n\t\t\t\t\t\t\t\t\tsplitData.id = chunk.id;\n\t\t\t\t\t\t\t\t\tallSplits.add(splitData);\n\t\t\t\t\t\t\t\t\t// set flag for stats\n\t\t\t\t\t\t\t\t\trecordedChunks.add(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Also add all unused historical splits (after the used ones)\n\t\t\t\t\t\t\t// They can still be used in some future compilation\n\t\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t\tcompilation.records && compilation.records.aggressiveSplits;\n\t\t\t\t\t\t\tif (recordedSplits) {\n\t\t\t\t\t\t\t\tfor (const splitData of recordedSplits) {\n\t\t\t\t\t\t\t\t\tif (!invalidSplits.has(splitData)) allSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// record all splits\n\t\t\t\t\t\t\trecords.aggressiveSplits = Array.from(allSplits);\n\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.needAdditionalSeal.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\t() => {\n\t\t\t\t\t\tif (needAdditionalSeal) {\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = AggressiveSplittingPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}