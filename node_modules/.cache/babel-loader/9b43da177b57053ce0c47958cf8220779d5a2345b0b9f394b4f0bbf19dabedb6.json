{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sergey Melyukov @smelukov\n*/\n\n\"use strict\";\n\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _require = require(\"../ExportsInfo\"),\n  UsageState = _require.UsageState;\n\n/** @typedef {import(\"estree\").Node} AnyNode */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n/** @typedef {import(\"../ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @typedef {Map<TopLevelSymbol | null, Set<string | TopLevelSymbol> | true>} InnerGraph */\n/** @typedef {function(boolean | Set<string> | undefined): void} UsageCallback */\n\n/**\n * @typedef {Object} StateObject\n * @property {InnerGraph} innerGraph\n * @property {TopLevelSymbol=} currentTopLevelSymbol\n * @property {Map<TopLevelSymbol, Set<UsageCallback>>} usageCallbackMap\n */\n\n/** @typedef {false|StateObject} State */\n\n/** @type {WeakMap<ParserState, State>} */\nvar parserStateMap = new WeakMap();\nvar topLevelSymbolTag = Symbol(\"top level symbol\");\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {State} state\n */\nfunction getState(parserState) {\n  return parserStateMap.get(parserState);\n}\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\nexports.bailout = function (parserState) {\n  parserStateMap.set(parserState, false);\n};\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\nexports.enable = function (parserState) {\n  var state = parserStateMap.get(parserState);\n  if (state === false) {\n    return;\n  }\n  parserStateMap.set(parserState, {\n    innerGraph: new Map(),\n    currentTopLevelSymbol: undefined,\n    usageCallbackMap: new Map()\n  });\n};\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {boolean} true, when enabled\n */\nexports.isEnabled = function (parserState) {\n  var state = parserStateMap.get(parserState);\n  return !!state;\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol | null} symbol the symbol, or null for all symbols\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\nexports.addUsage = function (state, symbol, usage) {\n  var innerGraphState = getState(state);\n  if (innerGraphState) {\n    var innerGraph = innerGraphState.innerGraph;\n    var info = innerGraph.get(symbol);\n    if (usage === true) {\n      innerGraph.set(symbol, true);\n    } else if (info === undefined) {\n      innerGraph.set(symbol, new Set([usage]));\n    } else if (info !== true) {\n      info.add(usage);\n    }\n  }\n};\n\n/**\n * @param {JavascriptParser} parser the parser\n * @param {string} name name of variable\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\nexports.addVariableUsage = function (parser, name, usage) {\n  var symbol = /** @type {TopLevelSymbol} */parser.getTagData(name, topLevelSymbolTag) || exports.tagTopLevelSymbol(parser, name);\n  if (symbol) {\n    exports.addUsage(parser.state, symbol, usage);\n  }\n};\n\n/**\n * @param {ParserState} state parser state\n * @returns {void}\n */\nexports.inferDependencyUsage = function (state) {\n  var innerGraphState = getState(state);\n  if (!innerGraphState) {\n    return;\n  }\n  var innerGraph = innerGraphState.innerGraph,\n    usageCallbackMap = innerGraphState.usageCallbackMap;\n  var processed = new Map();\n  // flatten graph to terminal nodes (string, undefined or true)\n  var nonTerminal = new Set(innerGraph.keys());\n  while (nonTerminal.size > 0) {\n    var _iterator = _createForOfIteratorHelper(nonTerminal),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var key = _step.value;\n        /** @type {Set<string|TopLevelSymbol> | true} */\n        var newSet = new Set();\n        var isTerminal = true;\n        var value = innerGraph.get(key);\n        var alreadyProcessed = processed.get(key);\n        if (alreadyProcessed === undefined) {\n          alreadyProcessed = new Set();\n          processed.set(key, alreadyProcessed);\n        }\n        if (value !== true && value !== undefined) {\n          var _iterator2 = _createForOfIteratorHelper(value),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var item = _step2.value;\n              alreadyProcessed.add(item);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          var _iterator3 = _createForOfIteratorHelper(value),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _item = _step3.value;\n              if (typeof _item === \"string\") {\n                newSet.add(_item);\n              } else {\n                var itemValue = innerGraph.get(_item);\n                if (itemValue === true) {\n                  newSet = true;\n                  break;\n                }\n                if (itemValue !== undefined) {\n                  var _iterator4 = _createForOfIteratorHelper(itemValue),\n                    _step4;\n                  try {\n                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                      var i = _step4.value;\n                      if (i === key) continue;\n                      if (alreadyProcessed.has(i)) continue;\n                      newSet.add(i);\n                      if (typeof i !== \"string\") {\n                        isTerminal = false;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator4.e(err);\n                  } finally {\n                    _iterator4.f();\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          if (newSet === true) {\n            innerGraph.set(key, true);\n          } else if (newSet.size === 0) {\n            innerGraph.set(key, undefined);\n          } else {\n            innerGraph.set(key, newSet);\n          }\n        }\n        if (isTerminal) {\n          nonTerminal.delete(key);\n\n          // For the global key, merge with all other keys\n          if (key === null) {\n            var globalValue = innerGraph.get(null);\n            if (globalValue) {\n              var _iterator5 = _createForOfIteratorHelper(innerGraph),\n                _step5;\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  var _step5$value = _slicedToArray(_step5.value, 2),\n                    _key = _step5$value[0],\n                    _value = _step5$value[1];\n                  if (_key !== null && _value !== true) {\n                    if (globalValue === true) {\n                      innerGraph.set(_key, true);\n                    } else {\n                      var _newSet = new Set(_value);\n                      var _iterator6 = _createForOfIteratorHelper(globalValue),\n                        _step6;\n                      try {\n                        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                          var _item2 = _step6.value;\n                          _newSet.add(_item2);\n                        }\n                      } catch (err) {\n                        _iterator6.e(err);\n                      } finally {\n                        _iterator6.f();\n                      }\n                      innerGraph.set(_key, _newSet);\n                    }\n                  }\n                }\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  /** @type {Map<Dependency, true | Set<string>>} */\n  var _iterator7 = _createForOfIteratorHelper(usageCallbackMap),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var _step7$value = _slicedToArray(_step7.value, 2),\n        symbol = _step7$value[0],\n        callbacks = _step7$value[1];\n      var usage = /** @type {true | Set<string> | undefined} */\n      innerGraph.get(symbol);\n      var _iterator8 = _createForOfIteratorHelper(callbacks),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var callback = _step8.value;\n          callback(usage === undefined ? false : usage);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {UsageCallback} onUsageCallback on usage callback\n */\nexports.onUsage = function (state, onUsageCallback) {\n  var innerGraphState = getState(state);\n  if (innerGraphState) {\n    var usageCallbackMap = innerGraphState.usageCallbackMap,\n      currentTopLevelSymbol = innerGraphState.currentTopLevelSymbol;\n    if (currentTopLevelSymbol) {\n      var callbacks = usageCallbackMap.get(currentTopLevelSymbol);\n      if (callbacks === undefined) {\n        callbacks = new Set();\n        usageCallbackMap.set(currentTopLevelSymbol, callbacks);\n      }\n      callbacks.add(onUsageCallback);\n    } else {\n      onUsageCallback(true);\n    }\n  } else {\n    onUsageCallback(undefined);\n  }\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol} symbol the symbol\n */\nexports.setTopLevelSymbol = function (state, symbol) {\n  var innerGraphState = getState(state);\n  if (innerGraphState) {\n    innerGraphState.currentTopLevelSymbol = symbol;\n  }\n};\n\n/**\n * @param {ParserState} state parser state\n * @returns {TopLevelSymbol|void} usage data\n */\nexports.getTopLevelSymbol = function (state) {\n  var innerGraphState = getState(state);\n  if (innerGraphState) {\n    return innerGraphState.currentTopLevelSymbol;\n  }\n};\n\n/**\n * @param {JavascriptParser} parser parser\n * @param {string} name name of variable\n * @returns {TopLevelSymbol} symbol\n */\nexports.tagTopLevelSymbol = function (parser, name) {\n  var innerGraphState = getState(parser.state);\n  if (!innerGraphState) return;\n  parser.defineVariable(name);\n  var existingTag = /** @type {TopLevelSymbol} */\n  parser.getTagData(name, topLevelSymbolTag);\n  if (existingTag) {\n    return existingTag;\n  }\n  var fn = new TopLevelSymbol(name);\n  parser.tagVariable(name, topLevelSymbolTag, fn);\n  return fn;\n};\n\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @param {RuntimeSpec} runtime runtime\n * @returns {boolean} false, when unused. Otherwise true\n */\nexports.isDependencyUsedByExports = function (dependency, usedByExports, moduleGraph, runtime) {\n  if (usedByExports === false) return false;\n  if (usedByExports !== true && usedByExports !== undefined) {\n    var selfModule = moduleGraph.getParentModule(dependency);\n    var exportsInfo = moduleGraph.getExportsInfo(selfModule);\n    var used = false;\n    var _iterator9 = _createForOfIteratorHelper(usedByExports),\n      _step9;\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var exportName = _step9.value;\n        if (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused) used = true;\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n    if (!used) return false;\n  }\n  return true;\n};\n\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @returns {null | false | function(ModuleGraphConnection, RuntimeSpec): ConnectionState} function to determine if the connection is active\n */\nexports.getDependencyUsedByExportsCondition = function (dependency, usedByExports, moduleGraph) {\n  if (usedByExports === false) return false;\n  if (usedByExports !== true && usedByExports !== undefined) {\n    var selfModule = moduleGraph.getParentModule(dependency);\n    var exportsInfo = moduleGraph.getExportsInfo(selfModule);\n    return function (connections, runtime) {\n      var _iterator10 = _createForOfIteratorHelper(usedByExports),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var exportName = _step10.value;\n          if (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused) return true;\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n      return false;\n    };\n  }\n  return null;\n};\nvar TopLevelSymbol = /*#__PURE__*/_createClass(\n/**\n * @param {string} name name of the variable\n */\nfunction TopLevelSymbol(name) {\n  _classCallCheck(this, TopLevelSymbol);\n  this.name = name;\n});\nexports.TopLevelSymbol = TopLevelSymbol;\nexports.topLevelSymbolTag = topLevelSymbolTag;","map":{"version":3,"names":["require","UsageState","parserStateMap","WeakMap","topLevelSymbolTag","Symbol","getState","parserState","get","exports","bailout","set","enable","state","innerGraph","Map","currentTopLevelSymbol","undefined","usageCallbackMap","isEnabled","addUsage","symbol","usage","innerGraphState","info","Set","add","addVariableUsage","parser","name","getTagData","tagTopLevelSymbol","inferDependencyUsage","processed","nonTerminal","keys","size","key","newSet","isTerminal","value","alreadyProcessed","item","itemValue","i","has","delete","globalValue","callbacks","callback","onUsage","onUsageCallback","setTopLevelSymbol","getTopLevelSymbol","defineVariable","existingTag","fn","TopLevelSymbol","tagVariable","isDependencyUsedByExports","dependency","usedByExports","moduleGraph","runtime","selfModule","getParentModule","exportsInfo","getExportsInfo","used","exportName","getUsed","Unused","getDependencyUsedByExportsCondition","connections"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/optimize/InnerGraph.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sergey Melyukov @smelukov\n*/\n\n\"use strict\";\n\nconst { UsageState } = require(\"../ExportsInfo\");\n\n/** @typedef {import(\"estree\").Node} AnyNode */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n/** @typedef {import(\"../ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @typedef {Map<TopLevelSymbol | null, Set<string | TopLevelSymbol> | true>} InnerGraph */\n/** @typedef {function(boolean | Set<string> | undefined): void} UsageCallback */\n\n/**\n * @typedef {Object} StateObject\n * @property {InnerGraph} innerGraph\n * @property {TopLevelSymbol=} currentTopLevelSymbol\n * @property {Map<TopLevelSymbol, Set<UsageCallback>>} usageCallbackMap\n */\n\n/** @typedef {false|StateObject} State */\n\n/** @type {WeakMap<ParserState, State>} */\nconst parserStateMap = new WeakMap();\nconst topLevelSymbolTag = Symbol(\"top level symbol\");\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {State} state\n */\nfunction getState(parserState) {\n\treturn parserStateMap.get(parserState);\n}\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\nexports.bailout = parserState => {\n\tparserStateMap.set(parserState, false);\n};\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\nexports.enable = parserState => {\n\tconst state = parserStateMap.get(parserState);\n\tif (state === false) {\n\t\treturn;\n\t}\n\tparserStateMap.set(parserState, {\n\t\tinnerGraph: new Map(),\n\t\tcurrentTopLevelSymbol: undefined,\n\t\tusageCallbackMap: new Map()\n\t});\n};\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {boolean} true, when enabled\n */\nexports.isEnabled = parserState => {\n\tconst state = parserStateMap.get(parserState);\n\treturn !!state;\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol | null} symbol the symbol, or null for all symbols\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\nexports.addUsage = (state, symbol, usage) => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\tconst { innerGraph } = innerGraphState;\n\t\tconst info = innerGraph.get(symbol);\n\t\tif (usage === true) {\n\t\t\tinnerGraph.set(symbol, true);\n\t\t} else if (info === undefined) {\n\t\t\tinnerGraph.set(symbol, new Set([usage]));\n\t\t} else if (info !== true) {\n\t\t\tinfo.add(usage);\n\t\t}\n\t}\n};\n\n/**\n * @param {JavascriptParser} parser the parser\n * @param {string} name name of variable\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\nexports.addVariableUsage = (parser, name, usage) => {\n\tconst symbol =\n\t\t/** @type {TopLevelSymbol} */ (\n\t\t\tparser.getTagData(name, topLevelSymbolTag)\n\t\t) || exports.tagTopLevelSymbol(parser, name);\n\tif (symbol) {\n\t\texports.addUsage(parser.state, symbol, usage);\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @returns {void}\n */\nexports.inferDependencyUsage = state => {\n\tconst innerGraphState = getState(state);\n\n\tif (!innerGraphState) {\n\t\treturn;\n\t}\n\n\tconst { innerGraph, usageCallbackMap } = innerGraphState;\n\tconst processed = new Map();\n\t// flatten graph to terminal nodes (string, undefined or true)\n\tconst nonTerminal = new Set(innerGraph.keys());\n\twhile (nonTerminal.size > 0) {\n\t\tfor (const key of nonTerminal) {\n\t\t\t/** @type {Set<string|TopLevelSymbol> | true} */\n\t\t\tlet newSet = new Set();\n\t\t\tlet isTerminal = true;\n\t\t\tconst value = innerGraph.get(key);\n\t\t\tlet alreadyProcessed = processed.get(key);\n\t\t\tif (alreadyProcessed === undefined) {\n\t\t\t\talreadyProcessed = new Set();\n\t\t\t\tprocessed.set(key, alreadyProcessed);\n\t\t\t}\n\t\t\tif (value !== true && value !== undefined) {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\talreadyProcessed.add(item);\n\t\t\t\t}\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\tif (typeof item === \"string\") {\n\t\t\t\t\t\tnewSet.add(item);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst itemValue = innerGraph.get(item);\n\t\t\t\t\t\tif (itemValue === true) {\n\t\t\t\t\t\t\tnewSet = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (itemValue !== undefined) {\n\t\t\t\t\t\t\tfor (const i of itemValue) {\n\t\t\t\t\t\t\t\tif (i === key) continue;\n\t\t\t\t\t\t\t\tif (alreadyProcessed.has(i)) continue;\n\t\t\t\t\t\t\t\tnewSet.add(i);\n\t\t\t\t\t\t\t\tif (typeof i !== \"string\") {\n\t\t\t\t\t\t\t\t\tisTerminal = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (newSet === true) {\n\t\t\t\t\tinnerGraph.set(key, true);\n\t\t\t\t} else if (newSet.size === 0) {\n\t\t\t\t\tinnerGraph.set(key, undefined);\n\t\t\t\t} else {\n\t\t\t\t\tinnerGraph.set(key, newSet);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isTerminal) {\n\t\t\t\tnonTerminal.delete(key);\n\n\t\t\t\t// For the global key, merge with all other keys\n\t\t\t\tif (key === null) {\n\t\t\t\t\tconst globalValue = innerGraph.get(null);\n\t\t\t\t\tif (globalValue) {\n\t\t\t\t\t\tfor (const [key, value] of innerGraph) {\n\t\t\t\t\t\t\tif (key !== null && value !== true) {\n\t\t\t\t\t\t\t\tif (globalValue === true) {\n\t\t\t\t\t\t\t\t\tinnerGraph.set(key, true);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst newSet = new Set(value);\n\t\t\t\t\t\t\t\t\tfor (const item of globalValue) {\n\t\t\t\t\t\t\t\t\t\tnewSet.add(item);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tinnerGraph.set(key, newSet);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @type {Map<Dependency, true | Set<string>>} */\n\tfor (const [symbol, callbacks] of usageCallbackMap) {\n\t\tconst usage = /** @type {true | Set<string> | undefined} */ (\n\t\t\tinnerGraph.get(symbol)\n\t\t);\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(usage === undefined ? false : usage);\n\t\t}\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {UsageCallback} onUsageCallback on usage callback\n */\nexports.onUsage = (state, onUsageCallback) => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\tconst { usageCallbackMap, currentTopLevelSymbol } = innerGraphState;\n\t\tif (currentTopLevelSymbol) {\n\t\t\tlet callbacks = usageCallbackMap.get(currentTopLevelSymbol);\n\n\t\t\tif (callbacks === undefined) {\n\t\t\t\tcallbacks = new Set();\n\t\t\t\tusageCallbackMap.set(currentTopLevelSymbol, callbacks);\n\t\t\t}\n\n\t\t\tcallbacks.add(onUsageCallback);\n\t\t} else {\n\t\t\tonUsageCallback(true);\n\t\t}\n\t} else {\n\t\tonUsageCallback(undefined);\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol} symbol the symbol\n */\nexports.setTopLevelSymbol = (state, symbol) => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\tinnerGraphState.currentTopLevelSymbol = symbol;\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @returns {TopLevelSymbol|void} usage data\n */\nexports.getTopLevelSymbol = state => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\treturn innerGraphState.currentTopLevelSymbol;\n\t}\n};\n\n/**\n * @param {JavascriptParser} parser parser\n * @param {string} name name of variable\n * @returns {TopLevelSymbol} symbol\n */\nexports.tagTopLevelSymbol = (parser, name) => {\n\tconst innerGraphState = getState(parser.state);\n\tif (!innerGraphState) return;\n\n\tparser.defineVariable(name);\n\n\tconst existingTag = /** @type {TopLevelSymbol} */ (\n\t\tparser.getTagData(name, topLevelSymbolTag)\n\t);\n\tif (existingTag) {\n\t\treturn existingTag;\n\t}\n\n\tconst fn = new TopLevelSymbol(name);\n\tparser.tagVariable(name, topLevelSymbolTag, fn);\n\treturn fn;\n};\n\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @param {RuntimeSpec} runtime runtime\n * @returns {boolean} false, when unused. Otherwise true\n */\nexports.isDependencyUsedByExports = (\n\tdependency,\n\tusedByExports,\n\tmoduleGraph,\n\truntime\n) => {\n\tif (usedByExports === false) return false;\n\tif (usedByExports !== true && usedByExports !== undefined) {\n\t\tconst selfModule = moduleGraph.getParentModule(dependency);\n\t\tconst exportsInfo = moduleGraph.getExportsInfo(selfModule);\n\t\tlet used = false;\n\t\tfor (const exportName of usedByExports) {\n\t\t\tif (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused)\n\t\t\t\tused = true;\n\t\t}\n\t\tif (!used) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @returns {null | false | function(ModuleGraphConnection, RuntimeSpec): ConnectionState} function to determine if the connection is active\n */\nexports.getDependencyUsedByExportsCondition = (\n\tdependency,\n\tusedByExports,\n\tmoduleGraph\n) => {\n\tif (usedByExports === false) return false;\n\tif (usedByExports !== true && usedByExports !== undefined) {\n\t\tconst selfModule = moduleGraph.getParentModule(dependency);\n\t\tconst exportsInfo = moduleGraph.getExportsInfo(selfModule);\n\t\treturn (connections, runtime) => {\n\t\t\tfor (const exportName of usedByExports) {\n\t\t\t\tif (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t}\n\treturn null;\n};\n\nclass TopLevelSymbol {\n\t/**\n\t * @param {string} name name of the variable\n\t */\n\tconstructor(name) {\n\t\tthis.name = name;\n\t}\n}\n\nexports.TopLevelSymbol = TopLevelSymbol;\nexports.topLevelSymbolTag = topLevelSymbolTag;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}