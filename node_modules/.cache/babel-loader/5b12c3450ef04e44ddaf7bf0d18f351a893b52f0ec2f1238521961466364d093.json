{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar Cache = require(\"../Cache\");\nvar ProgressPlugin = require(\"../ProgressPlugin\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nvar BUILD_DEPENDENCIES_KEY = Symbol();\nvar IdleFileCachePlugin = /*#__PURE__*/function () {\n  /**\n   * @param {TODO} strategy cache strategy\n   * @param {number} idleTimeout timeout\n   * @param {number} idleTimeoutForInitialStore initial timeout\n   * @param {number} idleTimeoutAfterLargeChanges timeout after changes\n   */\n  function IdleFileCachePlugin(strategy, idleTimeout, idleTimeoutForInitialStore, idleTimeoutAfterLargeChanges) {\n    _classCallCheck(this, IdleFileCachePlugin);\n    this.strategy = strategy;\n    this.idleTimeout = idleTimeout;\n    this.idleTimeoutForInitialStore = idleTimeoutForInitialStore;\n    this.idleTimeoutAfterLargeChanges = idleTimeoutAfterLargeChanges;\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  _createClass(IdleFileCachePlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var strategy = this.strategy;\n      var idleTimeout = this.idleTimeout;\n      var idleTimeoutForInitialStore = Math.min(idleTimeout, this.idleTimeoutForInitialStore);\n      var idleTimeoutAfterLargeChanges = this.idleTimeoutAfterLargeChanges;\n      var resolvedPromise = Promise.resolve();\n      var timeSpendInBuild = 0;\n      var timeSpendInStore = 0;\n      var avgTimeSpendInStore = 0;\n\n      /** @type {Map<string | typeof BUILD_DEPENDENCIES_KEY, () => Promise>} */\n      var pendingIdleTasks = new Map();\n      compiler.cache.hooks.store.tap({\n        name: \"IdleFileCachePlugin\",\n        stage: Cache.STAGE_DISK\n      }, function (identifier, etag, data) {\n        pendingIdleTasks.set(identifier, function () {\n          return strategy.store(identifier, etag, data);\n        });\n      });\n      compiler.cache.hooks.get.tapPromise({\n        name: \"IdleFileCachePlugin\",\n        stage: Cache.STAGE_DISK\n      }, function (identifier, etag, gotHandlers) {\n        var restore = function restore() {\n          return strategy.restore(identifier, etag).then(function (cacheEntry) {\n            if (cacheEntry === undefined) {\n              gotHandlers.push(function (result, callback) {\n                if (result !== undefined) {\n                  pendingIdleTasks.set(identifier, function () {\n                    return strategy.store(identifier, etag, result);\n                  });\n                }\n                callback();\n              });\n            } else {\n              return cacheEntry;\n            }\n          });\n        };\n        var pendingTask = pendingIdleTasks.get(identifier);\n        if (pendingTask !== undefined) {\n          pendingIdleTasks.delete(identifier);\n          return pendingTask().then(restore);\n        }\n        return restore();\n      });\n      compiler.cache.hooks.storeBuildDependencies.tap({\n        name: \"IdleFileCachePlugin\",\n        stage: Cache.STAGE_DISK\n      }, function (dependencies) {\n        pendingIdleTasks.set(BUILD_DEPENDENCIES_KEY, function () {\n          return strategy.storeBuildDependencies(dependencies);\n        });\n      });\n      compiler.cache.hooks.shutdown.tapPromise({\n        name: \"IdleFileCachePlugin\",\n        stage: Cache.STAGE_DISK\n      }, function () {\n        if (idleTimer) {\n          clearTimeout(idleTimer);\n          idleTimer = undefined;\n        }\n        isIdle = false;\n        var reportProgress = ProgressPlugin.getReporter(compiler);\n        var jobs = Array.from(pendingIdleTasks.values());\n        if (reportProgress) reportProgress(0, \"process pending cache items\");\n        var promises = jobs.map(function (fn) {\n          return fn();\n        });\n        pendingIdleTasks.clear();\n        promises.push(currentIdlePromise);\n        var promise = Promise.all(promises);\n        currentIdlePromise = promise.then(function () {\n          return strategy.afterAllStored();\n        });\n        if (reportProgress) {\n          currentIdlePromise = currentIdlePromise.then(function () {\n            reportProgress(1, \"stored\");\n          });\n        }\n        return currentIdlePromise.then(function () {\n          // Reset strategy\n          if (strategy.clear) strategy.clear();\n        });\n      });\n\n      /** @type {Promise<any>} */\n      var currentIdlePromise = resolvedPromise;\n      var isIdle = false;\n      var isInitialStore = true;\n      var processIdleTasks = function processIdleTasks() {\n        if (isIdle) {\n          var startTime = Date.now();\n          if (pendingIdleTasks.size > 0) {\n            var promises = [currentIdlePromise];\n            var maxTime = startTime + 100;\n            var maxCount = 100;\n            var _iterator = _createForOfIteratorHelper(pendingIdleTasks),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var _step$value = _slicedToArray(_step.value, 2),\n                  filename = _step$value[0],\n                  factory = _step$value[1];\n                pendingIdleTasks.delete(filename);\n                promises.push(factory());\n                if (maxCount-- <= 0 || Date.now() > maxTime) break;\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n            currentIdlePromise = Promise.all(promises);\n            currentIdlePromise.then(function () {\n              timeSpendInStore += Date.now() - startTime;\n              // Allow to exit the process between\n              idleTimer = setTimeout(processIdleTasks, 0);\n              idleTimer.unref();\n            });\n            return;\n          }\n          currentIdlePromise = currentIdlePromise.then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n            return _regeneratorRuntime().wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return strategy.afterAllStored();\n                case 2:\n                  timeSpendInStore += Date.now() - startTime;\n                  avgTimeSpendInStore = Math.max(avgTimeSpendInStore, timeSpendInStore) * 0.9 + timeSpendInStore * 0.1;\n                  timeSpendInStore = 0;\n                  timeSpendInBuild = 0;\n                case 6:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }))).catch(function (err) {\n            var logger = compiler.getInfrastructureLogger(\"IdleFileCachePlugin\");\n            logger.warn(\"Background tasks during idle failed: \".concat(err.message));\n            logger.debug(err.stack);\n          });\n          isInitialStore = false;\n        }\n      };\n      var idleTimer = undefined;\n      compiler.cache.hooks.beginIdle.tap({\n        name: \"IdleFileCachePlugin\",\n        stage: Cache.STAGE_DISK\n      }, function () {\n        var isLargeChange = timeSpendInBuild > avgTimeSpendInStore * 2;\n        if (isInitialStore && idleTimeoutForInitialStore < idleTimeout) {\n          compiler.getInfrastructureLogger(\"IdleFileCachePlugin\").log(\"Initial cache was generated and cache will be persisted in \".concat(idleTimeoutForInitialStore / 1000, \"s.\"));\n        } else if (isLargeChange && idleTimeoutAfterLargeChanges < idleTimeout) {\n          compiler.getInfrastructureLogger(\"IdleFileCachePlugin\").log(\"Spend \".concat(Math.round(timeSpendInBuild) / 1000, \"s in build and \").concat(Math.round(avgTimeSpendInStore) / 1000, \"s in average in cache store. This is considered as large change and cache will be persisted in \").concat(idleTimeoutAfterLargeChanges / 1000, \"s.\"));\n        }\n        idleTimer = setTimeout(function () {\n          idleTimer = undefined;\n          isIdle = true;\n          resolvedPromise.then(processIdleTasks);\n        }, Math.min(isInitialStore ? idleTimeoutForInitialStore : Infinity, isLargeChange ? idleTimeoutAfterLargeChanges : Infinity, idleTimeout));\n        idleTimer.unref();\n      });\n      compiler.cache.hooks.endIdle.tap({\n        name: \"IdleFileCachePlugin\",\n        stage: Cache.STAGE_DISK\n      }, function () {\n        if (idleTimer) {\n          clearTimeout(idleTimer);\n          idleTimer = undefined;\n        }\n        isIdle = false;\n      });\n      compiler.hooks.done.tap(\"IdleFileCachePlugin\", function (stats) {\n        // 10% build overhead is ignored, as it's not cacheable\n        timeSpendInBuild *= 0.9;\n        timeSpendInBuild += stats.endTime - stats.startTime;\n      });\n    }\n  }]);\n  return IdleFileCachePlugin;\n}();\nmodule.exports = IdleFileCachePlugin;","map":{"version":3,"names":["Cache","require","ProgressPlugin","BUILD_DEPENDENCIES_KEY","Symbol","IdleFileCachePlugin","strategy","idleTimeout","idleTimeoutForInitialStore","idleTimeoutAfterLargeChanges","compiler","Math","min","resolvedPromise","Promise","resolve","timeSpendInBuild","timeSpendInStore","avgTimeSpendInStore","pendingIdleTasks","Map","cache","hooks","store","tap","name","stage","STAGE_DISK","identifier","etag","data","set","get","tapPromise","gotHandlers","restore","then","cacheEntry","undefined","push","result","callback","pendingTask","delete","storeBuildDependencies","dependencies","shutdown","idleTimer","clearTimeout","isIdle","reportProgress","getReporter","jobs","Array","from","values","promises","map","fn","clear","currentIdlePromise","promise","all","afterAllStored","isInitialStore","processIdleTasks","startTime","Date","now","size","maxTime","maxCount","filename","factory","setTimeout","unref","max","catch","err","logger","getInfrastructureLogger","warn","message","debug","stack","beginIdle","isLargeChange","log","round","Infinity","endIdle","done","stats","endTime","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/cache/IdleFileCachePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Cache = require(\"../Cache\");\nconst ProgressPlugin = require(\"../ProgressPlugin\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst BUILD_DEPENDENCIES_KEY = Symbol();\n\nclass IdleFileCachePlugin {\n\t/**\n\t * @param {TODO} strategy cache strategy\n\t * @param {number} idleTimeout timeout\n\t * @param {number} idleTimeoutForInitialStore initial timeout\n\t * @param {number} idleTimeoutAfterLargeChanges timeout after changes\n\t */\n\tconstructor(\n\t\tstrategy,\n\t\tidleTimeout,\n\t\tidleTimeoutForInitialStore,\n\t\tidleTimeoutAfterLargeChanges\n\t) {\n\t\tthis.strategy = strategy;\n\t\tthis.idleTimeout = idleTimeout;\n\t\tthis.idleTimeoutForInitialStore = idleTimeoutForInitialStore;\n\t\tthis.idleTimeoutAfterLargeChanges = idleTimeoutAfterLargeChanges;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tlet strategy = this.strategy;\n\t\tconst idleTimeout = this.idleTimeout;\n\t\tconst idleTimeoutForInitialStore = Math.min(\n\t\t\tidleTimeout,\n\t\t\tthis.idleTimeoutForInitialStore\n\t\t);\n\t\tconst idleTimeoutAfterLargeChanges = this.idleTimeoutAfterLargeChanges;\n\t\tconst resolvedPromise = Promise.resolve();\n\n\t\tlet timeSpendInBuild = 0;\n\t\tlet timeSpendInStore = 0;\n\t\tlet avgTimeSpendInStore = 0;\n\n\t\t/** @type {Map<string | typeof BUILD_DEPENDENCIES_KEY, () => Promise>} */\n\t\tconst pendingIdleTasks = new Map();\n\n\t\tcompiler.cache.hooks.store.tap(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t(identifier, etag, data) => {\n\t\t\t\tpendingIdleTasks.set(identifier, () =>\n\t\t\t\t\tstrategy.store(identifier, etag, data)\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\n\t\tcompiler.cache.hooks.get.tapPromise(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t(identifier, etag, gotHandlers) => {\n\t\t\t\tconst restore = () =>\n\t\t\t\t\tstrategy.restore(identifier, etag).then(cacheEntry => {\n\t\t\t\t\t\tif (cacheEntry === undefined) {\n\t\t\t\t\t\t\tgotHandlers.push((result, callback) => {\n\t\t\t\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\t\t\t\tpendingIdleTasks.set(identifier, () =>\n\t\t\t\t\t\t\t\t\t\tstrategy.store(identifier, etag, result)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn cacheEntry;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\tconst pendingTask = pendingIdleTasks.get(identifier);\n\t\t\t\tif (pendingTask !== undefined) {\n\t\t\t\t\tpendingIdleTasks.delete(identifier);\n\t\t\t\t\treturn pendingTask().then(restore);\n\t\t\t\t}\n\t\t\t\treturn restore();\n\t\t\t}\n\t\t);\n\n\t\tcompiler.cache.hooks.storeBuildDependencies.tap(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\tdependencies => {\n\t\t\t\tpendingIdleTasks.set(BUILD_DEPENDENCIES_KEY, () =>\n\t\t\t\t\tstrategy.storeBuildDependencies(dependencies)\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\n\t\tcompiler.cache.hooks.shutdown.tapPromise(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t() => {\n\t\t\t\tif (idleTimer) {\n\t\t\t\t\tclearTimeout(idleTimer);\n\t\t\t\t\tidleTimer = undefined;\n\t\t\t\t}\n\t\t\t\tisIdle = false;\n\t\t\t\tconst reportProgress = ProgressPlugin.getReporter(compiler);\n\t\t\t\tconst jobs = Array.from(pendingIdleTasks.values());\n\t\t\t\tif (reportProgress) reportProgress(0, \"process pending cache items\");\n\t\t\t\tconst promises = jobs.map(fn => fn());\n\t\t\t\tpendingIdleTasks.clear();\n\t\t\t\tpromises.push(currentIdlePromise);\n\t\t\t\tconst promise = Promise.all(promises);\n\t\t\t\tcurrentIdlePromise = promise.then(() => strategy.afterAllStored());\n\t\t\t\tif (reportProgress) {\n\t\t\t\t\tcurrentIdlePromise = currentIdlePromise.then(() => {\n\t\t\t\t\t\treportProgress(1, `stored`);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn currentIdlePromise.then(() => {\n\t\t\t\t\t// Reset strategy\n\t\t\t\t\tif (strategy.clear) strategy.clear();\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\n\t\t/** @type {Promise<any>} */\n\t\tlet currentIdlePromise = resolvedPromise;\n\t\tlet isIdle = false;\n\t\tlet isInitialStore = true;\n\t\tconst processIdleTasks = () => {\n\t\t\tif (isIdle) {\n\t\t\t\tconst startTime = Date.now();\n\t\t\t\tif (pendingIdleTasks.size > 0) {\n\t\t\t\t\tconst promises = [currentIdlePromise];\n\t\t\t\t\tconst maxTime = startTime + 100;\n\t\t\t\t\tlet maxCount = 100;\n\t\t\t\t\tfor (const [filename, factory] of pendingIdleTasks) {\n\t\t\t\t\t\tpendingIdleTasks.delete(filename);\n\t\t\t\t\t\tpromises.push(factory());\n\t\t\t\t\t\tif (maxCount-- <= 0 || Date.now() > maxTime) break;\n\t\t\t\t\t}\n\t\t\t\t\tcurrentIdlePromise = Promise.all(promises);\n\t\t\t\t\tcurrentIdlePromise.then(() => {\n\t\t\t\t\t\ttimeSpendInStore += Date.now() - startTime;\n\t\t\t\t\t\t// Allow to exit the process between\n\t\t\t\t\t\tidleTimer = setTimeout(processIdleTasks, 0);\n\t\t\t\t\t\tidleTimer.unref();\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentIdlePromise = currentIdlePromise\n\t\t\t\t\t.then(async () => {\n\t\t\t\t\t\tawait strategy.afterAllStored();\n\t\t\t\t\t\ttimeSpendInStore += Date.now() - startTime;\n\t\t\t\t\t\tavgTimeSpendInStore =\n\t\t\t\t\t\t\tMath.max(avgTimeSpendInStore, timeSpendInStore) * 0.9 +\n\t\t\t\t\t\t\ttimeSpendInStore * 0.1;\n\t\t\t\t\t\ttimeSpendInStore = 0;\n\t\t\t\t\t\ttimeSpendInBuild = 0;\n\t\t\t\t\t})\n\t\t\t\t\t.catch(err => {\n\t\t\t\t\t\tconst logger = compiler.getInfrastructureLogger(\n\t\t\t\t\t\t\t\"IdleFileCachePlugin\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\tlogger.warn(`Background tasks during idle failed: ${err.message}`);\n\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t});\n\t\t\t\tisInitialStore = false;\n\t\t\t}\n\t\t};\n\t\tlet idleTimer = undefined;\n\t\tcompiler.cache.hooks.beginIdle.tap(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t() => {\n\t\t\t\tconst isLargeChange = timeSpendInBuild > avgTimeSpendInStore * 2;\n\t\t\t\tif (isInitialStore && idleTimeoutForInitialStore < idleTimeout) {\n\t\t\t\t\tcompiler\n\t\t\t\t\t\t.getInfrastructureLogger(\"IdleFileCachePlugin\")\n\t\t\t\t\t\t.log(\n\t\t\t\t\t\t\t`Initial cache was generated and cache will be persisted in ${\n\t\t\t\t\t\t\t\tidleTimeoutForInitialStore / 1000\n\t\t\t\t\t\t\t}s.`\n\t\t\t\t\t\t);\n\t\t\t\t} else if (\n\t\t\t\t\tisLargeChange &&\n\t\t\t\t\tidleTimeoutAfterLargeChanges < idleTimeout\n\t\t\t\t) {\n\t\t\t\t\tcompiler\n\t\t\t\t\t\t.getInfrastructureLogger(\"IdleFileCachePlugin\")\n\t\t\t\t\t\t.log(\n\t\t\t\t\t\t\t`Spend ${Math.round(timeSpendInBuild) / 1000}s in build and ${\n\t\t\t\t\t\t\t\tMath.round(avgTimeSpendInStore) / 1000\n\t\t\t\t\t\t\t}s in average in cache store. This is considered as large change and cache will be persisted in ${\n\t\t\t\t\t\t\t\tidleTimeoutAfterLargeChanges / 1000\n\t\t\t\t\t\t\t}s.`\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tidleTimer = setTimeout(() => {\n\t\t\t\t\tidleTimer = undefined;\n\t\t\t\t\tisIdle = true;\n\t\t\t\t\tresolvedPromise.then(processIdleTasks);\n\t\t\t\t}, Math.min(isInitialStore ? idleTimeoutForInitialStore : Infinity, isLargeChange ? idleTimeoutAfterLargeChanges : Infinity, idleTimeout));\n\t\t\t\tidleTimer.unref();\n\t\t\t}\n\t\t);\n\t\tcompiler.cache.hooks.endIdle.tap(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t() => {\n\t\t\t\tif (idleTimer) {\n\t\t\t\t\tclearTimeout(idleTimer);\n\t\t\t\t\tidleTimer = undefined;\n\t\t\t\t}\n\t\t\t\tisIdle = false;\n\t\t\t}\n\t\t);\n\t\tcompiler.hooks.done.tap(\"IdleFileCachePlugin\", stats => {\n\t\t\t// 10% build overhead is ignored, as it's not cacheable\n\t\t\ttimeSpendInBuild *= 0.9;\n\t\t\ttimeSpendInBuild += stats.endTime - stats.startTime;\n\t\t});\n\t}\n}\n\nmodule.exports = IdleFileCachePlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}