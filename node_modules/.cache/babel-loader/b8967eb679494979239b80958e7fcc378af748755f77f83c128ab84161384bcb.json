{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar Source = require(\"./Source\");\nvar RawSource = require(\"./RawSource\");\nvar _streamChunks = require(\"./helpers/streamChunks\");\nvar _require = require(\"./helpers/getFromStreamChunks\"),\n  getMap = _require.getMap,\n  getSourceAndMap = _require.getSourceAndMap;\nvar stringsAsRawSources = new WeakSet();\nvar ConcatSource = /*#__PURE__*/function (_Source) {\n  _inherits(ConcatSource, _Source);\n  var _super = _createSuper(ConcatSource);\n  function ConcatSource() {\n    var _this;\n    _classCallCheck(this, ConcatSource);\n    _this = _super.call(this);\n    _this._children = [];\n    for (var i = 0; i < arguments.length; i++) {\n      var item = arguments[i];\n      if (item instanceof ConcatSource) {\n        var _iterator = _createForOfIteratorHelper(item._children),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var child = _step.value;\n            _this._children.push(child);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        _this._children.push(item);\n      }\n    }\n    _this._isOptimized = arguments.length === 0;\n    return _this;\n  }\n  _createClass(ConcatSource, [{\n    key: \"getChildren\",\n    value: function getChildren() {\n      if (!this._isOptimized) this._optimize();\n      return this._children;\n    }\n  }, {\n    key: \"add\",\n    value: function add(item) {\n      if (item instanceof ConcatSource) {\n        var _iterator2 = _createForOfIteratorHelper(item._children),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var child = _step2.value;\n            this._children.push(child);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      } else {\n        this._children.push(item);\n      }\n      this._isOptimized = false;\n    }\n  }, {\n    key: \"addAllSkipOptimizing\",\n    value: function addAllSkipOptimizing(items) {\n      var _iterator3 = _createForOfIteratorHelper(items),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var item = _step3.value;\n          this._children.push(item);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"buffer\",\n    value: function buffer() {\n      if (!this._isOptimized) this._optimize();\n      var buffers = [];\n      var _iterator4 = _createForOfIteratorHelper(this._children),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var child = _step4.value;\n          if (typeof child.buffer === \"function\") {\n            buffers.push(child.buffer());\n          } else {\n            var bufferOrString = child.source();\n            if (Buffer.isBuffer(bufferOrString)) {\n              buffers.push(bufferOrString);\n            } else {\n              // This will not happen\n              buffers.push(Buffer.from(bufferOrString, \"utf-8\"));\n            }\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      return Buffer.concat(buffers);\n    }\n  }, {\n    key: \"source\",\n    value: function source() {\n      if (!this._isOptimized) this._optimize();\n      var source = \"\";\n      var _iterator5 = _createForOfIteratorHelper(this._children),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var child = _step5.value;\n          source += child.source();\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      return source;\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      if (!this._isOptimized) this._optimize();\n      var size = 0;\n      var _iterator6 = _createForOfIteratorHelper(this._children),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var child = _step6.value;\n          size += child.size();\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      return size;\n    }\n  }, {\n    key: \"map\",\n    value: function map(options) {\n      return getMap(this, options);\n    }\n  }, {\n    key: \"sourceAndMap\",\n    value: function sourceAndMap(options) {\n      return getSourceAndMap(this, options);\n    }\n  }, {\n    key: \"streamChunks\",\n    value: function streamChunks(options, onChunk, onSource, onName) {\n      if (!this._isOptimized) this._optimize();\n      if (this._children.length === 1) return this._children[0].streamChunks(options, onChunk, onSource, onName);\n      var currentLineOffset = 0;\n      var currentColumnOffset = 0;\n      var sourceMapping = new Map();\n      var nameMapping = new Map();\n      var finalSource = !!(options && options.finalSource);\n      var code = \"\";\n      var needToCloseMapping = false;\n      var _iterator7 = _createForOfIteratorHelper(this._children),\n        _step7;\n      try {\n        var _loop = function _loop() {\n          var item = _step7.value;\n          var sourceIndexMapping = [];\n          var nameIndexMapping = [];\n          var lastMappingLine = 0;\n          var _streamChunks2 = _streamChunks(item, options,\n            // eslint-disable-next-line no-loop-func\n            function (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) {\n              var line = generatedLine + currentLineOffset;\n              var column = generatedLine === 1 ? generatedColumn + currentColumnOffset : generatedColumn;\n              if (needToCloseMapping) {\n                if (generatedLine !== 1 || generatedColumn !== 0) {\n                  onChunk(undefined, currentLineOffset + 1, currentColumnOffset, -1, -1, -1, -1);\n                }\n                needToCloseMapping = false;\n              }\n              var resultSourceIndex = sourceIndex < 0 || sourceIndex >= sourceIndexMapping.length ? -1 : sourceIndexMapping[sourceIndex];\n              var resultNameIndex = nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex];\n              lastMappingLine = resultSourceIndex < 0 ? 0 : generatedLine;\n              if (finalSource) {\n                if (chunk !== undefined) code += chunk;\n                if (resultSourceIndex >= 0) {\n                  onChunk(undefined, line, column, resultSourceIndex, originalLine, originalColumn, resultNameIndex);\n                }\n              } else {\n                if (resultSourceIndex < 0) {\n                  onChunk(chunk, line, column, -1, -1, -1, -1);\n                } else {\n                  onChunk(chunk, line, column, resultSourceIndex, originalLine, originalColumn, resultNameIndex);\n                }\n              }\n            }, function (i, source, sourceContent) {\n              var globalIndex = sourceMapping.get(source);\n              if (globalIndex === undefined) {\n                sourceMapping.set(source, globalIndex = sourceMapping.size);\n                onSource(globalIndex, source, sourceContent);\n              }\n              sourceIndexMapping[i] = globalIndex;\n            }, function (i, name) {\n              var globalIndex = nameMapping.get(name);\n              if (globalIndex === undefined) {\n                nameMapping.set(name, globalIndex = nameMapping.size);\n                onName(globalIndex, name);\n              }\n              nameIndexMapping[i] = globalIndex;\n            }),\n            generatedLine = _streamChunks2.generatedLine,\n            generatedColumn = _streamChunks2.generatedColumn,\n            source = _streamChunks2.source;\n          if (source !== undefined) code += source;\n          if (needToCloseMapping) {\n            if (generatedLine !== 1 || generatedColumn !== 0) {\n              onChunk(undefined, currentLineOffset + 1, currentColumnOffset, -1, -1, -1, -1);\n              needToCloseMapping = false;\n            }\n          }\n          if (generatedLine > 1) {\n            currentColumnOffset = generatedColumn;\n          } else {\n            currentColumnOffset += generatedColumn;\n          }\n          needToCloseMapping = needToCloseMapping || finalSource && lastMappingLine === generatedLine;\n          currentLineOffset += generatedLine - 1;\n        };\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      return {\n        generatedLine: currentLineOffset + 1,\n        generatedColumn: currentColumnOffset,\n        source: finalSource ? code : undefined\n      };\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      if (!this._isOptimized) this._optimize();\n      hash.update(\"ConcatSource\");\n      var _iterator8 = _createForOfIteratorHelper(this._children),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var item = _step8.value;\n          item.updateHash(hash);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  }, {\n    key: \"_optimize\",\n    value: function _optimize() {\n      var newChildren = [];\n      var currentString = undefined;\n      var currentRawSources = undefined;\n      var addStringToRawSources = function addStringToRawSources(string) {\n        if (currentRawSources === undefined) {\n          currentRawSources = string;\n        } else if (Array.isArray(currentRawSources)) {\n          currentRawSources.push(string);\n        } else {\n          currentRawSources = [typeof currentRawSources === \"string\" ? currentRawSources : currentRawSources.source(), string];\n        }\n      };\n      var addSourceToRawSources = function addSourceToRawSources(source) {\n        if (currentRawSources === undefined) {\n          currentRawSources = source;\n        } else if (Array.isArray(currentRawSources)) {\n          currentRawSources.push(source.source());\n        } else {\n          currentRawSources = [typeof currentRawSources === \"string\" ? currentRawSources : currentRawSources.source(), source.source()];\n        }\n      };\n      var mergeRawSources = function mergeRawSources() {\n        if (Array.isArray(currentRawSources)) {\n          var rawSource = new RawSource(currentRawSources.join(\"\"));\n          stringsAsRawSources.add(rawSource);\n          newChildren.push(rawSource);\n        } else if (typeof currentRawSources === \"string\") {\n          var _rawSource = new RawSource(currentRawSources);\n          stringsAsRawSources.add(_rawSource);\n          newChildren.push(_rawSource);\n        } else {\n          newChildren.push(currentRawSources);\n        }\n      };\n      var _iterator9 = _createForOfIteratorHelper(this._children),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var child = _step9.value;\n          if (typeof child === \"string\") {\n            if (currentString === undefined) {\n              currentString = child;\n            } else {\n              currentString += child;\n            }\n          } else {\n            if (currentString !== undefined) {\n              addStringToRawSources(currentString);\n              currentString = undefined;\n            }\n            if (stringsAsRawSources.has(child)) {\n              addSourceToRawSources(child);\n            } else {\n              if (currentRawSources !== undefined) {\n                mergeRawSources();\n                currentRawSources = undefined;\n              }\n              newChildren.push(child);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n      if (currentString !== undefined) {\n        addStringToRawSources(currentString);\n      }\n      if (currentRawSources !== undefined) {\n        mergeRawSources();\n      }\n      this._children = newChildren;\n      this._isOptimized = true;\n    }\n  }]);\n  return ConcatSource;\n}(Source);\nmodule.exports = ConcatSource;","map":{"version":3,"names":["Source","require","RawSource","streamChunks","getMap","getSourceAndMap","stringsAsRawSources","WeakSet","ConcatSource","_children","i","arguments","length","item","child","push","_isOptimized","_optimize","items","buffers","buffer","bufferOrString","source","Buffer","isBuffer","from","concat","size","options","onChunk","onSource","onName","currentLineOffset","currentColumnOffset","sourceMapping","Map","nameMapping","finalSource","code","needToCloseMapping","sourceIndexMapping","nameIndexMapping","lastMappingLine","chunk","generatedLine","generatedColumn","sourceIndex","originalLine","originalColumn","nameIndex","line","column","undefined","resultSourceIndex","resultNameIndex","sourceContent","globalIndex","get","set","name","hash","update","updateHash","newChildren","currentString","currentRawSources","addStringToRawSources","string","Array","isArray","addSourceToRawSources","mergeRawSources","rawSource","join","add","has","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack-sources/lib/ConcatSource.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\nconst RawSource = require(\"./RawSource\");\nconst streamChunks = require(\"./helpers/streamChunks\");\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\n\nconst stringsAsRawSources = new WeakSet();\n\nclass ConcatSource extends Source {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._children = [];\n\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\tconst item = arguments[i];\n\t\t\tif (item instanceof ConcatSource) {\n\t\t\t\tfor (const child of item._children) {\n\t\t\t\t\tthis._children.push(child);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._children.push(item);\n\t\t\t}\n\t\t}\n\t\tthis._isOptimized = arguments.length === 0;\n\t}\n\n\tgetChildren() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\treturn this._children;\n\t}\n\n\tadd(item) {\n\t\tif (item instanceof ConcatSource) {\n\t\t\tfor (const child of item._children) {\n\t\t\t\tthis._children.push(child);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._children.push(item);\n\t\t}\n\t\tthis._isOptimized = false;\n\t}\n\n\taddAllSkipOptimizing(items) {\n\t\tfor (const item of items) {\n\t\t\tthis._children.push(item);\n\t\t}\n\t}\n\n\tbuffer() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tconst buffers = [];\n\t\tfor (const child of this._children) {\n\t\t\tif (typeof child.buffer === \"function\") {\n\t\t\t\tbuffers.push(child.buffer());\n\t\t\t} else {\n\t\t\t\tconst bufferOrString = child.source();\n\t\t\t\tif (Buffer.isBuffer(bufferOrString)) {\n\t\t\t\t\tbuffers.push(bufferOrString);\n\t\t\t\t} else {\n\t\t\t\t\t// This will not happen\n\t\t\t\t\tbuffers.push(Buffer.from(bufferOrString, \"utf-8\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Buffer.concat(buffers);\n\t}\n\n\tsource() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tlet source = \"\";\n\t\tfor (const child of this._children) {\n\t\t\tsource += child.source();\n\t\t}\n\t\treturn source;\n\t}\n\n\tsize() {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tlet size = 0;\n\t\tfor (const child of this._children) {\n\t\t\tsize += child.size();\n\t\t}\n\t\treturn size;\n\t}\n\n\tmap(options) {\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tif (!this._isOptimized) this._optimize();\n\t\tif (this._children.length === 1)\n\t\t\treturn this._children[0].streamChunks(options, onChunk, onSource, onName);\n\t\tlet currentLineOffset = 0;\n\t\tlet currentColumnOffset = 0;\n\t\tlet sourceMapping = new Map();\n\t\tlet nameMapping = new Map();\n\t\tconst finalSource = !!(options && options.finalSource);\n\t\tlet code = \"\";\n\t\tlet needToCloseMapping = false;\n\t\tfor (const item of this._children) {\n\t\t\tconst sourceIndexMapping = [];\n\t\t\tconst nameIndexMapping = [];\n\t\t\tlet lastMappingLine = 0;\n\t\t\tconst { generatedLine, generatedColumn, source } = streamChunks(\n\t\t\t\titem,\n\t\t\t\toptions,\n\t\t\t\t// eslint-disable-next-line no-loop-func\n\t\t\t\t(\n\t\t\t\t\tchunk,\n\t\t\t\t\tgeneratedLine,\n\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\toriginalLine,\n\t\t\t\t\toriginalColumn,\n\t\t\t\t\tnameIndex\n\t\t\t\t) => {\n\t\t\t\t\tconst line = generatedLine + currentLineOffset;\n\t\t\t\t\tconst column =\n\t\t\t\t\t\tgeneratedLine === 1\n\t\t\t\t\t\t\t? generatedColumn + currentColumnOffset\n\t\t\t\t\t\t\t: generatedColumn;\n\t\t\t\t\tif (needToCloseMapping) {\n\t\t\t\t\t\tif (generatedLine !== 1 || generatedColumn !== 0) {\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tcurrentLineOffset + 1,\n\t\t\t\t\t\t\t\tcurrentColumnOffset,\n\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t-1,\n\t\t\t\t\t\t\t\t-1\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tneedToCloseMapping = false;\n\t\t\t\t\t}\n\t\t\t\t\tconst resultSourceIndex =\n\t\t\t\t\t\tsourceIndex < 0 || sourceIndex >= sourceIndexMapping.length\n\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t: sourceIndexMapping[sourceIndex];\n\t\t\t\t\tconst resultNameIndex =\n\t\t\t\t\t\tnameIndex < 0 || nameIndex >= nameIndexMapping.length\n\t\t\t\t\t\t\t? -1\n\t\t\t\t\t\t\t: nameIndexMapping[nameIndex];\n\t\t\t\t\tlastMappingLine = resultSourceIndex < 0 ? 0 : generatedLine;\n\t\t\t\t\tif (finalSource) {\n\t\t\t\t\t\tif (chunk !== undefined) code += chunk;\n\t\t\t\t\t\tif (resultSourceIndex >= 0) {\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tcolumn,\n\t\t\t\t\t\t\t\tresultSourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\tresultNameIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (resultSourceIndex < 0) {\n\t\t\t\t\t\t\tonChunk(chunk, line, column, -1, -1, -1, -1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tonChunk(\n\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\tline,\n\t\t\t\t\t\t\t\tcolumn,\n\t\t\t\t\t\t\t\tresultSourceIndex,\n\t\t\t\t\t\t\t\toriginalLine,\n\t\t\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\t\t\tresultNameIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t(i, source, sourceContent) => {\n\t\t\t\t\tlet globalIndex = sourceMapping.get(source);\n\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\tsourceMapping.set(source, (globalIndex = sourceMapping.size));\n\t\t\t\t\t\tonSource(globalIndex, source, sourceContent);\n\t\t\t\t\t}\n\t\t\t\t\tsourceIndexMapping[i] = globalIndex;\n\t\t\t\t},\n\t\t\t\t(i, name) => {\n\t\t\t\t\tlet globalIndex = nameMapping.get(name);\n\t\t\t\t\tif (globalIndex === undefined) {\n\t\t\t\t\t\tnameMapping.set(name, (globalIndex = nameMapping.size));\n\t\t\t\t\t\tonName(globalIndex, name);\n\t\t\t\t\t}\n\t\t\t\t\tnameIndexMapping[i] = globalIndex;\n\t\t\t\t}\n\t\t\t);\n\t\t\tif (source !== undefined) code += source;\n\t\t\tif (needToCloseMapping) {\n\t\t\t\tif (generatedLine !== 1 || generatedColumn !== 0) {\n\t\t\t\t\tonChunk(\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tcurrentLineOffset + 1,\n\t\t\t\t\t\tcurrentColumnOffset,\n\t\t\t\t\t\t-1,\n\t\t\t\t\t\t-1,\n\t\t\t\t\t\t-1,\n\t\t\t\t\t\t-1\n\t\t\t\t\t);\n\t\t\t\t\tneedToCloseMapping = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (generatedLine > 1) {\n\t\t\t\tcurrentColumnOffset = generatedColumn;\n\t\t\t} else {\n\t\t\t\tcurrentColumnOffset += generatedColumn;\n\t\t\t}\n\t\t\tneedToCloseMapping =\n\t\t\t\tneedToCloseMapping ||\n\t\t\t\t(finalSource && lastMappingLine === generatedLine);\n\t\t\tcurrentLineOffset += generatedLine - 1;\n\t\t}\n\t\treturn {\n\t\t\tgeneratedLine: currentLineOffset + 1,\n\t\t\tgeneratedColumn: currentColumnOffset,\n\t\t\tsource: finalSource ? code : undefined\n\t\t};\n\t}\n\n\tupdateHash(hash) {\n\t\tif (!this._isOptimized) this._optimize();\n\t\thash.update(\"ConcatSource\");\n\t\tfor (const item of this._children) {\n\t\t\titem.updateHash(hash);\n\t\t}\n\t}\n\n\t_optimize() {\n\t\tconst newChildren = [];\n\t\tlet currentString = undefined;\n\t\tlet currentRawSources = undefined;\n\t\tconst addStringToRawSources = string => {\n\t\t\tif (currentRawSources === undefined) {\n\t\t\t\tcurrentRawSources = string;\n\t\t\t} else if (Array.isArray(currentRawSources)) {\n\t\t\t\tcurrentRawSources.push(string);\n\t\t\t} else {\n\t\t\t\tcurrentRawSources = [\n\t\t\t\t\ttypeof currentRawSources === \"string\"\n\t\t\t\t\t\t? currentRawSources\n\t\t\t\t\t\t: currentRawSources.source(),\n\t\t\t\t\tstring\n\t\t\t\t];\n\t\t\t}\n\t\t};\n\t\tconst addSourceToRawSources = source => {\n\t\t\tif (currentRawSources === undefined) {\n\t\t\t\tcurrentRawSources = source;\n\t\t\t} else if (Array.isArray(currentRawSources)) {\n\t\t\t\tcurrentRawSources.push(source.source());\n\t\t\t} else {\n\t\t\t\tcurrentRawSources = [\n\t\t\t\t\ttypeof currentRawSources === \"string\"\n\t\t\t\t\t\t? currentRawSources\n\t\t\t\t\t\t: currentRawSources.source(),\n\t\t\t\t\tsource.source()\n\t\t\t\t];\n\t\t\t}\n\t\t};\n\t\tconst mergeRawSources = () => {\n\t\t\tif (Array.isArray(currentRawSources)) {\n\t\t\t\tconst rawSource = new RawSource(currentRawSources.join(\"\"));\n\t\t\t\tstringsAsRawSources.add(rawSource);\n\t\t\t\tnewChildren.push(rawSource);\n\t\t\t} else if (typeof currentRawSources === \"string\") {\n\t\t\t\tconst rawSource = new RawSource(currentRawSources);\n\t\t\t\tstringsAsRawSources.add(rawSource);\n\t\t\t\tnewChildren.push(rawSource);\n\t\t\t} else {\n\t\t\t\tnewChildren.push(currentRawSources);\n\t\t\t}\n\t\t};\n\t\tfor (const child of this._children) {\n\t\t\tif (typeof child === \"string\") {\n\t\t\t\tif (currentString === undefined) {\n\t\t\t\t\tcurrentString = child;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentString += child;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (currentString !== undefined) {\n\t\t\t\t\taddStringToRawSources(currentString);\n\t\t\t\t\tcurrentString = undefined;\n\t\t\t\t}\n\t\t\t\tif (stringsAsRawSources.has(child)) {\n\t\t\t\t\taddSourceToRawSources(child);\n\t\t\t\t} else {\n\t\t\t\t\tif (currentRawSources !== undefined) {\n\t\t\t\t\t\tmergeRawSources();\n\t\t\t\t\t\tcurrentRawSources = undefined;\n\t\t\t\t\t}\n\t\t\t\t\tnewChildren.push(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (currentString !== undefined) {\n\t\t\taddStringToRawSources(currentString);\n\t\t}\n\t\tif (currentRawSources !== undefined) {\n\t\t\tmergeRawSources();\n\t\t}\n\t\tthis._children = newChildren;\n\t\tthis._isOptimized = true;\n\t}\n}\n\nmodule.exports = ConcatSource;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}