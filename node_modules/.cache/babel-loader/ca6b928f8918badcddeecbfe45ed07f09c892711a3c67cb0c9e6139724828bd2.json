{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar path = require(\"path\");\nvar CHAR_HASH = \"#\".charCodeAt(0);\nvar CHAR_SLASH = \"/\".charCodeAt(0);\nvar CHAR_BACKSLASH = \"\\\\\".charCodeAt(0);\nvar CHAR_A = \"A\".charCodeAt(0);\nvar CHAR_Z = \"Z\".charCodeAt(0);\nvar CHAR_LOWER_A = \"a\".charCodeAt(0);\nvar CHAR_LOWER_Z = \"z\".charCodeAt(0);\nvar CHAR_DOT = \".\".charCodeAt(0);\nvar CHAR_COLON = \":\".charCodeAt(0);\nvar posixNormalize = path.posix.normalize;\nvar winNormalize = path.win32.normalize;\n\n/**\n * @enum {number}\n */\nvar PathType = Object.freeze({\n  Empty: 0,\n  Normal: 1,\n  Relative: 2,\n  AbsoluteWin: 3,\n  AbsolutePosix: 4,\n  Internal: 5\n});\nexports.PathType = PathType;\n\n/**\n * @param {string} p a path\n * @returns {PathType} type of path\n */\nvar getType = function getType(p) {\n  switch (p.length) {\n    case 0:\n      return PathType.Empty;\n    case 1:\n      {\n        var _c = p.charCodeAt(0);\n        switch (_c) {\n          case CHAR_DOT:\n            return PathType.Relative;\n          case CHAR_SLASH:\n            return PathType.AbsolutePosix;\n          case CHAR_HASH:\n            return PathType.Internal;\n        }\n        return PathType.Normal;\n      }\n    case 2:\n      {\n        var _c2 = p.charCodeAt(0);\n        switch (_c2) {\n          case CHAR_DOT:\n            {\n              var _c3 = p.charCodeAt(1);\n              switch (_c3) {\n                case CHAR_DOT:\n                case CHAR_SLASH:\n                  return PathType.Relative;\n              }\n              return PathType.Normal;\n            }\n          case CHAR_SLASH:\n            return PathType.AbsolutePosix;\n          case CHAR_HASH:\n            return PathType.Internal;\n        }\n        var _c4 = p.charCodeAt(1);\n        if (_c4 === CHAR_COLON) {\n          if (_c2 >= CHAR_A && _c2 <= CHAR_Z || _c2 >= CHAR_LOWER_A && _c2 <= CHAR_LOWER_Z) {\n            return PathType.AbsoluteWin;\n          }\n        }\n        return PathType.Normal;\n      }\n  }\n  var c0 = p.charCodeAt(0);\n  switch (c0) {\n    case CHAR_DOT:\n      {\n        var _c5 = p.charCodeAt(1);\n        switch (_c5) {\n          case CHAR_SLASH:\n            return PathType.Relative;\n          case CHAR_DOT:\n            {\n              var c2 = p.charCodeAt(2);\n              if (c2 === CHAR_SLASH) return PathType.Relative;\n              return PathType.Normal;\n            }\n        }\n        return PathType.Normal;\n      }\n    case CHAR_SLASH:\n      return PathType.AbsolutePosix;\n    case CHAR_HASH:\n      return PathType.Internal;\n  }\n  var c1 = p.charCodeAt(1);\n  if (c1 === CHAR_COLON) {\n    var _c6 = p.charCodeAt(2);\n    if ((_c6 === CHAR_BACKSLASH || _c6 === CHAR_SLASH) && (c0 >= CHAR_A && c0 <= CHAR_Z || c0 >= CHAR_LOWER_A && c0 <= CHAR_LOWER_Z)) {\n      return PathType.AbsoluteWin;\n    }\n  }\n  return PathType.Normal;\n};\nexports.getType = getType;\n\n/**\n * @param {string} p a path\n * @returns {string} the normalized path\n */\nvar normalize = function normalize(p) {\n  switch (getType(p)) {\n    case PathType.Empty:\n      return p;\n    case PathType.AbsoluteWin:\n      return winNormalize(p);\n    case PathType.Relative:\n      {\n        var r = posixNormalize(p);\n        return getType(r) === PathType.Relative ? r : \"./\".concat(r);\n      }\n  }\n  return posixNormalize(p);\n};\nexports.normalize = normalize;\n\n/**\n * @param {string} rootPath the root path\n * @param {string | undefined} request the request path\n * @returns {string} the joined path\n */\nvar join = function join(rootPath, request) {\n  if (!request) return normalize(rootPath);\n  var requestType = getType(request);\n  switch (requestType) {\n    case PathType.AbsolutePosix:\n      return posixNormalize(request);\n    case PathType.AbsoluteWin:\n      return winNormalize(request);\n  }\n  switch (getType(rootPath)) {\n    case PathType.Normal:\n    case PathType.Relative:\n    case PathType.AbsolutePosix:\n      return posixNormalize(\"\".concat(rootPath, \"/\").concat(request));\n    case PathType.AbsoluteWin:\n      return winNormalize(\"\".concat(rootPath, \"\\\\\").concat(request));\n  }\n  switch (requestType) {\n    case PathType.Empty:\n      return rootPath;\n    case PathType.Relative:\n      {\n        var r = posixNormalize(rootPath);\n        return getType(r) === PathType.Relative ? r : \"./\".concat(r);\n      }\n  }\n  return posixNormalize(rootPath);\n};\nexports.join = join;\nvar joinCache = new Map();\n\n/**\n * @param {string} rootPath the root path\n * @param {string | undefined} request the request path\n * @returns {string} the joined path\n */\nvar cachedJoin = function cachedJoin(rootPath, request) {\n  var cacheEntry;\n  var cache = joinCache.get(rootPath);\n  if (cache === undefined) {\n    joinCache.set(rootPath, cache = new Map());\n  } else {\n    cacheEntry = cache.get(request);\n    if (cacheEntry !== undefined) return cacheEntry;\n  }\n  cacheEntry = join(rootPath, request);\n  cache.set(request, cacheEntry);\n  return cacheEntry;\n};\nexports.cachedJoin = cachedJoin;\nvar checkImportsExportsFieldTarget = function checkImportsExportsFieldTarget(relativePath) {\n  var lastNonSlashIndex = 0;\n  var slashIndex = relativePath.indexOf(\"/\", 1);\n  var cd = 0;\n  while (slashIndex !== -1) {\n    var folder = relativePath.slice(lastNonSlashIndex, slashIndex);\n    switch (folder) {\n      case \"..\":\n        {\n          cd--;\n          if (cd < 0) return new Error(\"Trying to access out of package scope. Requesting \".concat(relativePath));\n          break;\n        }\n      case \".\":\n        break;\n      default:\n        cd++;\n        break;\n    }\n    lastNonSlashIndex = slashIndex + 1;\n    slashIndex = relativePath.indexOf(\"/\", lastNonSlashIndex);\n  }\n};\nexports.checkImportsExportsFieldTarget = checkImportsExportsFieldTarget;","map":{"version":3,"names":["path","require","CHAR_HASH","charCodeAt","CHAR_SLASH","CHAR_BACKSLASH","CHAR_A","CHAR_Z","CHAR_LOWER_A","CHAR_LOWER_Z","CHAR_DOT","CHAR_COLON","posixNormalize","posix","normalize","winNormalize","win32","PathType","Object","freeze","Empty","Normal","Relative","AbsoluteWin","AbsolutePosix","Internal","exports","getType","p","length","c0","c1","c2","r","join","rootPath","request","requestType","joinCache","Map","cachedJoin","cacheEntry","cache","get","undefined","set","checkImportsExportsFieldTarget","relativePath","lastNonSlashIndex","slashIndex","indexOf","cd","folder","slice","Error"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/enhanced-resolve/lib/util/path.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\n\nconst CHAR_HASH = \"#\".charCodeAt(0);\nconst CHAR_SLASH = \"/\".charCodeAt(0);\nconst CHAR_BACKSLASH = \"\\\\\".charCodeAt(0);\nconst CHAR_A = \"A\".charCodeAt(0);\nconst CHAR_Z = \"Z\".charCodeAt(0);\nconst CHAR_LOWER_A = \"a\".charCodeAt(0);\nconst CHAR_LOWER_Z = \"z\".charCodeAt(0);\nconst CHAR_DOT = \".\".charCodeAt(0);\nconst CHAR_COLON = \":\".charCodeAt(0);\n\nconst posixNormalize = path.posix.normalize;\nconst winNormalize = path.win32.normalize;\n\n/**\n * @enum {number}\n */\nconst PathType = Object.freeze({\n\tEmpty: 0,\n\tNormal: 1,\n\tRelative: 2,\n\tAbsoluteWin: 3,\n\tAbsolutePosix: 4,\n\tInternal: 5\n});\nexports.PathType = PathType;\n\n/**\n * @param {string} p a path\n * @returns {PathType} type of path\n */\nconst getType = p => {\n\tswitch (p.length) {\n\t\tcase 0:\n\t\t\treturn PathType.Empty;\n\t\tcase 1: {\n\t\t\tconst c0 = p.charCodeAt(0);\n\t\t\tswitch (c0) {\n\t\t\t\tcase CHAR_DOT:\n\t\t\t\t\treturn PathType.Relative;\n\t\t\t\tcase CHAR_SLASH:\n\t\t\t\t\treturn PathType.AbsolutePosix;\n\t\t\t\tcase CHAR_HASH:\n\t\t\t\t\treturn PathType.Internal;\n\t\t\t}\n\t\t\treturn PathType.Normal;\n\t\t}\n\t\tcase 2: {\n\t\t\tconst c0 = p.charCodeAt(0);\n\t\t\tswitch (c0) {\n\t\t\t\tcase CHAR_DOT: {\n\t\t\t\t\tconst c1 = p.charCodeAt(1);\n\t\t\t\t\tswitch (c1) {\n\t\t\t\t\t\tcase CHAR_DOT:\n\t\t\t\t\t\tcase CHAR_SLASH:\n\t\t\t\t\t\t\treturn PathType.Relative;\n\t\t\t\t\t}\n\t\t\t\t\treturn PathType.Normal;\n\t\t\t\t}\n\t\t\t\tcase CHAR_SLASH:\n\t\t\t\t\treturn PathType.AbsolutePosix;\n\t\t\t\tcase CHAR_HASH:\n\t\t\t\t\treturn PathType.Internal;\n\t\t\t}\n\t\t\tconst c1 = p.charCodeAt(1);\n\t\t\tif (c1 === CHAR_COLON) {\n\t\t\t\tif (\n\t\t\t\t\t(c0 >= CHAR_A && c0 <= CHAR_Z) ||\n\t\t\t\t\t(c0 >= CHAR_LOWER_A && c0 <= CHAR_LOWER_Z)\n\t\t\t\t) {\n\t\t\t\t\treturn PathType.AbsoluteWin;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn PathType.Normal;\n\t\t}\n\t}\n\tconst c0 = p.charCodeAt(0);\n\tswitch (c0) {\n\t\tcase CHAR_DOT: {\n\t\t\tconst c1 = p.charCodeAt(1);\n\t\t\tswitch (c1) {\n\t\t\t\tcase CHAR_SLASH:\n\t\t\t\t\treturn PathType.Relative;\n\t\t\t\tcase CHAR_DOT: {\n\t\t\t\t\tconst c2 = p.charCodeAt(2);\n\t\t\t\t\tif (c2 === CHAR_SLASH) return PathType.Relative;\n\t\t\t\t\treturn PathType.Normal;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn PathType.Normal;\n\t\t}\n\t\tcase CHAR_SLASH:\n\t\t\treturn PathType.AbsolutePosix;\n\t\tcase CHAR_HASH:\n\t\t\treturn PathType.Internal;\n\t}\n\tconst c1 = p.charCodeAt(1);\n\tif (c1 === CHAR_COLON) {\n\t\tconst c2 = p.charCodeAt(2);\n\t\tif (\n\t\t\t(c2 === CHAR_BACKSLASH || c2 === CHAR_SLASH) &&\n\t\t\t((c0 >= CHAR_A && c0 <= CHAR_Z) ||\n\t\t\t\t(c0 >= CHAR_LOWER_A && c0 <= CHAR_LOWER_Z))\n\t\t) {\n\t\t\treturn PathType.AbsoluteWin;\n\t\t}\n\t}\n\treturn PathType.Normal;\n};\nexports.getType = getType;\n\n/**\n * @param {string} p a path\n * @returns {string} the normalized path\n */\nconst normalize = p => {\n\tswitch (getType(p)) {\n\t\tcase PathType.Empty:\n\t\t\treturn p;\n\t\tcase PathType.AbsoluteWin:\n\t\t\treturn winNormalize(p);\n\t\tcase PathType.Relative: {\n\t\t\tconst r = posixNormalize(p);\n\t\t\treturn getType(r) === PathType.Relative ? r : `./${r}`;\n\t\t}\n\t}\n\treturn posixNormalize(p);\n};\nexports.normalize = normalize;\n\n/**\n * @param {string} rootPath the root path\n * @param {string | undefined} request the request path\n * @returns {string} the joined path\n */\nconst join = (rootPath, request) => {\n\tif (!request) return normalize(rootPath);\n\tconst requestType = getType(request);\n\tswitch (requestType) {\n\t\tcase PathType.AbsolutePosix:\n\t\t\treturn posixNormalize(request);\n\t\tcase PathType.AbsoluteWin:\n\t\t\treturn winNormalize(request);\n\t}\n\tswitch (getType(rootPath)) {\n\t\tcase PathType.Normal:\n\t\tcase PathType.Relative:\n\t\tcase PathType.AbsolutePosix:\n\t\t\treturn posixNormalize(`${rootPath}/${request}`);\n\t\tcase PathType.AbsoluteWin:\n\t\t\treturn winNormalize(`${rootPath}\\\\${request}`);\n\t}\n\tswitch (requestType) {\n\t\tcase PathType.Empty:\n\t\t\treturn rootPath;\n\t\tcase PathType.Relative: {\n\t\t\tconst r = posixNormalize(rootPath);\n\t\t\treturn getType(r) === PathType.Relative ? r : `./${r}`;\n\t\t}\n\t}\n\treturn posixNormalize(rootPath);\n};\nexports.join = join;\n\nconst joinCache = new Map();\n\n/**\n * @param {string} rootPath the root path\n * @param {string | undefined} request the request path\n * @returns {string} the joined path\n */\nconst cachedJoin = (rootPath, request) => {\n\tlet cacheEntry;\n\tlet cache = joinCache.get(rootPath);\n\tif (cache === undefined) {\n\t\tjoinCache.set(rootPath, (cache = new Map()));\n\t} else {\n\t\tcacheEntry = cache.get(request);\n\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t}\n\tcacheEntry = join(rootPath, request);\n\tcache.set(request, cacheEntry);\n\treturn cacheEntry;\n};\nexports.cachedJoin = cachedJoin;\n\nconst checkImportsExportsFieldTarget = relativePath => {\n\tlet lastNonSlashIndex = 0;\n\tlet slashIndex = relativePath.indexOf(\"/\", 1);\n\tlet cd = 0;\n\n\twhile (slashIndex !== -1) {\n\t\tconst folder = relativePath.slice(lastNonSlashIndex, slashIndex);\n\n\t\tswitch (folder) {\n\t\t\tcase \"..\": {\n\t\t\t\tcd--;\n\t\t\t\tif (cd < 0)\n\t\t\t\t\treturn new Error(\n\t\t\t\t\t\t`Trying to access out of package scope. Requesting ${relativePath}`\n\t\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \".\":\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcd++;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tlastNonSlashIndex = slashIndex + 1;\n\t\tslashIndex = relativePath.indexOf(\"/\", lastNonSlashIndex);\n\t}\n};\nexports.checkImportsExportsFieldTarget = checkImportsExportsFieldTarget;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}