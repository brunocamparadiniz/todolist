{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar createHash = require(\"../util/createHash\");\nvar _require = require(\"../util/identifier\"),\n  makePathsRelative = _require.makePathsRelative;\nvar numberHash = require(\"../util/numberHash\");\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n\n/**\n * @param {string} str string to hash\n * @param {number} len max length of the hash\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\nvar getHash = function getHash(str, len, hashFunction) {\n  var hash = createHash(hashFunction);\n  hash.update(str);\n  var digest = /** @type {string} */hash.digest(\"hex\");\n  return digest.slice(0, len);\n};\n\n/**\n * @param {string} str the string\n * @returns {string} string prefixed by an underscore if it is a number\n */\nvar avoidNumber = function avoidNumber(str) {\n  // max length of a number is 21 chars, bigger numbers a written as \"...e+xx\"\n  if (str.length > 21) return str;\n  var firstChar = str.charCodeAt(0);\n  // skip everything that doesn't look like a number\n  // charCodes: \"-\": 45, \"1\": 49, \"9\": 57\n  if (firstChar < 49) {\n    if (firstChar !== 45) return str;\n  } else if (firstChar > 57) {\n    return str;\n  }\n  if (str === +str + \"\") {\n    return \"_\".concat(str);\n  }\n  return str;\n};\n\n/**\n * @param {string} request the request\n * @returns {string} id representation\n */\nvar requestToId = function requestToId(request) {\n  return request.replace(/^(\\.\\.?\\/)+/, \"\").replace(/(^[.-]|[^a-zA-Z0-9_-])+/g, \"_\");\n};\nexports.requestToId = requestToId;\n\n/**\n * @param {string} string the string\n * @param {string} delimiter separator for string and hash\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} string with limited max length to 100 chars\n */\nvar shortenLongString = function shortenLongString(string, delimiter, hashFunction) {\n  if (string.length < 100) return string;\n  return string.slice(0, 100 - 6 - delimiter.length) + delimiter + getHash(string, 6, hashFunction);\n};\n\n/**\n * @param {Module} module the module\n * @param {string} context context directory\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} short module name\n */\nvar getShortModuleName = function getShortModuleName(module, context, associatedObjectForCache) {\n  var libIdent = module.libIdent({\n    context: context,\n    associatedObjectForCache: associatedObjectForCache\n  });\n  if (libIdent) return avoidNumber(libIdent);\n  var nameForCondition = module.nameForCondition();\n  if (nameForCondition) return avoidNumber(makePathsRelative(context, nameForCondition, associatedObjectForCache));\n  return \"\";\n};\nexports.getShortModuleName = getShortModuleName;\n\n/**\n * @param {string} shortName the short name\n * @param {Module} module the module\n * @param {string} context context directory\n * @param {string | Hash} hashFunction hash function to use\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} long module name\n */\nvar getLongModuleName = function getLongModuleName(shortName, module, context, hashFunction, associatedObjectForCache) {\n  var fullName = getFullModuleName(module, context, associatedObjectForCache);\n  return \"\".concat(shortName, \"?\").concat(getHash(fullName, 4, hashFunction));\n};\nexports.getLongModuleName = getLongModuleName;\n\n/**\n * @param {Module} module the module\n * @param {string} context context directory\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} full module name\n */\nvar getFullModuleName = function getFullModuleName(module, context, associatedObjectForCache) {\n  return makePathsRelative(context, module.identifier(), associatedObjectForCache);\n};\nexports.getFullModuleName = getFullModuleName;\n\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {string} context context directory\n * @param {string} delimiter delimiter for names\n * @param {string | Hash} hashFunction hash function to use\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} short chunk name\n */\nvar getShortChunkName = function getShortChunkName(chunk, chunkGraph, context, delimiter, hashFunction, associatedObjectForCache) {\n  var modules = chunkGraph.getChunkRootModules(chunk);\n  var shortModuleNames = modules.map(function (m) {\n    return requestToId(getShortModuleName(m, context, associatedObjectForCache));\n  });\n  chunk.idNameHints.sort();\n  var chunkName = Array.from(chunk.idNameHints).concat(shortModuleNames).filter(Boolean).join(delimiter);\n  return shortenLongString(chunkName, delimiter, hashFunction);\n};\nexports.getShortChunkName = getShortChunkName;\n\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {string} context context directory\n * @param {string} delimiter delimiter for names\n * @param {string | Hash} hashFunction hash function to use\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} short chunk name\n */\nvar getLongChunkName = function getLongChunkName(chunk, chunkGraph, context, delimiter, hashFunction, associatedObjectForCache) {\n  var modules = chunkGraph.getChunkRootModules(chunk);\n  var shortModuleNames = modules.map(function (m) {\n    return requestToId(getShortModuleName(m, context, associatedObjectForCache));\n  });\n  var longModuleNames = modules.map(function (m) {\n    return requestToId(getLongModuleName(\"\", m, context, hashFunction, associatedObjectForCache));\n  });\n  chunk.idNameHints.sort();\n  var chunkName = Array.from(chunk.idNameHints).concat(shortModuleNames, longModuleNames).filter(Boolean).join(delimiter);\n  return shortenLongString(chunkName, delimiter, hashFunction);\n};\nexports.getLongChunkName = getLongChunkName;\n\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {string} context context directory\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} full chunk name\n */\nvar getFullChunkName = function getFullChunkName(chunk, chunkGraph, context, associatedObjectForCache) {\n  if (chunk.name) return chunk.name;\n  var modules = chunkGraph.getChunkRootModules(chunk);\n  var fullModuleNames = modules.map(function (m) {\n    return makePathsRelative(context, m.identifier(), associatedObjectForCache);\n  });\n  return fullModuleNames.join();\n};\nexports.getFullChunkName = getFullChunkName;\n\n/**\n * @template K\n * @template V\n * @param {Map<K, V[]>} map a map from key to values\n * @param {K} key key\n * @param {V} value value\n * @returns {void}\n */\nvar addToMapOfItems = function addToMapOfItems(map, key, value) {\n  var array = map.get(key);\n  if (array === undefined) {\n    array = [];\n    map.set(key, array);\n  }\n  array.push(value);\n};\n\n/**\n * @param {Compilation} compilation the compilation\n * @param {function(Module): boolean=} filter filter modules\n * @returns {[Set<string>, Module[]]} used module ids as strings and modules without id matching the filter\n */\nvar getUsedModuleIdsAndModules = function getUsedModuleIdsAndModules(compilation, filter) {\n  var chunkGraph = compilation.chunkGraph;\n  var modules = [];\n\n  /** @type {Set<string>} */\n  var usedIds = new Set();\n  if (compilation.usedModuleIds) {\n    var _iterator = _createForOfIteratorHelper(compilation.usedModuleIds),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var id = _step.value;\n        usedIds.add(id + \"\");\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n  var _iterator2 = _createForOfIteratorHelper(compilation.modules),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var module = _step2.value;\n      if (!module.needId) continue;\n      var moduleId = chunkGraph.getModuleId(module);\n      if (moduleId !== null) {\n        usedIds.add(moduleId + \"\");\n      } else {\n        if ((!filter || filter(module)) && chunkGraph.getNumberOfModuleChunks(module) !== 0) {\n          modules.push(module);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return [usedIds, modules];\n};\nexports.getUsedModuleIdsAndModules = getUsedModuleIdsAndModules;\n\n/**\n * @param {Compilation} compilation the compilation\n * @returns {Set<string>} used chunk ids as strings\n */\nvar getUsedChunkIds = function getUsedChunkIds(compilation) {\n  /** @type {Set<string>} */\n  var usedIds = new Set();\n  if (compilation.usedChunkIds) {\n    var _iterator3 = _createForOfIteratorHelper(compilation.usedChunkIds),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var id = _step3.value;\n        usedIds.add(id + \"\");\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n  var _iterator4 = _createForOfIteratorHelper(compilation.chunks),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var chunk = _step4.value;\n      var chunkId = chunk.id;\n      if (chunkId !== null) {\n        usedIds.add(chunkId + \"\");\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return usedIds;\n};\nexports.getUsedChunkIds = getUsedChunkIds;\n\n/**\n * @template T\n * @param {Iterable<T>} items list of items to be named\n * @param {function(T): string} getShortName get a short name for an item\n * @param {function(T, string): string} getLongName get a long name for an item\n * @param {function(T, T): -1|0|1} comparator order of items\n * @param {Set<string>} usedIds already used ids, will not be assigned\n * @param {function(T, string): void} assignName assign a name to an item\n * @returns {T[]} list of items without a name\n */\nvar assignNames = function assignNames(items, getShortName, getLongName, comparator, usedIds, assignName) {\n  /** @type {Map<string, T[]>} */\n  var nameToItems = new Map();\n  var _iterator5 = _createForOfIteratorHelper(items),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var item = _step5.value;\n      var name = getShortName(item);\n      addToMapOfItems(nameToItems, name, item);\n    }\n\n    /** @type {Map<string, T[]>} */\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  var nameToItems2 = new Map();\n  var _iterator6 = _createForOfIteratorHelper(nameToItems),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var _step6$value = _slicedToArray(_step6.value, 2),\n        _name = _step6$value[0],\n        _items = _step6$value[1];\n      if (_items.length > 1 || !_name) {\n        var _iterator8 = _createForOfIteratorHelper(_items),\n          _step8;\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var _item = _step8.value;\n            var longName = getLongName(_item, _name);\n            addToMapOfItems(nameToItems2, longName, _item);\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n      } else {\n        addToMapOfItems(nameToItems2, _name, _items[0]);\n      }\n    }\n\n    /** @type {T[]} */\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  var unnamedItems = [];\n  var _iterator7 = _createForOfIteratorHelper(nameToItems2),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var _step7$value = _slicedToArray(_step7.value, 2),\n        _name2 = _step7$value[0],\n        _items2 = _step7$value[1];\n      if (!_name2) {\n        var _iterator9 = _createForOfIteratorHelper(_items2),\n          _step9;\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var _item2 = _step9.value;\n            unnamedItems.push(_item2);\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n      } else if (_items2.length === 1 && !usedIds.has(_name2)) {\n        assignName(_items2[0], _name2);\n        usedIds.add(_name2);\n      } else {\n        _items2.sort(comparator);\n        var i = 0;\n        var _iterator10 = _createForOfIteratorHelper(_items2),\n          _step10;\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var _item3 = _step10.value;\n            while (nameToItems2.has(_name2 + i) && usedIds.has(_name2 + i)) i++;\n            assignName(_item3, _name2 + i);\n            usedIds.add(_name2 + i);\n            i++;\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  unnamedItems.sort(comparator);\n  return unnamedItems;\n};\nexports.assignNames = assignNames;\n\n/**\n * @template T\n * @param {T[]} items list of items to be named\n * @param {function(T): string} getName get a name for an item\n * @param {function(T, T): -1|0|1} comparator order of items\n * @param {function(T, number): boolean} assignId assign an id to an item\n * @param {number[]} ranges usable ranges for ids\n * @param {number} expandFactor factor to create more ranges\n * @param {number} extraSpace extra space to allocate, i. e. when some ids are already used\n * @param {number} salt salting number to initialize hashing\n * @returns {void}\n */\nvar assignDeterministicIds = function assignDeterministicIds(items, getName, comparator, assignId) {\n  var ranges = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [10];\n  var expandFactor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 10;\n  var extraSpace = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var salt = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n  items.sort(comparator);\n\n  // max 5% fill rate\n  var optimalRange = Math.min(items.length * 20 + extraSpace, Number.MAX_SAFE_INTEGER);\n  var i = 0;\n  var range = ranges[i];\n  while (range < optimalRange) {\n    i++;\n    if (i < ranges.length) {\n      range = Math.min(ranges[i], Number.MAX_SAFE_INTEGER);\n    } else if (expandFactor) {\n      range = Math.min(range * expandFactor, Number.MAX_SAFE_INTEGER);\n    } else {\n      break;\n    }\n  }\n  var _iterator11 = _createForOfIteratorHelper(items),\n    _step11;\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var item = _step11.value;\n      var ident = getName(item);\n      var id = void 0;\n      var _i = salt;\n      do {\n        id = numberHash(ident + _i++, range);\n      } while (!assignId(item, id));\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n};\nexports.assignDeterministicIds = assignDeterministicIds;\n\n/**\n * @param {Set<string>} usedIds used ids\n * @param {Iterable<Module>} modules the modules\n * @param {Compilation} compilation the compilation\n * @returns {void}\n */\nvar assignAscendingModuleIds = function assignAscendingModuleIds(usedIds, modules, compilation) {\n  var chunkGraph = compilation.chunkGraph;\n  var nextId = 0;\n  var assignId;\n  if (usedIds.size > 0) {\n    assignId = function assignId(module) {\n      if (chunkGraph.getModuleId(module) === null) {\n        while (usedIds.has(nextId + \"\")) nextId++;\n        chunkGraph.setModuleId(module, nextId++);\n      }\n    };\n  } else {\n    assignId = function assignId(module) {\n      if (chunkGraph.getModuleId(module) === null) {\n        chunkGraph.setModuleId(module, nextId++);\n      }\n    };\n  }\n  var _iterator12 = _createForOfIteratorHelper(modules),\n    _step12;\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var module = _step12.value;\n      assignId(module);\n    }\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n};\nexports.assignAscendingModuleIds = assignAscendingModuleIds;\n\n/**\n * @param {Iterable<Chunk>} chunks the chunks\n * @param {Compilation} compilation the compilation\n * @returns {void}\n */\nvar assignAscendingChunkIds = function assignAscendingChunkIds(chunks, compilation) {\n  var usedIds = getUsedChunkIds(compilation);\n  var nextId = 0;\n  if (usedIds.size > 0) {\n    var _iterator13 = _createForOfIteratorHelper(chunks),\n      _step13;\n    try {\n      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n        var chunk = _step13.value;\n        if (chunk.id === null) {\n          while (usedIds.has(nextId + \"\")) nextId++;\n          chunk.id = nextId;\n          chunk.ids = [nextId];\n          nextId++;\n        }\n      }\n    } catch (err) {\n      _iterator13.e(err);\n    } finally {\n      _iterator13.f();\n    }\n  } else {\n    var _iterator14 = _createForOfIteratorHelper(chunks),\n      _step14;\n    try {\n      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n        var _chunk = _step14.value;\n        if (_chunk.id === null) {\n          _chunk.id = nextId;\n          _chunk.ids = [nextId];\n          nextId++;\n        }\n      }\n    } catch (err) {\n      _iterator14.e(err);\n    } finally {\n      _iterator14.f();\n    }\n  }\n};\nexports.assignAscendingChunkIds = assignAscendingChunkIds;","map":{"version":3,"names":["createHash","require","makePathsRelative","numberHash","getHash","str","len","hashFunction","hash","update","digest","slice","avoidNumber","length","firstChar","charCodeAt","requestToId","request","replace","exports","shortenLongString","string","delimiter","getShortModuleName","module","context","associatedObjectForCache","libIdent","nameForCondition","getLongModuleName","shortName","fullName","getFullModuleName","identifier","getShortChunkName","chunk","chunkGraph","modules","getChunkRootModules","shortModuleNames","map","m","idNameHints","sort","chunkName","Array","from","concat","filter","Boolean","join","getLongChunkName","longModuleNames","getFullChunkName","name","fullModuleNames","addToMapOfItems","key","value","array","get","undefined","set","push","getUsedModuleIdsAndModules","compilation","usedIds","Set","usedModuleIds","id","add","needId","moduleId","getModuleId","getNumberOfModuleChunks","getUsedChunkIds","usedChunkIds","chunks","chunkId","assignNames","items","getShortName","getLongName","comparator","assignName","nameToItems","Map","item","nameToItems2","longName","unnamedItems","has","i","assignDeterministicIds","getName","assignId","ranges","expandFactor","extraSpace","salt","optimalRange","Math","min","Number","MAX_SAFE_INTEGER","range","ident","assignAscendingModuleIds","nextId","size","setModuleId","assignAscendingChunkIds","ids"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/ids/IdHelpers.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst createHash = require(\"../util/createHash\");\nconst { makePathsRelative } = require(\"../util/identifier\");\nconst numberHash = require(\"../util/numberHash\");\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n\n/**\n * @param {string} str string to hash\n * @param {number} len max length of the hash\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\nconst getHash = (str, len, hashFunction) => {\n\tconst hash = createHash(hashFunction);\n\thash.update(str);\n\tconst digest = /** @type {string} */ (hash.digest(\"hex\"));\n\treturn digest.slice(0, len);\n};\n\n/**\n * @param {string} str the string\n * @returns {string} string prefixed by an underscore if it is a number\n */\nconst avoidNumber = str => {\n\t// max length of a number is 21 chars, bigger numbers a written as \"...e+xx\"\n\tif (str.length > 21) return str;\n\tconst firstChar = str.charCodeAt(0);\n\t// skip everything that doesn't look like a number\n\t// charCodes: \"-\": 45, \"1\": 49, \"9\": 57\n\tif (firstChar < 49) {\n\t\tif (firstChar !== 45) return str;\n\t} else if (firstChar > 57) {\n\t\treturn str;\n\t}\n\tif (str === +str + \"\") {\n\t\treturn `_${str}`;\n\t}\n\treturn str;\n};\n\n/**\n * @param {string} request the request\n * @returns {string} id representation\n */\nconst requestToId = request => {\n\treturn request\n\t\t.replace(/^(\\.\\.?\\/)+/, \"\")\n\t\t.replace(/(^[.-]|[^a-zA-Z0-9_-])+/g, \"_\");\n};\nexports.requestToId = requestToId;\n\n/**\n * @param {string} string the string\n * @param {string} delimiter separator for string and hash\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} string with limited max length to 100 chars\n */\nconst shortenLongString = (string, delimiter, hashFunction) => {\n\tif (string.length < 100) return string;\n\treturn (\n\t\tstring.slice(0, 100 - 6 - delimiter.length) +\n\t\tdelimiter +\n\t\tgetHash(string, 6, hashFunction)\n\t);\n};\n\n/**\n * @param {Module} module the module\n * @param {string} context context directory\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} short module name\n */\nconst getShortModuleName = (module, context, associatedObjectForCache) => {\n\tconst libIdent = module.libIdent({ context, associatedObjectForCache });\n\tif (libIdent) return avoidNumber(libIdent);\n\tconst nameForCondition = module.nameForCondition();\n\tif (nameForCondition)\n\t\treturn avoidNumber(\n\t\t\tmakePathsRelative(context, nameForCondition, associatedObjectForCache)\n\t\t);\n\treturn \"\";\n};\nexports.getShortModuleName = getShortModuleName;\n\n/**\n * @param {string} shortName the short name\n * @param {Module} module the module\n * @param {string} context context directory\n * @param {string | Hash} hashFunction hash function to use\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} long module name\n */\nconst getLongModuleName = (\n\tshortName,\n\tmodule,\n\tcontext,\n\thashFunction,\n\tassociatedObjectForCache\n) => {\n\tconst fullName = getFullModuleName(module, context, associatedObjectForCache);\n\treturn `${shortName}?${getHash(fullName, 4, hashFunction)}`;\n};\nexports.getLongModuleName = getLongModuleName;\n\n/**\n * @param {Module} module the module\n * @param {string} context context directory\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} full module name\n */\nconst getFullModuleName = (module, context, associatedObjectForCache) => {\n\treturn makePathsRelative(\n\t\tcontext,\n\t\tmodule.identifier(),\n\t\tassociatedObjectForCache\n\t);\n};\nexports.getFullModuleName = getFullModuleName;\n\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {string} context context directory\n * @param {string} delimiter delimiter for names\n * @param {string | Hash} hashFunction hash function to use\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} short chunk name\n */\nconst getShortChunkName = (\n\tchunk,\n\tchunkGraph,\n\tcontext,\n\tdelimiter,\n\thashFunction,\n\tassociatedObjectForCache\n) => {\n\tconst modules = chunkGraph.getChunkRootModules(chunk);\n\tconst shortModuleNames = modules.map(m =>\n\t\trequestToId(getShortModuleName(m, context, associatedObjectForCache))\n\t);\n\tchunk.idNameHints.sort();\n\tconst chunkName = Array.from(chunk.idNameHints)\n\t\t.concat(shortModuleNames)\n\t\t.filter(Boolean)\n\t\t.join(delimiter);\n\treturn shortenLongString(chunkName, delimiter, hashFunction);\n};\nexports.getShortChunkName = getShortChunkName;\n\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {string} context context directory\n * @param {string} delimiter delimiter for names\n * @param {string | Hash} hashFunction hash function to use\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} short chunk name\n */\nconst getLongChunkName = (\n\tchunk,\n\tchunkGraph,\n\tcontext,\n\tdelimiter,\n\thashFunction,\n\tassociatedObjectForCache\n) => {\n\tconst modules = chunkGraph.getChunkRootModules(chunk);\n\tconst shortModuleNames = modules.map(m =>\n\t\trequestToId(getShortModuleName(m, context, associatedObjectForCache))\n\t);\n\tconst longModuleNames = modules.map(m =>\n\t\trequestToId(\n\t\t\tgetLongModuleName(\"\", m, context, hashFunction, associatedObjectForCache)\n\t\t)\n\t);\n\tchunk.idNameHints.sort();\n\tconst chunkName = Array.from(chunk.idNameHints)\n\t\t.concat(shortModuleNames, longModuleNames)\n\t\t.filter(Boolean)\n\t\t.join(delimiter);\n\treturn shortenLongString(chunkName, delimiter, hashFunction);\n};\nexports.getLongChunkName = getLongChunkName;\n\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {string} context context directory\n * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} full chunk name\n */\nconst getFullChunkName = (\n\tchunk,\n\tchunkGraph,\n\tcontext,\n\tassociatedObjectForCache\n) => {\n\tif (chunk.name) return chunk.name;\n\tconst modules = chunkGraph.getChunkRootModules(chunk);\n\tconst fullModuleNames = modules.map(m =>\n\t\tmakePathsRelative(context, m.identifier(), associatedObjectForCache)\n\t);\n\treturn fullModuleNames.join();\n};\nexports.getFullChunkName = getFullChunkName;\n\n/**\n * @template K\n * @template V\n * @param {Map<K, V[]>} map a map from key to values\n * @param {K} key key\n * @param {V} value value\n * @returns {void}\n */\nconst addToMapOfItems = (map, key, value) => {\n\tlet array = map.get(key);\n\tif (array === undefined) {\n\t\tarray = [];\n\t\tmap.set(key, array);\n\t}\n\tarray.push(value);\n};\n\n/**\n * @param {Compilation} compilation the compilation\n * @param {function(Module): boolean=} filter filter modules\n * @returns {[Set<string>, Module[]]} used module ids as strings and modules without id matching the filter\n */\nconst getUsedModuleIdsAndModules = (compilation, filter) => {\n\tconst chunkGraph = compilation.chunkGraph;\n\n\tconst modules = [];\n\n\t/** @type {Set<string>} */\n\tconst usedIds = new Set();\n\tif (compilation.usedModuleIds) {\n\t\tfor (const id of compilation.usedModuleIds) {\n\t\t\tusedIds.add(id + \"\");\n\t\t}\n\t}\n\n\tfor (const module of compilation.modules) {\n\t\tif (!module.needId) continue;\n\t\tconst moduleId = chunkGraph.getModuleId(module);\n\t\tif (moduleId !== null) {\n\t\t\tusedIds.add(moduleId + \"\");\n\t\t} else {\n\t\t\tif (\n\t\t\t\t(!filter || filter(module)) &&\n\t\t\t\tchunkGraph.getNumberOfModuleChunks(module) !== 0\n\t\t\t) {\n\t\t\t\tmodules.push(module);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [usedIds, modules];\n};\nexports.getUsedModuleIdsAndModules = getUsedModuleIdsAndModules;\n\n/**\n * @param {Compilation} compilation the compilation\n * @returns {Set<string>} used chunk ids as strings\n */\nconst getUsedChunkIds = compilation => {\n\t/** @type {Set<string>} */\n\tconst usedIds = new Set();\n\tif (compilation.usedChunkIds) {\n\t\tfor (const id of compilation.usedChunkIds) {\n\t\t\tusedIds.add(id + \"\");\n\t\t}\n\t}\n\n\tfor (const chunk of compilation.chunks) {\n\t\tconst chunkId = chunk.id;\n\t\tif (chunkId !== null) {\n\t\t\tusedIds.add(chunkId + \"\");\n\t\t}\n\t}\n\n\treturn usedIds;\n};\nexports.getUsedChunkIds = getUsedChunkIds;\n\n/**\n * @template T\n * @param {Iterable<T>} items list of items to be named\n * @param {function(T): string} getShortName get a short name for an item\n * @param {function(T, string): string} getLongName get a long name for an item\n * @param {function(T, T): -1|0|1} comparator order of items\n * @param {Set<string>} usedIds already used ids, will not be assigned\n * @param {function(T, string): void} assignName assign a name to an item\n * @returns {T[]} list of items without a name\n */\nconst assignNames = (\n\titems,\n\tgetShortName,\n\tgetLongName,\n\tcomparator,\n\tusedIds,\n\tassignName\n) => {\n\t/** @type {Map<string, T[]>} */\n\tconst nameToItems = new Map();\n\n\tfor (const item of items) {\n\t\tconst name = getShortName(item);\n\t\taddToMapOfItems(nameToItems, name, item);\n\t}\n\n\t/** @type {Map<string, T[]>} */\n\tconst nameToItems2 = new Map();\n\n\tfor (const [name, items] of nameToItems) {\n\t\tif (items.length > 1 || !name) {\n\t\t\tfor (const item of items) {\n\t\t\t\tconst longName = getLongName(item, name);\n\t\t\t\taddToMapOfItems(nameToItems2, longName, item);\n\t\t\t}\n\t\t} else {\n\t\t\taddToMapOfItems(nameToItems2, name, items[0]);\n\t\t}\n\t}\n\n\t/** @type {T[]} */\n\tconst unnamedItems = [];\n\n\tfor (const [name, items] of nameToItems2) {\n\t\tif (!name) {\n\t\t\tfor (const item of items) {\n\t\t\t\tunnamedItems.push(item);\n\t\t\t}\n\t\t} else if (items.length === 1 && !usedIds.has(name)) {\n\t\t\tassignName(items[0], name);\n\t\t\tusedIds.add(name);\n\t\t} else {\n\t\t\titems.sort(comparator);\n\t\t\tlet i = 0;\n\t\t\tfor (const item of items) {\n\t\t\t\twhile (nameToItems2.has(name + i) && usedIds.has(name + i)) i++;\n\t\t\t\tassignName(item, name + i);\n\t\t\t\tusedIds.add(name + i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tunnamedItems.sort(comparator);\n\treturn unnamedItems;\n};\nexports.assignNames = assignNames;\n\n/**\n * @template T\n * @param {T[]} items list of items to be named\n * @param {function(T): string} getName get a name for an item\n * @param {function(T, T): -1|0|1} comparator order of items\n * @param {function(T, number): boolean} assignId assign an id to an item\n * @param {number[]} ranges usable ranges for ids\n * @param {number} expandFactor factor to create more ranges\n * @param {number} extraSpace extra space to allocate, i. e. when some ids are already used\n * @param {number} salt salting number to initialize hashing\n * @returns {void}\n */\nconst assignDeterministicIds = (\n\titems,\n\tgetName,\n\tcomparator,\n\tassignId,\n\tranges = [10],\n\texpandFactor = 10,\n\textraSpace = 0,\n\tsalt = 0\n) => {\n\titems.sort(comparator);\n\n\t// max 5% fill rate\n\tconst optimalRange = Math.min(\n\t\titems.length * 20 + extraSpace,\n\t\tNumber.MAX_SAFE_INTEGER\n\t);\n\n\tlet i = 0;\n\tlet range = ranges[i];\n\twhile (range < optimalRange) {\n\t\ti++;\n\t\tif (i < ranges.length) {\n\t\t\trange = Math.min(ranges[i], Number.MAX_SAFE_INTEGER);\n\t\t} else if (expandFactor) {\n\t\t\trange = Math.min(range * expandFactor, Number.MAX_SAFE_INTEGER);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (const item of items) {\n\t\tconst ident = getName(item);\n\t\tlet id;\n\t\tlet i = salt;\n\t\tdo {\n\t\t\tid = numberHash(ident + i++, range);\n\t\t} while (!assignId(item, id));\n\t}\n};\nexports.assignDeterministicIds = assignDeterministicIds;\n\n/**\n * @param {Set<string>} usedIds used ids\n * @param {Iterable<Module>} modules the modules\n * @param {Compilation} compilation the compilation\n * @returns {void}\n */\nconst assignAscendingModuleIds = (usedIds, modules, compilation) => {\n\tconst chunkGraph = compilation.chunkGraph;\n\n\tlet nextId = 0;\n\tlet assignId;\n\tif (usedIds.size > 0) {\n\t\tassignId = module => {\n\t\t\tif (chunkGraph.getModuleId(module) === null) {\n\t\t\t\twhile (usedIds.has(nextId + \"\")) nextId++;\n\t\t\t\tchunkGraph.setModuleId(module, nextId++);\n\t\t\t}\n\t\t};\n\t} else {\n\t\tassignId = module => {\n\t\t\tif (chunkGraph.getModuleId(module) === null) {\n\t\t\t\tchunkGraph.setModuleId(module, nextId++);\n\t\t\t}\n\t\t};\n\t}\n\tfor (const module of modules) {\n\t\tassignId(module);\n\t}\n};\nexports.assignAscendingModuleIds = assignAscendingModuleIds;\n\n/**\n * @param {Iterable<Chunk>} chunks the chunks\n * @param {Compilation} compilation the compilation\n * @returns {void}\n */\nconst assignAscendingChunkIds = (chunks, compilation) => {\n\tconst usedIds = getUsedChunkIds(compilation);\n\n\tlet nextId = 0;\n\tif (usedIds.size > 0) {\n\t\tfor (const chunk of chunks) {\n\t\t\tif (chunk.id === null) {\n\t\t\t\twhile (usedIds.has(nextId + \"\")) nextId++;\n\t\t\t\tchunk.id = nextId;\n\t\t\t\tchunk.ids = [nextId];\n\t\t\t\tnextId++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (const chunk of chunks) {\n\t\t\tif (chunk.id === null) {\n\t\t\t\tchunk.id = nextId;\n\t\t\t\tchunk.ids = [nextId];\n\t\t\t\tnextId++;\n\t\t\t}\n\t\t}\n\t}\n};\nexports.assignAscendingChunkIds = assignAscendingChunkIds;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}