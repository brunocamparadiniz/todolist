{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nvar _defineProperty = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _regeneratorRuntime = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _require = require(\"buffer\"),\n  constants = _require.constants;\nvar _require2 = require(\"stream\"),\n  pipeline = _require2.pipeline;\nvar _require3 = require(\"zlib\"),\n  createBrotliCompress = _require3.createBrotliCompress,\n  createBrotliDecompress = _require3.createBrotliDecompress,\n  createGzip = _require3.createGzip,\n  createGunzip = _require3.createGunzip,\n  zConstants = _require3.constants;\nvar createHash = require(\"../util/createHash\");\nvar _require4 = require(\"../util/fs\"),\n  dirname = _require4.dirname,\n  join = _require4.join,\n  mkdirp = _require4.mkdirp;\nvar memoize = require(\"../util/memoize\");\nvar SerializerMiddleware = require(\"./SerializerMiddleware\");\n\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./types\").BufferSerializableType} BufferSerializableType */\n\n/*\nFormat:\n\nFile -> Header Section*\n\nVersion -> u32\nAmountOfSections -> u32\nSectionSize -> i32 (if less than zero represents lazy value)\n\nHeader -> Version AmountOfSections SectionSize*\n\nBuffer -> n bytes\nSection -> Buffer\n\n*/\n\n// \"wpc\" + 1 in little-endian\nvar VERSION = 0x01637077;\nvar WRITE_LIMIT_TOTAL = 0x7fff0000;\nvar WRITE_LIMIT_CHUNK = 511 * 1024 * 1024;\n\n/**\n * @param {Buffer[]} buffers buffers\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\nvar hashForName = function hashForName(buffers, hashFunction) {\n  var hash = createHash(hashFunction);\n  var _iterator = _createForOfIteratorHelper(buffers),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var buf = _step.value;\n      hash.update(buf);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return (/** @type {string} */hash.digest(\"hex\")\n  );\n};\nvar COMPRESSION_CHUNK_SIZE = 100 * 1024 * 1024;\nvar DECOMPRESSION_CHUNK_SIZE = 100 * 1024 * 1024;\nvar writeUInt64LE = Buffer.prototype.writeBigUInt64LE ? function (buf, value, offset) {\n  buf.writeBigUInt64LE(BigInt(value), offset);\n} : function (buf, value, offset) {\n  var low = value % 0x100000000;\n  var high = (value - low) / 0x100000000;\n  buf.writeUInt32LE(low, offset);\n  buf.writeUInt32LE(high, offset + 4);\n};\nvar readUInt64LE = Buffer.prototype.readBigUInt64LE ? function (buf, offset) {\n  return Number(buf.readBigUInt64LE(offset));\n} : function (buf, offset) {\n  var low = buf.readUInt32LE(offset);\n  var high = buf.readUInt32LE(offset + 4);\n  return high * 0x100000000 + low;\n};\n\n/**\n * @typedef {Object} SerializeResult\n * @property {string | false} name\n * @property {number} size\n * @property {Promise=} backgroundJob\n */\n\n/**\n * @param {FileMiddleware} middleware this\n * @param {BufferSerializableType[] | Promise<BufferSerializableType[]>} data data to be serialized\n * @param {string | boolean} name file base name\n * @param {function(string | false, Buffer[], number): Promise<void>} writeFile writes a file\n * @param {string | Hash} hashFunction hash function to use\n * @returns {Promise<SerializeResult>} resulting file pointer and promise\n */\nvar _serialize = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(middleware, data, name, writeFile) {\n    var hashFunction,\n      processedData,\n      resultToLazy,\n      lastBuffers,\n      _iterator2,\n      _step2,\n      _loop,\n      backgroundJobs,\n      resolvedData,\n      lengths,\n      _iterator3,\n      _step3,\n      item,\n      l,\n      _iterator5,\n      _step5,\n      _b,\n      header,\n      i,\n      buf,\n      _iterator4,\n      _step4,\n      _item,\n      _iterator6,\n      _step6,\n      _b2,\n      size,\n      _i,\n      _buf,\n      b,\n      _args2 = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          hashFunction = _args2.length > 4 && _args2[4] !== undefined ? _args2[4] : \"md4\";\n          /** @type {(Buffer[] | Buffer | SerializeResult | Promise<SerializeResult>)[]} */\n          processedData = [];\n          /** @type {WeakMap<SerializeResult, function(): any | Promise<any>>} */\n          resultToLazy = new WeakMap();\n          /** @type {Buffer[]} */\n          lastBuffers = undefined;\n          _context2.t0 = _createForOfIteratorHelper;\n          _context2.next = 7;\n          return data;\n        case 7:\n          _context2.t1 = _context2.sent;\n          _iterator2 = (0, _context2.t0)(_context2.t1);\n          _context2.prev = 9;\n          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {\n            var item, serializedInfo, content, options;\n            return _regeneratorRuntime().wrap(function _loop$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  item = _step2.value;\n                  if (!(typeof item === \"function\")) {\n                    _context.next = 25;\n                    break;\n                  }\n                  if (SerializerMiddleware.isLazy(item)) {\n                    _context.next = 4;\n                    break;\n                  }\n                  throw new Error(\"Unexpected function\");\n                case 4:\n                  if (SerializerMiddleware.isLazy(item, middleware)) {\n                    _context.next = 6;\n                    break;\n                  }\n                  throw new Error(\"Unexpected lazy value with non-this target (can't pass through lazy values)\");\n                case 6:\n                  lastBuffers = undefined;\n                  serializedInfo = SerializerMiddleware.getLazySerializedValue(item);\n                  if (!serializedInfo) {\n                    _context.next = 16;\n                    break;\n                  }\n                  if (!(typeof serializedInfo === \"function\")) {\n                    _context.next = 13;\n                    break;\n                  }\n                  throw new Error(\"Unexpected lazy value with non-this target (can't pass through lazy values)\");\n                case 13:\n                  processedData.push(serializedInfo);\n                case 14:\n                  _context.next = 23;\n                  break;\n                case 16:\n                  content = item();\n                  if (!content) {\n                    _context.next = 22;\n                    break;\n                  }\n                  options = SerializerMiddleware.getLazyOptions(item);\n                  processedData.push(_serialize(middleware, content, options && options.name || true, writeFile, hashFunction).then(function (result) {\n                    /** @type {any} */item.options.size = result.size;\n                    resultToLazy.set(result, item);\n                    return result;\n                  }));\n                  _context.next = 23;\n                  break;\n                case 22:\n                  throw new Error(\"Unexpected falsy value returned by lazy value function\");\n                case 23:\n                  _context.next = 30;\n                  break;\n                case 25:\n                  if (!item) {\n                    _context.next = 29;\n                    break;\n                  }\n                  if (lastBuffers) {\n                    lastBuffers.push(item);\n                  } else {\n                    lastBuffers = [item];\n                    processedData.push(lastBuffers);\n                  }\n                  _context.next = 30;\n                  break;\n                case 29:\n                  throw new Error(\"Unexpected falsy value in items array\");\n                case 30:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _loop);\n          });\n          _iterator2.s();\n        case 12:\n          if ((_step2 = _iterator2.n()).done) {\n            _context2.next = 16;\n            break;\n          }\n          return _context2.delegateYield(_loop(), \"t2\", 14);\n        case 14:\n          _context2.next = 12;\n          break;\n        case 16:\n          _context2.next = 21;\n          break;\n        case 18:\n          _context2.prev = 18;\n          _context2.t3 = _context2[\"catch\"](9);\n          _iterator2.e(_context2.t3);\n        case 21:\n          _context2.prev = 21;\n          _iterator2.f();\n          return _context2.finish(21);\n        case 24:\n          /** @type {Promise<any>[]} */\n          backgroundJobs = [];\n          _context2.next = 27;\n          return Promise.all( /** @type {Promise<Buffer[] | Buffer | SerializeResult>[]} */\n          processedData);\n        case 27:\n          resolvedData = _context2.sent.map(function (item) {\n            if (Array.isArray(item) || Buffer.isBuffer(item)) return item;\n            backgroundJobs.push(item.backgroundJob);\n            // create pointer buffer from size and name\n            var name = /** @type {string} */item.name;\n            var nameBuffer = Buffer.from(name);\n            var buf = Buffer.allocUnsafe(8 + nameBuffer.length);\n            writeUInt64LE(buf, item.size, 0);\n            nameBuffer.copy(buf, 8, 0);\n            var lazy = resultToLazy.get(item);\n            SerializerMiddleware.setLazySerializedValue(lazy, buf);\n            return buf;\n          });\n          lengths = [];\n          _iterator3 = _createForOfIteratorHelper(resolvedData);\n          _context2.prev = 30;\n          _iterator3.s();\n        case 32:\n          if ((_step3 = _iterator3.n()).done) {\n            _context2.next = 49;\n            break;\n          }\n          item = _step3.value;\n          if (!Array.isArray(item)) {\n            _context2.next = 42;\n            break;\n          }\n          l = 0;\n          _iterator5 = _createForOfIteratorHelper(item);\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              _b = _step5.value;\n              l += _b.length;\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n          while (l > 0x7fffffff) {\n            lengths.push(0x7fffffff);\n            l -= 0x7fffffff;\n          }\n          lengths.push(l);\n          _context2.next = 47;\n          break;\n        case 42:\n          if (!item) {\n            _context2.next = 46;\n            break;\n          }\n          lengths.push(-item.length);\n          _context2.next = 47;\n          break;\n        case 46:\n          throw new Error(\"Unexpected falsy value in resolved data \" + item);\n        case 47:\n          _context2.next = 32;\n          break;\n        case 49:\n          _context2.next = 54;\n          break;\n        case 51:\n          _context2.prev = 51;\n          _context2.t4 = _context2[\"catch\"](30);\n          _iterator3.e(_context2.t4);\n        case 54:\n          _context2.prev = 54;\n          _iterator3.f();\n          return _context2.finish(54);\n        case 57:\n          header = Buffer.allocUnsafe(8 + lengths.length * 4);\n          header.writeUInt32LE(VERSION, 0);\n          header.writeUInt32LE(lengths.length, 4);\n          for (i = 0; i < lengths.length; i++) {\n            header.writeInt32LE(lengths[i], 8 + i * 4);\n          }\n          buf = [header];\n          _iterator4 = _createForOfIteratorHelper(resolvedData);\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              _item = _step4.value;\n              if (Array.isArray(_item)) {\n                _iterator6 = _createForOfIteratorHelper(_item);\n                try {\n                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                    _b2 = _step6.value;\n                    buf.push(_b2);\n                  }\n                } catch (err) {\n                  _iterator6.e(err);\n                } finally {\n                  _iterator6.f();\n                }\n              } else if (_item) {\n                buf.push(_item);\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          if (name === true) {\n            name = hashForName(buf, hashFunction);\n          }\n          size = 0;\n          for (_i = 0, _buf = buf; _i < _buf.length; _i++) {\n            b = _buf[_i];\n            size += b.length;\n          }\n          backgroundJobs.push(writeFile(name, buf, size));\n          return _context2.abrupt(\"return\", {\n            size: size,\n            name: name,\n            backgroundJob: backgroundJobs.length === 1 ? backgroundJobs[0] : Promise.all(backgroundJobs)\n          });\n        case 69:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee, null, [[9, 18, 21, 24], [30, 51, 54, 57]]);\n  }));\n  return function serialize(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/**\n * @param {FileMiddleware} middleware this\n * @param {string | false} name filename\n * @param {function(string | false): Promise<Buffer[]>} readFile read content of a file\n * @returns {Promise<BufferSerializableType[]>} deserialized data\n */\nvar _deserialize = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(middleware, name, readFile) {\n    var contents, contentsIndex, contentItem, contentItemLength, contentPosition, nextContent, ensureData, readUInt32LE, readInt32LE, readSlice, version, sectionCount, lengths, lastLengthPositive, i, value, valuePositive, result, _loop2, _i2, _lengths;\n    return _regeneratorRuntime().wrap(function _callee2$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.next = 2;\n          return readFile(name);\n        case 2:\n          contents = _context4.sent;\n          if (!(contents.length === 0)) {\n            _context4.next = 5;\n            break;\n          }\n          throw new Error(\"Empty file \" + name);\n        case 5:\n          contentsIndex = 0;\n          contentItem = contents[0];\n          contentItemLength = contentItem.length;\n          contentPosition = 0;\n          if (!(contentItemLength === 0)) {\n            _context4.next = 11;\n            break;\n          }\n          throw new Error(\"Empty file \" + name);\n        case 11:\n          nextContent = function nextContent() {\n            contentsIndex++;\n            contentItem = contents[contentsIndex];\n            contentItemLength = contentItem.length;\n            contentPosition = 0;\n          };\n          ensureData = function ensureData(n) {\n            if (contentPosition === contentItemLength) {\n              nextContent();\n            }\n            while (contentItemLength - contentPosition < n) {\n              var remaining = contentItem.slice(contentPosition);\n              var lengthFromNext = n - remaining.length;\n              var buffers = [remaining];\n              for (var i = contentsIndex + 1; i < contents.length; i++) {\n                var l = contents[i].length;\n                if (l > lengthFromNext) {\n                  buffers.push(contents[i].slice(0, lengthFromNext));\n                  contents[i] = contents[i].slice(lengthFromNext);\n                  lengthFromNext = 0;\n                  break;\n                } else {\n                  buffers.push(contents[i]);\n                  contentsIndex = i;\n                  lengthFromNext -= l;\n                }\n              }\n              if (lengthFromNext > 0) throw new Error(\"Unexpected end of data\");\n              contentItem = Buffer.concat(buffers, n);\n              contentItemLength = n;\n              contentPosition = 0;\n            }\n          };\n          readUInt32LE = function readUInt32LE() {\n            ensureData(4);\n            var value = contentItem.readUInt32LE(contentPosition);\n            contentPosition += 4;\n            return value;\n          };\n          readInt32LE = function readInt32LE() {\n            ensureData(4);\n            var value = contentItem.readInt32LE(contentPosition);\n            contentPosition += 4;\n            return value;\n          };\n          readSlice = function readSlice(l) {\n            ensureData(l);\n            if (contentPosition === 0 && contentItemLength === l) {\n              var _result = contentItem;\n              if (contentsIndex + 1 < contents.length) {\n                nextContent();\n              } else {\n                contentPosition = l;\n              }\n              return _result;\n            }\n            var result = contentItem.slice(contentPosition, contentPosition + l);\n            contentPosition += l;\n            // we clone the buffer here to allow the original content to be garbage collected\n            return l * 2 < contentItem.buffer.byteLength ? Buffer.from(result) : result;\n          };\n          version = readUInt32LE();\n          if (!(version !== VERSION)) {\n            _context4.next = 19;\n            break;\n          }\n          throw new Error(\"Invalid file version\");\n        case 19:\n          sectionCount = readUInt32LE();\n          lengths = [];\n          lastLengthPositive = false;\n          for (i = 0; i < sectionCount; i++) {\n            value = readInt32LE();\n            valuePositive = value >= 0;\n            if (lastLengthPositive && valuePositive) {\n              lengths[lengths.length - 1] += value;\n            } else {\n              lengths.push(value);\n              lastLengthPositive = valuePositive;\n            }\n          }\n          result = [];\n          _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {\n            var length, slice, size, nameBuffer, _name, l;\n            return _regeneratorRuntime().wrap(function _loop2$(_context3) {\n              while (1) switch (_context3.prev = _context3.next) {\n                case 0:\n                  length = _lengths[_i2];\n                  if (length < 0) {\n                    slice = readSlice(-length);\n                    size = Number(readUInt64LE(slice, 0));\n                    nameBuffer = slice.slice(8);\n                    _name = nameBuffer.toString();\n                    result.push(SerializerMiddleware.createLazy(memoize(function () {\n                      return _deserialize(middleware, _name, readFile);\n                    }), middleware, {\n                      name: _name,\n                      size: size\n                    }, slice));\n                  } else {\n                    if (contentPosition === contentItemLength) {\n                      nextContent();\n                    } else if (contentPosition !== 0) {\n                      if (length <= contentItemLength - contentPosition) {\n                        result.push(Buffer.from(contentItem.buffer, contentItem.byteOffset + contentPosition, length));\n                        contentPosition += length;\n                        length = 0;\n                      } else {\n                        l = contentItemLength - contentPosition;\n                        result.push(Buffer.from(contentItem.buffer, contentItem.byteOffset + contentPosition, l));\n                        length -= l;\n                        contentPosition = contentItemLength;\n                      }\n                    } else {\n                      if (length >= contentItemLength) {\n                        result.push(contentItem);\n                        length -= contentItemLength;\n                        contentPosition = contentItemLength;\n                      } else {\n                        result.push(Buffer.from(contentItem.buffer, contentItem.byteOffset, length));\n                        contentPosition += length;\n                        length = 0;\n                      }\n                    }\n                    while (length > 0) {\n                      nextContent();\n                      if (length >= contentItemLength) {\n                        result.push(contentItem);\n                        length -= contentItemLength;\n                        contentPosition = contentItemLength;\n                      } else {\n                        result.push(Buffer.from(contentItem.buffer, contentItem.byteOffset, length));\n                        contentPosition += length;\n                        length = 0;\n                      }\n                    }\n                  }\n                case 2:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }, _loop2);\n          });\n          _i2 = 0, _lengths = lengths;\n        case 26:\n          if (!(_i2 < _lengths.length)) {\n            _context4.next = 31;\n            break;\n          }\n          return _context4.delegateYield(_loop2(), \"t0\", 28);\n        case 28:\n          _i2++;\n          _context4.next = 26;\n          break;\n        case 31:\n          return _context4.abrupt(\"return\", result);\n        case 32:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee2);\n  }));\n  return function deserialize(_x5, _x6, _x7) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n/**\n * @typedef {BufferSerializableType[]} DeserializedType\n * @typedef {true} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\nvar FileMiddleware = /*#__PURE__*/function (_SerializerMiddleware) {\n  _inherits(FileMiddleware, _SerializerMiddleware);\n  var _super = _createSuper(FileMiddleware);\n  /**\n   * @param {IntermediateFileSystem} fs filesystem\n   * @param {string | Hash} hashFunction hash function to use\n   */\n  function FileMiddleware(fs) {\n    var _this;\n    var hashFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"md4\";\n    _classCallCheck(this, FileMiddleware);\n    _this = _super.call(this);\n    _this.fs = fs;\n    _this._hashFunction = hashFunction;\n    return _this;\n  }\n  /**\n   * @param {DeserializedType} data data\n   * @param {Object} context context object\n   * @returns {SerializedType|Promise<SerializedType>} serialized data\n   */\n  _createClass(FileMiddleware, [{\n    key: \"serialize\",\n    value: function serialize(data, context) {\n      var _this2 = this;\n      var filename = context.filename,\n        _context$extension = context.extension,\n        extension = _context$extension === void 0 ? \"\" : _context$extension;\n      return new Promise(function (resolve, reject) {\n        mkdirp(_this2.fs, dirname(_this2.fs, filename), function (err) {\n          if (err) return reject(err);\n\n          // It's important that we don't touch existing files during serialization\n          // because serialize may read existing files (when deserializing)\n          var allWrittenFiles = new Set();\n          var writeFile = /*#__PURE__*/function () {\n            var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(name, content, size) {\n              var file;\n              return _regeneratorRuntime().wrap(function _callee3$(_context5) {\n                while (1) switch (_context5.prev = _context5.next) {\n                  case 0:\n                    file = name ? join(_this2.fs, filename, \"../\".concat(name).concat(extension)) : filename;\n                    _context5.next = 3;\n                    return new Promise(function (resolve, reject) {\n                      var stream = _this2.fs.createWriteStream(file + \"_\");\n                      var compression;\n                      if (file.endsWith(\".gz\")) {\n                        compression = createGzip({\n                          chunkSize: COMPRESSION_CHUNK_SIZE,\n                          level: zConstants.Z_BEST_SPEED\n                        });\n                      } else if (file.endsWith(\".br\")) {\n                        var _params;\n                        compression = createBrotliCompress({\n                          chunkSize: COMPRESSION_CHUNK_SIZE,\n                          params: (_params = {}, _defineProperty(_params, zConstants.BROTLI_PARAM_MODE, zConstants.BROTLI_MODE_TEXT), _defineProperty(_params, zConstants.BROTLI_PARAM_QUALITY, 2), _defineProperty(_params, zConstants.BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING, true), _defineProperty(_params, zConstants.BROTLI_PARAM_SIZE_HINT, size), _params)\n                        });\n                      }\n                      if (compression) {\n                        pipeline(compression, stream, reject);\n                        stream = compression;\n                        stream.on(\"finish\", function () {\n                          return resolve();\n                        });\n                      } else {\n                        stream.on(\"error\", function (err) {\n                          return reject(err);\n                        });\n                        stream.on(\"finish\", function () {\n                          return resolve();\n                        });\n                      }\n                      // split into chunks for WRITE_LIMIT_CHUNK size\n                      var chunks = [];\n                      var _iterator7 = _createForOfIteratorHelper(content),\n                        _step7;\n                      try {\n                        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                          var b = _step7.value;\n                          if (b.length < WRITE_LIMIT_CHUNK) {\n                            chunks.push(b);\n                          } else {\n                            for (var _i3 = 0; _i3 < b.length; _i3 += WRITE_LIMIT_CHUNK) {\n                              chunks.push(b.slice(_i3, _i3 + WRITE_LIMIT_CHUNK));\n                            }\n                          }\n                        }\n                      } catch (err) {\n                        _iterator7.e(err);\n                      } finally {\n                        _iterator7.f();\n                      }\n                      var len = chunks.length;\n                      var i = 0;\n                      var batchWrite = function batchWrite(err) {\n                        // will be handled in \"on\" error handler\n                        if (err) return;\n                        if (i === len) {\n                          stream.end();\n                          return;\n                        }\n\n                        // queue up a batch of chunks up to the write limit\n                        // end is exclusive\n                        var end = i;\n                        var sum = chunks[end++].length;\n                        while (end < len) {\n                          sum += chunks[end].length;\n                          if (sum > WRITE_LIMIT_TOTAL) break;\n                          end++;\n                        }\n                        while (i < end - 1) {\n                          stream.write(chunks[i++]);\n                        }\n                        stream.write(chunks[i++], batchWrite);\n                      };\n                      batchWrite();\n                    });\n                  case 3:\n                    if (name) allWrittenFiles.add(file);\n                  case 4:\n                  case \"end\":\n                    return _context5.stop();\n                }\n              }, _callee3);\n            }));\n            return function writeFile(_x8, _x9, _x10) {\n              return _ref3.apply(this, arguments);\n            };\n          }();\n          resolve(_serialize(_this2, data, false, writeFile, _this2._hashFunction).then( /*#__PURE__*/function () {\n            var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_ref4) {\n              var backgroundJob;\n              return _regeneratorRuntime().wrap(function _callee4$(_context6) {\n                while (1) switch (_context6.prev = _context6.next) {\n                  case 0:\n                    backgroundJob = _ref4.backgroundJob;\n                    _context6.next = 3;\n                    return backgroundJob;\n                  case 3:\n                    _context6.next = 5;\n                    return new Promise(function (resolve) {\n                      return _this2.fs.rename(filename, filename + \".old\", function (err) {\n                        resolve();\n                      });\n                    });\n                  case 5:\n                    _context6.next = 7;\n                    return Promise.all(Array.from(allWrittenFiles, function (file) {\n                      return new Promise(function (resolve, reject) {\n                        _this2.fs.rename(file + \"_\", file, function (err) {\n                          if (err) return reject(err);\n                          resolve();\n                        });\n                      });\n                    }));\n                  case 7:\n                    _context6.next = 9;\n                    return new Promise(function (resolve) {\n                      _this2.fs.rename(filename + \"_\", filename, function (err) {\n                        if (err) return reject(err);\n                        resolve();\n                      });\n                    });\n                  case 9:\n                    return _context6.abrupt(\"return\", /** @type {true} */true);\n                  case 10:\n                  case \"end\":\n                    return _context6.stop();\n                }\n              }, _callee4);\n            }));\n            return function (_x11) {\n              return _ref5.apply(this, arguments);\n            };\n          }()));\n        });\n      });\n    }\n\n    /**\n     * @param {SerializedType} data data\n     * @param {Object} context context object\n     * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n     */\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data, context) {\n      var _this3 = this;\n      var filename = context.filename,\n        _context$extension2 = context.extension,\n        extension = _context$extension2 === void 0 ? \"\" : _context$extension2;\n      var readFile = function readFile(name) {\n        return new Promise(function (resolve, reject) {\n          var file = name ? join(_this3.fs, filename, \"../\".concat(name).concat(extension)) : filename;\n          _this3.fs.stat(file, function (err, stats) {\n            if (err) {\n              reject(err);\n              return;\n            }\n            var remaining = /** @type {number} */stats.size;\n            var currentBuffer;\n            var currentBufferUsed;\n            var buf = [];\n            var decompression;\n            if (file.endsWith(\".gz\")) {\n              decompression = createGunzip({\n                chunkSize: DECOMPRESSION_CHUNK_SIZE\n              });\n            } else if (file.endsWith(\".br\")) {\n              decompression = createBrotliDecompress({\n                chunkSize: DECOMPRESSION_CHUNK_SIZE\n              });\n            }\n            if (decompression) {\n              var newResolve, newReject;\n              resolve(Promise.all([new Promise(function (rs, rj) {\n                newResolve = rs;\n                newReject = rj;\n              }), new Promise(function (resolve, reject) {\n                decompression.on(\"data\", function (chunk) {\n                  return buf.push(chunk);\n                });\n                decompression.on(\"end\", function () {\n                  return resolve();\n                });\n                decompression.on(\"error\", function (err) {\n                  return reject(err);\n                });\n              })]).then(function () {\n                return buf;\n              }));\n              resolve = newResolve;\n              reject = newReject;\n            }\n            _this3.fs.open(file, \"r\", function (err, fd) {\n              if (err) {\n                reject(err);\n                return;\n              }\n              var read = function read() {\n                if (currentBuffer === undefined) {\n                  currentBuffer = Buffer.allocUnsafeSlow(Math.min(constants.MAX_LENGTH, remaining, decompression ? DECOMPRESSION_CHUNK_SIZE : Infinity));\n                  currentBufferUsed = 0;\n                }\n                var readBuffer = currentBuffer;\n                var readOffset = currentBufferUsed;\n                var readLength = currentBuffer.length - currentBufferUsed;\n                // values passed to fs.read must be valid int32 values\n                if (readOffset > 0x7fffffff) {\n                  readBuffer = currentBuffer.slice(readOffset);\n                  readOffset = 0;\n                }\n                if (readLength > 0x7fffffff) {\n                  readLength = 0x7fffffff;\n                }\n                _this3.fs.read(fd, readBuffer, readOffset, readLength, null, function (err, bytesRead) {\n                  if (err) {\n                    _this3.fs.close(fd, function () {\n                      reject(err);\n                    });\n                    return;\n                  }\n                  currentBufferUsed += bytesRead;\n                  remaining -= bytesRead;\n                  if (currentBufferUsed === currentBuffer.length) {\n                    if (decompression) {\n                      decompression.write(currentBuffer);\n                    } else {\n                      buf.push(currentBuffer);\n                    }\n                    currentBuffer = undefined;\n                    if (remaining === 0) {\n                      if (decompression) {\n                        decompression.end();\n                      }\n                      _this3.fs.close(fd, function (err) {\n                        if (err) {\n                          reject(err);\n                          return;\n                        }\n                        resolve(buf);\n                      });\n                      return;\n                    }\n                  }\n                  read();\n                });\n              };\n              read();\n            });\n          });\n        });\n      };\n      return _deserialize(this, false, readFile);\n    }\n  }]);\n  return FileMiddleware;\n}(SerializerMiddleware);\nmodule.exports = FileMiddleware;","map":{"version":3,"names":["require","constants","pipeline","createBrotliCompress","createBrotliDecompress","createGzip","createGunzip","zConstants","createHash","dirname","join","mkdirp","memoize","SerializerMiddleware","VERSION","WRITE_LIMIT_TOTAL","WRITE_LIMIT_CHUNK","hashForName","buffers","hashFunction","hash","buf","update","digest","COMPRESSION_CHUNK_SIZE","DECOMPRESSION_CHUNK_SIZE","writeUInt64LE","Buffer","prototype","writeBigUInt64LE","value","offset","BigInt","low","high","writeUInt32LE","readUInt64LE","readBigUInt64LE","Number","readUInt32LE","serialize","middleware","data","name","writeFile","processedData","resultToLazy","WeakMap","lastBuffers","undefined","item","isLazy","Error","serializedInfo","getLazySerializedValue","push","content","options","getLazyOptions","then","result","size","set","backgroundJobs","Promise","all","resolvedData","map","Array","isArray","isBuffer","backgroundJob","nameBuffer","from","allocUnsafe","length","copy","lazy","get","setLazySerializedValue","lengths","l","b","header","i","writeInt32LE","deserialize","readFile","contents","contentsIndex","contentItem","contentItemLength","contentPosition","nextContent","ensureData","n","remaining","slice","lengthFromNext","concat","readInt32LE","readSlice","buffer","byteLength","version","sectionCount","lastLengthPositive","valuePositive","toString","createLazy","byteOffset","FileMiddleware","fs","_hashFunction","context","filename","extension","resolve","reject","err","allWrittenFiles","Set","file","stream","createWriteStream","compression","endsWith","chunkSize","level","Z_BEST_SPEED","params","BROTLI_PARAM_MODE","BROTLI_MODE_TEXT","BROTLI_PARAM_QUALITY","BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING","BROTLI_PARAM_SIZE_HINT","on","chunks","len","batchWrite","end","sum","write","add","rename","stat","stats","currentBuffer","currentBufferUsed","decompression","newResolve","newReject","rs","rj","chunk","open","fd","read","allocUnsafeSlow","Math","min","MAX_LENGTH","Infinity","readBuffer","readOffset","readLength","bytesRead","close","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/serialization/FileMiddleware.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst { constants } = require(\"buffer\");\nconst { pipeline } = require(\"stream\");\nconst {\n\tcreateBrotliCompress,\n\tcreateBrotliDecompress,\n\tcreateGzip,\n\tcreateGunzip,\n\tconstants: zConstants\n} = require(\"zlib\");\nconst createHash = require(\"../util/createHash\");\nconst { dirname, join, mkdirp } = require(\"../util/fs\");\nconst memoize = require(\"../util/memoize\");\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\n\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./types\").BufferSerializableType} BufferSerializableType */\n\n/*\nFormat:\n\nFile -> Header Section*\n\nVersion -> u32\nAmountOfSections -> u32\nSectionSize -> i32 (if less than zero represents lazy value)\n\nHeader -> Version AmountOfSections SectionSize*\n\nBuffer -> n bytes\nSection -> Buffer\n\n*/\n\n// \"wpc\" + 1 in little-endian\nconst VERSION = 0x01637077;\nconst WRITE_LIMIT_TOTAL = 0x7fff0000;\nconst WRITE_LIMIT_CHUNK = 511 * 1024 * 1024;\n\n/**\n * @param {Buffer[]} buffers buffers\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\nconst hashForName = (buffers, hashFunction) => {\n\tconst hash = createHash(hashFunction);\n\tfor (const buf of buffers) hash.update(buf);\n\treturn /** @type {string} */ (hash.digest(\"hex\"));\n};\n\nconst COMPRESSION_CHUNK_SIZE = 100 * 1024 * 1024;\nconst DECOMPRESSION_CHUNK_SIZE = 100 * 1024 * 1024;\n\nconst writeUInt64LE = Buffer.prototype.writeBigUInt64LE\n\t? (buf, value, offset) => {\n\t\t\tbuf.writeBigUInt64LE(BigInt(value), offset);\n\t  }\n\t: (buf, value, offset) => {\n\t\t\tconst low = value % 0x100000000;\n\t\t\tconst high = (value - low) / 0x100000000;\n\t\t\tbuf.writeUInt32LE(low, offset);\n\t\t\tbuf.writeUInt32LE(high, offset + 4);\n\t  };\n\nconst readUInt64LE = Buffer.prototype.readBigUInt64LE\n\t? (buf, offset) => {\n\t\t\treturn Number(buf.readBigUInt64LE(offset));\n\t  }\n\t: (buf, offset) => {\n\t\t\tconst low = buf.readUInt32LE(offset);\n\t\t\tconst high = buf.readUInt32LE(offset + 4);\n\t\t\treturn high * 0x100000000 + low;\n\t  };\n\n/**\n * @typedef {Object} SerializeResult\n * @property {string | false} name\n * @property {number} size\n * @property {Promise=} backgroundJob\n */\n\n/**\n * @param {FileMiddleware} middleware this\n * @param {BufferSerializableType[] | Promise<BufferSerializableType[]>} data data to be serialized\n * @param {string | boolean} name file base name\n * @param {function(string | false, Buffer[], number): Promise<void>} writeFile writes a file\n * @param {string | Hash} hashFunction hash function to use\n * @returns {Promise<SerializeResult>} resulting file pointer and promise\n */\nconst serialize = async (\n\tmiddleware,\n\tdata,\n\tname,\n\twriteFile,\n\thashFunction = \"md4\"\n) => {\n\t/** @type {(Buffer[] | Buffer | SerializeResult | Promise<SerializeResult>)[]} */\n\tconst processedData = [];\n\t/** @type {WeakMap<SerializeResult, function(): any | Promise<any>>} */\n\tconst resultToLazy = new WeakMap();\n\t/** @type {Buffer[]} */\n\tlet lastBuffers = undefined;\n\tfor (const item of await data) {\n\t\tif (typeof item === \"function\") {\n\t\t\tif (!SerializerMiddleware.isLazy(item))\n\t\t\t\tthrow new Error(\"Unexpected function\");\n\t\t\tif (!SerializerMiddleware.isLazy(item, middleware)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Unexpected lazy value with non-this target (can't pass through lazy values)\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tlastBuffers = undefined;\n\t\t\tconst serializedInfo = SerializerMiddleware.getLazySerializedValue(item);\n\t\t\tif (serializedInfo) {\n\t\t\t\tif (typeof serializedInfo === \"function\") {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\"Unexpected lazy value with non-this target (can't pass through lazy values)\"\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tprocessedData.push(serializedInfo);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst content = item();\n\t\t\t\tif (content) {\n\t\t\t\t\tconst options = SerializerMiddleware.getLazyOptions(item);\n\t\t\t\t\tprocessedData.push(\n\t\t\t\t\t\tserialize(\n\t\t\t\t\t\t\tmiddleware,\n\t\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t\t(options && options.name) || true,\n\t\t\t\t\t\t\twriteFile,\n\t\t\t\t\t\t\thashFunction\n\t\t\t\t\t\t).then(result => {\n\t\t\t\t\t\t\t/** @type {any} */ (item).options.size = result.size;\n\t\t\t\t\t\t\tresultToLazy.set(result, item);\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\"Unexpected falsy value returned by lazy value function\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (item) {\n\t\t\tif (lastBuffers) {\n\t\t\t\tlastBuffers.push(item);\n\t\t\t} else {\n\t\t\t\tlastBuffers = [item];\n\t\t\t\tprocessedData.push(lastBuffers);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(\"Unexpected falsy value in items array\");\n\t\t}\n\t}\n\t/** @type {Promise<any>[]} */\n\tconst backgroundJobs = [];\n\tconst resolvedData = (\n\t\tawait Promise.all(\n\t\t\t/** @type {Promise<Buffer[] | Buffer | SerializeResult>[]} */ (\n\t\t\t\tprocessedData\n\t\t\t)\n\t\t)\n\t).map(item => {\n\t\tif (Array.isArray(item) || Buffer.isBuffer(item)) return item;\n\n\t\tbackgroundJobs.push(item.backgroundJob);\n\t\t// create pointer buffer from size and name\n\t\tconst name = /** @type {string} */ (item.name);\n\t\tconst nameBuffer = Buffer.from(name);\n\t\tconst buf = Buffer.allocUnsafe(8 + nameBuffer.length);\n\t\twriteUInt64LE(buf, item.size, 0);\n\t\tnameBuffer.copy(buf, 8, 0);\n\t\tconst lazy = resultToLazy.get(item);\n\t\tSerializerMiddleware.setLazySerializedValue(lazy, buf);\n\t\treturn buf;\n\t});\n\tconst lengths = [];\n\tfor (const item of resolvedData) {\n\t\tif (Array.isArray(item)) {\n\t\t\tlet l = 0;\n\t\t\tfor (const b of item) l += b.length;\n\t\t\twhile (l > 0x7fffffff) {\n\t\t\t\tlengths.push(0x7fffffff);\n\t\t\t\tl -= 0x7fffffff;\n\t\t\t}\n\t\t\tlengths.push(l);\n\t\t} else if (item) {\n\t\t\tlengths.push(-item.length);\n\t\t} else {\n\t\t\tthrow new Error(\"Unexpected falsy value in resolved data \" + item);\n\t\t}\n\t}\n\tconst header = Buffer.allocUnsafe(8 + lengths.length * 4);\n\theader.writeUInt32LE(VERSION, 0);\n\theader.writeUInt32LE(lengths.length, 4);\n\tfor (let i = 0; i < lengths.length; i++) {\n\t\theader.writeInt32LE(lengths[i], 8 + i * 4);\n\t}\n\tconst buf = [header];\n\tfor (const item of resolvedData) {\n\t\tif (Array.isArray(item)) {\n\t\t\tfor (const b of item) buf.push(b);\n\t\t} else if (item) {\n\t\t\tbuf.push(item);\n\t\t}\n\t}\n\tif (name === true) {\n\t\tname = hashForName(buf, hashFunction);\n\t}\n\tlet size = 0;\n\tfor (const b of buf) size += b.length;\n\tbackgroundJobs.push(writeFile(name, buf, size));\n\treturn {\n\t\tsize,\n\t\tname,\n\t\tbackgroundJob:\n\t\t\tbackgroundJobs.length === 1\n\t\t\t\t? backgroundJobs[0]\n\t\t\t\t: Promise.all(backgroundJobs)\n\t};\n};\n\n/**\n * @param {FileMiddleware} middleware this\n * @param {string | false} name filename\n * @param {function(string | false): Promise<Buffer[]>} readFile read content of a file\n * @returns {Promise<BufferSerializableType[]>} deserialized data\n */\nconst deserialize = async (middleware, name, readFile) => {\n\tconst contents = await readFile(name);\n\tif (contents.length === 0) throw new Error(\"Empty file \" + name);\n\tlet contentsIndex = 0;\n\tlet contentItem = contents[0];\n\tlet contentItemLength = contentItem.length;\n\tlet contentPosition = 0;\n\tif (contentItemLength === 0) throw new Error(\"Empty file \" + name);\n\tconst nextContent = () => {\n\t\tcontentsIndex++;\n\t\tcontentItem = contents[contentsIndex];\n\t\tcontentItemLength = contentItem.length;\n\t\tcontentPosition = 0;\n\t};\n\tconst ensureData = n => {\n\t\tif (contentPosition === contentItemLength) {\n\t\t\tnextContent();\n\t\t}\n\t\twhile (contentItemLength - contentPosition < n) {\n\t\t\tconst remaining = contentItem.slice(contentPosition);\n\t\t\tlet lengthFromNext = n - remaining.length;\n\t\t\tconst buffers = [remaining];\n\t\t\tfor (let i = contentsIndex + 1; i < contents.length; i++) {\n\t\t\t\tconst l = contents[i].length;\n\t\t\t\tif (l > lengthFromNext) {\n\t\t\t\t\tbuffers.push(contents[i].slice(0, lengthFromNext));\n\t\t\t\t\tcontents[i] = contents[i].slice(lengthFromNext);\n\t\t\t\t\tlengthFromNext = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tbuffers.push(contents[i]);\n\t\t\t\t\tcontentsIndex = i;\n\t\t\t\t\tlengthFromNext -= l;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lengthFromNext > 0) throw new Error(\"Unexpected end of data\");\n\t\t\tcontentItem = Buffer.concat(buffers, n);\n\t\t\tcontentItemLength = n;\n\t\t\tcontentPosition = 0;\n\t\t}\n\t};\n\tconst readUInt32LE = () => {\n\t\tensureData(4);\n\t\tconst value = contentItem.readUInt32LE(contentPosition);\n\t\tcontentPosition += 4;\n\t\treturn value;\n\t};\n\tconst readInt32LE = () => {\n\t\tensureData(4);\n\t\tconst value = contentItem.readInt32LE(contentPosition);\n\t\tcontentPosition += 4;\n\t\treturn value;\n\t};\n\tconst readSlice = l => {\n\t\tensureData(l);\n\t\tif (contentPosition === 0 && contentItemLength === l) {\n\t\t\tconst result = contentItem;\n\t\t\tif (contentsIndex + 1 < contents.length) {\n\t\t\t\tnextContent();\n\t\t\t} else {\n\t\t\t\tcontentPosition = l;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tconst result = contentItem.slice(contentPosition, contentPosition + l);\n\t\tcontentPosition += l;\n\t\t// we clone the buffer here to allow the original content to be garbage collected\n\t\treturn l * 2 < contentItem.buffer.byteLength ? Buffer.from(result) : result;\n\t};\n\tconst version = readUInt32LE();\n\tif (version !== VERSION) {\n\t\tthrow new Error(\"Invalid file version\");\n\t}\n\tconst sectionCount = readUInt32LE();\n\tconst lengths = [];\n\tlet lastLengthPositive = false;\n\tfor (let i = 0; i < sectionCount; i++) {\n\t\tconst value = readInt32LE();\n\t\tconst valuePositive = value >= 0;\n\t\tif (lastLengthPositive && valuePositive) {\n\t\t\tlengths[lengths.length - 1] += value;\n\t\t} else {\n\t\t\tlengths.push(value);\n\t\t\tlastLengthPositive = valuePositive;\n\t\t}\n\t}\n\tconst result = [];\n\tfor (let length of lengths) {\n\t\tif (length < 0) {\n\t\t\tconst slice = readSlice(-length);\n\t\t\tconst size = Number(readUInt64LE(slice, 0));\n\t\t\tconst nameBuffer = slice.slice(8);\n\t\t\tconst name = nameBuffer.toString();\n\t\t\tresult.push(\n\t\t\t\tSerializerMiddleware.createLazy(\n\t\t\t\t\tmemoize(() => deserialize(middleware, name, readFile)),\n\t\t\t\t\tmiddleware,\n\t\t\t\t\t{\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tsize\n\t\t\t\t\t},\n\t\t\t\t\tslice\n\t\t\t\t)\n\t\t\t);\n\t\t} else {\n\t\t\tif (contentPosition === contentItemLength) {\n\t\t\t\tnextContent();\n\t\t\t} else if (contentPosition !== 0) {\n\t\t\t\tif (length <= contentItemLength - contentPosition) {\n\t\t\t\t\tresult.push(\n\t\t\t\t\t\tBuffer.from(\n\t\t\t\t\t\t\tcontentItem.buffer,\n\t\t\t\t\t\t\tcontentItem.byteOffset + contentPosition,\n\t\t\t\t\t\t\tlength\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tcontentPosition += length;\n\t\t\t\t\tlength = 0;\n\t\t\t\t} else {\n\t\t\t\t\tconst l = contentItemLength - contentPosition;\n\t\t\t\t\tresult.push(\n\t\t\t\t\t\tBuffer.from(\n\t\t\t\t\t\t\tcontentItem.buffer,\n\t\t\t\t\t\t\tcontentItem.byteOffset + contentPosition,\n\t\t\t\t\t\t\tl\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tlength -= l;\n\t\t\t\t\tcontentPosition = contentItemLength;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (length >= contentItemLength) {\n\t\t\t\t\tresult.push(contentItem);\n\t\t\t\t\tlength -= contentItemLength;\n\t\t\t\t\tcontentPosition = contentItemLength;\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(\n\t\t\t\t\t\tBuffer.from(contentItem.buffer, contentItem.byteOffset, length)\n\t\t\t\t\t);\n\t\t\t\t\tcontentPosition += length;\n\t\t\t\t\tlength = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (length > 0) {\n\t\t\t\tnextContent();\n\t\t\t\tif (length >= contentItemLength) {\n\t\t\t\t\tresult.push(contentItem);\n\t\t\t\t\tlength -= contentItemLength;\n\t\t\t\t\tcontentPosition = contentItemLength;\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(\n\t\t\t\t\t\tBuffer.from(contentItem.buffer, contentItem.byteOffset, length)\n\t\t\t\t\t);\n\t\t\t\t\tcontentPosition += length;\n\t\t\t\t\tlength = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n};\n\n/**\n * @typedef {BufferSerializableType[]} DeserializedType\n * @typedef {true} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\nclass FileMiddleware extends SerializerMiddleware {\n\t/**\n\t * @param {IntermediateFileSystem} fs filesystem\n\t * @param {string | Hash} hashFunction hash function to use\n\t */\n\tconstructor(fs, hashFunction = \"md4\") {\n\t\tsuper();\n\t\tthis.fs = fs;\n\t\tthis._hashFunction = hashFunction;\n\t}\n\t/**\n\t * @param {DeserializedType} data data\n\t * @param {Object} context context object\n\t * @returns {SerializedType|Promise<SerializedType>} serialized data\n\t */\n\tserialize(data, context) {\n\t\tconst { filename, extension = \"\" } = context;\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tmkdirp(this.fs, dirname(this.fs, filename), err => {\n\t\t\t\tif (err) return reject(err);\n\n\t\t\t\t// It's important that we don't touch existing files during serialization\n\t\t\t\t// because serialize may read existing files (when deserializing)\n\t\t\t\tconst allWrittenFiles = new Set();\n\t\t\t\tconst writeFile = async (name, content, size) => {\n\t\t\t\t\tconst file = name\n\t\t\t\t\t\t? join(this.fs, filename, `../${name}${extension}`)\n\t\t\t\t\t\t: filename;\n\t\t\t\t\tawait new Promise((resolve, reject) => {\n\t\t\t\t\t\tlet stream = this.fs.createWriteStream(file + \"_\");\n\t\t\t\t\t\tlet compression;\n\t\t\t\t\t\tif (file.endsWith(\".gz\")) {\n\t\t\t\t\t\t\tcompression = createGzip({\n\t\t\t\t\t\t\t\tchunkSize: COMPRESSION_CHUNK_SIZE,\n\t\t\t\t\t\t\t\tlevel: zConstants.Z_BEST_SPEED\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (file.endsWith(\".br\")) {\n\t\t\t\t\t\t\tcompression = createBrotliCompress({\n\t\t\t\t\t\t\t\tchunkSize: COMPRESSION_CHUNK_SIZE,\n\t\t\t\t\t\t\t\tparams: {\n\t\t\t\t\t\t\t\t\t[zConstants.BROTLI_PARAM_MODE]: zConstants.BROTLI_MODE_TEXT,\n\t\t\t\t\t\t\t\t\t[zConstants.BROTLI_PARAM_QUALITY]: 2,\n\t\t\t\t\t\t\t\t\t[zConstants.BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING]: true,\n\t\t\t\t\t\t\t\t\t[zConstants.BROTLI_PARAM_SIZE_HINT]: size\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (compression) {\n\t\t\t\t\t\t\tpipeline(compression, stream, reject);\n\t\t\t\t\t\t\tstream = compression;\n\t\t\t\t\t\t\tstream.on(\"finish\", () => resolve());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstream.on(\"error\", err => reject(err));\n\t\t\t\t\t\t\tstream.on(\"finish\", () => resolve());\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// split into chunks for WRITE_LIMIT_CHUNK size\n\t\t\t\t\t\tconst chunks = [];\n\t\t\t\t\t\tfor (const b of content) {\n\t\t\t\t\t\t\tif (b.length < WRITE_LIMIT_CHUNK) {\n\t\t\t\t\t\t\t\tchunks.push(b);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < b.length; i += WRITE_LIMIT_CHUNK) {\n\t\t\t\t\t\t\t\t\tchunks.push(b.slice(i, i + WRITE_LIMIT_CHUNK));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst len = chunks.length;\n\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\tconst batchWrite = err => {\n\t\t\t\t\t\t\t// will be handled in \"on\" error handler\n\t\t\t\t\t\t\tif (err) return;\n\n\t\t\t\t\t\t\tif (i === len) {\n\t\t\t\t\t\t\t\tstream.end();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// queue up a batch of chunks up to the write limit\n\t\t\t\t\t\t\t// end is exclusive\n\t\t\t\t\t\t\tlet end = i;\n\t\t\t\t\t\t\tlet sum = chunks[end++].length;\n\t\t\t\t\t\t\twhile (end < len) {\n\t\t\t\t\t\t\t\tsum += chunks[end].length;\n\t\t\t\t\t\t\t\tif (sum > WRITE_LIMIT_TOTAL) break;\n\t\t\t\t\t\t\t\tend++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhile (i < end - 1) {\n\t\t\t\t\t\t\t\tstream.write(chunks[i++]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstream.write(chunks[i++], batchWrite);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbatchWrite();\n\t\t\t\t\t});\n\t\t\t\t\tif (name) allWrittenFiles.add(file);\n\t\t\t\t};\n\n\t\t\t\tresolve(\n\t\t\t\t\tserialize(this, data, false, writeFile, this._hashFunction).then(\n\t\t\t\t\t\tasync ({ backgroundJob }) => {\n\t\t\t\t\t\t\tawait backgroundJob;\n\n\t\t\t\t\t\t\t// Rename the index file to disallow access during inconsistent file state\n\t\t\t\t\t\t\tawait new Promise(resolve =>\n\t\t\t\t\t\t\t\tthis.fs.rename(filename, filename + \".old\", err => {\n\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// update all written files\n\t\t\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\t\t\tArray.from(\n\t\t\t\t\t\t\t\t\tallWrittenFiles,\n\t\t\t\t\t\t\t\t\tfile =>\n\t\t\t\t\t\t\t\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t\t\t\t\t\t\t\tthis.fs.rename(file + \"_\", file, err => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) return reject(err);\n\t\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// As final step automatically update the index file to have a consistent pack again\n\t\t\t\t\t\t\tawait new Promise(resolve => {\n\t\t\t\t\t\t\t\tthis.fs.rename(filename + \"_\", filename, err => {\n\t\t\t\t\t\t\t\t\tif (err) return reject(err);\n\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn /** @type {true} */ (true);\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {SerializedType} data data\n\t * @param {Object} context context object\n\t * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n\t */\n\tdeserialize(data, context) {\n\t\tconst { filename, extension = \"\" } = context;\n\t\tconst readFile = name =>\n\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\tconst file = name\n\t\t\t\t\t? join(this.fs, filename, `../${name}${extension}`)\n\t\t\t\t\t: filename;\n\t\t\t\tthis.fs.stat(file, (err, stats) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlet remaining = /** @type {number} */ (stats.size);\n\t\t\t\t\tlet currentBuffer;\n\t\t\t\t\tlet currentBufferUsed;\n\t\t\t\t\tconst buf = [];\n\t\t\t\t\tlet decompression;\n\t\t\t\t\tif (file.endsWith(\".gz\")) {\n\t\t\t\t\t\tdecompression = createGunzip({\n\t\t\t\t\t\t\tchunkSize: DECOMPRESSION_CHUNK_SIZE\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (file.endsWith(\".br\")) {\n\t\t\t\t\t\tdecompression = createBrotliDecompress({\n\t\t\t\t\t\t\tchunkSize: DECOMPRESSION_CHUNK_SIZE\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (decompression) {\n\t\t\t\t\t\tlet newResolve, newReject;\n\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\tPromise.all([\n\t\t\t\t\t\t\t\tnew Promise((rs, rj) => {\n\t\t\t\t\t\t\t\t\tnewResolve = rs;\n\t\t\t\t\t\t\t\t\tnewReject = rj;\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t\t\t\t\t\tdecompression.on(\"data\", chunk => buf.push(chunk));\n\t\t\t\t\t\t\t\t\tdecompression.on(\"end\", () => resolve());\n\t\t\t\t\t\t\t\t\tdecompression.on(\"error\", err => reject(err));\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t]).then(() => buf)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tresolve = newResolve;\n\t\t\t\t\t\treject = newReject;\n\t\t\t\t\t}\n\t\t\t\t\tthis.fs.open(file, \"r\", (err, fd) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst read = () => {\n\t\t\t\t\t\t\tif (currentBuffer === undefined) {\n\t\t\t\t\t\t\t\tcurrentBuffer = Buffer.allocUnsafeSlow(\n\t\t\t\t\t\t\t\t\tMath.min(\n\t\t\t\t\t\t\t\t\t\tconstants.MAX_LENGTH,\n\t\t\t\t\t\t\t\t\t\tremaining,\n\t\t\t\t\t\t\t\t\t\tdecompression ? DECOMPRESSION_CHUNK_SIZE : Infinity\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentBufferUsed = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet readBuffer = currentBuffer;\n\t\t\t\t\t\t\tlet readOffset = currentBufferUsed;\n\t\t\t\t\t\t\tlet readLength = currentBuffer.length - currentBufferUsed;\n\t\t\t\t\t\t\t// values passed to fs.read must be valid int32 values\n\t\t\t\t\t\t\tif (readOffset > 0x7fffffff) {\n\t\t\t\t\t\t\t\treadBuffer = currentBuffer.slice(readOffset);\n\t\t\t\t\t\t\t\treadOffset = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (readLength > 0x7fffffff) {\n\t\t\t\t\t\t\t\treadLength = 0x7fffffff;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.fs.read(\n\t\t\t\t\t\t\t\tfd,\n\t\t\t\t\t\t\t\treadBuffer,\n\t\t\t\t\t\t\t\treadOffset,\n\t\t\t\t\t\t\t\treadLength,\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t(err, bytesRead) => {\n\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\tthis.fs.close(fd, () => {\n\t\t\t\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcurrentBufferUsed += bytesRead;\n\t\t\t\t\t\t\t\t\tremaining -= bytesRead;\n\t\t\t\t\t\t\t\t\tif (currentBufferUsed === currentBuffer.length) {\n\t\t\t\t\t\t\t\t\t\tif (decompression) {\n\t\t\t\t\t\t\t\t\t\t\tdecompression.write(currentBuffer);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tbuf.push(currentBuffer);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcurrentBuffer = undefined;\n\t\t\t\t\t\t\t\t\t\tif (remaining === 0) {\n\t\t\t\t\t\t\t\t\t\t\tif (decompression) {\n\t\t\t\t\t\t\t\t\t\t\t\tdecompression.end();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tthis.fs.close(fd, err => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tresolve(buf);\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tread();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tread();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\treturn deserialize(this, false, readFile);\n\t}\n}\n\nmodule.exports = FileMiddleware;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}