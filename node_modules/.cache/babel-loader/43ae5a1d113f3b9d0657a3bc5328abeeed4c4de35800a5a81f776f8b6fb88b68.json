{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar glob2regexp = require(\"glob-to-regexp\");\nvar _require = require(\"../OptimizationStages\"),\n  STAGE_DEFAULT = _require.STAGE_DEFAULT;\nvar HarmonyExportImportedSpecifierDependency = require(\"../dependencies/HarmonyExportImportedSpecifierDependency\");\nvar HarmonyImportSpecifierDependency = require(\"../dependencies/HarmonyImportSpecifierDependency\");\nvar formatLocation = require(\"../formatLocation\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\n/**\n * @typedef {Object} ExportInModule\n * @property {Module} module the module\n * @property {string} exportName the name of the export\n * @property {boolean} checked if the export is conditional\n */\n\n/**\n * @typedef {Object} ReexportInfo\n * @property {Map<string, ExportInModule[]>} static\n * @property {Map<Module, Set<string>>} dynamic\n */\n\n/** @type {WeakMap<any, Map<string, RegExp>>} */\nvar globToRegexpCache = new WeakMap();\n\n/**\n * @param {string} glob the pattern\n * @param {Map<string, RegExp>} cache the glob to RegExp cache\n * @returns {RegExp} a regular expression\n */\nvar globToRegexp = function globToRegexp(glob, cache) {\n  var cacheEntry = cache.get(glob);\n  if (cacheEntry !== undefined) return cacheEntry;\n  if (!glob.includes(\"/\")) {\n    glob = \"**/\".concat(glob);\n  }\n  var baseRegexp = glob2regexp(glob, {\n    globstar: true,\n    extended: true\n  });\n  var regexpSource = baseRegexp.source;\n  var regexp = new RegExp(\"^(\\\\./)?\" + regexpSource.slice(1));\n  cache.set(glob, regexp);\n  return regexp;\n};\nvar SideEffectsFlagPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {boolean} analyseSource analyse source code for side effects\n   */\n  function SideEffectsFlagPlugin() {\n    var analyseSource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    _classCallCheck(this, SideEffectsFlagPlugin);\n    this._analyseSource = analyseSource;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  _createClass(SideEffectsFlagPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this = this;\n      var cache = globToRegexpCache.get(compiler.root);\n      if (cache === undefined) {\n        cache = new Map();\n        globToRegexpCache.set(compiler.root, cache);\n      }\n      compiler.hooks.compilation.tap(\"SideEffectsFlagPlugin\", function (compilation, _ref) {\n        var normalModuleFactory = _ref.normalModuleFactory;\n        var moduleGraph = compilation.moduleGraph;\n        normalModuleFactory.hooks.module.tap(\"SideEffectsFlagPlugin\", function (module, data) {\n          var resolveData = data.resourceResolveData;\n          if (resolveData && resolveData.descriptionFileData && resolveData.relativePath) {\n            var sideEffects = resolveData.descriptionFileData.sideEffects;\n            if (sideEffects !== undefined) {\n              if (module.factoryMeta === undefined) {\n                module.factoryMeta = {};\n              }\n              var hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(resolveData.relativePath, sideEffects, cache);\n              module.factoryMeta.sideEffectFree = !hasSideEffects;\n            }\n          }\n          return module;\n        });\n        normalModuleFactory.hooks.module.tap(\"SideEffectsFlagPlugin\", function (module, data) {\n          if (typeof data.settings.sideEffects === \"boolean\") {\n            if (module.factoryMeta === undefined) {\n              module.factoryMeta = {};\n            }\n            module.factoryMeta.sideEffectFree = !data.settings.sideEffects;\n          }\n          return module;\n        });\n        if (_this._analyseSource) {\n          /**\n           * @param {JavascriptParser} parser the parser\n           * @returns {void}\n           */\n          var parserHandler = function parserHandler(parser) {\n            var sideEffectsStatement;\n            parser.hooks.program.tap(\"SideEffectsFlagPlugin\", function () {\n              sideEffectsStatement = undefined;\n            });\n            parser.hooks.statement.tap({\n              name: \"SideEffectsFlagPlugin\",\n              stage: -100\n            }, function (statement) {\n              if (sideEffectsStatement) return;\n              if (parser.scope.topLevelScope !== true) return;\n              switch (statement.type) {\n                case \"ExpressionStatement\":\n                  if (!parser.isPure(statement.expression, statement.range[0])) {\n                    sideEffectsStatement = statement;\n                  }\n                  break;\n                case \"IfStatement\":\n                case \"WhileStatement\":\n                case \"DoWhileStatement\":\n                  if (!parser.isPure(statement.test, statement.range[0])) {\n                    sideEffectsStatement = statement;\n                  }\n                  // statement hook will be called for child statements too\n                  break;\n                case \"ForStatement\":\n                  if (!parser.isPure(statement.init, statement.range[0]) || !parser.isPure(statement.test, statement.init ? statement.init.range[1] : statement.range[0]) || !parser.isPure(statement.update, statement.test ? statement.test.range[1] : statement.init ? statement.init.range[1] : statement.range[0])) {\n                    sideEffectsStatement = statement;\n                  }\n                  // statement hook will be called for child statements too\n                  break;\n                case \"SwitchStatement\":\n                  if (!parser.isPure(statement.discriminant, statement.range[0])) {\n                    sideEffectsStatement = statement;\n                  }\n                  // statement hook will be called for child statements too\n                  break;\n                case \"VariableDeclaration\":\n                case \"ClassDeclaration\":\n                case \"FunctionDeclaration\":\n                  if (!parser.isPure(statement, statement.range[0])) {\n                    sideEffectsStatement = statement;\n                  }\n                  break;\n                case \"ExportNamedDeclaration\":\n                case \"ExportDefaultDeclaration\":\n                  if (!parser.isPure(statement.declaration, statement.range[0])) {\n                    sideEffectsStatement = statement;\n                  }\n                  break;\n                case \"LabeledStatement\":\n                case \"BlockStatement\":\n                  // statement hook will be called for child statements too\n                  break;\n                case \"EmptyStatement\":\n                  break;\n                case \"ExportAllDeclaration\":\n                case \"ImportDeclaration\":\n                  // imports will be handled by the dependencies\n                  break;\n                default:\n                  sideEffectsStatement = statement;\n                  break;\n              }\n            });\n            parser.hooks.finish.tap(\"SideEffectsFlagPlugin\", function () {\n              if (sideEffectsStatement === undefined) {\n                parser.state.module.buildMeta.sideEffectFree = true;\n              } else {\n                var _sideEffectsStatement = sideEffectsStatement,\n                  loc = _sideEffectsStatement.loc,\n                  type = _sideEffectsStatement.type;\n                moduleGraph.getOptimizationBailout(parser.state.module).push(function () {\n                  return \"Statement (\".concat(type, \") with side effects in source code at \").concat(formatLocation(loc));\n                });\n              }\n            });\n          };\n          for (var _i = 0, _arr = [\"javascript/auto\", \"javascript/esm\", \"javascript/dynamic\"]; _i < _arr.length; _i++) {\n            var key = _arr[_i];\n            normalModuleFactory.hooks.parser.for(key).tap(\"SideEffectsFlagPlugin\", parserHandler);\n          }\n        }\n        compilation.hooks.optimizeDependencies.tap({\n          name: \"SideEffectsFlagPlugin\",\n          stage: STAGE_DEFAULT\n        }, function (modules) {\n          var logger = compilation.getLogger(\"webpack.SideEffectsFlagPlugin\");\n          logger.time(\"update dependencies\");\n          var _iterator = _createForOfIteratorHelper(modules),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _module = _step.value;\n              if (_module.getSideEffectsConnectionState(moduleGraph) === false) {\n                var exportsInfo = moduleGraph.getExportsInfo(_module);\n                var _iterator2 = _createForOfIteratorHelper(moduleGraph.getIncomingConnections(_module)),\n                  _step2;\n                try {\n                  var _loop = function _loop() {\n                    var connection = _step2.value;\n                    var dep = connection.dependency;\n                    var isReexport;\n                    if ((isReexport = dep instanceof HarmonyExportImportedSpecifierDependency) || dep instanceof HarmonyImportSpecifierDependency && !dep.namespaceObjectAsContext) {\n                      // TODO improve for export *\n                      if (isReexport && dep.name) {\n                        var exportInfo = moduleGraph.getExportInfo(connection.originModule, dep.name);\n                        exportInfo.moveTarget(moduleGraph, function (_ref2) {\n                          var module = _ref2.module;\n                          return module.getSideEffectsConnectionState(moduleGraph) === false;\n                        }, function (_ref3) {\n                          var newModule = _ref3.module,\n                            exportName = _ref3.export;\n                          moduleGraph.updateModule(dep, newModule);\n                          moduleGraph.addExplanation(dep, \"(skipped side-effect-free modules)\");\n                          var ids = dep.getIds(moduleGraph);\n                          dep.setIds(moduleGraph, exportName ? [].concat(_toConsumableArray(exportName), _toConsumableArray(ids.slice(1))) : ids.slice(1));\n                          return moduleGraph.getConnection(dep);\n                        });\n                        return \"continue\";\n                      }\n                      // TODO improve for nested imports\n                      var ids = dep.getIds(moduleGraph);\n                      if (ids.length > 0) {\n                        var _exportInfo = exportsInfo.getExportInfo(ids[0]);\n                        var target = _exportInfo.getTarget(moduleGraph, function (_ref4) {\n                          var module = _ref4.module;\n                          return module.getSideEffectsConnectionState(moduleGraph) === false;\n                        });\n                        if (!target) return \"continue\";\n                        moduleGraph.updateModule(dep, target.module);\n                        moduleGraph.addExplanation(dep, \"(skipped side-effect-free modules)\");\n                        dep.setIds(moduleGraph, target.export ? [].concat(_toConsumableArray(target.export), _toConsumableArray(ids.slice(1))) : ids.slice(1));\n                      }\n                    }\n                  };\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    var _ret = _loop();\n                    if (_ret === \"continue\") continue;\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          logger.timeEnd(\"update dependencies\");\n        });\n      });\n    }\n  }], [{\n    key: \"moduleHasSideEffects\",\n    value: function moduleHasSideEffects(moduleName, flagValue, cache) {\n      switch (typeof flagValue) {\n        case \"undefined\":\n          return true;\n        case \"boolean\":\n          return flagValue;\n        case \"string\":\n          return globToRegexp(flagValue, cache).test(moduleName);\n        case \"object\":\n          return flagValue.some(function (glob) {\n            return SideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob, cache);\n          });\n      }\n    }\n  }]);\n  return SideEffectsFlagPlugin;\n}();\nmodule.exports = SideEffectsFlagPlugin;","map":{"version":3,"names":["glob2regexp","require","STAGE_DEFAULT","HarmonyExportImportedSpecifierDependency","HarmonyImportSpecifierDependency","formatLocation","globToRegexpCache","WeakMap","globToRegexp","glob","cache","cacheEntry","get","undefined","includes","baseRegexp","globstar","extended","regexpSource","source","regexp","RegExp","slice","set","SideEffectsFlagPlugin","analyseSource","_analyseSource","compiler","root","Map","hooks","compilation","tap","normalModuleFactory","moduleGraph","module","data","resolveData","resourceResolveData","descriptionFileData","relativePath","sideEffects","factoryMeta","hasSideEffects","moduleHasSideEffects","sideEffectFree","settings","parserHandler","parser","sideEffectsStatement","program","statement","name","stage","scope","topLevelScope","type","isPure","expression","range","test","init","update","discriminant","declaration","finish","state","buildMeta","loc","getOptimizationBailout","push","key","for","optimizeDependencies","modules","logger","getLogger","time","getSideEffectsConnectionState","exportsInfo","getExportsInfo","getIncomingConnections","connection","dep","dependency","isReexport","namespaceObjectAsContext","exportInfo","getExportInfo","originModule","moveTarget","newModule","exportName","export","updateModule","addExplanation","ids","getIds","setIds","getConnection","length","target","getTarget","timeEnd","moduleName","flagValue","some","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/optimize/SideEffectsFlagPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst glob2regexp = require(\"glob-to-regexp\");\nconst { STAGE_DEFAULT } = require(\"../OptimizationStages\");\nconst HarmonyExportImportedSpecifierDependency = require(\"../dependencies/HarmonyExportImportedSpecifierDependency\");\nconst HarmonyImportSpecifierDependency = require(\"../dependencies/HarmonyImportSpecifierDependency\");\nconst formatLocation = require(\"../formatLocation\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\n/**\n * @typedef {Object} ExportInModule\n * @property {Module} module the module\n * @property {string} exportName the name of the export\n * @property {boolean} checked if the export is conditional\n */\n\n/**\n * @typedef {Object} ReexportInfo\n * @property {Map<string, ExportInModule[]>} static\n * @property {Map<Module, Set<string>>} dynamic\n */\n\n/** @type {WeakMap<any, Map<string, RegExp>>} */\nconst globToRegexpCache = new WeakMap();\n\n/**\n * @param {string} glob the pattern\n * @param {Map<string, RegExp>} cache the glob to RegExp cache\n * @returns {RegExp} a regular expression\n */\nconst globToRegexp = (glob, cache) => {\n\tconst cacheEntry = cache.get(glob);\n\tif (cacheEntry !== undefined) return cacheEntry;\n\tif (!glob.includes(\"/\")) {\n\t\tglob = `**/${glob}`;\n\t}\n\tconst baseRegexp = glob2regexp(glob, { globstar: true, extended: true });\n\tconst regexpSource = baseRegexp.source;\n\tconst regexp = new RegExp(\"^(\\\\./)?\" + regexpSource.slice(1));\n\tcache.set(glob, regexp);\n\treturn regexp;\n};\n\nclass SideEffectsFlagPlugin {\n\t/**\n\t * @param {boolean} analyseSource analyse source code for side effects\n\t */\n\tconstructor(analyseSource = true) {\n\t\tthis._analyseSource = analyseSource;\n\t}\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tlet cache = globToRegexpCache.get(compiler.root);\n\t\tif (cache === undefined) {\n\t\t\tcache = new Map();\n\t\t\tglobToRegexpCache.set(compiler.root, cache);\n\t\t}\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"SideEffectsFlagPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\t\tnormalModuleFactory.hooks.module.tap(\n\t\t\t\t\t\"SideEffectsFlagPlugin\",\n\t\t\t\t\t(module, data) => {\n\t\t\t\t\t\tconst resolveData = data.resourceResolveData;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tresolveData &&\n\t\t\t\t\t\t\tresolveData.descriptionFileData &&\n\t\t\t\t\t\t\tresolveData.relativePath\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst sideEffects = resolveData.descriptionFileData.sideEffects;\n\t\t\t\t\t\t\tif (sideEffects !== undefined) {\n\t\t\t\t\t\t\t\tif (module.factoryMeta === undefined) {\n\t\t\t\t\t\t\t\t\tmodule.factoryMeta = {};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst hasSideEffects =\n\t\t\t\t\t\t\t\t\tSideEffectsFlagPlugin.moduleHasSideEffects(\n\t\t\t\t\t\t\t\t\t\tresolveData.relativePath,\n\t\t\t\t\t\t\t\t\t\tsideEffects,\n\t\t\t\t\t\t\t\t\t\tcache\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tmodule.factoryMeta.sideEffectFree = !hasSideEffects;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn module;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tnormalModuleFactory.hooks.module.tap(\n\t\t\t\t\t\"SideEffectsFlagPlugin\",\n\t\t\t\t\t(module, data) => {\n\t\t\t\t\t\tif (typeof data.settings.sideEffects === \"boolean\") {\n\t\t\t\t\t\t\tif (module.factoryMeta === undefined) {\n\t\t\t\t\t\t\t\tmodule.factoryMeta = {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmodule.factoryMeta.sideEffectFree = !data.settings.sideEffects;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn module;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tif (this._analyseSource) {\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {JavascriptParser} parser the parser\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst parserHandler = parser => {\n\t\t\t\t\t\tlet sideEffectsStatement;\n\t\t\t\t\t\tparser.hooks.program.tap(\"SideEffectsFlagPlugin\", () => {\n\t\t\t\t\t\t\tsideEffectsStatement = undefined;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.statement.tap(\n\t\t\t\t\t\t\t{ name: \"SideEffectsFlagPlugin\", stage: -100 },\n\t\t\t\t\t\t\tstatement => {\n\t\t\t\t\t\t\t\tif (sideEffectsStatement) return;\n\t\t\t\t\t\t\t\tif (parser.scope.topLevelScope !== true) return;\n\t\t\t\t\t\t\t\tswitch (statement.type) {\n\t\t\t\t\t\t\t\t\tcase \"ExpressionStatement\":\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(statement.expression, statement.range[0])\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"IfStatement\":\n\t\t\t\t\t\t\t\t\tcase \"WhileStatement\":\n\t\t\t\t\t\t\t\t\tcase \"DoWhileStatement\":\n\t\t\t\t\t\t\t\t\t\tif (!parser.isPure(statement.test, statement.range[0])) {\n\t\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// statement hook will be called for child statements too\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"ForStatement\":\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(statement.init, statement.range[0]) ||\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(\n\t\t\t\t\t\t\t\t\t\t\t\tstatement.test,\n\t\t\t\t\t\t\t\t\t\t\t\tstatement.init\n\t\t\t\t\t\t\t\t\t\t\t\t\t? statement.init.range[1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t: statement.range[0]\n\t\t\t\t\t\t\t\t\t\t\t) ||\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(\n\t\t\t\t\t\t\t\t\t\t\t\tstatement.update,\n\t\t\t\t\t\t\t\t\t\t\t\tstatement.test\n\t\t\t\t\t\t\t\t\t\t\t\t\t? statement.test.range[1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t: statement.init\n\t\t\t\t\t\t\t\t\t\t\t\t\t? statement.init.range[1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t: statement.range[0]\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// statement hook will be called for child statements too\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"SwitchStatement\":\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(statement.discriminant, statement.range[0])\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// statement hook will be called for child statements too\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"VariableDeclaration\":\n\t\t\t\t\t\t\t\t\tcase \"ClassDeclaration\":\n\t\t\t\t\t\t\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\t\t\t\t\t\t\tif (!parser.isPure(statement, statement.range[0])) {\n\t\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\t\t\t\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!parser.isPure(statement.declaration, statement.range[0])\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"LabeledStatement\":\n\t\t\t\t\t\t\t\t\tcase \"BlockStatement\":\n\t\t\t\t\t\t\t\t\t\t// statement hook will be called for child statements too\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"EmptyStatement\":\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase \"ExportAllDeclaration\":\n\t\t\t\t\t\t\t\t\tcase \"ImportDeclaration\":\n\t\t\t\t\t\t\t\t\t\t// imports will be handled by the dependencies\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tsideEffectsStatement = statement;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\tparser.hooks.finish.tap(\"SideEffectsFlagPlugin\", () => {\n\t\t\t\t\t\t\tif (sideEffectsStatement === undefined) {\n\t\t\t\t\t\t\t\tparser.state.module.buildMeta.sideEffectFree = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst { loc, type } = sideEffectsStatement;\n\t\t\t\t\t\t\t\tmoduleGraph\n\t\t\t\t\t\t\t\t\t.getOptimizationBailout(parser.state.module)\n\t\t\t\t\t\t\t\t\t.push(\n\t\t\t\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\t\t\t\t`Statement (${type}) with side effects in source code at ${formatLocation(\n\t\t\t\t\t\t\t\t\t\t\t\tloc\n\t\t\t\t\t\t\t\t\t\t\t)}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t\tfor (const key of [\n\t\t\t\t\t\t\"javascript/auto\",\n\t\t\t\t\t\t\"javascript/esm\",\n\t\t\t\t\t\t\"javascript/dynamic\"\n\t\t\t\t\t]) {\n\t\t\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\"SideEffectsFlagPlugin\", parserHandler);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcompilation.hooks.optimizeDependencies.tap(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"SideEffectsFlagPlugin\",\n\t\t\t\t\t\tstage: STAGE_DEFAULT\n\t\t\t\t\t},\n\t\t\t\t\tmodules => {\n\t\t\t\t\t\tconst logger = compilation.getLogger(\n\t\t\t\t\t\t\t\"webpack.SideEffectsFlagPlugin\"\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tlogger.time(\"update dependencies\");\n\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\tif (module.getSideEffectsConnectionState(moduleGraph) === false) {\n\t\t\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\t\t\tfor (const connection of moduleGraph.getIncomingConnections(\n\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\t\tconst dep = connection.dependency;\n\t\t\t\t\t\t\t\t\tlet isReexport;\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t(isReexport =\n\t\t\t\t\t\t\t\t\t\t\tdep instanceof\n\t\t\t\t\t\t\t\t\t\t\tHarmonyExportImportedSpecifierDependency) ||\n\t\t\t\t\t\t\t\t\t\t(dep instanceof HarmonyImportSpecifierDependency &&\n\t\t\t\t\t\t\t\t\t\t\t!dep.namespaceObjectAsContext)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t// TODO improve for export *\n\t\t\t\t\t\t\t\t\t\tif (isReexport && dep.name) {\n\t\t\t\t\t\t\t\t\t\t\tconst exportInfo = moduleGraph.getExportInfo(\n\t\t\t\t\t\t\t\t\t\t\t\tconnection.originModule,\n\t\t\t\t\t\t\t\t\t\t\t\tdep.name\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\texportInfo.moveTarget(\n\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\t\t\t\t\t\t\t({ module }) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodule.getSideEffectsConnectionState(moduleGraph) ===\n\t\t\t\t\t\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\t\t\t\t\t({ module: newModule, export: exportName }) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph.updateModule(dep, newModule);\n\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph.addExplanation(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"(skipped side-effect-free modules)\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst ids = dep.getIds(moduleGraph);\n\t\t\t\t\t\t\t\t\t\t\t\t\tdep.setIds(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\texportName\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? [...exportName, ...ids.slice(1)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: ids.slice(1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn moduleGraph.getConnection(dep);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t// TODO improve for nested imports\n\t\t\t\t\t\t\t\t\t\tconst ids = dep.getIds(moduleGraph);\n\t\t\t\t\t\t\t\t\t\tif (ids.length > 0) {\n\t\t\t\t\t\t\t\t\t\t\tconst exportInfo = exportsInfo.getExportInfo(ids[0]);\n\t\t\t\t\t\t\t\t\t\t\tconst target = exportInfo.getTarget(\n\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\t\t\t\t\t\t\t({ module }) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodule.getSideEffectsConnectionState(moduleGraph) ===\n\t\t\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tif (!target) continue;\n\n\t\t\t\t\t\t\t\t\t\t\tmoduleGraph.updateModule(dep, target.module);\n\t\t\t\t\t\t\t\t\t\t\tmoduleGraph.addExplanation(\n\t\t\t\t\t\t\t\t\t\t\t\tdep,\n\t\t\t\t\t\t\t\t\t\t\t\t\"(skipped side-effect-free modules)\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tdep.setIds(\n\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\t\t\t\t\t\t\ttarget.export\n\t\t\t\t\t\t\t\t\t\t\t\t\t? [...target.export, ...ids.slice(1)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t: ids.slice(1)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlogger.timeEnd(\"update dependencies\");\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\tstatic moduleHasSideEffects(moduleName, flagValue, cache) {\n\t\tswitch (typeof flagValue) {\n\t\t\tcase \"undefined\":\n\t\t\t\treturn true;\n\t\t\tcase \"boolean\":\n\t\t\t\treturn flagValue;\n\t\t\tcase \"string\":\n\t\t\t\treturn globToRegexp(flagValue, cache).test(moduleName);\n\t\t\tcase \"object\":\n\t\t\t\treturn flagValue.some(glob =>\n\t\t\t\t\tSideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob, cache)\n\t\t\t\t);\n\t\t}\n\t}\n}\nmodule.exports = SideEffectsFlagPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}