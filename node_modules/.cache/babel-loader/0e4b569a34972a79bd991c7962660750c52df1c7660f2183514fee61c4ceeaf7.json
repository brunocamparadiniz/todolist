{"ast":null,"code":"\"use strict\";\n\n/** @typedef {import(\"@jridgewell/trace-mapping\").SourceMapInput} SourceMapInput */\n\n/** @typedef {import(\"terser\").FormatOptions} TerserFormatOptions */\n\n/** @typedef {import(\"terser\").MinifyOptions} TerserOptions */\n\n/** @typedef {import(\"terser\").CompressOptions} TerserCompressOptions */\n\n/** @typedef {import(\"terser\").ECMA} TerserECMA */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsOptions} ExtractCommentsOptions */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsFunction} ExtractCommentsFunction */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsCondition} ExtractCommentsCondition */\n\n/** @typedef {import(\"./index.js\").Input} Input */\n\n/** @typedef {import(\"./index.js\").MinimizedResult} MinimizedResult */\n\n/** @typedef {import(\"./index.js\").PredefinedOptions} PredefinedOptions */\n\n/** @typedef {import(\"./index.js\").CustomOptions} CustomOptions */\n\n/**\n * @typedef {Array<string>} ExtractedComments\n */\nvar _regeneratorRuntime = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _defineProperty = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _objectSpread = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _asyncToGenerator = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar notSettled = Symbol(\"not-settled\");\n/**\n * @template T\n * @typedef {() => Promise<T>} Task\n */\n\n/**\n * Run tasks with limited concurency.\n * @template T\n * @param {number} limit - Limit of tasks that run at once.\n * @param {Task<T>[]} tasks - List of tasks to run.\n * @returns {Promise<T[]>} A promise that fulfills to an array of the results\n */\n\nfunction throttleAll(limit, tasks) {\n  if (!Number.isInteger(limit) || limit < 1) {\n    throw new TypeError(\"Expected `limit` to be a finite number > 0, got `\".concat(limit, \"` (\").concat(typeof limit, \")\"));\n  }\n  if (!Array.isArray(tasks) || !tasks.every(function (task) {\n    return typeof task === \"function\";\n  })) {\n    throw new TypeError(\"Expected `tasks` to be a list of functions returning a promise\");\n  }\n  return new Promise(function (resolve, reject) {\n    var result = Array(tasks.length).fill(notSettled);\n    var entries = tasks.entries();\n    var next = function next() {\n      var _entries$next = entries.next(),\n        done = _entries$next.done,\n        value = _entries$next.value;\n      if (done) {\n        var isLast = !result.includes(notSettled);\n        if (isLast) resolve( /** @type{T[]} **/\n        result);\n        return;\n      }\n      var _value = _slicedToArray(value, 2),\n        index = _value[0],\n        task = _value[1];\n      /**\n       * @param {T} x\n       */\n\n      var onFulfilled = function onFulfilled(x) {\n        result[index] = x;\n        next();\n      };\n      task().then(onFulfilled, reject);\n    };\n    Array(limit).fill(0).forEach(next);\n  });\n}\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {SourceMapInput | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @param {ExtractCommentsOptions | undefined} extractComments\n * @return {Promise<MinimizedResult>}\n */\nfunction terserMinify(_x, _x2, _x3, _x4) {\n  return _terserMinify.apply(this, arguments);\n}\n/**\n * @returns {string | undefined}\n */\nfunction _terserMinify() {\n  _terserMinify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(input, sourceMap, minimizerOptions, extractComments) {\n    var isObject, buildComments, buildTerserOptions, _require, minify, terserOptions, extractedComments, _Object$entries, _Object$entries2, _Object$entries2$, filename, code, result;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          /**\n           * @param {any} value\n           * @returns {boolean}\n           */\n          isObject = function isObject(value) {\n            var type = typeof value;\n            return value != null && (type === \"object\" || type === \"function\");\n          };\n          /**\n           * @param {TerserOptions & { sourceMap: undefined } & ({ output: TerserFormatOptions & { beautify: boolean } } | { format: TerserFormatOptions & { beautify: boolean } })} terserOptions\n           * @param {ExtractedComments} extractedComments\n           * @returns {ExtractCommentsFunction}\n           */\n          buildComments = function buildComments(terserOptions, extractedComments) {\n            /** @type {{ [index: string]: ExtractCommentsCondition }} */\n            var condition = {};\n            var comments;\n            if (terserOptions.format) {\n              comments = terserOptions.format.comments;\n            } else if (terserOptions.output) {\n              comments = terserOptions.output.comments;\n            }\n            condition.preserve = typeof comments !== \"undefined\" ? comments : false;\n            if (typeof extractComments === \"boolean\" && extractComments) {\n              condition.extract = \"some\";\n            } else if (typeof extractComments === \"string\" || extractComments instanceof RegExp) {\n              condition.extract = extractComments;\n            } else if (typeof extractComments === \"function\") {\n              condition.extract = extractComments;\n            } else if (extractComments && isObject(extractComments)) {\n              condition.extract = typeof extractComments.condition === \"boolean\" && extractComments.condition ? \"some\" : typeof extractComments.condition !== \"undefined\" ? extractComments.condition : \"some\";\n            } else {\n              // No extract\n              // Preserve using \"commentsOpts\" or \"some\"\n              condition.preserve = typeof comments !== \"undefined\" ? comments : \"some\";\n              condition.extract = false;\n            } // Ensure that both conditions are functions\n\n            [\"preserve\", \"extract\"].forEach(function (key) {\n              /** @type {undefined | string} */\n              var regexStr;\n              /** @type {undefined | RegExp} */\n\n              var regex;\n              switch (typeof condition[key]) {\n                case \"boolean\":\n                  condition[key] = condition[key] ? function () {\n                    return true;\n                  } : function () {\n                    return false;\n                  };\n                  break;\n                case \"function\":\n                  break;\n                case \"string\":\n                  if (condition[key] === \"all\") {\n                    condition[key] = function () {\n                      return true;\n                    };\n                    break;\n                  }\n                  if (condition[key] === \"some\") {\n                    condition[key] = /** @type {ExtractCommentsFunction} */\n                    function (astNode, comment) {\n                      return (comment.type === \"comment2\" || comment.type === \"comment1\") && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n                    };\n                    break;\n                  }\n                  regexStr = /** @type {string} */\n                  condition[key];\n                  condition[key] = /** @type {ExtractCommentsFunction} */\n                  function (astNode, comment) {\n                    return new RegExp( /** @type {string} */\n                    regexStr).test(comment.value);\n                  };\n                  break;\n                default:\n                  regex = /** @type {RegExp} */\n                  condition[key];\n                  condition[key] = /** @type {ExtractCommentsFunction} */\n                  function (astNode, comment) {\n                    return (/** @type {RegExp} */\n                      regex.test(comment.value)\n                    );\n                  };\n              }\n            }); // Redefine the comments function to extract and preserve\n            // comments according to the two conditions\n\n            return function (astNode, comment) {\n              if ( /** @type {{ extract: ExtractCommentsFunction }} */\n              condition.extract(astNode, comment)) {\n                var commentText = comment.type === \"comment2\" ? \"/*\".concat(comment.value, \"*/\") : \"//\".concat(comment.value); // Don't include duplicate comments\n\n                if (!extractedComments.includes(commentText)) {\n                  extractedComments.push(commentText);\n                }\n              }\n              return (/** @type {{ preserve: ExtractCommentsFunction }} */\n                condition.preserve(astNode, comment)\n              );\n            };\n          };\n          /**\n           * @param {PredefinedOptions & TerserOptions} [terserOptions={}]\n           * @returns {TerserOptions & { sourceMap: undefined } & { compress: TerserCompressOptions } & ({ output: TerserFormatOptions & { beautify: boolean } } | { format: TerserFormatOptions & { beautify: boolean } })}\n           */\n          buildTerserOptions = function buildTerserOptions() {\n            var terserOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n            return _objectSpread(_objectSpread(_objectSpread({}, terserOptions), {}, {\n              compress: typeof terserOptions.compress === \"boolean\" ? terserOptions.compress ? {} : false : _objectSpread({}, terserOptions.compress),\n              // ecma: terserOptions.ecma,\n              // ie8: terserOptions.ie8,\n              // keep_classnames: terserOptions.keep_classnames,\n              // keep_fnames: terserOptions.keep_fnames,\n              mangle: terserOptions.mangle == null ? true : typeof terserOptions.mangle === \"boolean\" ? terserOptions.mangle : _objectSpread({}, terserOptions.mangle)\n            }, terserOptions.format ? {\n              format: _objectSpread({\n                beautify: false\n              }, terserOptions.format)\n            } : {\n              output: _objectSpread({\n                beautify: false\n              }, terserOptions.output)\n            }), {}, {\n              parse: _objectSpread({}, terserOptions.parse),\n              // safari10: terserOptions.safari10,\n              // Ignoring sourceMap from options\n              // eslint-disable-next-line no-undefined\n              sourceMap: undefined // toplevel: terserOptions.toplevel\n            });\n          }; // eslint-disable-next-line global-require\n          _require = require(\"terser\"), minify = _require.minify; // Copy `terser` options\n          terserOptions = buildTerserOptions(minimizerOptions); // Let terser generate a SourceMap\n          if (sourceMap) {\n            // @ts-ignore\n            terserOptions.sourceMap = {\n              asObject: true\n            };\n          }\n          /** @type {ExtractedComments} */\n          extractedComments = [];\n          if (terserOptions.output) {\n            terserOptions.output.comments = buildComments(terserOptions, extractedComments);\n          } else if (terserOptions.format) {\n            terserOptions.format.comments = buildComments(terserOptions, extractedComments);\n          }\n          if (terserOptions.compress) {\n            // More optimizations\n            if (typeof terserOptions.compress.ecma === \"undefined\") {\n              terserOptions.compress.ecma = terserOptions.ecma;\n            } // https://github.com/webpack/webpack/issues/16135\n\n            if (terserOptions.ecma === 5 && typeof terserOptions.compress.arrows === \"undefined\") {\n              terserOptions.compress.arrows = false;\n            }\n          }\n          _Object$entries = Object.entries(input), _Object$entries2 = _slicedToArray(_Object$entries, 1), _Object$entries2$ = _slicedToArray(_Object$entries2[0], 2), filename = _Object$entries2$[0], code = _Object$entries2$[1];\n          _context.next = 12;\n          return minify(_defineProperty({}, filename, code), terserOptions);\n        case 12:\n          result = _context.sent;\n          return _context.abrupt(\"return\", {\n            code: /** @type {string} **/\n            result.code,\n            // @ts-ignore\n            // eslint-disable-next-line no-undefined\n            map: result.map ? /** @type {SourceMapInput} **/\n            result.map : undefined,\n            extractedComments: extractedComments\n          });\n        case 14:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _terserMinify.apply(this, arguments);\n}\nterserMinify.getMinimizerVersion = function () {\n  var packageJson;\n  try {\n    // eslint-disable-next-line global-require\n    packageJson = require(\"terser/package.json\");\n  } catch (error) {// Ignore\n  }\n  return packageJson && packageJson.version;\n};\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {SourceMapInput | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @param {ExtractCommentsOptions | undefined} extractComments\n * @return {Promise<MinimizedResult>}\n */\nfunction uglifyJsMinify(_x5, _x6, _x7, _x8) {\n  return _uglifyJsMinify.apply(this, arguments);\n}\n/**\n * @returns {string | undefined}\n */\nfunction _uglifyJsMinify() {\n  _uglifyJsMinify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(input, sourceMap, minimizerOptions, extractComments) {\n    var isObject, buildComments, buildUglifyJsOptions, _require2, minify, uglifyJsOptions, extractedComments, _Object$entries3, _Object$entries4, _Object$entries4$, filename, code, result;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          /**\n           * @param {any} value\n           * @returns {boolean}\n           */\n          isObject = function isObject(value) {\n            var type = typeof value;\n            return value != null && (type === \"object\" || type === \"function\");\n          };\n          /**\n           * @param {import(\"uglify-js\").MinifyOptions & { sourceMap: undefined } & { output: import(\"uglify-js\").OutputOptions & { beautify: boolean }}} uglifyJsOptions\n           * @param {ExtractedComments} extractedComments\n           * @returns {ExtractCommentsFunction}\n           */\n          buildComments = function buildComments(uglifyJsOptions, extractedComments) {\n            /** @type {{ [index: string]: ExtractCommentsCondition }} */\n            var condition = {};\n            var comments = uglifyJsOptions.output.comments;\n            condition.preserve = typeof comments !== \"undefined\" ? comments : false;\n            if (typeof extractComments === \"boolean\" && extractComments) {\n              condition.extract = \"some\";\n            } else if (typeof extractComments === \"string\" || extractComments instanceof RegExp) {\n              condition.extract = extractComments;\n            } else if (typeof extractComments === \"function\") {\n              condition.extract = extractComments;\n            } else if (extractComments && isObject(extractComments)) {\n              condition.extract = typeof extractComments.condition === \"boolean\" && extractComments.condition ? \"some\" : typeof extractComments.condition !== \"undefined\" ? extractComments.condition : \"some\";\n            } else {\n              // No extract\n              // Preserve using \"commentsOpts\" or \"some\"\n              condition.preserve = typeof comments !== \"undefined\" ? comments : \"some\";\n              condition.extract = false;\n            } // Ensure that both conditions are functions\n\n            [\"preserve\", \"extract\"].forEach(function (key) {\n              /** @type {undefined | string} */\n              var regexStr;\n              /** @type {undefined | RegExp} */\n\n              var regex;\n              switch (typeof condition[key]) {\n                case \"boolean\":\n                  condition[key] = condition[key] ? function () {\n                    return true;\n                  } : function () {\n                    return false;\n                  };\n                  break;\n                case \"function\":\n                  break;\n                case \"string\":\n                  if (condition[key] === \"all\") {\n                    condition[key] = function () {\n                      return true;\n                    };\n                    break;\n                  }\n                  if (condition[key] === \"some\") {\n                    condition[key] = /** @type {ExtractCommentsFunction} */\n                    function (astNode, comment) {\n                      return (comment.type === \"comment2\" || comment.type === \"comment1\") && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n                    };\n                    break;\n                  }\n                  regexStr = /** @type {string} */\n                  condition[key];\n                  condition[key] = /** @type {ExtractCommentsFunction} */\n                  function (astNode, comment) {\n                    return new RegExp( /** @type {string} */\n                    regexStr).test(comment.value);\n                  };\n                  break;\n                default:\n                  regex = /** @type {RegExp} */\n                  condition[key];\n                  condition[key] = /** @type {ExtractCommentsFunction} */\n                  function (astNode, comment) {\n                    return (/** @type {RegExp} */\n                      regex.test(comment.value)\n                    );\n                  };\n              }\n            }); // Redefine the comments function to extract and preserve\n            // comments according to the two conditions\n\n            return function (astNode, comment) {\n              if ( /** @type {{ extract: ExtractCommentsFunction }} */\n              condition.extract(astNode, comment)) {\n                var commentText = comment.type === \"comment2\" ? \"/*\".concat(comment.value, \"*/\") : \"//\".concat(comment.value); // Don't include duplicate comments\n\n                if (!extractedComments.includes(commentText)) {\n                  extractedComments.push(commentText);\n                }\n              }\n              return (/** @type {{ preserve: ExtractCommentsFunction }} */\n                condition.preserve(astNode, comment)\n              );\n            };\n          };\n          /**\n           * @param {PredefinedOptions & import(\"uglify-js\").MinifyOptions} [uglifyJsOptions={}]\n           * @returns {import(\"uglify-js\").MinifyOptions & { sourceMap: undefined } & { output: import(\"uglify-js\").OutputOptions & { beautify: boolean }}}\n           */\n          buildUglifyJsOptions = function buildUglifyJsOptions() {\n            var uglifyJsOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            // eslint-disable-next-line no-param-reassign\n            delete minimizerOptions.ecma; // eslint-disable-next-line no-param-reassign\n\n            delete minimizerOptions.module; // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n\n            return _objectSpread(_objectSpread({}, uglifyJsOptions), {}, {\n              // warnings: uglifyJsOptions.warnings,\n              parse: _objectSpread({}, uglifyJsOptions.parse),\n              compress: typeof uglifyJsOptions.compress === \"boolean\" ? uglifyJsOptions.compress : _objectSpread({}, uglifyJsOptions.compress),\n              mangle: uglifyJsOptions.mangle == null ? true : typeof uglifyJsOptions.mangle === \"boolean\" ? uglifyJsOptions.mangle : _objectSpread({}, uglifyJsOptions.mangle),\n              output: _objectSpread({\n                beautify: false\n              }, uglifyJsOptions.output),\n              // Ignoring sourceMap from options\n              // eslint-disable-next-line no-undefined\n              sourceMap: undefined // toplevel: uglifyJsOptions.toplevel\n              // nameCache: { ...uglifyJsOptions.toplevel },\n              // ie8: uglifyJsOptions.ie8,\n              // keep_fnames: uglifyJsOptions.keep_fnames,\n            });\n          }; // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n          _require2 = require(\"uglify-js\"), minify = _require2.minify; // Copy `uglify-js` options\n          uglifyJsOptions = buildUglifyJsOptions(minimizerOptions); // Let terser generate a SourceMap\n          if (sourceMap) {\n            // @ts-ignore\n            uglifyJsOptions.sourceMap = true;\n          }\n          /** @type {ExtractedComments} */\n          extractedComments = []; // @ts-ignore\n          uglifyJsOptions.output.comments = buildComments(uglifyJsOptions, extractedComments);\n          _Object$entries3 = Object.entries(input), _Object$entries4 = _slicedToArray(_Object$entries3, 1), _Object$entries4$ = _slicedToArray(_Object$entries4[0], 2), filename = _Object$entries4$[0], code = _Object$entries4$[1];\n          _context2.next = 11;\n          return minify(_defineProperty({}, filename, code), uglifyJsOptions);\n        case 11:\n          result = _context2.sent;\n          return _context2.abrupt(\"return\", {\n            code: result.code,\n            // eslint-disable-next-line no-undefined\n            map: result.map ? JSON.parse(result.map) : undefined,\n            errors: result.error ? [result.error] : [],\n            warnings: result.warnings || [],\n            extractedComments: extractedComments\n          });\n        case 13:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _uglifyJsMinify.apply(this, arguments);\n}\nuglifyJsMinify.getMinimizerVersion = function () {\n  var packageJson;\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"uglify-js/package.json\");\n  } catch (error) {// Ignore\n  }\n  return packageJson && packageJson.version;\n};\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {SourceMapInput | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @return {Promise<MinimizedResult>}\n */\nfunction swcMinify(_x9, _x10, _x11) {\n  return _swcMinify.apply(this, arguments);\n}\n/**\n * @returns {string | undefined}\n */\nfunction _swcMinify() {\n  _swcMinify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(input, sourceMap, minimizerOptions) {\n    var buildSwcOptions, swc, swcOptions, _Object$entries5, _Object$entries6, _Object$entries6$, filename, code, result, map;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          /**\n           * @param {PredefinedOptions & import(\"@swc/core\").JsMinifyOptions} [swcOptions={}]\n           * @returns {import(\"@swc/core\").JsMinifyOptions & { sourceMap: undefined } & { compress: import(\"@swc/core\").TerserCompressOptions }}\n           */\n          buildSwcOptions = function buildSwcOptions() {\n            var swcOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n            return _objectSpread(_objectSpread({}, swcOptions), {}, {\n              compress: typeof swcOptions.compress === \"boolean\" ? swcOptions.compress ? {} : false : _objectSpread({}, swcOptions.compress),\n              mangle: swcOptions.mangle == null ? true : typeof swcOptions.mangle === \"boolean\" ? swcOptions.mangle : _objectSpread({}, swcOptions.mangle),\n              // ecma: swcOptions.ecma,\n              // keep_classnames: swcOptions.keep_classnames,\n              // keep_fnames: swcOptions.keep_fnames,\n              // module: swcOptions.module,\n              // safari10: swcOptions.safari10,\n              // toplevel: swcOptions.toplevel\n              // eslint-disable-next-line no-undefined\n              sourceMap: undefined\n            });\n          }; // eslint-disable-next-line import/no-extraneous-dependencies, global-require\n          swc = require(\"@swc/core\"); // Copy `swc` options\n          swcOptions = buildSwcOptions(minimizerOptions); // Let `swc` generate a SourceMap\n          if (sourceMap) {\n            // @ts-ignore\n            swcOptions.sourceMap = true;\n          }\n          if (swcOptions.compress) {\n            // More optimizations\n            if (typeof swcOptions.compress.ecma === \"undefined\") {\n              swcOptions.compress.ecma = swcOptions.ecma;\n            } // https://github.com/webpack/webpack/issues/16135\n\n            if (swcOptions.ecma === 5 && typeof swcOptions.compress.arrows === \"undefined\") {\n              swcOptions.compress.arrows = false;\n            }\n          }\n          _Object$entries5 = Object.entries(input), _Object$entries6 = _slicedToArray(_Object$entries5, 1), _Object$entries6$ = _slicedToArray(_Object$entries6[0], 2), filename = _Object$entries6$[0], code = _Object$entries6$[1];\n          _context3.next = 8;\n          return swc.minify(code, swcOptions);\n        case 8:\n          result = _context3.sent;\n          if (result.map) {\n            map = JSON.parse(result.map); // TODO workaround for swc because `filename` is not preset as in `swc` signature as for `terser`\n\n            map.sources = [filename];\n            delete map.sourcesContent;\n          }\n          return _context3.abrupt(\"return\", {\n            code: result.code,\n            map: map\n          });\n        case 11:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _swcMinify.apply(this, arguments);\n}\nswcMinify.getMinimizerVersion = function () {\n  var packageJson;\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"@swc/core/package.json\");\n  } catch (error) {// Ignore\n  }\n  return packageJson && packageJson.version;\n};\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {SourceMapInput | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @return {Promise<MinimizedResult>}\n */\nfunction esbuildMinify(_x12, _x13, _x14) {\n  return _esbuildMinify.apply(this, arguments);\n}\n/**\n * @returns {string | undefined}\n */\nfunction _esbuildMinify() {\n  _esbuildMinify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(input, sourceMap, minimizerOptions) {\n    var buildEsbuildOptions, esbuild, esbuildOptions, _Object$entries7, _Object$entries8, _Object$entries8$, filename, code, result;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          /**\n           * @param {PredefinedOptions & import(\"esbuild\").TransformOptions} [esbuildOptions={}]\n           * @returns {import(\"esbuild\").TransformOptions}\n           */\n          buildEsbuildOptions = function buildEsbuildOptions() {\n            var esbuildOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            // eslint-disable-next-line no-param-reassign\n            delete esbuildOptions.ecma;\n            if (esbuildOptions.module) {\n              // eslint-disable-next-line no-param-reassign\n              esbuildOptions.format = \"esm\";\n            } // eslint-disable-next-line no-param-reassign\n\n            delete esbuildOptions.module; // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n\n            return _objectSpread(_objectSpread({\n              minify: true,\n              legalComments: \"inline\"\n            }, esbuildOptions), {}, {\n              sourcemap: false\n            });\n          }; // eslint-disable-next-line import/no-extraneous-dependencies, global-require\n          esbuild = require(\"esbuild\"); // Copy `esbuild` options\n          esbuildOptions = buildEsbuildOptions(minimizerOptions); // Let `esbuild` generate a SourceMap\n          if (sourceMap) {\n            esbuildOptions.sourcemap = true;\n            esbuildOptions.sourcesContent = false;\n          }\n          _Object$entries7 = Object.entries(input), _Object$entries8 = _slicedToArray(_Object$entries7, 1), _Object$entries8$ = _slicedToArray(_Object$entries8[0], 2), filename = _Object$entries8$[0], code = _Object$entries8$[1];\n          esbuildOptions.sourcefile = filename;\n          _context4.next = 8;\n          return esbuild.transform(code, esbuildOptions);\n        case 8:\n          result = _context4.sent;\n          return _context4.abrupt(\"return\", {\n            code: result.code,\n            // eslint-disable-next-line no-undefined\n            map: result.map ? JSON.parse(result.map) : undefined,\n            warnings: result.warnings.length > 0 ? result.warnings.map(function (item) {\n              return {\n                name: \"Warning\",\n                source: item.location && item.location.file,\n                line: item.location && item.location.line,\n                column: item.location && item.location.column,\n                plugin: item.pluginName,\n                message: \"\".concat(item.text).concat(item.detail ? \"\\nDetails:\\n\".concat(item.detail) : \"\").concat(item.notes.length > 0 ? \"\\n\\nNotes:\\n\".concat(item.notes.map(function (note) {\n                  return \"\".concat(note.location ? \"[\".concat(note.location.file, \":\").concat(note.location.line, \":\").concat(note.location.column, \"] \") : \"\").concat(note.text).concat(note.location ? \"\\nSuggestion: \".concat(note.location.suggestion) : \"\").concat(note.location ? \"\\nLine text:\\n\".concat(note.location.lineText, \"\\n\") : \"\");\n                }).join(\"\\n\")) : \"\")\n              };\n            }) : []\n          });\n        case 10:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _esbuildMinify.apply(this, arguments);\n}\nesbuildMinify.getMinimizerVersion = function () {\n  var packageJson;\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"esbuild/package.json\");\n  } catch (error) {// Ignore\n  }\n  return packageJson && packageJson.version;\n};\nmodule.exports = {\n  throttleAll: throttleAll,\n  terserMinify: terserMinify,\n  uglifyJsMinify: uglifyJsMinify,\n  swcMinify: swcMinify,\n  esbuildMinify: esbuildMinify\n};","map":{"version":3,"names":["notSettled","Symbol","throttleAll","limit","tasks","Number","isInteger","TypeError","Array","isArray","every","task","Promise","resolve","reject","result","length","fill","entries","next","done","value","isLast","includes","index","onFulfilled","x","then","forEach","terserMinify","input","sourceMap","minimizerOptions","extractComments","isObject","type","buildComments","terserOptions","extractedComments","condition","comments","format","output","preserve","extract","RegExp","key","regexStr","regex","astNode","comment","test","commentText","push","buildTerserOptions","compress","mangle","beautify","parse","undefined","require","minify","asObject","ecma","arrows","Object","filename","code","map","getMinimizerVersion","packageJson","error","version","uglifyJsMinify","uglifyJsOptions","buildUglifyJsOptions","module","JSON","errors","warnings","swcMinify","buildSwcOptions","swcOptions","swc","sources","sourcesContent","esbuildMinify","buildEsbuildOptions","esbuildOptions","legalComments","sourcemap","esbuild","sourcefile","transform","item","name","source","location","file","line","column","plugin","pluginName","message","text","detail","notes","note","suggestion","lineText","join","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/terser-webpack-plugin/dist/utils.js"],"sourcesContent":["\"use strict\";\n\n/** @typedef {import(\"@jridgewell/trace-mapping\").SourceMapInput} SourceMapInput */\n\n/** @typedef {import(\"terser\").FormatOptions} TerserFormatOptions */\n\n/** @typedef {import(\"terser\").MinifyOptions} TerserOptions */\n\n/** @typedef {import(\"terser\").CompressOptions} TerserCompressOptions */\n\n/** @typedef {import(\"terser\").ECMA} TerserECMA */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsOptions} ExtractCommentsOptions */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsFunction} ExtractCommentsFunction */\n\n/** @typedef {import(\"./index.js\").ExtractCommentsCondition} ExtractCommentsCondition */\n\n/** @typedef {import(\"./index.js\").Input} Input */\n\n/** @typedef {import(\"./index.js\").MinimizedResult} MinimizedResult */\n\n/** @typedef {import(\"./index.js\").PredefinedOptions} PredefinedOptions */\n\n/** @typedef {import(\"./index.js\").CustomOptions} CustomOptions */\n\n/**\n * @typedef {Array<string>} ExtractedComments\n */\nconst notSettled = Symbol(`not-settled`);\n/**\n * @template T\n * @typedef {() => Promise<T>} Task\n */\n\n/**\n * Run tasks with limited concurency.\n * @template T\n * @param {number} limit - Limit of tasks that run at once.\n * @param {Task<T>[]} tasks - List of tasks to run.\n * @returns {Promise<T[]>} A promise that fulfills to an array of the results\n */\n\nfunction throttleAll(limit, tasks) {\n  if (!Number.isInteger(limit) || limit < 1) {\n    throw new TypeError(`Expected \\`limit\\` to be a finite number > 0, got \\`${limit}\\` (${typeof limit})`);\n  }\n\n  if (!Array.isArray(tasks) || !tasks.every(task => typeof task === `function`)) {\n    throw new TypeError(`Expected \\`tasks\\` to be a list of functions returning a promise`);\n  }\n\n  return new Promise((resolve, reject) => {\n    const result = Array(tasks.length).fill(notSettled);\n    const entries = tasks.entries();\n\n    const next = () => {\n      const {\n        done,\n        value\n      } = entries.next();\n\n      if (done) {\n        const isLast = !result.includes(notSettled);\n        if (isLast) resolve(\n        /** @type{T[]} **/\n        result);\n        return;\n      }\n\n      const [index, task] = value;\n      /**\n       * @param {T} x\n       */\n\n      const onFulfilled = x => {\n        result[index] = x;\n        next();\n      };\n\n      task().then(onFulfilled, reject);\n    };\n\n    Array(limit).fill(0).forEach(next);\n  });\n}\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {SourceMapInput | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @param {ExtractCommentsOptions | undefined} extractComments\n * @return {Promise<MinimizedResult>}\n */\n\n\nasync function terserMinify(input, sourceMap, minimizerOptions, extractComments) {\n  /**\n   * @param {any} value\n   * @returns {boolean}\n   */\n  const isObject = value => {\n    const type = typeof value;\n    return value != null && (type === \"object\" || type === \"function\");\n  };\n  /**\n   * @param {TerserOptions & { sourceMap: undefined } & ({ output: TerserFormatOptions & { beautify: boolean } } | { format: TerserFormatOptions & { beautify: boolean } })} terserOptions\n   * @param {ExtractedComments} extractedComments\n   * @returns {ExtractCommentsFunction}\n   */\n\n\n  const buildComments = (terserOptions, extractedComments) => {\n    /** @type {{ [index: string]: ExtractCommentsCondition }} */\n    const condition = {};\n    let comments;\n\n    if (terserOptions.format) {\n      ({\n        comments\n      } = terserOptions.format);\n    } else if (terserOptions.output) {\n      ({\n        comments\n      } = terserOptions.output);\n    }\n\n    condition.preserve = typeof comments !== \"undefined\" ? comments : false;\n\n    if (typeof extractComments === \"boolean\" && extractComments) {\n      condition.extract = \"some\";\n    } else if (typeof extractComments === \"string\" || extractComments instanceof RegExp) {\n      condition.extract = extractComments;\n    } else if (typeof extractComments === \"function\") {\n      condition.extract = extractComments;\n    } else if (extractComments && isObject(extractComments)) {\n      condition.extract = typeof extractComments.condition === \"boolean\" && extractComments.condition ? \"some\" : typeof extractComments.condition !== \"undefined\" ? extractComments.condition : \"some\";\n    } else {\n      // No extract\n      // Preserve using \"commentsOpts\" or \"some\"\n      condition.preserve = typeof comments !== \"undefined\" ? comments : \"some\";\n      condition.extract = false;\n    } // Ensure that both conditions are functions\n\n\n    [\"preserve\", \"extract\"].forEach(key => {\n      /** @type {undefined | string} */\n      let regexStr;\n      /** @type {undefined | RegExp} */\n\n      let regex;\n\n      switch (typeof condition[key]) {\n        case \"boolean\":\n          condition[key] = condition[key] ? () => true : () => false;\n          break;\n\n        case \"function\":\n          break;\n\n        case \"string\":\n          if (condition[key] === \"all\") {\n            condition[key] = () => true;\n\n            break;\n          }\n\n          if (condition[key] === \"some\") {\n            condition[key] =\n            /** @type {ExtractCommentsFunction} */\n            (astNode, comment) => (comment.type === \"comment2\" || comment.type === \"comment1\") && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n\n            break;\n          }\n\n          regexStr =\n          /** @type {string} */\n          condition[key];\n\n          condition[key] =\n          /** @type {ExtractCommentsFunction} */\n          (astNode, comment) => new RegExp(\n          /** @type {string} */\n          regexStr).test(comment.value);\n\n          break;\n\n        default:\n          regex =\n          /** @type {RegExp} */\n          condition[key];\n\n          condition[key] =\n          /** @type {ExtractCommentsFunction} */\n          (astNode, comment) =>\n          /** @type {RegExp} */\n          regex.test(comment.value);\n\n      }\n    }); // Redefine the comments function to extract and preserve\n    // comments according to the two conditions\n\n    return (astNode, comment) => {\n      if (\n      /** @type {{ extract: ExtractCommentsFunction }} */\n      condition.extract(astNode, comment)) {\n        const commentText = comment.type === \"comment2\" ? `/*${comment.value}*/` : `//${comment.value}`; // Don't include duplicate comments\n\n        if (!extractedComments.includes(commentText)) {\n          extractedComments.push(commentText);\n        }\n      }\n\n      return (\n        /** @type {{ preserve: ExtractCommentsFunction }} */\n        condition.preserve(astNode, comment)\n      );\n    };\n  };\n  /**\n   * @param {PredefinedOptions & TerserOptions} [terserOptions={}]\n   * @returns {TerserOptions & { sourceMap: undefined } & { compress: TerserCompressOptions } & ({ output: TerserFormatOptions & { beautify: boolean } } | { format: TerserFormatOptions & { beautify: boolean } })}\n   */\n\n\n  const buildTerserOptions = (terserOptions = {}) => {\n    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n    return { ...terserOptions,\n      compress: typeof terserOptions.compress === \"boolean\" ? terserOptions.compress ? {} : false : { ...terserOptions.compress\n      },\n      // ecma: terserOptions.ecma,\n      // ie8: terserOptions.ie8,\n      // keep_classnames: terserOptions.keep_classnames,\n      // keep_fnames: terserOptions.keep_fnames,\n      mangle: terserOptions.mangle == null ? true : typeof terserOptions.mangle === \"boolean\" ? terserOptions.mangle : { ...terserOptions.mangle\n      },\n      // module: terserOptions.module,\n      // nameCache: { ...terserOptions.toplevel },\n      // the `output` option is deprecated\n      ...(terserOptions.format ? {\n        format: {\n          beautify: false,\n          ...terserOptions.format\n        }\n      } : {\n        output: {\n          beautify: false,\n          ...terserOptions.output\n        }\n      }),\n      parse: { ...terserOptions.parse\n      },\n      // safari10: terserOptions.safari10,\n      // Ignoring sourceMap from options\n      // eslint-disable-next-line no-undefined\n      sourceMap: undefined // toplevel: terserOptions.toplevel\n\n    };\n  }; // eslint-disable-next-line global-require\n\n\n  const {\n    minify\n  } = require(\"terser\"); // Copy `terser` options\n\n\n  const terserOptions = buildTerserOptions(minimizerOptions); // Let terser generate a SourceMap\n\n  if (sourceMap) {\n    // @ts-ignore\n    terserOptions.sourceMap = {\n      asObject: true\n    };\n  }\n  /** @type {ExtractedComments} */\n\n\n  const extractedComments = [];\n\n  if (terserOptions.output) {\n    terserOptions.output.comments = buildComments(terserOptions, extractedComments);\n  } else if (terserOptions.format) {\n    terserOptions.format.comments = buildComments(terserOptions, extractedComments);\n  }\n\n  if (terserOptions.compress) {\n    // More optimizations\n    if (typeof terserOptions.compress.ecma === \"undefined\") {\n      terserOptions.compress.ecma = terserOptions.ecma;\n    } // https://github.com/webpack/webpack/issues/16135\n\n\n    if (terserOptions.ecma === 5 && typeof terserOptions.compress.arrows === \"undefined\") {\n      terserOptions.compress.arrows = false;\n    }\n  }\n\n  const [[filename, code]] = Object.entries(input);\n  const result = await minify({\n    [filename]: code\n  }, terserOptions);\n  return {\n    code:\n    /** @type {string} **/\n    result.code,\n    // @ts-ignore\n    // eslint-disable-next-line no-undefined\n    map: result.map ?\n    /** @type {SourceMapInput} **/\n    result.map : undefined,\n    extractedComments\n  };\n}\n/**\n * @returns {string | undefined}\n */\n\n\nterserMinify.getMinimizerVersion = () => {\n  let packageJson;\n\n  try {\n    // eslint-disable-next-line global-require\n    packageJson = require(\"terser/package.json\");\n  } catch (error) {// Ignore\n  }\n\n  return packageJson && packageJson.version;\n};\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {SourceMapInput | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @param {ExtractCommentsOptions | undefined} extractComments\n * @return {Promise<MinimizedResult>}\n */\n\n\nasync function uglifyJsMinify(input, sourceMap, minimizerOptions, extractComments) {\n  /**\n   * @param {any} value\n   * @returns {boolean}\n   */\n  const isObject = value => {\n    const type = typeof value;\n    return value != null && (type === \"object\" || type === \"function\");\n  };\n  /**\n   * @param {import(\"uglify-js\").MinifyOptions & { sourceMap: undefined } & { output: import(\"uglify-js\").OutputOptions & { beautify: boolean }}} uglifyJsOptions\n   * @param {ExtractedComments} extractedComments\n   * @returns {ExtractCommentsFunction}\n   */\n\n\n  const buildComments = (uglifyJsOptions, extractedComments) => {\n    /** @type {{ [index: string]: ExtractCommentsCondition }} */\n    const condition = {};\n    const {\n      comments\n    } = uglifyJsOptions.output;\n    condition.preserve = typeof comments !== \"undefined\" ? comments : false;\n\n    if (typeof extractComments === \"boolean\" && extractComments) {\n      condition.extract = \"some\";\n    } else if (typeof extractComments === \"string\" || extractComments instanceof RegExp) {\n      condition.extract = extractComments;\n    } else if (typeof extractComments === \"function\") {\n      condition.extract = extractComments;\n    } else if (extractComments && isObject(extractComments)) {\n      condition.extract = typeof extractComments.condition === \"boolean\" && extractComments.condition ? \"some\" : typeof extractComments.condition !== \"undefined\" ? extractComments.condition : \"some\";\n    } else {\n      // No extract\n      // Preserve using \"commentsOpts\" or \"some\"\n      condition.preserve = typeof comments !== \"undefined\" ? comments : \"some\";\n      condition.extract = false;\n    } // Ensure that both conditions are functions\n\n\n    [\"preserve\", \"extract\"].forEach(key => {\n      /** @type {undefined | string} */\n      let regexStr;\n      /** @type {undefined | RegExp} */\n\n      let regex;\n\n      switch (typeof condition[key]) {\n        case \"boolean\":\n          condition[key] = condition[key] ? () => true : () => false;\n          break;\n\n        case \"function\":\n          break;\n\n        case \"string\":\n          if (condition[key] === \"all\") {\n            condition[key] = () => true;\n\n            break;\n          }\n\n          if (condition[key] === \"some\") {\n            condition[key] =\n            /** @type {ExtractCommentsFunction} */\n            (astNode, comment) => (comment.type === \"comment2\" || comment.type === \"comment1\") && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n\n            break;\n          }\n\n          regexStr =\n          /** @type {string} */\n          condition[key];\n\n          condition[key] =\n          /** @type {ExtractCommentsFunction} */\n          (astNode, comment) => new RegExp(\n          /** @type {string} */\n          regexStr).test(comment.value);\n\n          break;\n\n        default:\n          regex =\n          /** @type {RegExp} */\n          condition[key];\n\n          condition[key] =\n          /** @type {ExtractCommentsFunction} */\n          (astNode, comment) =>\n          /** @type {RegExp} */\n          regex.test(comment.value);\n\n      }\n    }); // Redefine the comments function to extract and preserve\n    // comments according to the two conditions\n\n    return (astNode, comment) => {\n      if (\n      /** @type {{ extract: ExtractCommentsFunction }} */\n      condition.extract(astNode, comment)) {\n        const commentText = comment.type === \"comment2\" ? `/*${comment.value}*/` : `//${comment.value}`; // Don't include duplicate comments\n\n        if (!extractedComments.includes(commentText)) {\n          extractedComments.push(commentText);\n        }\n      }\n\n      return (\n        /** @type {{ preserve: ExtractCommentsFunction }} */\n        condition.preserve(astNode, comment)\n      );\n    };\n  };\n  /**\n   * @param {PredefinedOptions & import(\"uglify-js\").MinifyOptions} [uglifyJsOptions={}]\n   * @returns {import(\"uglify-js\").MinifyOptions & { sourceMap: undefined } & { output: import(\"uglify-js\").OutputOptions & { beautify: boolean }}}\n   */\n\n\n  const buildUglifyJsOptions = (uglifyJsOptions = {}) => {\n    // eslint-disable-next-line no-param-reassign\n    delete minimizerOptions.ecma; // eslint-disable-next-line no-param-reassign\n\n    delete minimizerOptions.module; // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n\n    return { ...uglifyJsOptions,\n      // warnings: uglifyJsOptions.warnings,\n      parse: { ...uglifyJsOptions.parse\n      },\n      compress: typeof uglifyJsOptions.compress === \"boolean\" ? uglifyJsOptions.compress : { ...uglifyJsOptions.compress\n      },\n      mangle: uglifyJsOptions.mangle == null ? true : typeof uglifyJsOptions.mangle === \"boolean\" ? uglifyJsOptions.mangle : { ...uglifyJsOptions.mangle\n      },\n      output: {\n        beautify: false,\n        ...uglifyJsOptions.output\n      },\n      // Ignoring sourceMap from options\n      // eslint-disable-next-line no-undefined\n      sourceMap: undefined // toplevel: uglifyJsOptions.toplevel\n      // nameCache: { ...uglifyJsOptions.toplevel },\n      // ie8: uglifyJsOptions.ie8,\n      // keep_fnames: uglifyJsOptions.keep_fnames,\n\n    };\n  }; // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n\n\n  const {\n    minify\n  } = require(\"uglify-js\"); // Copy `uglify-js` options\n\n\n  const uglifyJsOptions = buildUglifyJsOptions(minimizerOptions); // Let terser generate a SourceMap\n\n  if (sourceMap) {\n    // @ts-ignore\n    uglifyJsOptions.sourceMap = true;\n  }\n  /** @type {ExtractedComments} */\n\n\n  const extractedComments = []; // @ts-ignore\n\n  uglifyJsOptions.output.comments = buildComments(uglifyJsOptions, extractedComments);\n  const [[filename, code]] = Object.entries(input);\n  const result = await minify({\n    [filename]: code\n  }, uglifyJsOptions);\n  return {\n    code: result.code,\n    // eslint-disable-next-line no-undefined\n    map: result.map ? JSON.parse(result.map) : undefined,\n    errors: result.error ? [result.error] : [],\n    warnings: result.warnings || [],\n    extractedComments\n  };\n}\n/**\n * @returns {string | undefined}\n */\n\n\nuglifyJsMinify.getMinimizerVersion = () => {\n  let packageJson;\n\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"uglify-js/package.json\");\n  } catch (error) {// Ignore\n  }\n\n  return packageJson && packageJson.version;\n};\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {SourceMapInput | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @return {Promise<MinimizedResult>}\n */\n\n\nasync function swcMinify(input, sourceMap, minimizerOptions) {\n  /**\n   * @param {PredefinedOptions & import(\"@swc/core\").JsMinifyOptions} [swcOptions={}]\n   * @returns {import(\"@swc/core\").JsMinifyOptions & { sourceMap: undefined } & { compress: import(\"@swc/core\").TerserCompressOptions }}\n   */\n  const buildSwcOptions = (swcOptions = {}) => {\n    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n    return { ...swcOptions,\n      compress: typeof swcOptions.compress === \"boolean\" ? swcOptions.compress ? {} : false : { ...swcOptions.compress\n      },\n      mangle: swcOptions.mangle == null ? true : typeof swcOptions.mangle === \"boolean\" ? swcOptions.mangle : { ...swcOptions.mangle\n      },\n      // ecma: swcOptions.ecma,\n      // keep_classnames: swcOptions.keep_classnames,\n      // keep_fnames: swcOptions.keep_fnames,\n      // module: swcOptions.module,\n      // safari10: swcOptions.safari10,\n      // toplevel: swcOptions.toplevel\n      // eslint-disable-next-line no-undefined\n      sourceMap: undefined\n    };\n  }; // eslint-disable-next-line import/no-extraneous-dependencies, global-require\n\n\n  const swc = require(\"@swc/core\"); // Copy `swc` options\n\n\n  const swcOptions = buildSwcOptions(minimizerOptions); // Let `swc` generate a SourceMap\n\n  if (sourceMap) {\n    // @ts-ignore\n    swcOptions.sourceMap = true;\n  }\n\n  if (swcOptions.compress) {\n    // More optimizations\n    if (typeof swcOptions.compress.ecma === \"undefined\") {\n      swcOptions.compress.ecma = swcOptions.ecma;\n    } // https://github.com/webpack/webpack/issues/16135\n\n\n    if (swcOptions.ecma === 5 && typeof swcOptions.compress.arrows === \"undefined\") {\n      swcOptions.compress.arrows = false;\n    }\n  }\n\n  const [[filename, code]] = Object.entries(input);\n  const result = await swc.minify(code, swcOptions);\n  let map;\n\n  if (result.map) {\n    map = JSON.parse(result.map); // TODO workaround for swc because `filename` is not preset as in `swc` signature as for `terser`\n\n    map.sources = [filename];\n    delete map.sourcesContent;\n  }\n\n  return {\n    code: result.code,\n    map\n  };\n}\n/**\n * @returns {string | undefined}\n */\n\n\nswcMinify.getMinimizerVersion = () => {\n  let packageJson;\n\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"@swc/core/package.json\");\n  } catch (error) {// Ignore\n  }\n\n  return packageJson && packageJson.version;\n};\n/* istanbul ignore next */\n\n/**\n * @param {Input} input\n * @param {SourceMapInput | undefined} sourceMap\n * @param {PredefinedOptions & CustomOptions} minimizerOptions\n * @return {Promise<MinimizedResult>}\n */\n\n\nasync function esbuildMinify(input, sourceMap, minimizerOptions) {\n  /**\n   * @param {PredefinedOptions & import(\"esbuild\").TransformOptions} [esbuildOptions={}]\n   * @returns {import(\"esbuild\").TransformOptions}\n   */\n  const buildEsbuildOptions = (esbuildOptions = {}) => {\n    // eslint-disable-next-line no-param-reassign\n    delete esbuildOptions.ecma;\n\n    if (esbuildOptions.module) {\n      // eslint-disable-next-line no-param-reassign\n      esbuildOptions.format = \"esm\";\n    } // eslint-disable-next-line no-param-reassign\n\n\n    delete esbuildOptions.module; // Need deep copy objects to avoid https://github.com/terser/terser/issues/366\n\n    return {\n      minify: true,\n      legalComments: \"inline\",\n      ...esbuildOptions,\n      sourcemap: false\n    };\n  }; // eslint-disable-next-line import/no-extraneous-dependencies, global-require\n\n\n  const esbuild = require(\"esbuild\"); // Copy `esbuild` options\n\n\n  const esbuildOptions = buildEsbuildOptions(minimizerOptions); // Let `esbuild` generate a SourceMap\n\n  if (sourceMap) {\n    esbuildOptions.sourcemap = true;\n    esbuildOptions.sourcesContent = false;\n  }\n\n  const [[filename, code]] = Object.entries(input);\n  esbuildOptions.sourcefile = filename;\n  const result = await esbuild.transform(code, esbuildOptions);\n  return {\n    code: result.code,\n    // eslint-disable-next-line no-undefined\n    map: result.map ? JSON.parse(result.map) : undefined,\n    warnings: result.warnings.length > 0 ? result.warnings.map(item => {\n      return {\n        name: \"Warning\",\n        source: item.location && item.location.file,\n        line: item.location && item.location.line,\n        column: item.location && item.location.column,\n        plugin: item.pluginName,\n        message: `${item.text}${item.detail ? `\\nDetails:\\n${item.detail}` : \"\"}${item.notes.length > 0 ? `\\n\\nNotes:\\n${item.notes.map(note => `${note.location ? `[${note.location.file}:${note.location.line}:${note.location.column}] ` : \"\"}${note.text}${note.location ? `\\nSuggestion: ${note.location.suggestion}` : \"\"}${note.location ? `\\nLine text:\\n${note.location.lineText}\\n` : \"\"}`).join(\"\\n\")}` : \"\"}`\n      };\n    }) : []\n  };\n}\n/**\n * @returns {string | undefined}\n */\n\n\nesbuildMinify.getMinimizerVersion = () => {\n  let packageJson;\n\n  try {\n    // eslint-disable-next-line global-require, import/no-extraneous-dependencies\n    packageJson = require(\"esbuild/package.json\");\n  } catch (error) {// Ignore\n  }\n\n  return packageJson && packageJson.version;\n};\n\nmodule.exports = {\n  throttleAll,\n  terserMinify,\n  uglifyJsMinify,\n  swcMinify,\n  esbuildMinify\n};"],"mappings":"AAAA,YAAY;;AAEZ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AAAA;AAAA;AAGA,IAAMA,UAAU,GAAGC,MAAM,eAAe;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,WAAW,CAACC,KAAK,EAAEC,KAAK,EAAE;EACjC,IAAI,CAACC,MAAM,CAACC,SAAS,CAACH,KAAK,CAAC,IAAIA,KAAK,GAAG,CAAC,EAAE;IACzC,MAAM,IAAII,SAAS,4DAAwDJ,KAAK,gBAAO,OAAOA,KAAK,OAAI;EACzG;EAEA,IAAI,CAACK,KAAK,CAACC,OAAO,CAACL,KAAK,CAAC,IAAI,CAACA,KAAK,CAACM,KAAK,CAAC,UAAAC,IAAI;IAAA,OAAI,OAAOA,IAAI,eAAe;EAAA,EAAC,EAAE;IAC7E,MAAM,IAAIJ,SAAS,kEAAoE;EACzF;EAEA,OAAO,IAAIK,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM,EAAK;IACtC,IAAMC,MAAM,GAAGP,KAAK,CAACJ,KAAK,CAACY,MAAM,CAAC,CAACC,IAAI,CAACjB,UAAU,CAAC;IACnD,IAAMkB,OAAO,GAAGd,KAAK,CAACc,OAAO,EAAE;IAE/B,IAAMC,IAAI,GAAG,SAAPA,IAAI,GAAS;MACjB,oBAGID,OAAO,CAACC,IAAI,EAAE;QAFhBC,IAAI,iBAAJA,IAAI;QACJC,KAAK,iBAALA,KAAK;MAGP,IAAID,IAAI,EAAE;QACR,IAAME,MAAM,GAAG,CAACP,MAAM,CAACQ,QAAQ,CAACvB,UAAU,CAAC;QAC3C,IAAIsB,MAAM,EAAET,OAAO,EACnB;QACAE,MAAM,CAAC;QACP;MACF;MAEA,4BAAsBM,KAAK;QAApBG,KAAK;QAAEb,IAAI;MAClB;AACN;AACA;;MAEM,IAAMc,WAAW,GAAG,SAAdA,WAAW,CAAGC,CAAC,EAAI;QACvBX,MAAM,CAACS,KAAK,CAAC,GAAGE,CAAC;QACjBP,IAAI,EAAE;MACR,CAAC;MAEDR,IAAI,EAAE,CAACgB,IAAI,CAACF,WAAW,EAAEX,MAAM,CAAC;IAClC,CAAC;IAEDN,KAAK,CAACL,KAAK,CAAC,CAACc,IAAI,CAAC,CAAC,CAAC,CAACW,OAAO,CAACT,IAAI,CAAC;EACpC,CAAC,CAAC;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA,SASeU,YAAY;EAAA;AAAA;AAyN3B;AACA;AACA;AAFA;EAAA,2EAzNA,iBAA4BC,KAAK,EAAEC,SAAS,EAAEC,gBAAgB,EAAEC,eAAe;IAAA;IAAA;MAAA;QAAA;UAC7E;AACF;AACA;AACA;UACQC,QAAQ,GAAG,SAAXA,QAAQ,CAAGb,KAAK,EAAI;YACxB,IAAMc,IAAI,GAAG,OAAOd,KAAK;YACzB,OAAOA,KAAK,IAAI,IAAI,KAAKc,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,UAAU,CAAC;UACpE,CAAC;UACD;AACF;AACA;AACA;AACA;UAGQC,aAAa,GAAG,SAAhBA,aAAa,CAAIC,aAAa,EAAEC,iBAAiB,EAAK;YAC1D;YACA,IAAMC,SAAS,GAAG,CAAC,CAAC;YACpB,IAAIC,QAAQ;YAEZ,IAAIH,aAAa,CAACI,MAAM,EAAE;cAEtBD,QAAQ,GACNH,aAAa,CAACI,MAAM,CADtBD,QAAQ;YAEZ,CAAC,MAAM,IAAIH,aAAa,CAACK,MAAM,EAAE;cAE7BF,QAAQ,GACNH,aAAa,CAACK,MAAM,CADtBF,QAAQ;YAEZ;YAEAD,SAAS,CAACI,QAAQ,GAAG,OAAOH,QAAQ,KAAK,WAAW,GAAGA,QAAQ,GAAG,KAAK;YAEvE,IAAI,OAAOP,eAAe,KAAK,SAAS,IAAIA,eAAe,EAAE;cAC3DM,SAAS,CAACK,OAAO,GAAG,MAAM;YAC5B,CAAC,MAAM,IAAI,OAAOX,eAAe,KAAK,QAAQ,IAAIA,eAAe,YAAYY,MAAM,EAAE;cACnFN,SAAS,CAACK,OAAO,GAAGX,eAAe;YACrC,CAAC,MAAM,IAAI,OAAOA,eAAe,KAAK,UAAU,EAAE;cAChDM,SAAS,CAACK,OAAO,GAAGX,eAAe;YACrC,CAAC,MAAM,IAAIA,eAAe,IAAIC,QAAQ,CAACD,eAAe,CAAC,EAAE;cACvDM,SAAS,CAACK,OAAO,GAAG,OAAOX,eAAe,CAACM,SAAS,KAAK,SAAS,IAAIN,eAAe,CAACM,SAAS,GAAG,MAAM,GAAG,OAAON,eAAe,CAACM,SAAS,KAAK,WAAW,GAAGN,eAAe,CAACM,SAAS,GAAG,MAAM;YAClM,CAAC,MAAM;cACL;cACA;cACAA,SAAS,CAACI,QAAQ,GAAG,OAAOH,QAAQ,KAAK,WAAW,GAAGA,QAAQ,GAAG,MAAM;cACxED,SAAS,CAACK,OAAO,GAAG,KAAK;YAC3B,CAAC,CAAC;;YAGF,CAAC,UAAU,EAAE,SAAS,CAAC,CAAChB,OAAO,CAAC,UAAAkB,GAAG,EAAI;cACrC;cACA,IAAIC,QAAQ;cACZ;;cAEA,IAAIC,KAAK;cAET,QAAQ,OAAOT,SAAS,CAACO,GAAG,CAAC;gBAC3B,KAAK,SAAS;kBACZP,SAAS,CAACO,GAAG,CAAC,GAAGP,SAAS,CAACO,GAAG,CAAC,GAAG;oBAAA,OAAM,IAAI;kBAAA,IAAG;oBAAA,OAAM,KAAK;kBAAA;kBAC1D;gBAEF,KAAK,UAAU;kBACb;gBAEF,KAAK,QAAQ;kBACX,IAAIP,SAAS,CAACO,GAAG,CAAC,KAAK,KAAK,EAAE;oBAC5BP,SAAS,CAACO,GAAG,CAAC,GAAG;sBAAA,OAAM,IAAI;oBAAA;oBAE3B;kBACF;kBAEA,IAAIP,SAAS,CAACO,GAAG,CAAC,KAAK,MAAM,EAAE;oBAC7BP,SAAS,CAACO,GAAG,CAAC,GACd;oBACA,UAACG,OAAO,EAAEC,OAAO;sBAAA,OAAK,CAACA,OAAO,CAACf,IAAI,KAAK,UAAU,IAAIe,OAAO,CAACf,IAAI,KAAK,UAAU,KAAK,8BAA8B,CAACgB,IAAI,CAACD,OAAO,CAAC7B,KAAK,CAAC;oBAAA;oBAExI;kBACF;kBAEA0B,QAAQ,GACR;kBACAR,SAAS,CAACO,GAAG,CAAC;kBAEdP,SAAS,CAACO,GAAG,CAAC,GACd;kBACA,UAACG,OAAO,EAAEC,OAAO;oBAAA,OAAK,IAAIL,MAAM,EAChC;oBACAE,QAAQ,CAAC,CAACI,IAAI,CAACD,OAAO,CAAC7B,KAAK,CAAC;kBAAA;kBAE7B;gBAEF;kBACE2B,KAAK,GACL;kBACAT,SAAS,CAACO,GAAG,CAAC;kBAEdP,SAAS,CAACO,GAAG,CAAC,GACd;kBACA,UAACG,OAAO,EAAEC,OAAO;oBAAA,OACjB;sBACAF,KAAK,CAACG,IAAI,CAACD,OAAO,CAAC7B,KAAK;oBAAC;kBAAA;cAAC;YAGhC,CAAC,CAAC,CAAC,CAAC;YACJ;;YAEA,OAAO,UAAC4B,OAAO,EAAEC,OAAO,EAAK;cAC3B,KACA;cACAX,SAAS,CAACK,OAAO,CAACK,OAAO,EAAEC,OAAO,CAAC,EAAE;gBACnC,IAAME,WAAW,GAAGF,OAAO,CAACf,IAAI,KAAK,UAAU,eAAQe,OAAO,CAAC7B,KAAK,sBAAY6B,OAAO,CAAC7B,KAAK,CAAE,CAAC,CAAC;;gBAEjG,IAAI,CAACiB,iBAAiB,CAACf,QAAQ,CAAC6B,WAAW,CAAC,EAAE;kBAC5Cd,iBAAiB,CAACe,IAAI,CAACD,WAAW,CAAC;gBACrC;cACF;cAEA,OACE;gBACAb,SAAS,CAACI,QAAQ,CAACM,OAAO,EAAEC,OAAO;cAAC;YAExC,CAAC;UACH,CAAC;UACD;AACF;AACA;AACA;UAGQI,kBAAkB,GAAG,SAArBA,kBAAkB,GAA2B;YAAA,IAAvBjB,aAAa,uEAAG,CAAC,CAAC;YAC5C;YACA,qDAAYA,aAAa;cACvBkB,QAAQ,EAAE,OAAOlB,aAAa,CAACkB,QAAQ,KAAK,SAAS,GAAGlB,aAAa,CAACkB,QAAQ,GAAG,CAAC,CAAC,GAAG,KAAK,qBAAQlB,aAAa,CAACkB,QAAQ,CACxH;cACD;cACA;cACA;cACA;cACAC,MAAM,EAAEnB,aAAa,CAACmB,MAAM,IAAI,IAAI,GAAG,IAAI,GAAG,OAAOnB,aAAa,CAACmB,MAAM,KAAK,SAAS,GAAGnB,aAAa,CAACmB,MAAM,qBAAQnB,aAAa,CAACmB,MAAM;YACzI,GAIGnB,aAAa,CAACI,MAAM,GAAG;cACzBA,MAAM;gBACJgB,QAAQ,EAAE;cAAK,GACZpB,aAAa,CAACI,MAAM;YAE3B,CAAC,GAAG;cACFC,MAAM;gBACJe,QAAQ,EAAE;cAAK,GACZpB,aAAa,CAACK,MAAM;YAE3B,CAAC;cACDgB,KAAK,oBAAOrB,aAAa,CAACqB,KAAK,CAC9B;cACD;cACA;cACA;cACA3B,SAAS,EAAE4B,SAAS,CAAC;YAAA;UAGzB,CAAC,EAAE;UAAA,WAKCC,OAAO,CAAC,QAAQ,CAAC,EADnBC,MAAM,YAANA,MAAM,EACe;UAGjBxB,aAAa,GAAGiB,kBAAkB,CAACtB,gBAAgB,CAAC,EAAE;UAE5D,IAAID,SAAS,EAAE;YACb;YACAM,aAAa,CAACN,SAAS,GAAG;cACxB+B,QAAQ,EAAE;YACZ,CAAC;UACH;UACA;UAGMxB,iBAAiB,GAAG,EAAE;UAE5B,IAAID,aAAa,CAACK,MAAM,EAAE;YACxBL,aAAa,CAACK,MAAM,CAACF,QAAQ,GAAGJ,aAAa,CAACC,aAAa,EAAEC,iBAAiB,CAAC;UACjF,CAAC,MAAM,IAAID,aAAa,CAACI,MAAM,EAAE;YAC/BJ,aAAa,CAACI,MAAM,CAACD,QAAQ,GAAGJ,aAAa,CAACC,aAAa,EAAEC,iBAAiB,CAAC;UACjF;UAEA,IAAID,aAAa,CAACkB,QAAQ,EAAE;YAC1B;YACA,IAAI,OAAOlB,aAAa,CAACkB,QAAQ,CAACQ,IAAI,KAAK,WAAW,EAAE;cACtD1B,aAAa,CAACkB,QAAQ,CAACQ,IAAI,GAAG1B,aAAa,CAAC0B,IAAI;YAClD,CAAC,CAAC;;YAGF,IAAI1B,aAAa,CAAC0B,IAAI,KAAK,CAAC,IAAI,OAAO1B,aAAa,CAACkB,QAAQ,CAACS,MAAM,KAAK,WAAW,EAAE;cACpF3B,aAAa,CAACkB,QAAQ,CAACS,MAAM,GAAG,KAAK;YACvC;UACF;UAAC,kBAE0BC,MAAM,CAAC/C,OAAO,CAACY,KAAK,CAAC,qHAAxCoC,QAAQ,yBAAEC,IAAI;UAAA;UAAA,OACDN,MAAM,qBACxBK,QAAQ,EAAGC,IAAI,GACf9B,aAAa,CAAC;QAAA;UAFXtB,MAAM;UAAA,iCAGL;YACLoD,IAAI,EACJ;YACApD,MAAM,CAACoD,IAAI;YACX;YACA;YACAC,GAAG,EAAErD,MAAM,CAACqD,GAAG,GACf;YACArD,MAAM,CAACqD,GAAG,GAAGT,SAAS;YACtBrB,iBAAiB,EAAjBA;UACF,CAAC;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA,CACF;EAAA;AAAA;AAMDT,YAAY,CAACwC,mBAAmB,GAAG,YAAM;EACvC,IAAIC,WAAW;EAEf,IAAI;IACF;IACAA,WAAW,GAAGV,OAAO,CAAC,qBAAqB,CAAC;EAC9C,CAAC,CAAC,OAAOW,KAAK,EAAE,CAAC;EAAA;EAGjB,OAAOD,WAAW,IAAIA,WAAW,CAACE,OAAO;AAC3C,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA,SASeC,cAAc;EAAA;AAAA;AAmL7B;AACA;AACA;AAFA;EAAA,6EAnLA,kBAA8B3C,KAAK,EAAEC,SAAS,EAAEC,gBAAgB,EAAEC,eAAe;IAAA;IAAA;MAAA;QAAA;UAC/E;AACF;AACA;AACA;UACQC,QAAQ,GAAG,SAAXA,QAAQ,CAAGb,KAAK,EAAI;YACxB,IAAMc,IAAI,GAAG,OAAOd,KAAK;YACzB,OAAOA,KAAK,IAAI,IAAI,KAAKc,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,UAAU,CAAC;UACpE,CAAC;UACD;AACF;AACA;AACA;AACA;UAGQC,aAAa,GAAG,SAAhBA,aAAa,CAAIsC,eAAe,EAAEpC,iBAAiB,EAAK;YAC5D;YACA,IAAMC,SAAS,GAAG,CAAC,CAAC;YACpB,IACEC,QAAQ,GACNkC,eAAe,CAAChC,MAAM,CADxBF,QAAQ;YAEVD,SAAS,CAACI,QAAQ,GAAG,OAAOH,QAAQ,KAAK,WAAW,GAAGA,QAAQ,GAAG,KAAK;YAEvE,IAAI,OAAOP,eAAe,KAAK,SAAS,IAAIA,eAAe,EAAE;cAC3DM,SAAS,CAACK,OAAO,GAAG,MAAM;YAC5B,CAAC,MAAM,IAAI,OAAOX,eAAe,KAAK,QAAQ,IAAIA,eAAe,YAAYY,MAAM,EAAE;cACnFN,SAAS,CAACK,OAAO,GAAGX,eAAe;YACrC,CAAC,MAAM,IAAI,OAAOA,eAAe,KAAK,UAAU,EAAE;cAChDM,SAAS,CAACK,OAAO,GAAGX,eAAe;YACrC,CAAC,MAAM,IAAIA,eAAe,IAAIC,QAAQ,CAACD,eAAe,CAAC,EAAE;cACvDM,SAAS,CAACK,OAAO,GAAG,OAAOX,eAAe,CAACM,SAAS,KAAK,SAAS,IAAIN,eAAe,CAACM,SAAS,GAAG,MAAM,GAAG,OAAON,eAAe,CAACM,SAAS,KAAK,WAAW,GAAGN,eAAe,CAACM,SAAS,GAAG,MAAM;YAClM,CAAC,MAAM;cACL;cACA;cACAA,SAAS,CAACI,QAAQ,GAAG,OAAOH,QAAQ,KAAK,WAAW,GAAGA,QAAQ,GAAG,MAAM;cACxED,SAAS,CAACK,OAAO,GAAG,KAAK;YAC3B,CAAC,CAAC;;YAGF,CAAC,UAAU,EAAE,SAAS,CAAC,CAAChB,OAAO,CAAC,UAAAkB,GAAG,EAAI;cACrC;cACA,IAAIC,QAAQ;cACZ;;cAEA,IAAIC,KAAK;cAET,QAAQ,OAAOT,SAAS,CAACO,GAAG,CAAC;gBAC3B,KAAK,SAAS;kBACZP,SAAS,CAACO,GAAG,CAAC,GAAGP,SAAS,CAACO,GAAG,CAAC,GAAG;oBAAA,OAAM,IAAI;kBAAA,IAAG;oBAAA,OAAM,KAAK;kBAAA;kBAC1D;gBAEF,KAAK,UAAU;kBACb;gBAEF,KAAK,QAAQ;kBACX,IAAIP,SAAS,CAACO,GAAG,CAAC,KAAK,KAAK,EAAE;oBAC5BP,SAAS,CAACO,GAAG,CAAC,GAAG;sBAAA,OAAM,IAAI;oBAAA;oBAE3B;kBACF;kBAEA,IAAIP,SAAS,CAACO,GAAG,CAAC,KAAK,MAAM,EAAE;oBAC7BP,SAAS,CAACO,GAAG,CAAC,GACd;oBACA,UAACG,OAAO,EAAEC,OAAO;sBAAA,OAAK,CAACA,OAAO,CAACf,IAAI,KAAK,UAAU,IAAIe,OAAO,CAACf,IAAI,KAAK,UAAU,KAAK,8BAA8B,CAACgB,IAAI,CAACD,OAAO,CAAC7B,KAAK,CAAC;oBAAA;oBAExI;kBACF;kBAEA0B,QAAQ,GACR;kBACAR,SAAS,CAACO,GAAG,CAAC;kBAEdP,SAAS,CAACO,GAAG,CAAC,GACd;kBACA,UAACG,OAAO,EAAEC,OAAO;oBAAA,OAAK,IAAIL,MAAM,EAChC;oBACAE,QAAQ,CAAC,CAACI,IAAI,CAACD,OAAO,CAAC7B,KAAK,CAAC;kBAAA;kBAE7B;gBAEF;kBACE2B,KAAK,GACL;kBACAT,SAAS,CAACO,GAAG,CAAC;kBAEdP,SAAS,CAACO,GAAG,CAAC,GACd;kBACA,UAACG,OAAO,EAAEC,OAAO;oBAAA,OACjB;sBACAF,KAAK,CAACG,IAAI,CAACD,OAAO,CAAC7B,KAAK;oBAAC;kBAAA;cAAC;YAGhC,CAAC,CAAC,CAAC,CAAC;YACJ;;YAEA,OAAO,UAAC4B,OAAO,EAAEC,OAAO,EAAK;cAC3B,KACA;cACAX,SAAS,CAACK,OAAO,CAACK,OAAO,EAAEC,OAAO,CAAC,EAAE;gBACnC,IAAME,WAAW,GAAGF,OAAO,CAACf,IAAI,KAAK,UAAU,eAAQe,OAAO,CAAC7B,KAAK,sBAAY6B,OAAO,CAAC7B,KAAK,CAAE,CAAC,CAAC;;gBAEjG,IAAI,CAACiB,iBAAiB,CAACf,QAAQ,CAAC6B,WAAW,CAAC,EAAE;kBAC5Cd,iBAAiB,CAACe,IAAI,CAACD,WAAW,CAAC;gBACrC;cACF;cAEA,OACE;gBACAb,SAAS,CAACI,QAAQ,CAACM,OAAO,EAAEC,OAAO;cAAC;YAExC,CAAC;UACH,CAAC;UACD;AACF;AACA;AACA;UAGQyB,oBAAoB,GAAG,SAAvBA,oBAAoB,GAA6B;YAAA,IAAzBD,eAAe,uEAAG,CAAC,CAAC;YAChD;YACA,OAAO1C,gBAAgB,CAAC+B,IAAI,CAAC,CAAC;;YAE9B,OAAO/B,gBAAgB,CAAC4C,MAAM,CAAC,CAAC;;YAEhC,uCAAYF,eAAe;cACzB;cACAhB,KAAK,oBAAOgB,eAAe,CAAChB,KAAK,CAChC;cACDH,QAAQ,EAAE,OAAOmB,eAAe,CAACnB,QAAQ,KAAK,SAAS,GAAGmB,eAAe,CAACnB,QAAQ,qBAAQmB,eAAe,CAACnB,QAAQ,CACjH;cACDC,MAAM,EAAEkB,eAAe,CAAClB,MAAM,IAAI,IAAI,GAAG,IAAI,GAAG,OAAOkB,eAAe,CAAClB,MAAM,KAAK,SAAS,GAAGkB,eAAe,CAAClB,MAAM,qBAAQkB,eAAe,CAAClB,MAAM,CACjJ;cACDd,MAAM;gBACJe,QAAQ,EAAE;cAAK,GACZiB,eAAe,CAAChC,MAAM,CAC1B;cACD;cACA;cACAX,SAAS,EAAE4B,SAAS,CAAC;cACrB;cACA;cACA;YAAA;UAGJ,CAAC,EAAE;UAAA,YAKCC,OAAO,CAAC,WAAW,CAAC,EADtBC,MAAM,aAANA,MAAM,EACkB;UAGpBa,eAAe,GAAGC,oBAAoB,CAAC3C,gBAAgB,CAAC,EAAE;UAEhE,IAAID,SAAS,EAAE;YACb;YACA2C,eAAe,CAAC3C,SAAS,GAAG,IAAI;UAClC;UACA;UAGMO,iBAAiB,GAAG,EAAE,EAAE;UAE9BoC,eAAe,CAAChC,MAAM,CAACF,QAAQ,GAAGJ,aAAa,CAACsC,eAAe,EAAEpC,iBAAiB,CAAC;UAAC,mBACzD2B,MAAM,CAAC/C,OAAO,CAACY,KAAK,CAAC,sHAAxCoC,QAAQ,yBAAEC,IAAI;UAAA;UAAA,OACDN,MAAM,qBACxBK,QAAQ,EAAGC,IAAI,GACfO,eAAe,CAAC;QAAA;UAFb3D,MAAM;UAAA,kCAGL;YACLoD,IAAI,EAAEpD,MAAM,CAACoD,IAAI;YACjB;YACAC,GAAG,EAAErD,MAAM,CAACqD,GAAG,GAAGS,IAAI,CAACnB,KAAK,CAAC3C,MAAM,CAACqD,GAAG,CAAC,GAAGT,SAAS;YACpDmB,MAAM,EAAE/D,MAAM,CAACwD,KAAK,GAAG,CAACxD,MAAM,CAACwD,KAAK,CAAC,GAAG,EAAE;YAC1CQ,QAAQ,EAAEhE,MAAM,CAACgE,QAAQ,IAAI,EAAE;YAC/BzC,iBAAiB,EAAjBA;UACF,CAAC;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA,CACF;EAAA;AAAA;AAMDmC,cAAc,CAACJ,mBAAmB,GAAG,YAAM;EACzC,IAAIC,WAAW;EAEf,IAAI;IACF;IACAA,WAAW,GAAGV,OAAO,CAAC,wBAAwB,CAAC;EACjD,CAAC,CAAC,OAAOW,KAAK,EAAE,CAAC;EAAA;EAGjB,OAAOD,WAAW,IAAIA,WAAW,CAACE,OAAO;AAC3C,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AALA,SAQeQ,SAAS;EAAA;AAAA;AA8DxB;AACA;AACA;AAFA;EAAA,wEA9DA,kBAAyBlD,KAAK,EAAEC,SAAS,EAAEC,gBAAgB;IAAA;IAAA;MAAA;QAAA;UACzD;AACF;AACA;AACA;UACQiD,eAAe,GAAG,SAAlBA,eAAe,GAAwB;YAAA,IAApBC,UAAU,uEAAG,CAAC,CAAC;YACtC;YACA,uCAAYA,UAAU;cACpB3B,QAAQ,EAAE,OAAO2B,UAAU,CAAC3B,QAAQ,KAAK,SAAS,GAAG2B,UAAU,CAAC3B,QAAQ,GAAG,CAAC,CAAC,GAAG,KAAK,qBAAQ2B,UAAU,CAAC3B,QAAQ,CAC/G;cACDC,MAAM,EAAE0B,UAAU,CAAC1B,MAAM,IAAI,IAAI,GAAG,IAAI,GAAG,OAAO0B,UAAU,CAAC1B,MAAM,KAAK,SAAS,GAAG0B,UAAU,CAAC1B,MAAM,qBAAQ0B,UAAU,CAAC1B,MAAM,CAC7H;cACD;cACA;cACA;cACA;cACA;cACA;cACA;cACAzB,SAAS,EAAE4B;YAAS;UAExB,CAAC,EAAE;UAGGwB,GAAG,GAAGvB,OAAO,CAAC,WAAW,CAAC,EAAE;UAG5BsB,UAAU,GAAGD,eAAe,CAACjD,gBAAgB,CAAC,EAAE;UAEtD,IAAID,SAAS,EAAE;YACb;YACAmD,UAAU,CAACnD,SAAS,GAAG,IAAI;UAC7B;UAEA,IAAImD,UAAU,CAAC3B,QAAQ,EAAE;YACvB;YACA,IAAI,OAAO2B,UAAU,CAAC3B,QAAQ,CAACQ,IAAI,KAAK,WAAW,EAAE;cACnDmB,UAAU,CAAC3B,QAAQ,CAACQ,IAAI,GAAGmB,UAAU,CAACnB,IAAI;YAC5C,CAAC,CAAC;;YAGF,IAAImB,UAAU,CAACnB,IAAI,KAAK,CAAC,IAAI,OAAOmB,UAAU,CAAC3B,QAAQ,CAACS,MAAM,KAAK,WAAW,EAAE;cAC9EkB,UAAU,CAAC3B,QAAQ,CAACS,MAAM,GAAG,KAAK;YACpC;UACF;UAAC,mBAE0BC,MAAM,CAAC/C,OAAO,CAACY,KAAK,CAAC,sHAAxCoC,QAAQ,yBAAEC,IAAI;UAAA;UAAA,OACDgB,GAAG,CAACtB,MAAM,CAACM,IAAI,EAAEe,UAAU,CAAC;QAAA;UAA3CnE,MAAM;UAGZ,IAAIA,MAAM,CAACqD,GAAG,EAAE;YACdA,GAAG,GAAGS,IAAI,CAACnB,KAAK,CAAC3C,MAAM,CAACqD,GAAG,CAAC,CAAC,CAAC;;YAE9BA,GAAG,CAACgB,OAAO,GAAG,CAAClB,QAAQ,CAAC;YACxB,OAAOE,GAAG,CAACiB,cAAc;UAC3B;UAAC,kCAEM;YACLlB,IAAI,EAAEpD,MAAM,CAACoD,IAAI;YACjBC,GAAG,EAAHA;UACF,CAAC;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA,CACF;EAAA;AAAA;AAMDY,SAAS,CAACX,mBAAmB,GAAG,YAAM;EACpC,IAAIC,WAAW;EAEf,IAAI;IACF;IACAA,WAAW,GAAGV,OAAO,CAAC,wBAAwB,CAAC;EACjD,CAAC,CAAC,OAAOW,KAAK,EAAE,CAAC;EAAA;EAGjB,OAAOD,WAAW,IAAIA,WAAW,CAACE,OAAO;AAC3C,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AALA,SAQec,aAAa;EAAA;AAAA;AAuD5B;AACA;AACA;AAFA;EAAA,4EAvDA,kBAA6BxD,KAAK,EAAEC,SAAS,EAAEC,gBAAgB;IAAA;IAAA;MAAA;QAAA;UAC7D;AACF;AACA;AACA;UACQuD,mBAAmB,GAAG,SAAtBA,mBAAmB,GAA4B;YAAA,IAAxBC,cAAc,uEAAG,CAAC,CAAC;YAC9C;YACA,OAAOA,cAAc,CAACzB,IAAI;YAE1B,IAAIyB,cAAc,CAACZ,MAAM,EAAE;cACzB;cACAY,cAAc,CAAC/C,MAAM,GAAG,KAAK;YAC/B,CAAC,CAAC;;YAGF,OAAO+C,cAAc,CAACZ,MAAM,CAAC,CAAC;;YAE9B;cACEf,MAAM,EAAE,IAAI;cACZ4B,aAAa,EAAE;YAAQ,GACpBD,cAAc;cACjBE,SAAS,EAAE;YAAK;UAEpB,CAAC,EAAE;UAGGC,OAAO,GAAG/B,OAAO,CAAC,SAAS,CAAC,EAAE;UAG9B4B,cAAc,GAAGD,mBAAmB,CAACvD,gBAAgB,CAAC,EAAE;UAE9D,IAAID,SAAS,EAAE;YACbyD,cAAc,CAACE,SAAS,GAAG,IAAI;YAC/BF,cAAc,CAACH,cAAc,GAAG,KAAK;UACvC;UAAC,mBAE0BpB,MAAM,CAAC/C,OAAO,CAACY,KAAK,CAAC,sHAAxCoC,QAAQ,yBAAEC,IAAI;UACtBqB,cAAc,CAACI,UAAU,GAAG1B,QAAQ;UAAC;UAAA,OAChByB,OAAO,CAACE,SAAS,CAAC1B,IAAI,EAAEqB,cAAc,CAAC;QAAA;UAAtDzE,MAAM;UAAA,kCACL;YACLoD,IAAI,EAAEpD,MAAM,CAACoD,IAAI;YACjB;YACAC,GAAG,EAAErD,MAAM,CAACqD,GAAG,GAAGS,IAAI,CAACnB,KAAK,CAAC3C,MAAM,CAACqD,GAAG,CAAC,GAAGT,SAAS;YACpDoB,QAAQ,EAAEhE,MAAM,CAACgE,QAAQ,CAAC/D,MAAM,GAAG,CAAC,GAAGD,MAAM,CAACgE,QAAQ,CAACX,GAAG,CAAC,UAAA0B,IAAI,EAAI;cACjE,OAAO;gBACLC,IAAI,EAAE,SAAS;gBACfC,MAAM,EAAEF,IAAI,CAACG,QAAQ,IAAIH,IAAI,CAACG,QAAQ,CAACC,IAAI;gBAC3CC,IAAI,EAAEL,IAAI,CAACG,QAAQ,IAAIH,IAAI,CAACG,QAAQ,CAACE,IAAI;gBACzCC,MAAM,EAAEN,IAAI,CAACG,QAAQ,IAAIH,IAAI,CAACG,QAAQ,CAACG,MAAM;gBAC7CC,MAAM,EAAEP,IAAI,CAACQ,UAAU;gBACvBC,OAAO,YAAKT,IAAI,CAACU,IAAI,SAAGV,IAAI,CAACW,MAAM,yBAAkBX,IAAI,CAACW,MAAM,IAAK,EAAE,SAAGX,IAAI,CAACY,KAAK,CAAC1F,MAAM,GAAG,CAAC,yBAAkB8E,IAAI,CAACY,KAAK,CAACtC,GAAG,CAAC,UAAAuC,IAAI;kBAAA,iBAAOA,IAAI,CAACV,QAAQ,cAAOU,IAAI,CAACV,QAAQ,CAACC,IAAI,cAAIS,IAAI,CAACV,QAAQ,CAACE,IAAI,cAAIQ,IAAI,CAACV,QAAQ,CAACG,MAAM,UAAO,EAAE,SAAGO,IAAI,CAACH,IAAI,SAAGG,IAAI,CAACV,QAAQ,2BAAoBU,IAAI,CAACV,QAAQ,CAACW,UAAU,IAAK,EAAE,SAAGD,IAAI,CAACV,QAAQ,2BAAoBU,IAAI,CAACV,QAAQ,CAACY,QAAQ,UAAO,EAAE;gBAAA,CAAE,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC,IAAK,EAAE;cACjZ,CAAC;YACH,CAAC,CAAC,GAAG;UACP,CAAC;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA,CACF;EAAA;AAAA;AAMDxB,aAAa,CAACjB,mBAAmB,GAAG,YAAM;EACxC,IAAIC,WAAW;EAEf,IAAI;IACF;IACAA,WAAW,GAAGV,OAAO,CAAC,sBAAsB,CAAC;EAC/C,CAAC,CAAC,OAAOW,KAAK,EAAE,CAAC;EAAA;EAGjB,OAAOD,WAAW,IAAIA,WAAW,CAACE,OAAO;AAC3C,CAAC;AAEDI,MAAM,CAACmC,OAAO,GAAG;EACf7G,WAAW,EAAXA,WAAW;EACX2B,YAAY,EAAZA,YAAY;EACZ4C,cAAc,EAAdA,cAAc;EACdO,SAAS,EAATA,SAAS;EACTM,aAAa,EAAbA;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}