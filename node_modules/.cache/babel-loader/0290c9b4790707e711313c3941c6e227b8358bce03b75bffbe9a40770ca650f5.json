{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _objectSpread = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _toConsumableArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar parseJson = require(\"json-parse-even-better-errors\");\nvar asyncLib = require(\"neo-async\");\nvar _require = require(\"tapable\"),\n  SyncHook = _require.SyncHook,\n  SyncBailHook = _require.SyncBailHook,\n  AsyncParallelHook = _require.AsyncParallelHook,\n  AsyncSeriesHook = _require.AsyncSeriesHook;\nvar _require2 = require(\"webpack-sources\"),\n  SizeOnlySource = _require2.SizeOnlySource;\nvar webpack = require(\"./\");\nvar Cache = require(\"./Cache\");\nvar CacheFacade = require(\"./CacheFacade\");\nvar ChunkGraph = require(\"./ChunkGraph\");\nvar Compilation = require(\"./Compilation\");\nvar ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\nvar ContextModuleFactory = require(\"./ContextModuleFactory\");\nvar ModuleGraph = require(\"./ModuleGraph\");\nvar NormalModuleFactory = require(\"./NormalModuleFactory\");\nvar RequestShortener = require(\"./RequestShortener\");\nvar ResolverFactory = require(\"./ResolverFactory\");\nvar Stats = require(\"./Stats\");\nvar Watching = require(\"./Watching\");\nvar WebpackError = require(\"./WebpackError\");\nvar _require3 = require(\"./logging/Logger\"),\n  Logger = _require3.Logger;\nvar _require4 = require(\"./util/fs\"),\n  join = _require4.join,\n  dirname = _require4.dirname,\n  mkdirp = _require4.mkdirp;\nvar _require5 = require(\"./util/identifier\"),\n  makePathsRelative = _require5.makePathsRelative;\nvar _require6 = require(\"./util/source\"),\n  isSourceEqual = _require6.isSourceEqual;\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../declarations/WebpackOptions\").EntryNormalized} Entry */\n/** @typedef {import(\"../declarations/WebpackOptions\").OutputNormalized} OutputOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackOptionsNormalized} WebpackOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackPluginInstance} WebpackPluginInstance */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./FileSystemInfo\").FileSystemInfoEntry} FileSystemInfoEntry */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./util/WeakTupleMap\")} WeakTupleMap */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @typedef {Object} CompilationParams\n * @property {NormalModuleFactory} normalModuleFactory\n * @property {ContextModuleFactory} contextModuleFactory\n */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n/**\n * @callback RunAsChildCallback\n * @param {(Error | null)=} err\n * @param {Chunk[]=} entries\n * @param {Compilation=} compilation\n */\n\n/**\n * @typedef {Object} AssetEmittedInfo\n * @property {Buffer} content\n * @property {Source} source\n * @property {Compilation} compilation\n * @property {string} outputPath\n * @property {string} targetPath\n */\n\n/**\n * @param {string[]} array an array\n * @returns {boolean} true, if the array is sorted\n */\nvar isSorted = function isSorted(array) {\n  for (var i = 1; i < array.length; i++) {\n    if (array[i - 1] > array[i]) return false;\n  }\n  return true;\n};\n\n/**\n * @param {Object} obj an object\n * @param {string[]} keys the keys of the object\n * @returns {Object} the object with properties sorted by property name\n */\nvar sortObject = function sortObject(obj, keys) {\n  var o = {};\n  var _iterator = _createForOfIteratorHelper(keys.sort()),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var k = _step.value;\n      o[k] = obj[k];\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return o;\n};\n\n/**\n * @param {string} filename filename\n * @param {string | string[] | undefined} hashes list of hashes\n * @returns {boolean} true, if the filename contains any hash\n */\nvar includesHash = function includesHash(filename, hashes) {\n  if (!hashes) return false;\n  if (Array.isArray(hashes)) {\n    return hashes.some(function (hash) {\n      return filename.includes(hash);\n    });\n  } else {\n    return filename.includes(hashes);\n  }\n};\nvar Compiler = /*#__PURE__*/function () {\n  /**\n   * @param {string} context the compilation path\n   * @param {WebpackOptions} options options\n   */\n  function Compiler(context) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /** @type {WebpackOptions} */{};\n    _classCallCheck(this, Compiler);\n    this.hooks = Object.freeze({\n      /** @type {SyncHook<[]>} */\n      initialize: new SyncHook([]),\n      /** @type {SyncBailHook<[Compilation], boolean>} */\n      shouldEmit: new SyncBailHook([\"compilation\"]),\n      /** @type {AsyncSeriesHook<[Stats]>} */\n      done: new AsyncSeriesHook([\"stats\"]),\n      /** @type {SyncHook<[Stats]>} */\n      afterDone: new SyncHook([\"stats\"]),\n      /** @type {AsyncSeriesHook<[]>} */\n      additionalPass: new AsyncSeriesHook([]),\n      /** @type {AsyncSeriesHook<[Compiler]>} */\n      beforeRun: new AsyncSeriesHook([\"compiler\"]),\n      /** @type {AsyncSeriesHook<[Compiler]>} */\n      run: new AsyncSeriesHook([\"compiler\"]),\n      /** @type {AsyncSeriesHook<[Compilation]>} */\n      emit: new AsyncSeriesHook([\"compilation\"]),\n      /** @type {AsyncSeriesHook<[string, AssetEmittedInfo]>} */\n      assetEmitted: new AsyncSeriesHook([\"file\", \"info\"]),\n      /** @type {AsyncSeriesHook<[Compilation]>} */\n      afterEmit: new AsyncSeriesHook([\"compilation\"]),\n      /** @type {SyncHook<[Compilation, CompilationParams]>} */\n      thisCompilation: new SyncHook([\"compilation\", \"params\"]),\n      /** @type {SyncHook<[Compilation, CompilationParams]>} */\n      compilation: new SyncHook([\"compilation\", \"params\"]),\n      /** @type {SyncHook<[NormalModuleFactory]>} */\n      normalModuleFactory: new SyncHook([\"normalModuleFactory\"]),\n      /** @type {SyncHook<[ContextModuleFactory]>}  */\n      contextModuleFactory: new SyncHook([\"contextModuleFactory\"]),\n      /** @type {AsyncSeriesHook<[CompilationParams]>} */\n      beforeCompile: new AsyncSeriesHook([\"params\"]),\n      /** @type {SyncHook<[CompilationParams]>} */\n      compile: new SyncHook([\"params\"]),\n      /** @type {AsyncParallelHook<[Compilation]>} */\n      make: new AsyncParallelHook([\"compilation\"]),\n      /** @type {AsyncParallelHook<[Compilation]>} */\n      finishMake: new AsyncSeriesHook([\"compilation\"]),\n      /** @type {AsyncSeriesHook<[Compilation]>} */\n      afterCompile: new AsyncSeriesHook([\"compilation\"]),\n      /** @type {AsyncSeriesHook<[]>} */\n      readRecords: new AsyncSeriesHook([]),\n      /** @type {AsyncSeriesHook<[]>} */\n      emitRecords: new AsyncSeriesHook([]),\n      /** @type {AsyncSeriesHook<[Compiler]>} */\n      watchRun: new AsyncSeriesHook([\"compiler\"]),\n      /** @type {SyncHook<[Error]>} */\n      failed: new SyncHook([\"error\"]),\n      /** @type {SyncHook<[string | null, number]>} */\n      invalid: new SyncHook([\"filename\", \"changeTime\"]),\n      /** @type {SyncHook<[]>} */\n      watchClose: new SyncHook([]),\n      /** @type {AsyncSeriesHook<[]>} */\n      shutdown: new AsyncSeriesHook([]),\n      /** @type {SyncBailHook<[string, string, any[]], true>} */\n      infrastructureLog: new SyncBailHook([\"origin\", \"type\", \"args\"]),\n      // TODO the following hooks are weirdly located here\n      // TODO move them for webpack 5\n      /** @type {SyncHook<[]>} */\n      environment: new SyncHook([]),\n      /** @type {SyncHook<[]>} */\n      afterEnvironment: new SyncHook([]),\n      /** @type {SyncHook<[Compiler]>} */\n      afterPlugins: new SyncHook([\"compiler\"]),\n      /** @type {SyncHook<[Compiler]>} */\n      afterResolvers: new SyncHook([\"compiler\"]),\n      /** @type {SyncBailHook<[string, Entry], boolean>} */\n      entryOption: new SyncBailHook([\"context\", \"entry\"])\n    });\n    this.webpack = webpack;\n\n    /** @type {string=} */\n    this.name = undefined;\n    /** @type {Compilation=} */\n    this.parentCompilation = undefined;\n    /** @type {Compiler} */\n    this.root = this;\n    /** @type {string} */\n    this.outputPath = \"\";\n    /** @type {Watching} */\n    this.watching = undefined;\n\n    /** @type {OutputFileSystem} */\n    this.outputFileSystem = null;\n    /** @type {IntermediateFileSystem} */\n    this.intermediateFileSystem = null;\n    /** @type {InputFileSystem} */\n    this.inputFileSystem = null;\n    /** @type {WatchFileSystem} */\n    this.watchFileSystem = null;\n\n    /** @type {string|null} */\n    this.recordsInputPath = null;\n    /** @type {string|null} */\n    this.recordsOutputPath = null;\n    this.records = {};\n    /** @type {Set<string | RegExp>} */\n    this.managedPaths = new Set();\n    /** @type {Set<string | RegExp>} */\n    this.immutablePaths = new Set();\n\n    /** @type {ReadonlySet<string>} */\n    this.modifiedFiles = undefined;\n    /** @type {ReadonlySet<string>} */\n    this.removedFiles = undefined;\n    /** @type {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} */\n    this.fileTimestamps = undefined;\n    /** @type {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} */\n    this.contextTimestamps = undefined;\n    /** @type {number} */\n    this.fsStartTime = undefined;\n\n    /** @type {ResolverFactory} */\n    this.resolverFactory = new ResolverFactory();\n    this.infrastructureLogger = undefined;\n    this.options = options;\n    this.context = context;\n    this.requestShortener = new RequestShortener(context, this.root);\n    this.cache = new Cache();\n\n    /** @type {Map<Module, { buildInfo: object, references: WeakMap<Dependency, Module>, memCache: WeakTupleMap }> | undefined} */\n    this.moduleMemCaches = undefined;\n    this.compilerPath = \"\";\n\n    /** @type {boolean} */\n    this.running = false;\n\n    /** @type {boolean} */\n    this.idle = false;\n\n    /** @type {boolean} */\n    this.watchMode = false;\n    this._backCompat = this.options.experiments.backCompat !== false;\n\n    /** @type {Compilation} */\n    this._lastCompilation = undefined;\n    /** @type {NormalModuleFactory} */\n    this._lastNormalModuleFactory = undefined;\n\n    /** @private @type {WeakMap<Source, { sizeOnlySource: SizeOnlySource, writtenTo: Map<string, number> }>} */\n    this._assetEmittingSourceCache = new WeakMap();\n    /** @private @type {Map<string, number>} */\n    this._assetEmittingWrittenFiles = new Map();\n    /** @private @type {Set<string>} */\n    this._assetEmittingPreviousFiles = new Set();\n  }\n\n  /**\n   * @param {string} name cache name\n   * @returns {CacheFacade} the cache facade instance\n   */\n  _createClass(Compiler, [{\n    key: \"getCache\",\n    value: function getCache(name) {\n      return new CacheFacade(this.cache, \"\".concat(this.compilerPath).concat(name), this.options.output.hashFunction);\n    }\n\n    /**\n     * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name\n     * @returns {Logger} a logger with that name\n     */\n  }, {\n    key: \"getInfrastructureLogger\",\n    value: function getInfrastructureLogger(name) {\n      var _this = this;\n      if (!name) {\n        throw new TypeError(\"Compiler.getInfrastructureLogger(name) called without a name\");\n      }\n      return new Logger(function (type, args) {\n        if (typeof name === \"function\") {\n          name = name();\n          if (!name) {\n            throw new TypeError(\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\");\n          }\n        }\n        if (_this.hooks.infrastructureLog.call(name, type, args) === undefined) {\n          if (_this.infrastructureLogger !== undefined) {\n            _this.infrastructureLogger(name, type, args);\n          }\n        }\n      }, function (childName) {\n        if (typeof name === \"function\") {\n          if (typeof childName === \"function\") {\n            return _this.getInfrastructureLogger(function () {\n              if (typeof name === \"function\") {\n                name = name();\n                if (!name) {\n                  throw new TypeError(\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\");\n                }\n              }\n              if (typeof childName === \"function\") {\n                childName = childName();\n                if (!childName) {\n                  throw new TypeError(\"Logger.getChildLogger(name) called with a function not returning a name\");\n                }\n              }\n              return \"\".concat(name, \"/\").concat(childName);\n            });\n          } else {\n            return _this.getInfrastructureLogger(function () {\n              if (typeof name === \"function\") {\n                name = name();\n                if (!name) {\n                  throw new TypeError(\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\");\n                }\n              }\n              return \"\".concat(name, \"/\").concat(childName);\n            });\n          }\n        } else {\n          if (typeof childName === \"function\") {\n            return _this.getInfrastructureLogger(function () {\n              if (typeof childName === \"function\") {\n                childName = childName();\n                if (!childName) {\n                  throw new TypeError(\"Logger.getChildLogger(name) called with a function not returning a name\");\n                }\n              }\n              return \"\".concat(name, \"/\").concat(childName);\n            });\n          } else {\n            return _this.getInfrastructureLogger(\"\".concat(name, \"/\").concat(childName));\n          }\n        }\n      });\n    }\n\n    // TODO webpack 6: solve this in a better way\n    // e.g. move compilation specific info from Modules into ModuleGraph\n  }, {\n    key: \"_cleanupLastCompilation\",\n    value: function _cleanupLastCompilation() {\n      if (this._lastCompilation !== undefined) {\n        var _iterator2 = _createForOfIteratorHelper(this._lastCompilation.modules),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _module = _step2.value;\n            ChunkGraph.clearChunkGraphForModule(_module);\n            ModuleGraph.clearModuleGraphForModule(_module);\n            _module.cleanupForCache();\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        var _iterator3 = _createForOfIteratorHelper(this._lastCompilation.chunks),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var chunk = _step3.value;\n            ChunkGraph.clearChunkGraphForChunk(chunk);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        this._lastCompilation = undefined;\n      }\n    }\n\n    // TODO webpack 6: solve this in a better way\n  }, {\n    key: \"_cleanupLastNormalModuleFactory\",\n    value: function _cleanupLastNormalModuleFactory() {\n      if (this._lastNormalModuleFactory !== undefined) {\n        this._lastNormalModuleFactory.cleanupForCache();\n        this._lastNormalModuleFactory = undefined;\n      }\n    }\n\n    /**\n     * @param {WatchOptions} watchOptions the watcher's options\n     * @param {Callback<Stats>} handler signals when the call finishes\n     * @returns {Watching} a compiler watcher\n     */\n  }, {\n    key: \"watch\",\n    value: function watch(watchOptions, handler) {\n      if (this.running) {\n        return handler(new ConcurrentCompilationError());\n      }\n      this.running = true;\n      this.watchMode = true;\n      this.watching = new Watching(this, watchOptions, handler);\n      return this.watching;\n    }\n\n    /**\n     * @param {Callback<Stats>} callback signals when the call finishes\n     * @returns {void}\n     */\n  }, {\n    key: \"run\",\n    value: function run(callback) {\n      var _this2 = this;\n      if (this.running) {\n        return callback(new ConcurrentCompilationError());\n      }\n      var logger;\n      var finalCallback = function finalCallback(err, stats) {\n        if (logger) logger.time(\"beginIdle\");\n        _this2.idle = true;\n        _this2.cache.beginIdle();\n        _this2.idle = true;\n        if (logger) logger.timeEnd(\"beginIdle\");\n        _this2.running = false;\n        if (err) {\n          _this2.hooks.failed.call(err);\n        }\n        if (callback !== undefined) callback(err, stats);\n        _this2.hooks.afterDone.call(stats);\n      };\n      var startTime = Date.now();\n      this.running = true;\n      var onCompiled = function onCompiled(err, compilation) {\n        if (err) return finalCallback(err);\n        if (_this2.hooks.shouldEmit.call(compilation) === false) {\n          compilation.startTime = startTime;\n          compilation.endTime = Date.now();\n          var stats = new Stats(compilation);\n          _this2.hooks.done.callAsync(stats, function (err) {\n            if (err) return finalCallback(err);\n            return finalCallback(null, stats);\n          });\n          return;\n        }\n        process.nextTick(function () {\n          logger = compilation.getLogger(\"webpack.Compiler\");\n          logger.time(\"emitAssets\");\n          _this2.emitAssets(compilation, function (err) {\n            logger.timeEnd(\"emitAssets\");\n            if (err) return finalCallback(err);\n            if (compilation.hooks.needAdditionalPass.call()) {\n              compilation.needAdditionalPass = true;\n              compilation.startTime = startTime;\n              compilation.endTime = Date.now();\n              logger.time(\"done hook\");\n              var _stats = new Stats(compilation);\n              _this2.hooks.done.callAsync(_stats, function (err) {\n                logger.timeEnd(\"done hook\");\n                if (err) return finalCallback(err);\n                _this2.hooks.additionalPass.callAsync(function (err) {\n                  if (err) return finalCallback(err);\n                  _this2.compile(onCompiled);\n                });\n              });\n              return;\n            }\n            logger.time(\"emitRecords\");\n            _this2.emitRecords(function (err) {\n              logger.timeEnd(\"emitRecords\");\n              if (err) return finalCallback(err);\n              compilation.startTime = startTime;\n              compilation.endTime = Date.now();\n              logger.time(\"done hook\");\n              var stats = new Stats(compilation);\n              _this2.hooks.done.callAsync(stats, function (err) {\n                logger.timeEnd(\"done hook\");\n                if (err) return finalCallback(err);\n                _this2.cache.storeBuildDependencies(compilation.buildDependencies, function (err) {\n                  if (err) return finalCallback(err);\n                  return finalCallback(null, stats);\n                });\n              });\n            });\n          });\n        });\n      };\n      var run = function run() {\n        _this2.hooks.beforeRun.callAsync(_this2, function (err) {\n          if (err) return finalCallback(err);\n          _this2.hooks.run.callAsync(_this2, function (err) {\n            if (err) return finalCallback(err);\n            _this2.readRecords(function (err) {\n              if (err) return finalCallback(err);\n              _this2.compile(onCompiled);\n            });\n          });\n        });\n      };\n      if (this.idle) {\n        this.cache.endIdle(function (err) {\n          if (err) return finalCallback(err);\n          _this2.idle = false;\n          run();\n        });\n      } else {\n        run();\n      }\n    }\n\n    /**\n     * @param {RunAsChildCallback} callback signals when the call finishes\n     * @returns {void}\n     */\n  }, {\n    key: \"runAsChild\",\n    value: function runAsChild(callback) {\n      var _this3 = this;\n      var startTime = Date.now();\n      var finalCallback = function finalCallback(err, entries, compilation) {\n        try {\n          callback(err, entries, compilation);\n        } catch (e) {\n          var _err = new WebpackError(\"compiler.runAsChild callback error: \".concat(e));\n          _err.details = e.stack;\n          _this3.parentCompilation.errors.push(_err);\n        }\n      };\n      this.compile(function (err, compilation) {\n        if (err) return finalCallback(err);\n        _this3.parentCompilation.children.push(compilation);\n        var _iterator4 = _createForOfIteratorHelper(compilation.getAssets()),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _step4$value = _step4.value,\n              name = _step4$value.name,\n              source = _step4$value.source,\n              info = _step4$value.info;\n            _this3.parentCompilation.emitAsset(name, source, info);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n        var entries = [];\n        var _iterator5 = _createForOfIteratorHelper(compilation.entrypoints.values()),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var ep = _step5.value;\n            entries.push.apply(entries, _toConsumableArray(ep.chunks));\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n        compilation.startTime = startTime;\n        compilation.endTime = Date.now();\n        return finalCallback(null, entries, compilation);\n      });\n    }\n  }, {\n    key: \"purgeInputFileSystem\",\n    value: function purgeInputFileSystem() {\n      if (this.inputFileSystem && this.inputFileSystem.purge) {\n        this.inputFileSystem.purge();\n      }\n    }\n\n    /**\n     * @param {Compilation} compilation the compilation\n     * @param {Callback<void>} callback signals when the assets are emitted\n     * @returns {void}\n     */\n  }, {\n    key: \"emitAssets\",\n    value: function emitAssets(compilation, callback) {\n      var _this4 = this;\n      var outputPath;\n      var emitFiles = function emitFiles(err) {\n        if (err) return callback(err);\n        var assets = compilation.getAssets();\n        compilation.assets = _objectSpread({}, compilation.assets);\n        /** @type {Map<string, { path: string, source: Source, size: number, waiting: { cacheEntry: any, file: string }[] }>} */\n        var caseInsensitiveMap = new Map();\n        /** @type {Set<string>} */\n        var allTargetPaths = new Set();\n        asyncLib.forEachLimit(assets, 15, function (_ref, callback) {\n          var file = _ref.name,\n            source = _ref.source,\n            info = _ref.info;\n          var targetFile = file;\n          var immutable = info.immutable;\n          var queryStringIdx = targetFile.indexOf(\"?\");\n          if (queryStringIdx >= 0) {\n            targetFile = targetFile.slice(0, queryStringIdx);\n            // We may remove the hash, which is in the query string\n            // So we recheck if the file is immutable\n            // This doesn't cover all cases, but immutable is only a performance optimization anyway\n            immutable = immutable && (includesHash(targetFile, info.contenthash) || includesHash(targetFile, info.chunkhash) || includesHash(targetFile, info.modulehash) || includesHash(targetFile, info.fullhash));\n          }\n          var writeOut = function writeOut(err) {\n            if (err) return callback(err);\n            var targetPath = join(_this4.outputFileSystem, outputPath, targetFile);\n            allTargetPaths.add(targetPath);\n\n            // check if the target file has already been written by this Compiler\n            var targetFileGeneration = _this4._assetEmittingWrittenFiles.get(targetPath);\n\n            // create an cache entry for this Source if not already existing\n            var cacheEntry = _this4._assetEmittingSourceCache.get(source);\n            if (cacheEntry === undefined) {\n              cacheEntry = {\n                sizeOnlySource: undefined,\n                writtenTo: new Map()\n              };\n              _this4._assetEmittingSourceCache.set(source, cacheEntry);\n            }\n            var similarEntry;\n            var checkSimilarFile = function checkSimilarFile() {\n              var caseInsensitiveTargetPath = targetPath.toLowerCase();\n              similarEntry = caseInsensitiveMap.get(caseInsensitiveTargetPath);\n              if (similarEntry !== undefined) {\n                var _similarEntry = similarEntry,\n                  other = _similarEntry.path,\n                  otherSource = _similarEntry.source;\n                if (isSourceEqual(otherSource, source)) {\n                  // Size may or may not be available at this point.\n                  // If it's not available add to \"waiting\" list and it will be updated once available\n                  if (similarEntry.size !== undefined) {\n                    updateWithReplacementSource(similarEntry.size);\n                  } else {\n                    if (!similarEntry.waiting) similarEntry.waiting = [];\n                    similarEntry.waiting.push({\n                      file: file,\n                      cacheEntry: cacheEntry\n                    });\n                  }\n                  alreadyWritten();\n                } else {\n                  var _err2 = new WebpackError(\"Prevent writing to file that only differs in casing or query string from already written file.\\nThis will lead to a race-condition and corrupted files on case-insensitive file systems.\\n\".concat(targetPath, \"\\n\").concat(other));\n                  _err2.file = file;\n                  callback(_err2);\n                }\n                return true;\n              } else {\n                caseInsensitiveMap.set(caseInsensitiveTargetPath, similarEntry = {\n                  path: targetPath,\n                  source: source,\n                  size: undefined,\n                  waiting: undefined\n                });\n                return false;\n              }\n            };\n\n            /**\n             * get the binary (Buffer) content from the Source\n             * @returns {Buffer} content for the source\n             */\n            var getContent = function getContent() {\n              if (typeof source.buffer === \"function\") {\n                return source.buffer();\n              } else {\n                var bufferOrString = source.source();\n                if (Buffer.isBuffer(bufferOrString)) {\n                  return bufferOrString;\n                } else {\n                  return Buffer.from(bufferOrString, \"utf8\");\n                }\n              }\n            };\n            var alreadyWritten = function alreadyWritten() {\n              // cache the information that the Source has been already been written to that location\n              if (targetFileGeneration === undefined) {\n                var newGeneration = 1;\n                _this4._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n                cacheEntry.writtenTo.set(targetPath, newGeneration);\n              } else {\n                cacheEntry.writtenTo.set(targetPath, targetFileGeneration);\n              }\n              callback();\n            };\n\n            /**\n             * Write the file to output file system\n             * @param {Buffer} content content to be written\n             * @returns {void}\n             */\n            var doWrite = function doWrite(content) {\n              _this4.outputFileSystem.writeFile(targetPath, content, function (err) {\n                if (err) return callback(err);\n\n                // information marker that the asset has been emitted\n                compilation.emittedAssets.add(file);\n\n                // cache the information that the Source has been written to that location\n                var newGeneration = targetFileGeneration === undefined ? 1 : targetFileGeneration + 1;\n                cacheEntry.writtenTo.set(targetPath, newGeneration);\n                _this4._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n                _this4.hooks.assetEmitted.callAsync(file, {\n                  content: content,\n                  source: source,\n                  outputPath: outputPath,\n                  compilation: compilation,\n                  targetPath: targetPath\n                }, callback);\n              });\n            };\n            var updateWithReplacementSource = function updateWithReplacementSource(size) {\n              updateFileWithReplacementSource(file, cacheEntry, size);\n              similarEntry.size = size;\n              if (similarEntry.waiting !== undefined) {\n                var _iterator6 = _createForOfIteratorHelper(similarEntry.waiting),\n                  _step6;\n                try {\n                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                    var _step6$value = _step6.value,\n                      _file = _step6$value.file,\n                      _cacheEntry = _step6$value.cacheEntry;\n                    updateFileWithReplacementSource(_file, _cacheEntry, size);\n                  }\n                } catch (err) {\n                  _iterator6.e(err);\n                } finally {\n                  _iterator6.f();\n                }\n              }\n            };\n            var updateFileWithReplacementSource = function updateFileWithReplacementSource(file, cacheEntry, size) {\n              // Create a replacement resource which only allows to ask for size\n              // This allows to GC all memory allocated by the Source\n              // (expect when the Source is stored in any other cache)\n              if (!cacheEntry.sizeOnlySource) {\n                cacheEntry.sizeOnlySource = new SizeOnlySource(size);\n              }\n              compilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n                size: size\n              });\n            };\n            var processExistingFile = function processExistingFile(stats) {\n              // skip emitting if it's already there and an immutable file\n              if (immutable) {\n                updateWithReplacementSource(stats.size);\n                return alreadyWritten();\n              }\n              var content = getContent();\n              updateWithReplacementSource(content.length);\n\n              // if it exists and content on disk matches content\n              // skip writing the same content again\n              // (to keep mtime and don't trigger watchers)\n              // for a fast negative match file size is compared first\n              if (content.length === stats.size) {\n                compilation.comparedForEmitAssets.add(file);\n                return _this4.outputFileSystem.readFile(targetPath, function (err, existingContent) {\n                  if (err || !content.equals( /** @type {Buffer} */existingContent)) {\n                    return doWrite(content);\n                  } else {\n                    return alreadyWritten();\n                  }\n                });\n              }\n              return doWrite(content);\n            };\n            var processMissingFile = function processMissingFile() {\n              var content = getContent();\n              updateWithReplacementSource(content.length);\n              return doWrite(content);\n            };\n\n            // if the target file has already been written\n            if (targetFileGeneration !== undefined) {\n              // check if the Source has been written to this target file\n              var writtenGeneration = cacheEntry.writtenTo.get(targetPath);\n              if (writtenGeneration === targetFileGeneration) {\n                // if yes, we may skip writing the file\n                // if it's already there\n                // (we assume one doesn't modify files while the Compiler is running, other then removing them)\n\n                if (_this4._assetEmittingPreviousFiles.has(targetPath)) {\n                  // We assume that assets from the last compilation say intact on disk (they are not removed)\n                  compilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n                    size: cacheEntry.sizeOnlySource.size()\n                  });\n                  return callback();\n                } else {\n                  // Settings immutable will make it accept file content without comparing when file exist\n                  immutable = true;\n                }\n              } else if (!immutable) {\n                if (checkSimilarFile()) return;\n                // We wrote to this file before which has very likely a different content\n                // skip comparing and assume content is different for performance\n                // This case happens often during watch mode.\n                return processMissingFile();\n              }\n            }\n            if (checkSimilarFile()) return;\n            if (_this4.options.output.compareBeforeEmit) {\n              _this4.outputFileSystem.stat(targetPath, function (err, stats) {\n                var exists = !err && stats.isFile();\n                if (exists) {\n                  processExistingFile(stats);\n                } else {\n                  processMissingFile();\n                }\n              });\n            } else {\n              processMissingFile();\n            }\n          };\n          if (targetFile.match(/\\/|\\\\/)) {\n            var fs = _this4.outputFileSystem;\n            var dir = dirname(fs, join(fs, outputPath, targetFile));\n            mkdirp(fs, dir, writeOut);\n          } else {\n            writeOut();\n          }\n        }, function (err) {\n          // Clear map to free up memory\n          caseInsensitiveMap.clear();\n          if (err) {\n            _this4._assetEmittingPreviousFiles.clear();\n            return callback(err);\n          }\n          _this4._assetEmittingPreviousFiles = allTargetPaths;\n          _this4.hooks.afterEmit.callAsync(compilation, function (err) {\n            if (err) return callback(err);\n            return callback();\n          });\n        });\n      };\n      this.hooks.emit.callAsync(compilation, function (err) {\n        if (err) return callback(err);\n        outputPath = compilation.getPath(_this4.outputPath, {});\n        mkdirp(_this4.outputFileSystem, outputPath, emitFiles);\n      });\n    }\n\n    /**\n     * @param {Callback<void>} callback signals when the call finishes\n     * @returns {void}\n     */\n  }, {\n    key: \"emitRecords\",\n    value: function emitRecords(callback) {\n      var _this5 = this;\n      if (this.hooks.emitRecords.isUsed()) {\n        if (this.recordsOutputPath) {\n          asyncLib.parallel([function (cb) {\n            return _this5.hooks.emitRecords.callAsync(cb);\n          }, this._emitRecords.bind(this)], function (err) {\n            return callback(err);\n          });\n        } else {\n          this.hooks.emitRecords.callAsync(callback);\n        }\n      } else {\n        if (this.recordsOutputPath) {\n          this._emitRecords(callback);\n        } else {\n          callback();\n        }\n      }\n    }\n\n    /**\n     * @param {Callback<void>} callback signals when the call finishes\n     * @returns {void}\n     */\n  }, {\n    key: \"_emitRecords\",\n    value: function _emitRecords(callback) {\n      var _this6 = this;\n      var writeFile = function writeFile() {\n        _this6.outputFileSystem.writeFile(_this6.recordsOutputPath, JSON.stringify(_this6.records, function (n, value) {\n          if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n            var keys = Object.keys(value);\n            if (!isSorted(keys)) {\n              return sortObject(value, keys);\n            }\n          }\n          return value;\n        }, 2), callback);\n      };\n      var recordsOutputPathDirectory = dirname(this.outputFileSystem, this.recordsOutputPath);\n      if (!recordsOutputPathDirectory) {\n        return writeFile();\n      }\n      mkdirp(this.outputFileSystem, recordsOutputPathDirectory, function (err) {\n        if (err) return callback(err);\n        writeFile();\n      });\n    }\n\n    /**\n     * @param {Callback<void>} callback signals when the call finishes\n     * @returns {void}\n     */\n  }, {\n    key: \"readRecords\",\n    value: function readRecords(callback) {\n      var _this7 = this;\n      if (this.hooks.readRecords.isUsed()) {\n        if (this.recordsInputPath) {\n          asyncLib.parallel([function (cb) {\n            return _this7.hooks.readRecords.callAsync(cb);\n          }, this._readRecords.bind(this)]);\n        } else {\n          this.records = {};\n          this.hooks.readRecords.callAsync(callback);\n        }\n      } else {\n        if (this.recordsInputPath) {\n          this._readRecords(callback);\n        } else {\n          this.records = {};\n          callback();\n        }\n      }\n    }\n\n    /**\n     * @param {Callback<void>} callback signals when the call finishes\n     * @returns {void}\n     */\n  }, {\n    key: \"_readRecords\",\n    value: function _readRecords(callback) {\n      var _this8 = this;\n      if (!this.recordsInputPath) {\n        this.records = {};\n        return callback();\n      }\n      this.inputFileSystem.stat(this.recordsInputPath, function (err) {\n        // It doesn't exist\n        // We can ignore this.\n        if (err) return callback();\n        _this8.inputFileSystem.readFile(_this8.recordsInputPath, function (err, content) {\n          if (err) return callback(err);\n          try {\n            _this8.records = parseJson(content.toString(\"utf-8\"));\n          } catch (e) {\n            e.message = \"Cannot parse records: \" + e.message;\n            return callback(e);\n          }\n          return callback();\n        });\n      });\n    }\n\n    /**\n     * @param {Compilation} compilation the compilation\n     * @param {string} compilerName the compiler's name\n     * @param {number} compilerIndex the compiler's index\n     * @param {OutputOptions=} outputOptions the output options\n     * @param {WebpackPluginInstance[]=} plugins the plugins to apply\n     * @returns {Compiler} a child compiler\n     */\n  }, {\n    key: \"createChildCompiler\",\n    value: function createChildCompiler(compilation, compilerName, compilerIndex, outputOptions, plugins) {\n      var childCompiler = new Compiler(this.context, _objectSpread(_objectSpread({}, this.options), {}, {\n        output: _objectSpread(_objectSpread({}, this.options.output), outputOptions)\n      }));\n      childCompiler.name = compilerName;\n      childCompiler.outputPath = this.outputPath;\n      childCompiler.inputFileSystem = this.inputFileSystem;\n      childCompiler.outputFileSystem = null;\n      childCompiler.resolverFactory = this.resolverFactory;\n      childCompiler.modifiedFiles = this.modifiedFiles;\n      childCompiler.removedFiles = this.removedFiles;\n      childCompiler.fileTimestamps = this.fileTimestamps;\n      childCompiler.contextTimestamps = this.contextTimestamps;\n      childCompiler.fsStartTime = this.fsStartTime;\n      childCompiler.cache = this.cache;\n      childCompiler.compilerPath = \"\".concat(this.compilerPath).concat(compilerName, \"|\").concat(compilerIndex, \"|\");\n      childCompiler._backCompat = this._backCompat;\n      var relativeCompilerName = makePathsRelative(this.context, compilerName, this.root);\n      if (!this.records[relativeCompilerName]) {\n        this.records[relativeCompilerName] = [];\n      }\n      if (this.records[relativeCompilerName][compilerIndex]) {\n        childCompiler.records = this.records[relativeCompilerName][compilerIndex];\n      } else {\n        this.records[relativeCompilerName].push(childCompiler.records = {});\n      }\n      childCompiler.parentCompilation = compilation;\n      childCompiler.root = this.root;\n      if (Array.isArray(plugins)) {\n        var _iterator7 = _createForOfIteratorHelper(plugins),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var plugin = _step7.value;\n            plugin.apply(childCompiler);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n      for (var name in this.hooks) {\n        if (![\"make\", \"compile\", \"emit\", \"afterEmit\", \"invalid\", \"done\", \"thisCompilation\"].includes(name)) {\n          if (childCompiler.hooks[name]) {\n            childCompiler.hooks[name].taps = this.hooks[name].taps.slice();\n          }\n        }\n      }\n      compilation.hooks.childCompiler.call(childCompiler, compilerName, compilerIndex);\n      return childCompiler;\n    }\n  }, {\n    key: \"isChild\",\n    value: function isChild() {\n      return !!this.parentCompilation;\n    }\n  }, {\n    key: \"createCompilation\",\n    value: function createCompilation(params) {\n      this._cleanupLastCompilation();\n      return this._lastCompilation = new Compilation(this, params);\n    }\n\n    /**\n     * @param {CompilationParams} params the compilation parameters\n     * @returns {Compilation} the created compilation\n     */\n  }, {\n    key: \"newCompilation\",\n    value: function newCompilation(params) {\n      var compilation = this.createCompilation(params);\n      compilation.name = this.name;\n      compilation.records = this.records;\n      this.hooks.thisCompilation.call(compilation, params);\n      this.hooks.compilation.call(compilation, params);\n      return compilation;\n    }\n  }, {\n    key: \"createNormalModuleFactory\",\n    value: function createNormalModuleFactory() {\n      this._cleanupLastNormalModuleFactory();\n      var normalModuleFactory = new NormalModuleFactory({\n        context: this.options.context,\n        fs: this.inputFileSystem,\n        resolverFactory: this.resolverFactory,\n        options: this.options.module,\n        associatedObjectForCache: this.root,\n        layers: this.options.experiments.layers\n      });\n      this._lastNormalModuleFactory = normalModuleFactory;\n      this.hooks.normalModuleFactory.call(normalModuleFactory);\n      return normalModuleFactory;\n    }\n  }, {\n    key: \"createContextModuleFactory\",\n    value: function createContextModuleFactory() {\n      var contextModuleFactory = new ContextModuleFactory(this.resolverFactory);\n      this.hooks.contextModuleFactory.call(contextModuleFactory);\n      return contextModuleFactory;\n    }\n  }, {\n    key: \"newCompilationParams\",\n    value: function newCompilationParams() {\n      var params = {\n        normalModuleFactory: this.createNormalModuleFactory(),\n        contextModuleFactory: this.createContextModuleFactory()\n      };\n      return params;\n    }\n\n    /**\n     * @param {Callback<Compilation>} callback signals when the compilation finishes\n     * @returns {void}\n     */\n  }, {\n    key: \"compile\",\n    value: function compile(callback) {\n      var _this9 = this;\n      var params = this.newCompilationParams();\n      this.hooks.beforeCompile.callAsync(params, function (err) {\n        if (err) return callback(err);\n        _this9.hooks.compile.call(params);\n        var compilation = _this9.newCompilation(params);\n        var logger = compilation.getLogger(\"webpack.Compiler\");\n        logger.time(\"make hook\");\n        _this9.hooks.make.callAsync(compilation, function (err) {\n          logger.timeEnd(\"make hook\");\n          if (err) return callback(err);\n          logger.time(\"finish make hook\");\n          _this9.hooks.finishMake.callAsync(compilation, function (err) {\n            logger.timeEnd(\"finish make hook\");\n            if (err) return callback(err);\n            process.nextTick(function () {\n              logger.time(\"finish compilation\");\n              compilation.finish(function (err) {\n                logger.timeEnd(\"finish compilation\");\n                if (err) return callback(err);\n                logger.time(\"seal compilation\");\n                compilation.seal(function (err) {\n                  logger.timeEnd(\"seal compilation\");\n                  if (err) return callback(err);\n                  logger.time(\"afterCompile hook\");\n                  _this9.hooks.afterCompile.callAsync(compilation, function (err) {\n                    logger.timeEnd(\"afterCompile hook\");\n                    if (err) return callback(err);\n                    return callback(null, compilation);\n                  });\n                });\n              });\n            });\n          });\n        });\n      });\n    }\n\n    /**\n     * @param {Callback<void>} callback signals when the compiler closes\n     * @returns {void}\n     */\n  }, {\n    key: \"close\",\n    value: function close(callback) {\n      var _this10 = this;\n      if (this.watching) {\n        // When there is still an active watching, close this first\n        this.watching.close(function (err) {\n          _this10.close(callback);\n        });\n        return;\n      }\n      this.hooks.shutdown.callAsync(function (err) {\n        if (err) return callback(err);\n        // Get rid of reference to last compilation to avoid leaking memory\n        // We can't run this._cleanupLastCompilation() as the Stats to this compilation\n        // might be still in use. We try to get rid of the reference to the cache instead.\n        _this10._lastCompilation = undefined;\n        _this10._lastNormalModuleFactory = undefined;\n        _this10.cache.shutdown(callback);\n      });\n    }\n  }]);\n  return Compiler;\n}();\nmodule.exports = Compiler;","map":{"version":3,"names":["parseJson","require","asyncLib","SyncHook","SyncBailHook","AsyncParallelHook","AsyncSeriesHook","SizeOnlySource","webpack","Cache","CacheFacade","ChunkGraph","Compilation","ConcurrentCompilationError","ContextModuleFactory","ModuleGraph","NormalModuleFactory","RequestShortener","ResolverFactory","Stats","Watching","WebpackError","Logger","join","dirname","mkdirp","makePathsRelative","isSourceEqual","isSorted","array","i","length","sortObject","obj","keys","o","sort","k","includesHash","filename","hashes","Array","isArray","some","hash","includes","Compiler","context","options","hooks","Object","freeze","initialize","shouldEmit","done","afterDone","additionalPass","beforeRun","run","emit","assetEmitted","afterEmit","thisCompilation","compilation","normalModuleFactory","contextModuleFactory","beforeCompile","compile","make","finishMake","afterCompile","readRecords","emitRecords","watchRun","failed","invalid","watchClose","shutdown","infrastructureLog","environment","afterEnvironment","afterPlugins","afterResolvers","entryOption","name","undefined","parentCompilation","root","outputPath","watching","outputFileSystem","intermediateFileSystem","inputFileSystem","watchFileSystem","recordsInputPath","recordsOutputPath","records","managedPaths","Set","immutablePaths","modifiedFiles","removedFiles","fileTimestamps","contextTimestamps","fsStartTime","resolverFactory","infrastructureLogger","requestShortener","cache","moduleMemCaches","compilerPath","running","idle","watchMode","_backCompat","experiments","backCompat","_lastCompilation","_lastNormalModuleFactory","_assetEmittingSourceCache","WeakMap","_assetEmittingWrittenFiles","Map","_assetEmittingPreviousFiles","output","hashFunction","TypeError","type","args","call","childName","getInfrastructureLogger","modules","module","clearChunkGraphForModule","clearModuleGraphForModule","cleanupForCache","chunks","chunk","clearChunkGraphForChunk","watchOptions","handler","callback","logger","finalCallback","err","stats","time","beginIdle","timeEnd","startTime","Date","now","onCompiled","endTime","callAsync","process","nextTick","getLogger","emitAssets","needAdditionalPass","storeBuildDependencies","buildDependencies","endIdle","entries","e","details","stack","errors","push","children","getAssets","source","info","emitAsset","entrypoints","values","ep","purge","emitFiles","assets","caseInsensitiveMap","allTargetPaths","forEachLimit","file","targetFile","immutable","queryStringIdx","indexOf","slice","contenthash","chunkhash","modulehash","fullhash","writeOut","targetPath","add","targetFileGeneration","get","cacheEntry","sizeOnlySource","writtenTo","set","similarEntry","checkSimilarFile","caseInsensitiveTargetPath","toLowerCase","other","path","otherSource","size","updateWithReplacementSource","waiting","alreadyWritten","getContent","buffer","bufferOrString","Buffer","isBuffer","from","newGeneration","doWrite","content","writeFile","emittedAssets","updateFileWithReplacementSource","updateAsset","processExistingFile","comparedForEmitAssets","readFile","existingContent","equals","processMissingFile","writtenGeneration","has","compareBeforeEmit","stat","exists","isFile","match","fs","dir","clear","getPath","isUsed","parallel","cb","_emitRecords","bind","JSON","stringify","n","value","recordsOutputPathDirectory","_readRecords","toString","message","compilerName","compilerIndex","outputOptions","plugins","childCompiler","relativeCompilerName","plugin","apply","taps","params","_cleanupLastCompilation","createCompilation","_cleanupLastNormalModuleFactory","associatedObjectForCache","layers","createNormalModuleFactory","createContextModuleFactory","newCompilationParams","newCompilation","finish","seal","close","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/Compiler.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst parseJson = require(\"json-parse-even-better-errors\");\nconst asyncLib = require(\"neo-async\");\nconst {\n\tSyncHook,\n\tSyncBailHook,\n\tAsyncParallelHook,\n\tAsyncSeriesHook\n} = require(\"tapable\");\nconst { SizeOnlySource } = require(\"webpack-sources\");\nconst webpack = require(\"./\");\nconst Cache = require(\"./Cache\");\nconst CacheFacade = require(\"./CacheFacade\");\nconst ChunkGraph = require(\"./ChunkGraph\");\nconst Compilation = require(\"./Compilation\");\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\nconst ContextModuleFactory = require(\"./ContextModuleFactory\");\nconst ModuleGraph = require(\"./ModuleGraph\");\nconst NormalModuleFactory = require(\"./NormalModuleFactory\");\nconst RequestShortener = require(\"./RequestShortener\");\nconst ResolverFactory = require(\"./ResolverFactory\");\nconst Stats = require(\"./Stats\");\nconst Watching = require(\"./Watching\");\nconst WebpackError = require(\"./WebpackError\");\nconst { Logger } = require(\"./logging/Logger\");\nconst { join, dirname, mkdirp } = require(\"./util/fs\");\nconst { makePathsRelative } = require(\"./util/identifier\");\nconst { isSourceEqual } = require(\"./util/source\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../declarations/WebpackOptions\").EntryNormalized} Entry */\n/** @typedef {import(\"../declarations/WebpackOptions\").OutputNormalized} OutputOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackOptionsNormalized} WebpackOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackPluginInstance} WebpackPluginInstance */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./FileSystemInfo\").FileSystemInfoEntry} FileSystemInfoEntry */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./util/WeakTupleMap\")} WeakTupleMap */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @typedef {Object} CompilationParams\n * @property {NormalModuleFactory} normalModuleFactory\n * @property {ContextModuleFactory} contextModuleFactory\n */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n/**\n * @callback RunAsChildCallback\n * @param {(Error | null)=} err\n * @param {Chunk[]=} entries\n * @param {Compilation=} compilation\n */\n\n/**\n * @typedef {Object} AssetEmittedInfo\n * @property {Buffer} content\n * @property {Source} source\n * @property {Compilation} compilation\n * @property {string} outputPath\n * @property {string} targetPath\n */\n\n/**\n * @param {string[]} array an array\n * @returns {boolean} true, if the array is sorted\n */\nconst isSorted = array => {\n\tfor (let i = 1; i < array.length; i++) {\n\t\tif (array[i - 1] > array[i]) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {Object} obj an object\n * @param {string[]} keys the keys of the object\n * @returns {Object} the object with properties sorted by property name\n */\nconst sortObject = (obj, keys) => {\n\tconst o = {};\n\tfor (const k of keys.sort()) {\n\t\to[k] = obj[k];\n\t}\n\treturn o;\n};\n\n/**\n * @param {string} filename filename\n * @param {string | string[] | undefined} hashes list of hashes\n * @returns {boolean} true, if the filename contains any hash\n */\nconst includesHash = (filename, hashes) => {\n\tif (!hashes) return false;\n\tif (Array.isArray(hashes)) {\n\t\treturn hashes.some(hash => filename.includes(hash));\n\t} else {\n\t\treturn filename.includes(hashes);\n\t}\n};\n\nclass Compiler {\n\t/**\n\t * @param {string} context the compilation path\n\t * @param {WebpackOptions} options options\n\t */\n\tconstructor(context, options = /** @type {WebpackOptions} */ ({})) {\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\tinitialize: new SyncHook([]),\n\n\t\t\t/** @type {SyncBailHook<[Compilation], boolean>} */\n\t\t\tshouldEmit: new SyncBailHook([\"compilation\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Stats]>} */\n\t\t\tdone: new AsyncSeriesHook([\"stats\"]),\n\t\t\t/** @type {SyncHook<[Stats]>} */\n\t\t\tafterDone: new SyncHook([\"stats\"]),\n\t\t\t/** @type {AsyncSeriesHook<[]>} */\n\t\t\tadditionalPass: new AsyncSeriesHook([]),\n\t\t\t/** @type {AsyncSeriesHook<[Compiler]>} */\n\t\t\tbeforeRun: new AsyncSeriesHook([\"compiler\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Compiler]>} */\n\t\t\trun: new AsyncSeriesHook([\"compiler\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Compilation]>} */\n\t\t\temit: new AsyncSeriesHook([\"compilation\"]),\n\t\t\t/** @type {AsyncSeriesHook<[string, AssetEmittedInfo]>} */\n\t\t\tassetEmitted: new AsyncSeriesHook([\"file\", \"info\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Compilation]>} */\n\t\t\tafterEmit: new AsyncSeriesHook([\"compilation\"]),\n\n\t\t\t/** @type {SyncHook<[Compilation, CompilationParams]>} */\n\t\t\tthisCompilation: new SyncHook([\"compilation\", \"params\"]),\n\t\t\t/** @type {SyncHook<[Compilation, CompilationParams]>} */\n\t\t\tcompilation: new SyncHook([\"compilation\", \"params\"]),\n\t\t\t/** @type {SyncHook<[NormalModuleFactory]>} */\n\t\t\tnormalModuleFactory: new SyncHook([\"normalModuleFactory\"]),\n\t\t\t/** @type {SyncHook<[ContextModuleFactory]>}  */\n\t\t\tcontextModuleFactory: new SyncHook([\"contextModuleFactory\"]),\n\n\t\t\t/** @type {AsyncSeriesHook<[CompilationParams]>} */\n\t\t\tbeforeCompile: new AsyncSeriesHook([\"params\"]),\n\t\t\t/** @type {SyncHook<[CompilationParams]>} */\n\t\t\tcompile: new SyncHook([\"params\"]),\n\t\t\t/** @type {AsyncParallelHook<[Compilation]>} */\n\t\t\tmake: new AsyncParallelHook([\"compilation\"]),\n\t\t\t/** @type {AsyncParallelHook<[Compilation]>} */\n\t\t\tfinishMake: new AsyncSeriesHook([\"compilation\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Compilation]>} */\n\t\t\tafterCompile: new AsyncSeriesHook([\"compilation\"]),\n\n\t\t\t/** @type {AsyncSeriesHook<[]>} */\n\t\t\treadRecords: new AsyncSeriesHook([]),\n\t\t\t/** @type {AsyncSeriesHook<[]>} */\n\t\t\temitRecords: new AsyncSeriesHook([]),\n\n\t\t\t/** @type {AsyncSeriesHook<[Compiler]>} */\n\t\t\twatchRun: new AsyncSeriesHook([\"compiler\"]),\n\t\t\t/** @type {SyncHook<[Error]>} */\n\t\t\tfailed: new SyncHook([\"error\"]),\n\t\t\t/** @type {SyncHook<[string | null, number]>} */\n\t\t\tinvalid: new SyncHook([\"filename\", \"changeTime\"]),\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\twatchClose: new SyncHook([]),\n\t\t\t/** @type {AsyncSeriesHook<[]>} */\n\t\t\tshutdown: new AsyncSeriesHook([]),\n\n\t\t\t/** @type {SyncBailHook<[string, string, any[]], true>} */\n\t\t\tinfrastructureLog: new SyncBailHook([\"origin\", \"type\", \"args\"]),\n\n\t\t\t// TODO the following hooks are weirdly located here\n\t\t\t// TODO move them for webpack 5\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\tenvironment: new SyncHook([]),\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\tafterEnvironment: new SyncHook([]),\n\t\t\t/** @type {SyncHook<[Compiler]>} */\n\t\t\tafterPlugins: new SyncHook([\"compiler\"]),\n\t\t\t/** @type {SyncHook<[Compiler]>} */\n\t\t\tafterResolvers: new SyncHook([\"compiler\"]),\n\t\t\t/** @type {SyncBailHook<[string, Entry], boolean>} */\n\t\t\tentryOption: new SyncBailHook([\"context\", \"entry\"])\n\t\t});\n\n\t\tthis.webpack = webpack;\n\n\t\t/** @type {string=} */\n\t\tthis.name = undefined;\n\t\t/** @type {Compilation=} */\n\t\tthis.parentCompilation = undefined;\n\t\t/** @type {Compiler} */\n\t\tthis.root = this;\n\t\t/** @type {string} */\n\t\tthis.outputPath = \"\";\n\t\t/** @type {Watching} */\n\t\tthis.watching = undefined;\n\n\t\t/** @type {OutputFileSystem} */\n\t\tthis.outputFileSystem = null;\n\t\t/** @type {IntermediateFileSystem} */\n\t\tthis.intermediateFileSystem = null;\n\t\t/** @type {InputFileSystem} */\n\t\tthis.inputFileSystem = null;\n\t\t/** @type {WatchFileSystem} */\n\t\tthis.watchFileSystem = null;\n\n\t\t/** @type {string|null} */\n\t\tthis.recordsInputPath = null;\n\t\t/** @type {string|null} */\n\t\tthis.recordsOutputPath = null;\n\t\tthis.records = {};\n\t\t/** @type {Set<string | RegExp>} */\n\t\tthis.managedPaths = new Set();\n\t\t/** @type {Set<string | RegExp>} */\n\t\tthis.immutablePaths = new Set();\n\n\t\t/** @type {ReadonlySet<string>} */\n\t\tthis.modifiedFiles = undefined;\n\t\t/** @type {ReadonlySet<string>} */\n\t\tthis.removedFiles = undefined;\n\t\t/** @type {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} */\n\t\tthis.fileTimestamps = undefined;\n\t\t/** @type {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} */\n\t\tthis.contextTimestamps = undefined;\n\t\t/** @type {number} */\n\t\tthis.fsStartTime = undefined;\n\n\t\t/** @type {ResolverFactory} */\n\t\tthis.resolverFactory = new ResolverFactory();\n\n\t\tthis.infrastructureLogger = undefined;\n\n\t\tthis.options = options;\n\n\t\tthis.context = context;\n\n\t\tthis.requestShortener = new RequestShortener(context, this.root);\n\n\t\tthis.cache = new Cache();\n\n\t\t/** @type {Map<Module, { buildInfo: object, references: WeakMap<Dependency, Module>, memCache: WeakTupleMap }> | undefined} */\n\t\tthis.moduleMemCaches = undefined;\n\n\t\tthis.compilerPath = \"\";\n\n\t\t/** @type {boolean} */\n\t\tthis.running = false;\n\n\t\t/** @type {boolean} */\n\t\tthis.idle = false;\n\n\t\t/** @type {boolean} */\n\t\tthis.watchMode = false;\n\n\t\tthis._backCompat = this.options.experiments.backCompat !== false;\n\n\t\t/** @type {Compilation} */\n\t\tthis._lastCompilation = undefined;\n\t\t/** @type {NormalModuleFactory} */\n\t\tthis._lastNormalModuleFactory = undefined;\n\n\t\t/** @private @type {WeakMap<Source, { sizeOnlySource: SizeOnlySource, writtenTo: Map<string, number> }>} */\n\t\tthis._assetEmittingSourceCache = new WeakMap();\n\t\t/** @private @type {Map<string, number>} */\n\t\tthis._assetEmittingWrittenFiles = new Map();\n\t\t/** @private @type {Set<string>} */\n\t\tthis._assetEmittingPreviousFiles = new Set();\n\t}\n\n\t/**\n\t * @param {string} name cache name\n\t * @returns {CacheFacade} the cache facade instance\n\t */\n\tgetCache(name) {\n\t\treturn new CacheFacade(\n\t\t\tthis.cache,\n\t\t\t`${this.compilerPath}${name}`,\n\t\t\tthis.options.output.hashFunction\n\t\t);\n\t}\n\n\t/**\n\t * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name\n\t * @returns {Logger} a logger with that name\n\t */\n\tgetInfrastructureLogger(name) {\n\t\tif (!name) {\n\t\t\tthrow new TypeError(\n\t\t\t\t\"Compiler.getInfrastructureLogger(name) called without a name\"\n\t\t\t);\n\t\t}\n\t\treturn new Logger(\n\t\t\t(type, args) => {\n\t\t\t\tif (typeof name === \"function\") {\n\t\t\t\t\tname = name();\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.hooks.infrastructureLog.call(name, type, args) === undefined) {\n\t\t\t\t\tif (this.infrastructureLogger !== undefined) {\n\t\t\t\t\t\tthis.infrastructureLogger(name, type, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tchildName => {\n\t\t\t\tif (typeof name === \"function\") {\n\t\t\t\t\tif (typeof childName === \"function\") {\n\t\t\t\t\t\treturn this.getInfrastructureLogger(() => {\n\t\t\t\t\t\t\tif (typeof name === \"function\") {\n\t\t\t\t\t\t\t\tname = name();\n\t\t\t\t\t\t\t\tif (!name) {\n\t\t\t\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\t\t\t\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (typeof childName === \"function\") {\n\t\t\t\t\t\t\t\tchildName = childName();\n\t\t\t\t\t\t\t\tif (!childName) {\n\t\t\t\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\t\t\t\"Logger.getChildLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn `${name}/${childName}`;\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this.getInfrastructureLogger(() => {\n\t\t\t\t\t\t\tif (typeof name === \"function\") {\n\t\t\t\t\t\t\t\tname = name();\n\t\t\t\t\t\t\t\tif (!name) {\n\t\t\t\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\t\t\t\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn `${name}/${childName}`;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (typeof childName === \"function\") {\n\t\t\t\t\t\treturn this.getInfrastructureLogger(() => {\n\t\t\t\t\t\t\tif (typeof childName === \"function\") {\n\t\t\t\t\t\t\t\tchildName = childName();\n\t\t\t\t\t\t\t\tif (!childName) {\n\t\t\t\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\t\t\t\"Logger.getChildLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn `${name}/${childName}`;\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this.getInfrastructureLogger(`${name}/${childName}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\n\t// TODO webpack 6: solve this in a better way\n\t// e.g. move compilation specific info from Modules into ModuleGraph\n\t_cleanupLastCompilation() {\n\t\tif (this._lastCompilation !== undefined) {\n\t\t\tfor (const module of this._lastCompilation.modules) {\n\t\t\t\tChunkGraph.clearChunkGraphForModule(module);\n\t\t\t\tModuleGraph.clearModuleGraphForModule(module);\n\t\t\t\tmodule.cleanupForCache();\n\t\t\t}\n\t\t\tfor (const chunk of this._lastCompilation.chunks) {\n\t\t\t\tChunkGraph.clearChunkGraphForChunk(chunk);\n\t\t\t}\n\t\t\tthis._lastCompilation = undefined;\n\t\t}\n\t}\n\n\t// TODO webpack 6: solve this in a better way\n\t_cleanupLastNormalModuleFactory() {\n\t\tif (this._lastNormalModuleFactory !== undefined) {\n\t\t\tthis._lastNormalModuleFactory.cleanupForCache();\n\t\t\tthis._lastNormalModuleFactory = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {WatchOptions} watchOptions the watcher's options\n\t * @param {Callback<Stats>} handler signals when the call finishes\n\t * @returns {Watching} a compiler watcher\n\t */\n\twatch(watchOptions, handler) {\n\t\tif (this.running) {\n\t\t\treturn handler(new ConcurrentCompilationError());\n\t\t}\n\n\t\tthis.running = true;\n\t\tthis.watchMode = true;\n\t\tthis.watching = new Watching(this, watchOptions, handler);\n\t\treturn this.watching;\n\t}\n\n\t/**\n\t * @param {Callback<Stats>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\trun(callback) {\n\t\tif (this.running) {\n\t\t\treturn callback(new ConcurrentCompilationError());\n\t\t}\n\n\t\tlet logger;\n\n\t\tconst finalCallback = (err, stats) => {\n\t\t\tif (logger) logger.time(\"beginIdle\");\n\t\t\tthis.idle = true;\n\t\t\tthis.cache.beginIdle();\n\t\t\tthis.idle = true;\n\t\t\tif (logger) logger.timeEnd(\"beginIdle\");\n\t\t\tthis.running = false;\n\t\t\tif (err) {\n\t\t\t\tthis.hooks.failed.call(err);\n\t\t\t}\n\t\t\tif (callback !== undefined) callback(err, stats);\n\t\t\tthis.hooks.afterDone.call(stats);\n\t\t};\n\n\t\tconst startTime = Date.now();\n\n\t\tthis.running = true;\n\n\t\tconst onCompiled = (err, compilation) => {\n\t\t\tif (err) return finalCallback(err);\n\n\t\t\tif (this.hooks.shouldEmit.call(compilation) === false) {\n\t\t\t\tcompilation.startTime = startTime;\n\t\t\t\tcompilation.endTime = Date.now();\n\t\t\t\tconst stats = new Stats(compilation);\n\t\t\t\tthis.hooks.done.callAsync(stats, err => {\n\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\treturn finalCallback(null, stats);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tlogger = compilation.getLogger(\"webpack.Compiler\");\n\t\t\t\tlogger.time(\"emitAssets\");\n\t\t\t\tthis.emitAssets(compilation, err => {\n\t\t\t\t\tlogger.timeEnd(\"emitAssets\");\n\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\tif (compilation.hooks.needAdditionalPass.call()) {\n\t\t\t\t\t\tcompilation.needAdditionalPass = true;\n\n\t\t\t\t\t\tcompilation.startTime = startTime;\n\t\t\t\t\t\tcompilation.endTime = Date.now();\n\t\t\t\t\t\tlogger.time(\"done hook\");\n\t\t\t\t\t\tconst stats = new Stats(compilation);\n\t\t\t\t\t\tthis.hooks.done.callAsync(stats, err => {\n\t\t\t\t\t\t\tlogger.timeEnd(\"done hook\");\n\t\t\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\t\t\tthis.hooks.additionalPass.callAsync(err => {\n\t\t\t\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\t\t\t\tthis.compile(onCompiled);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.time(\"emitRecords\");\n\t\t\t\t\tthis.emitRecords(err => {\n\t\t\t\t\t\tlogger.timeEnd(\"emitRecords\");\n\t\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\t\tcompilation.startTime = startTime;\n\t\t\t\t\t\tcompilation.endTime = Date.now();\n\t\t\t\t\t\tlogger.time(\"done hook\");\n\t\t\t\t\t\tconst stats = new Stats(compilation);\n\t\t\t\t\t\tthis.hooks.done.callAsync(stats, err => {\n\t\t\t\t\t\t\tlogger.timeEnd(\"done hook\");\n\t\t\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\t\t\tthis.cache.storeBuildDependencies(\n\t\t\t\t\t\t\t\tcompilation.buildDependencies,\n\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\t\t\t\t\treturn finalCallback(null, stats);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\tconst run = () => {\n\t\t\tthis.hooks.beforeRun.callAsync(this, err => {\n\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\tthis.hooks.run.callAsync(this, err => {\n\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\tthis.readRecords(err => {\n\t\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\t\tthis.compile(onCompiled);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\tif (this.idle) {\n\t\t\tthis.cache.endIdle(err => {\n\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\tthis.idle = false;\n\t\t\t\trun();\n\t\t\t});\n\t\t} else {\n\t\t\trun();\n\t\t}\n\t}\n\n\t/**\n\t * @param {RunAsChildCallback} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\trunAsChild(callback) {\n\t\tconst startTime = Date.now();\n\n\t\tconst finalCallback = (err, entries, compilation) => {\n\t\t\ttry {\n\t\t\t\tcallback(err, entries, compilation);\n\t\t\t} catch (e) {\n\t\t\t\tconst err = new WebpackError(\n\t\t\t\t\t`compiler.runAsChild callback error: ${e}`\n\t\t\t\t);\n\t\t\t\terr.details = e.stack;\n\t\t\t\tthis.parentCompilation.errors.push(err);\n\t\t\t}\n\t\t};\n\n\t\tthis.compile((err, compilation) => {\n\t\t\tif (err) return finalCallback(err);\n\n\t\t\tthis.parentCompilation.children.push(compilation);\n\t\t\tfor (const { name, source, info } of compilation.getAssets()) {\n\t\t\t\tthis.parentCompilation.emitAsset(name, source, info);\n\t\t\t}\n\n\t\t\tconst entries = [];\n\t\t\tfor (const ep of compilation.entrypoints.values()) {\n\t\t\t\tentries.push(...ep.chunks);\n\t\t\t}\n\n\t\t\tcompilation.startTime = startTime;\n\t\t\tcompilation.endTime = Date.now();\n\n\t\t\treturn finalCallback(null, entries, compilation);\n\t\t});\n\t}\n\n\tpurgeInputFileSystem() {\n\t\tif (this.inputFileSystem && this.inputFileSystem.purge) {\n\t\t\tthis.inputFileSystem.purge();\n\t\t}\n\t}\n\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @param {Callback<void>} callback signals when the assets are emitted\n\t * @returns {void}\n\t */\n\temitAssets(compilation, callback) {\n\t\tlet outputPath;\n\n\t\tconst emitFiles = err => {\n\t\t\tif (err) return callback(err);\n\n\t\t\tconst assets = compilation.getAssets();\n\t\t\tcompilation.assets = { ...compilation.assets };\n\t\t\t/** @type {Map<string, { path: string, source: Source, size: number, waiting: { cacheEntry: any, file: string }[] }>} */\n\t\t\tconst caseInsensitiveMap = new Map();\n\t\t\t/** @type {Set<string>} */\n\t\t\tconst allTargetPaths = new Set();\n\t\t\tasyncLib.forEachLimit(\n\t\t\t\tassets,\n\t\t\t\t15,\n\t\t\t\t({ name: file, source, info }, callback) => {\n\t\t\t\t\tlet targetFile = file;\n\t\t\t\t\tlet immutable = info.immutable;\n\t\t\t\t\tconst queryStringIdx = targetFile.indexOf(\"?\");\n\t\t\t\t\tif (queryStringIdx >= 0) {\n\t\t\t\t\t\ttargetFile = targetFile.slice(0, queryStringIdx);\n\t\t\t\t\t\t// We may remove the hash, which is in the query string\n\t\t\t\t\t\t// So we recheck if the file is immutable\n\t\t\t\t\t\t// This doesn't cover all cases, but immutable is only a performance optimization anyway\n\t\t\t\t\t\timmutable =\n\t\t\t\t\t\t\timmutable &&\n\t\t\t\t\t\t\t(includesHash(targetFile, info.contenthash) ||\n\t\t\t\t\t\t\t\tincludesHash(targetFile, info.chunkhash) ||\n\t\t\t\t\t\t\t\tincludesHash(targetFile, info.modulehash) ||\n\t\t\t\t\t\t\t\tincludesHash(targetFile, info.fullhash));\n\t\t\t\t\t}\n\n\t\t\t\t\tconst writeOut = err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tconst targetPath = join(\n\t\t\t\t\t\t\tthis.outputFileSystem,\n\t\t\t\t\t\t\toutputPath,\n\t\t\t\t\t\t\ttargetFile\n\t\t\t\t\t\t);\n\t\t\t\t\t\tallTargetPaths.add(targetPath);\n\n\t\t\t\t\t\t// check if the target file has already been written by this Compiler\n\t\t\t\t\t\tconst targetFileGeneration =\n\t\t\t\t\t\t\tthis._assetEmittingWrittenFiles.get(targetPath);\n\n\t\t\t\t\t\t// create an cache entry for this Source if not already existing\n\t\t\t\t\t\tlet cacheEntry = this._assetEmittingSourceCache.get(source);\n\t\t\t\t\t\tif (cacheEntry === undefined) {\n\t\t\t\t\t\t\tcacheEntry = {\n\t\t\t\t\t\t\t\tsizeOnlySource: undefined,\n\t\t\t\t\t\t\t\twrittenTo: new Map()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tthis._assetEmittingSourceCache.set(source, cacheEntry);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet similarEntry;\n\n\t\t\t\t\t\tconst checkSimilarFile = () => {\n\t\t\t\t\t\t\tconst caseInsensitiveTargetPath = targetPath.toLowerCase();\n\t\t\t\t\t\t\tsimilarEntry = caseInsensitiveMap.get(caseInsensitiveTargetPath);\n\t\t\t\t\t\t\tif (similarEntry !== undefined) {\n\t\t\t\t\t\t\t\tconst { path: other, source: otherSource } = similarEntry;\n\t\t\t\t\t\t\t\tif (isSourceEqual(otherSource, source)) {\n\t\t\t\t\t\t\t\t\t// Size may or may not be available at this point.\n\t\t\t\t\t\t\t\t\t// If it's not available add to \"waiting\" list and it will be updated once available\n\t\t\t\t\t\t\t\t\tif (similarEntry.size !== undefined) {\n\t\t\t\t\t\t\t\t\t\tupdateWithReplacementSource(similarEntry.size);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif (!similarEntry.waiting) similarEntry.waiting = [];\n\t\t\t\t\t\t\t\t\t\tsimilarEntry.waiting.push({ file, cacheEntry });\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\talreadyWritten();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst err =\n\t\t\t\t\t\t\t\t\t\tnew WebpackError(`Prevent writing to file that only differs in casing or query string from already written file.\nThis will lead to a race-condition and corrupted files on case-insensitive file systems.\n${targetPath}\n${other}`);\n\t\t\t\t\t\t\t\t\terr.file = file;\n\t\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcaseInsensitiveMap.set(\n\t\t\t\t\t\t\t\t\tcaseInsensitiveTargetPath,\n\t\t\t\t\t\t\t\t\t(similarEntry = {\n\t\t\t\t\t\t\t\t\t\tpath: targetPath,\n\t\t\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\t\t\tsize: undefined,\n\t\t\t\t\t\t\t\t\t\twaiting: undefined\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * get the binary (Buffer) content from the Source\n\t\t\t\t\t\t * @returns {Buffer} content for the source\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst getContent = () => {\n\t\t\t\t\t\t\tif (typeof source.buffer === \"function\") {\n\t\t\t\t\t\t\t\treturn source.buffer();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst bufferOrString = source.source();\n\t\t\t\t\t\t\t\tif (Buffer.isBuffer(bufferOrString)) {\n\t\t\t\t\t\t\t\t\treturn bufferOrString;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn Buffer.from(bufferOrString, \"utf8\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst alreadyWritten = () => {\n\t\t\t\t\t\t\t// cache the information that the Source has been already been written to that location\n\t\t\t\t\t\t\tif (targetFileGeneration === undefined) {\n\t\t\t\t\t\t\t\tconst newGeneration = 1;\n\t\t\t\t\t\t\t\tthis._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n\t\t\t\t\t\t\t\tcacheEntry.writtenTo.set(targetPath, newGeneration);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcacheEntry.writtenTo.set(targetPath, targetFileGeneration);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Write the file to output file system\n\t\t\t\t\t\t * @param {Buffer} content content to be written\n\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst doWrite = content => {\n\t\t\t\t\t\t\tthis.outputFileSystem.writeFile(targetPath, content, err => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t// information marker that the asset has been emitted\n\t\t\t\t\t\t\t\tcompilation.emittedAssets.add(file);\n\n\t\t\t\t\t\t\t\t// cache the information that the Source has been written to that location\n\t\t\t\t\t\t\t\tconst newGeneration =\n\t\t\t\t\t\t\t\t\ttargetFileGeneration === undefined\n\t\t\t\t\t\t\t\t\t\t? 1\n\t\t\t\t\t\t\t\t\t\t: targetFileGeneration + 1;\n\t\t\t\t\t\t\t\tcacheEntry.writtenTo.set(targetPath, newGeneration);\n\t\t\t\t\t\t\t\tthis._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n\t\t\t\t\t\t\t\tthis.hooks.assetEmitted.callAsync(\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\t\t\toutputPath,\n\t\t\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\t\t\ttargetPath\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst updateWithReplacementSource = size => {\n\t\t\t\t\t\t\tupdateFileWithReplacementSource(file, cacheEntry, size);\n\t\t\t\t\t\t\tsimilarEntry.size = size;\n\t\t\t\t\t\t\tif (similarEntry.waiting !== undefined) {\n\t\t\t\t\t\t\t\tfor (const { file, cacheEntry } of similarEntry.waiting) {\n\t\t\t\t\t\t\t\t\tupdateFileWithReplacementSource(file, cacheEntry, size);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst updateFileWithReplacementSource = (\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tcacheEntry,\n\t\t\t\t\t\t\tsize\n\t\t\t\t\t\t) => {\n\t\t\t\t\t\t\t// Create a replacement resource which only allows to ask for size\n\t\t\t\t\t\t\t// This allows to GC all memory allocated by the Source\n\t\t\t\t\t\t\t// (expect when the Source is stored in any other cache)\n\t\t\t\t\t\t\tif (!cacheEntry.sizeOnlySource) {\n\t\t\t\t\t\t\t\tcacheEntry.sizeOnlySource = new SizeOnlySource(size);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcompilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n\t\t\t\t\t\t\t\tsize\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst processExistingFile = stats => {\n\t\t\t\t\t\t\t// skip emitting if it's already there and an immutable file\n\t\t\t\t\t\t\tif (immutable) {\n\t\t\t\t\t\t\t\tupdateWithReplacementSource(stats.size);\n\t\t\t\t\t\t\t\treturn alreadyWritten();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst content = getContent();\n\n\t\t\t\t\t\t\tupdateWithReplacementSource(content.length);\n\n\t\t\t\t\t\t\t// if it exists and content on disk matches content\n\t\t\t\t\t\t\t// skip writing the same content again\n\t\t\t\t\t\t\t// (to keep mtime and don't trigger watchers)\n\t\t\t\t\t\t\t// for a fast negative match file size is compared first\n\t\t\t\t\t\t\tif (content.length === stats.size) {\n\t\t\t\t\t\t\t\tcompilation.comparedForEmitAssets.add(file);\n\t\t\t\t\t\t\t\treturn this.outputFileSystem.readFile(\n\t\t\t\t\t\t\t\t\ttargetPath,\n\t\t\t\t\t\t\t\t\t(err, existingContent) => {\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\terr ||\n\t\t\t\t\t\t\t\t\t\t\t!content.equals(/** @type {Buffer} */ (existingContent))\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\treturn doWrite(content);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\treturn alreadyWritten();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn doWrite(content);\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst processMissingFile = () => {\n\t\t\t\t\t\t\tconst content = getContent();\n\n\t\t\t\t\t\t\tupdateWithReplacementSource(content.length);\n\n\t\t\t\t\t\t\treturn doWrite(content);\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// if the target file has already been written\n\t\t\t\t\t\tif (targetFileGeneration !== undefined) {\n\t\t\t\t\t\t\t// check if the Source has been written to this target file\n\t\t\t\t\t\t\tconst writtenGeneration = cacheEntry.writtenTo.get(targetPath);\n\t\t\t\t\t\t\tif (writtenGeneration === targetFileGeneration) {\n\t\t\t\t\t\t\t\t// if yes, we may skip writing the file\n\t\t\t\t\t\t\t\t// if it's already there\n\t\t\t\t\t\t\t\t// (we assume one doesn't modify files while the Compiler is running, other then removing them)\n\n\t\t\t\t\t\t\t\tif (this._assetEmittingPreviousFiles.has(targetPath)) {\n\t\t\t\t\t\t\t\t\t// We assume that assets from the last compilation say intact on disk (they are not removed)\n\t\t\t\t\t\t\t\t\tcompilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n\t\t\t\t\t\t\t\t\t\tsize: cacheEntry.sizeOnlySource.size()\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Settings immutable will make it accept file content without comparing when file exist\n\t\t\t\t\t\t\t\t\timmutable = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (!immutable) {\n\t\t\t\t\t\t\t\tif (checkSimilarFile()) return;\n\t\t\t\t\t\t\t\t// We wrote to this file before which has very likely a different content\n\t\t\t\t\t\t\t\t// skip comparing and assume content is different for performance\n\t\t\t\t\t\t\t\t// This case happens often during watch mode.\n\t\t\t\t\t\t\t\treturn processMissingFile();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (checkSimilarFile()) return;\n\t\t\t\t\t\tif (this.options.output.compareBeforeEmit) {\n\t\t\t\t\t\t\tthis.outputFileSystem.stat(targetPath, (err, stats) => {\n\t\t\t\t\t\t\t\tconst exists = !err && stats.isFile();\n\n\t\t\t\t\t\t\t\tif (exists) {\n\t\t\t\t\t\t\t\t\tprocessExistingFile(stats);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tprocessMissingFile();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprocessMissingFile();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tif (targetFile.match(/\\/|\\\\/)) {\n\t\t\t\t\t\tconst fs = this.outputFileSystem;\n\t\t\t\t\t\tconst dir = dirname(fs, join(fs, outputPath, targetFile));\n\t\t\t\t\t\tmkdirp(fs, dir, writeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twriteOut();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\terr => {\n\t\t\t\t\t// Clear map to free up memory\n\t\t\t\t\tcaseInsensitiveMap.clear();\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tthis._assetEmittingPreviousFiles.clear();\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._assetEmittingPreviousFiles = allTargetPaths;\n\n\t\t\t\t\tthis.hooks.afterEmit.callAsync(compilation, err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t);\n\t\t};\n\n\t\tthis.hooks.emit.callAsync(compilation, err => {\n\t\t\tif (err) return callback(err);\n\t\t\toutputPath = compilation.getPath(this.outputPath, {});\n\t\t\tmkdirp(this.outputFileSystem, outputPath, emitFiles);\n\t\t});\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\temitRecords(callback) {\n\t\tif (this.hooks.emitRecords.isUsed()) {\n\t\t\tif (this.recordsOutputPath) {\n\t\t\t\tasyncLib.parallel(\n\t\t\t\t\t[\n\t\t\t\t\t\tcb => this.hooks.emitRecords.callAsync(cb),\n\t\t\t\t\t\tthis._emitRecords.bind(this)\n\t\t\t\t\t],\n\t\t\t\t\terr => callback(err)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.hooks.emitRecords.callAsync(callback);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.recordsOutputPath) {\n\t\t\t\tthis._emitRecords(callback);\n\t\t\t} else {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\t_emitRecords(callback) {\n\t\tconst writeFile = () => {\n\t\t\tthis.outputFileSystem.writeFile(\n\t\t\t\tthis.recordsOutputPath,\n\t\t\t\tJSON.stringify(\n\t\t\t\t\tthis.records,\n\t\t\t\t\t(n, value) => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttypeof value === \"object\" &&\n\t\t\t\t\t\t\tvalue !== null &&\n\t\t\t\t\t\t\t!Array.isArray(value)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst keys = Object.keys(value);\n\t\t\t\t\t\t\tif (!isSorted(keys)) {\n\t\t\t\t\t\t\t\treturn sortObject(value, keys);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t},\n\t\t\t\t\t2\n\t\t\t\t),\n\t\t\t\tcallback\n\t\t\t);\n\t\t};\n\n\t\tconst recordsOutputPathDirectory = dirname(\n\t\t\tthis.outputFileSystem,\n\t\t\tthis.recordsOutputPath\n\t\t);\n\t\tif (!recordsOutputPathDirectory) {\n\t\t\treturn writeFile();\n\t\t}\n\t\tmkdirp(this.outputFileSystem, recordsOutputPathDirectory, err => {\n\t\t\tif (err) return callback(err);\n\t\t\twriteFile();\n\t\t});\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\treadRecords(callback) {\n\t\tif (this.hooks.readRecords.isUsed()) {\n\t\t\tif (this.recordsInputPath) {\n\t\t\t\tasyncLib.parallel([\n\t\t\t\t\tcb => this.hooks.readRecords.callAsync(cb),\n\t\t\t\t\tthis._readRecords.bind(this)\n\t\t\t\t]);\n\t\t\t} else {\n\t\t\t\tthis.records = {};\n\t\t\t\tthis.hooks.readRecords.callAsync(callback);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.recordsInputPath) {\n\t\t\t\tthis._readRecords(callback);\n\t\t\t} else {\n\t\t\t\tthis.records = {};\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\t_readRecords(callback) {\n\t\tif (!this.recordsInputPath) {\n\t\t\tthis.records = {};\n\t\t\treturn callback();\n\t\t}\n\t\tthis.inputFileSystem.stat(this.recordsInputPath, err => {\n\t\t\t// It doesn't exist\n\t\t\t// We can ignore this.\n\t\t\tif (err) return callback();\n\n\t\t\tthis.inputFileSystem.readFile(this.recordsInputPath, (err, content) => {\n\t\t\t\tif (err) return callback(err);\n\n\t\t\t\ttry {\n\t\t\t\t\tthis.records = parseJson(content.toString(\"utf-8\"));\n\t\t\t\t} catch (e) {\n\t\t\t\t\te.message = \"Cannot parse records: \" + e.message;\n\t\t\t\t\treturn callback(e);\n\t\t\t\t}\n\n\t\t\t\treturn callback();\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @param {string} compilerName the compiler's name\n\t * @param {number} compilerIndex the compiler's index\n\t * @param {OutputOptions=} outputOptions the output options\n\t * @param {WebpackPluginInstance[]=} plugins the plugins to apply\n\t * @returns {Compiler} a child compiler\n\t */\n\tcreateChildCompiler(\n\t\tcompilation,\n\t\tcompilerName,\n\t\tcompilerIndex,\n\t\toutputOptions,\n\t\tplugins\n\t) {\n\t\tconst childCompiler = new Compiler(this.context, {\n\t\t\t...this.options,\n\t\t\toutput: {\n\t\t\t\t...this.options.output,\n\t\t\t\t...outputOptions\n\t\t\t}\n\t\t});\n\t\tchildCompiler.name = compilerName;\n\t\tchildCompiler.outputPath = this.outputPath;\n\t\tchildCompiler.inputFileSystem = this.inputFileSystem;\n\t\tchildCompiler.outputFileSystem = null;\n\t\tchildCompiler.resolverFactory = this.resolverFactory;\n\t\tchildCompiler.modifiedFiles = this.modifiedFiles;\n\t\tchildCompiler.removedFiles = this.removedFiles;\n\t\tchildCompiler.fileTimestamps = this.fileTimestamps;\n\t\tchildCompiler.contextTimestamps = this.contextTimestamps;\n\t\tchildCompiler.fsStartTime = this.fsStartTime;\n\t\tchildCompiler.cache = this.cache;\n\t\tchildCompiler.compilerPath = `${this.compilerPath}${compilerName}|${compilerIndex}|`;\n\t\tchildCompiler._backCompat = this._backCompat;\n\n\t\tconst relativeCompilerName = makePathsRelative(\n\t\t\tthis.context,\n\t\t\tcompilerName,\n\t\t\tthis.root\n\t\t);\n\t\tif (!this.records[relativeCompilerName]) {\n\t\t\tthis.records[relativeCompilerName] = [];\n\t\t}\n\t\tif (this.records[relativeCompilerName][compilerIndex]) {\n\t\t\tchildCompiler.records = this.records[relativeCompilerName][compilerIndex];\n\t\t} else {\n\t\t\tthis.records[relativeCompilerName].push((childCompiler.records = {}));\n\t\t}\n\n\t\tchildCompiler.parentCompilation = compilation;\n\t\tchildCompiler.root = this.root;\n\t\tif (Array.isArray(plugins)) {\n\t\t\tfor (const plugin of plugins) {\n\t\t\t\tplugin.apply(childCompiler);\n\t\t\t}\n\t\t}\n\t\tfor (const name in this.hooks) {\n\t\t\tif (\n\t\t\t\t![\n\t\t\t\t\t\"make\",\n\t\t\t\t\t\"compile\",\n\t\t\t\t\t\"emit\",\n\t\t\t\t\t\"afterEmit\",\n\t\t\t\t\t\"invalid\",\n\t\t\t\t\t\"done\",\n\t\t\t\t\t\"thisCompilation\"\n\t\t\t\t].includes(name)\n\t\t\t) {\n\t\t\t\tif (childCompiler.hooks[name]) {\n\t\t\t\t\tchildCompiler.hooks[name].taps = this.hooks[name].taps.slice();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcompilation.hooks.childCompiler.call(\n\t\t\tchildCompiler,\n\t\t\tcompilerName,\n\t\t\tcompilerIndex\n\t\t);\n\n\t\treturn childCompiler;\n\t}\n\n\tisChild() {\n\t\treturn !!this.parentCompilation;\n\t}\n\n\tcreateCompilation(params) {\n\t\tthis._cleanupLastCompilation();\n\t\treturn (this._lastCompilation = new Compilation(this, params));\n\t}\n\n\t/**\n\t * @param {CompilationParams} params the compilation parameters\n\t * @returns {Compilation} the created compilation\n\t */\n\tnewCompilation(params) {\n\t\tconst compilation = this.createCompilation(params);\n\t\tcompilation.name = this.name;\n\t\tcompilation.records = this.records;\n\t\tthis.hooks.thisCompilation.call(compilation, params);\n\t\tthis.hooks.compilation.call(compilation, params);\n\t\treturn compilation;\n\t}\n\n\tcreateNormalModuleFactory() {\n\t\tthis._cleanupLastNormalModuleFactory();\n\t\tconst normalModuleFactory = new NormalModuleFactory({\n\t\t\tcontext: this.options.context,\n\t\t\tfs: this.inputFileSystem,\n\t\t\tresolverFactory: this.resolverFactory,\n\t\t\toptions: this.options.module,\n\t\t\tassociatedObjectForCache: this.root,\n\t\t\tlayers: this.options.experiments.layers\n\t\t});\n\t\tthis._lastNormalModuleFactory = normalModuleFactory;\n\t\tthis.hooks.normalModuleFactory.call(normalModuleFactory);\n\t\treturn normalModuleFactory;\n\t}\n\n\tcreateContextModuleFactory() {\n\t\tconst contextModuleFactory = new ContextModuleFactory(this.resolverFactory);\n\t\tthis.hooks.contextModuleFactory.call(contextModuleFactory);\n\t\treturn contextModuleFactory;\n\t}\n\n\tnewCompilationParams() {\n\t\tconst params = {\n\t\t\tnormalModuleFactory: this.createNormalModuleFactory(),\n\t\t\tcontextModuleFactory: this.createContextModuleFactory()\n\t\t};\n\t\treturn params;\n\t}\n\n\t/**\n\t * @param {Callback<Compilation>} callback signals when the compilation finishes\n\t * @returns {void}\n\t */\n\tcompile(callback) {\n\t\tconst params = this.newCompilationParams();\n\t\tthis.hooks.beforeCompile.callAsync(params, err => {\n\t\t\tif (err) return callback(err);\n\n\t\t\tthis.hooks.compile.call(params);\n\n\t\t\tconst compilation = this.newCompilation(params);\n\n\t\t\tconst logger = compilation.getLogger(\"webpack.Compiler\");\n\n\t\t\tlogger.time(\"make hook\");\n\t\t\tthis.hooks.make.callAsync(compilation, err => {\n\t\t\t\tlogger.timeEnd(\"make hook\");\n\t\t\t\tif (err) return callback(err);\n\n\t\t\t\tlogger.time(\"finish make hook\");\n\t\t\t\tthis.hooks.finishMake.callAsync(compilation, err => {\n\t\t\t\t\tlogger.timeEnd(\"finish make hook\");\n\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\t\tlogger.time(\"finish compilation\");\n\t\t\t\t\t\tcompilation.finish(err => {\n\t\t\t\t\t\t\tlogger.timeEnd(\"finish compilation\");\n\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\tlogger.time(\"seal compilation\");\n\t\t\t\t\t\t\tcompilation.seal(err => {\n\t\t\t\t\t\t\t\tlogger.timeEnd(\"seal compilation\");\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\tlogger.time(\"afterCompile hook\");\n\t\t\t\t\t\t\t\tthis.hooks.afterCompile.callAsync(compilation, err => {\n\t\t\t\t\t\t\t\t\tlogger.timeEnd(\"afterCompile hook\");\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t\treturn callback(null, compilation);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the compiler closes\n\t * @returns {void}\n\t */\n\tclose(callback) {\n\t\tif (this.watching) {\n\t\t\t// When there is still an active watching, close this first\n\t\t\tthis.watching.close(err => {\n\t\t\t\tthis.close(callback);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tthis.hooks.shutdown.callAsync(err => {\n\t\t\tif (err) return callback(err);\n\t\t\t// Get rid of reference to last compilation to avoid leaking memory\n\t\t\t// We can't run this._cleanupLastCompilation() as the Stats to this compilation\n\t\t\t// might be still in use. We try to get rid of the reference to the cache instead.\n\t\t\tthis._lastCompilation = undefined;\n\t\t\tthis._lastNormalModuleFactory = undefined;\n\t\t\tthis.cache.shutdown(callback);\n\t\t});\n\t}\n}\n\nmodule.exports = Compiler;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}