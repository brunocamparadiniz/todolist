{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _objectSpread = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _require = require(\"enhanced-resolve\"),\n  createResolver = _require.create;\nvar nodeModule = require(\"module\");\nvar asyncLib = require(\"neo-async\");\nvar _require2 = require(\"path\"),\n  isAbsolute = _require2.isAbsolute;\nvar AsyncQueue = require(\"./util/AsyncQueue\");\nvar StackedCacheMap = require(\"./util/StackedCacheMap\");\nvar createHash = require(\"./util/createHash\");\nvar _require3 = require(\"./util/fs\"),\n  join = _require3.join,\n  dirname = _require3.dirname,\n  relative = _require3.relative,\n  lstatReadlinkAbsolute = _require3.lstatReadlinkAbsolute;\nvar makeSerializable = require(\"./util/makeSerializable\");\nvar processAsyncTree = require(\"./util/processAsyncTree\");\n\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/fs\").IStats} IStats */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\nvar supportsEsm = +process.versions.modules >= 83;\nvar builtinModules = new Set(nodeModule.builtinModules);\nvar FS_ACCURACY = 2000;\nvar EMPTY_SET = new Set();\nvar RBDT_RESOLVE_CJS = 0;\nvar RBDT_RESOLVE_ESM = 1;\nvar RBDT_RESOLVE_DIRECTORY = 2;\nvar RBDT_RESOLVE_CJS_FILE = 3;\nvar RBDT_RESOLVE_CJS_FILE_AS_CHILD = 4;\nvar RBDT_RESOLVE_ESM_FILE = 5;\nvar RBDT_DIRECTORY = 6;\nvar RBDT_FILE = 7;\nvar RBDT_DIRECTORY_DEPENDENCIES = 8;\nvar RBDT_FILE_DEPENDENCIES = 9;\nvar INVALID = Symbol(\"invalid\");\n\n/**\n * @typedef {Object} FileSystemInfoEntry\n * @property {number} safeTime\n * @property {number=} timestamp\n */\n\n/**\n * @typedef {Object} ResolvedContextFileSystemInfoEntry\n * @property {number} safeTime\n * @property {string=} timestampHash\n */\n\n/**\n * @typedef {Object} ContextFileSystemInfoEntry\n * @property {number} safeTime\n * @property {string=} timestampHash\n * @property {ResolvedContextFileSystemInfoEntry=} resolved\n * @property {Set<string>=} symlinks\n */\n\n/**\n * @typedef {Object} TimestampAndHash\n * @property {number} safeTime\n * @property {number=} timestamp\n * @property {string} hash\n */\n\n/**\n * @typedef {Object} ResolvedContextTimestampAndHash\n * @property {number} safeTime\n * @property {string=} timestampHash\n * @property {string} hash\n */\n\n/**\n * @typedef {Object} ContextTimestampAndHash\n * @property {number} safeTime\n * @property {string=} timestampHash\n * @property {string} hash\n * @property {ResolvedContextTimestampAndHash=} resolved\n * @property {Set<string>=} symlinks\n */\n\n/**\n * @typedef {Object} ContextHash\n * @property {string} hash\n * @property {string=} resolved\n * @property {Set<string>=} symlinks\n */\n\n/**\n * @typedef {Object} SnapshotOptimizationEntry\n * @property {Snapshot} snapshot\n * @property {number} shared\n * @property {Set<string>} snapshotContent\n * @property {Set<SnapshotOptimizationEntry>} children\n */\n\n/**\n * @typedef {Object} ResolveBuildDependenciesResult\n * @property {Set<string>} files list of files\n * @property {Set<string>} directories list of directories\n * @property {Set<string>} missing list of missing entries\n * @property {Map<string, string | false>} resolveResults stored resolve results\n * @property {Object} resolveDependencies dependencies of the resolving\n * @property {Set<string>} resolveDependencies.files list of files\n * @property {Set<string>} resolveDependencies.directories list of directories\n * @property {Set<string>} resolveDependencies.missing list of missing entries\n */\n\nvar DONE_ITERATOR_RESULT = new Set().keys().next();\n\n// cspell:word tshs\n// Tsh = Timestamp + Hash\n// Tshs = Timestamp + Hash combinations\nvar SnapshotIterator = /*#__PURE__*/_createClass(function SnapshotIterator(next) {\n  _classCallCheck(this, SnapshotIterator);\n  this.next = next;\n});\nvar SnapshotIterable = /*#__PURE__*/function (_Symbol$iterator) {\n  function SnapshotIterable(snapshot, getMaps) {\n    _classCallCheck(this, SnapshotIterable);\n    this.snapshot = snapshot;\n    this.getMaps = getMaps;\n  }\n  _createClass(SnapshotIterable, [{\n    key: _Symbol$iterator,\n    value: function value() {\n      var _this = this;\n      var state = 0;\n      /** @type {IterableIterator<string>} */\n      var it;\n      /** @type {(Snapshot) => (Map<string, any> | Set<string>)[]} */\n      var getMaps;\n      /** @type {(Map<string, any> | Set<string>)[]} */\n      var maps;\n      /** @type {Snapshot} */\n      var snapshot;\n      var queue;\n      return new SnapshotIterator(function () {\n        for (;;) {\n          switch (state) {\n            case 0:\n              snapshot = _this.snapshot;\n              getMaps = _this.getMaps;\n              maps = getMaps(snapshot);\n              state = 1;\n            /* falls through */\n            case 1:\n              if (maps.length > 0) {\n                var map = maps.pop();\n                if (map !== undefined) {\n                  it = map.keys();\n                  state = 2;\n                } else {\n                  break;\n                }\n              } else {\n                state = 3;\n                break;\n              }\n            /* falls through */\n            case 2:\n              {\n                var result = it.next();\n                if (!result.done) return result;\n                state = 1;\n                break;\n              }\n            case 3:\n              {\n                var children = snapshot.children;\n                if (children !== undefined) {\n                  if (children.size === 1) {\n                    // shortcut for a single child\n                    // avoids allocation of queue\n                    var _iterator = _createForOfIteratorHelper(children),\n                      _step;\n                    try {\n                      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                        var child = _step.value;\n                        snapshot = child;\n                      }\n                    } catch (err) {\n                      _iterator.e(err);\n                    } finally {\n                      _iterator.f();\n                    }\n                    maps = getMaps(snapshot);\n                    state = 1;\n                    break;\n                  }\n                  if (queue === undefined) queue = [];\n                  var _iterator2 = _createForOfIteratorHelper(children),\n                    _step2;\n                  try {\n                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                      var _child = _step2.value;\n                      queue.push(_child);\n                    }\n                  } catch (err) {\n                    _iterator2.e(err);\n                  } finally {\n                    _iterator2.f();\n                  }\n                }\n                if (queue !== undefined && queue.length > 0) {\n                  snapshot = queue.pop();\n                  maps = getMaps(snapshot);\n                  state = 1;\n                  break;\n                } else {\n                  state = 4;\n                }\n              }\n            /* falls through */\n            case 4:\n              return DONE_ITERATOR_RESULT;\n          }\n        }\n      });\n    }\n  }]);\n  return SnapshotIterable;\n}(Symbol.iterator);\nvar Snapshot = /*#__PURE__*/function () {\n  function Snapshot() {\n    _classCallCheck(this, Snapshot);\n    this._flags = 0;\n    /** @type {Iterable<string> | undefined} */\n    this._cachedFileIterable = undefined;\n    /** @type {Iterable<string> | undefined} */\n    this._cachedContextIterable = undefined;\n    /** @type {Iterable<string> | undefined} */\n    this._cachedMissingIterable = undefined;\n    /** @type {number | undefined} */\n    this.startTime = undefined;\n    /** @type {Map<string, FileSystemInfoEntry | null> | undefined} */\n    this.fileTimestamps = undefined;\n    /** @type {Map<string, string | null> | undefined} */\n    this.fileHashes = undefined;\n    /** @type {Map<string, TimestampAndHash | string | null> | undefined} */\n    this.fileTshs = undefined;\n    /** @type {Map<string, ResolvedContextFileSystemInfoEntry | null> | undefined} */\n    this.contextTimestamps = undefined;\n    /** @type {Map<string, string | null> | undefined} */\n    this.contextHashes = undefined;\n    /** @type {Map<string, ResolvedContextTimestampAndHash | null> | undefined} */\n    this.contextTshs = undefined;\n    /** @type {Map<string, boolean> | undefined} */\n    this.missingExistence = undefined;\n    /** @type {Map<string, string> | undefined} */\n    this.managedItemInfo = undefined;\n    /** @type {Set<string> | undefined} */\n    this.managedFiles = undefined;\n    /** @type {Set<string> | undefined} */\n    this.managedContexts = undefined;\n    /** @type {Set<string> | undefined} */\n    this.managedMissing = undefined;\n    /** @type {Set<Snapshot> | undefined} */\n    this.children = undefined;\n  }\n  _createClass(Snapshot, [{\n    key: \"hasStartTime\",\n    value: function hasStartTime() {\n      return (this._flags & 1) !== 0;\n    }\n  }, {\n    key: \"setStartTime\",\n    value: function setStartTime(value) {\n      this._flags = this._flags | 1;\n      this.startTime = value;\n    }\n  }, {\n    key: \"setMergedStartTime\",\n    value: function setMergedStartTime(value, snapshot) {\n      if (value) {\n        if (snapshot.hasStartTime()) {\n          this.setStartTime(Math.min(value, snapshot.startTime));\n        } else {\n          this.setStartTime(value);\n        }\n      } else {\n        if (snapshot.hasStartTime()) this.setStartTime(snapshot.startTime);\n      }\n    }\n  }, {\n    key: \"hasFileTimestamps\",\n    value: function hasFileTimestamps() {\n      return (this._flags & 2) !== 0;\n    }\n  }, {\n    key: \"setFileTimestamps\",\n    value: function setFileTimestamps(value) {\n      this._flags = this._flags | 2;\n      this.fileTimestamps = value;\n    }\n  }, {\n    key: \"hasFileHashes\",\n    value: function hasFileHashes() {\n      return (this._flags & 4) !== 0;\n    }\n  }, {\n    key: \"setFileHashes\",\n    value: function setFileHashes(value) {\n      this._flags = this._flags | 4;\n      this.fileHashes = value;\n    }\n  }, {\n    key: \"hasFileTshs\",\n    value: function hasFileTshs() {\n      return (this._flags & 8) !== 0;\n    }\n  }, {\n    key: \"setFileTshs\",\n    value: function setFileTshs(value) {\n      this._flags = this._flags | 8;\n      this.fileTshs = value;\n    }\n  }, {\n    key: \"hasContextTimestamps\",\n    value: function hasContextTimestamps() {\n      return (this._flags & 0x10) !== 0;\n    }\n  }, {\n    key: \"setContextTimestamps\",\n    value: function setContextTimestamps(value) {\n      this._flags = this._flags | 0x10;\n      this.contextTimestamps = value;\n    }\n  }, {\n    key: \"hasContextHashes\",\n    value: function hasContextHashes() {\n      return (this._flags & 0x20) !== 0;\n    }\n  }, {\n    key: \"setContextHashes\",\n    value: function setContextHashes(value) {\n      this._flags = this._flags | 0x20;\n      this.contextHashes = value;\n    }\n  }, {\n    key: \"hasContextTshs\",\n    value: function hasContextTshs() {\n      return (this._flags & 0x40) !== 0;\n    }\n  }, {\n    key: \"setContextTshs\",\n    value: function setContextTshs(value) {\n      this._flags = this._flags | 0x40;\n      this.contextTshs = value;\n    }\n  }, {\n    key: \"hasMissingExistence\",\n    value: function hasMissingExistence() {\n      return (this._flags & 0x80) !== 0;\n    }\n  }, {\n    key: \"setMissingExistence\",\n    value: function setMissingExistence(value) {\n      this._flags = this._flags | 0x80;\n      this.missingExistence = value;\n    }\n  }, {\n    key: \"hasManagedItemInfo\",\n    value: function hasManagedItemInfo() {\n      return (this._flags & 0x100) !== 0;\n    }\n  }, {\n    key: \"setManagedItemInfo\",\n    value: function setManagedItemInfo(value) {\n      this._flags = this._flags | 0x100;\n      this.managedItemInfo = value;\n    }\n  }, {\n    key: \"hasManagedFiles\",\n    value: function hasManagedFiles() {\n      return (this._flags & 0x200) !== 0;\n    }\n  }, {\n    key: \"setManagedFiles\",\n    value: function setManagedFiles(value) {\n      this._flags = this._flags | 0x200;\n      this.managedFiles = value;\n    }\n  }, {\n    key: \"hasManagedContexts\",\n    value: function hasManagedContexts() {\n      return (this._flags & 0x400) !== 0;\n    }\n  }, {\n    key: \"setManagedContexts\",\n    value: function setManagedContexts(value) {\n      this._flags = this._flags | 0x400;\n      this.managedContexts = value;\n    }\n  }, {\n    key: \"hasManagedMissing\",\n    value: function hasManagedMissing() {\n      return (this._flags & 0x800) !== 0;\n    }\n  }, {\n    key: \"setManagedMissing\",\n    value: function setManagedMissing(value) {\n      this._flags = this._flags | 0x800;\n      this.managedMissing = value;\n    }\n  }, {\n    key: \"hasChildren\",\n    value: function hasChildren() {\n      return (this._flags & 0x1000) !== 0;\n    }\n  }, {\n    key: \"setChildren\",\n    value: function setChildren(value) {\n      this._flags = this._flags | 0x1000;\n      this.children = value;\n    }\n  }, {\n    key: \"addChild\",\n    value: function addChild(child) {\n      if (!this.hasChildren()) {\n        this.setChildren(new Set());\n      }\n      this.children.add(child);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(_ref) {\n      var write = _ref.write;\n      write(this._flags);\n      if (this.hasStartTime()) write(this.startTime);\n      if (this.hasFileTimestamps()) write(this.fileTimestamps);\n      if (this.hasFileHashes()) write(this.fileHashes);\n      if (this.hasFileTshs()) write(this.fileTshs);\n      if (this.hasContextTimestamps()) write(this.contextTimestamps);\n      if (this.hasContextHashes()) write(this.contextHashes);\n      if (this.hasContextTshs()) write(this.contextTshs);\n      if (this.hasMissingExistence()) write(this.missingExistence);\n      if (this.hasManagedItemInfo()) write(this.managedItemInfo);\n      if (this.hasManagedFiles()) write(this.managedFiles);\n      if (this.hasManagedContexts()) write(this.managedContexts);\n      if (this.hasManagedMissing()) write(this.managedMissing);\n      if (this.hasChildren()) write(this.children);\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(_ref2) {\n      var read = _ref2.read;\n      this._flags = read();\n      if (this.hasStartTime()) this.startTime = read();\n      if (this.hasFileTimestamps()) this.fileTimestamps = read();\n      if (this.hasFileHashes()) this.fileHashes = read();\n      if (this.hasFileTshs()) this.fileTshs = read();\n      if (this.hasContextTimestamps()) this.contextTimestamps = read();\n      if (this.hasContextHashes()) this.contextHashes = read();\n      if (this.hasContextTshs()) this.contextTshs = read();\n      if (this.hasMissingExistence()) this.missingExistence = read();\n      if (this.hasManagedItemInfo()) this.managedItemInfo = read();\n      if (this.hasManagedFiles()) this.managedFiles = read();\n      if (this.hasManagedContexts()) this.managedContexts = read();\n      if (this.hasManagedMissing()) this.managedMissing = read();\n      if (this.hasChildren()) this.children = read();\n    }\n\n    /**\n     * @param {function(Snapshot): (ReadonlyMap<string, any> | ReadonlySet<string>)[]} getMaps first\n     * @returns {Iterable<string>} iterable\n     */\n  }, {\n    key: \"_createIterable\",\n    value: function _createIterable(getMaps) {\n      return new SnapshotIterable(this, getMaps);\n    }\n\n    /**\n     * @returns {Iterable<string>} iterable\n     */\n  }, {\n    key: \"getFileIterable\",\n    value: function getFileIterable() {\n      if (this._cachedFileIterable === undefined) {\n        this._cachedFileIterable = this._createIterable(function (s) {\n          return [s.fileTimestamps, s.fileHashes, s.fileTshs, s.managedFiles];\n        });\n      }\n      return this._cachedFileIterable;\n    }\n\n    /**\n     * @returns {Iterable<string>} iterable\n     */\n  }, {\n    key: \"getContextIterable\",\n    value: function getContextIterable() {\n      if (this._cachedContextIterable === undefined) {\n        this._cachedContextIterable = this._createIterable(function (s) {\n          return [s.contextTimestamps, s.contextHashes, s.contextTshs, s.managedContexts];\n        });\n      }\n      return this._cachedContextIterable;\n    }\n\n    /**\n     * @returns {Iterable<string>} iterable\n     */\n  }, {\n    key: \"getMissingIterable\",\n    value: function getMissingIterable() {\n      if (this._cachedMissingIterable === undefined) {\n        this._cachedMissingIterable = this._createIterable(function (s) {\n          return [s.missingExistence, s.managedMissing];\n        });\n      }\n      return this._cachedMissingIterable;\n    }\n  }]);\n  return Snapshot;\n}();\nmakeSerializable(Snapshot, \"webpack/lib/FileSystemInfo\", \"Snapshot\");\nvar MIN_COMMON_SNAPSHOT_SIZE = 3;\n\n/**\n * @template T\n */\nvar SnapshotOptimization = /*#__PURE__*/function () {\n  /**\n   * @param {function(Snapshot): boolean} has has value\n   * @param {function(Snapshot): Map<string, T> | Set<string>} get get value\n   * @param {function(Snapshot, Map<string, T> | Set<string>): void} set set value\n   * @param {boolean=} useStartTime use the start time of snapshots\n   * @param {boolean=} isSet value is an Set instead of a Map\n   */\n  function SnapshotOptimization(has, get, set) {\n    var useStartTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var isSet = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    _classCallCheck(this, SnapshotOptimization);\n    this._has = has;\n    this._get = get;\n    this._set = set;\n    this._useStartTime = useStartTime;\n    this._isSet = isSet;\n    /** @type {Map<string, SnapshotOptimizationEntry>} */\n    this._map = new Map();\n    this._statItemsShared = 0;\n    this._statItemsUnshared = 0;\n    this._statSharedSnapshots = 0;\n    this._statReusedSharedSnapshots = 0;\n  }\n  _createClass(SnapshotOptimization, [{\n    key: \"getStatisticMessage\",\n    value: function getStatisticMessage() {\n      var total = this._statItemsShared + this._statItemsUnshared;\n      if (total === 0) return undefined;\n      return \"\".concat(this._statItemsShared && Math.round(this._statItemsShared * 100 / total), \"% (\").concat(this._statItemsShared, \"/\").concat(total, \") entries shared via \").concat(this._statSharedSnapshots, \" shared snapshots (\").concat(this._statReusedSharedSnapshots + this._statSharedSnapshots, \" times referenced)\");\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._map.clear();\n      this._statItemsShared = 0;\n      this._statItemsUnshared = 0;\n      this._statSharedSnapshots = 0;\n      this._statReusedSharedSnapshots = 0;\n    }\n\n    /**\n     * @param {Snapshot} newSnapshot snapshot\n     * @param {Set<string>} capturedFiles files to snapshot/share\n     * @returns {void}\n     */\n  }, {\n    key: \"optimize\",\n    value: function optimize(newSnapshot, capturedFiles) {\n      var _this2 = this;\n      /**\n       * @param {SnapshotOptimizationEntry} entry optimization entry\n       * @returns {void}\n       */\n      var increaseSharedAndStoreOptimizationEntry = function increaseSharedAndStoreOptimizationEntry(entry) {\n        if (entry.children !== undefined) {\n          entry.children.forEach(increaseSharedAndStoreOptimizationEntry);\n        }\n        entry.shared++;\n        storeOptimizationEntry(entry);\n      };\n      /**\n       * @param {SnapshotOptimizationEntry} entry optimization entry\n       * @returns {void}\n       */\n      var storeOptimizationEntry = function storeOptimizationEntry(entry) {\n        var _iterator3 = _createForOfIteratorHelper(entry.snapshotContent),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var path = _step3.value;\n            var old = _this2._map.get(path);\n            if (old.shared < entry.shared) {\n              _this2._map.set(path, entry);\n            }\n            capturedFiles.delete(path);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      };\n\n      /** @type {SnapshotOptimizationEntry} */\n      var newOptimizationEntry = undefined;\n      var capturedFilesSize = capturedFiles.size;\n\n      /** @type {Set<SnapshotOptimizationEntry> | undefined} */\n      var optimizationEntries = new Set();\n      var _iterator4 = _createForOfIteratorHelper(capturedFiles),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var path = _step4.value;\n          var optimizationEntry = this._map.get(path);\n          if (optimizationEntry === undefined) {\n            if (newOptimizationEntry === undefined) {\n              newOptimizationEntry = {\n                snapshot: newSnapshot,\n                shared: 0,\n                snapshotContent: undefined,\n                children: undefined\n              };\n            }\n            this._map.set(path, newOptimizationEntry);\n            continue;\n          } else {\n            optimizationEntries.add(optimizationEntry);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      var _iterator5 = _createForOfIteratorHelper(optimizationEntries),\n        _step5;\n      try {\n        optimizationEntries: for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _optimizationEntry = _step5.value;\n          var snapshot = _optimizationEntry.snapshot;\n          if (_optimizationEntry.shared > 0) {\n            // It's a shared snapshot\n            // We can't change it, so we can only use it when all files match\n            // and startTime is compatible\n            if (this._useStartTime && newSnapshot.startTime && (!snapshot.startTime || snapshot.startTime > newSnapshot.startTime)) {\n              continue;\n            }\n            var nonSharedFiles = new Set();\n            var snapshotContent = _optimizationEntry.snapshotContent;\n            var snapshotEntries = this._get(snapshot);\n            var _iterator6 = _createForOfIteratorHelper(snapshotContent),\n              _step6;\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var _path3 = _step6.value;\n                if (!capturedFiles.has(_path3)) {\n                  if (!snapshotEntries.has(_path3)) {\n                    // File is not shared and can't be removed from the snapshot\n                    // because it's in a child of the snapshot\n                    continue optimizationEntries;\n                  }\n                  nonSharedFiles.add(_path3);\n                  continue;\n                }\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n            if (nonSharedFiles.size === 0) {\n              // The complete snapshot is shared\n              // add it as child\n              newSnapshot.addChild(snapshot);\n              increaseSharedAndStoreOptimizationEntry(_optimizationEntry);\n              this._statReusedSharedSnapshots++;\n            } else {\n              // Only a part of the snapshot is shared\n              var sharedCount = snapshotContent.size - nonSharedFiles.size;\n              if (sharedCount < MIN_COMMON_SNAPSHOT_SIZE) {\n                // Common part it too small\n                continue optimizationEntries;\n              }\n              // Extract common timestamps from both snapshots\n              var commonMap = void 0;\n              if (this._isSet) {\n                commonMap = new Set();\n                var _iterator7 = _createForOfIteratorHelper( /** @type {Set<string>} */snapshotEntries),\n                  _step7;\n                try {\n                  for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                    var _path = _step7.value;\n                    if (nonSharedFiles.has(_path)) continue;\n                    commonMap.add(_path);\n                    snapshotEntries.delete(_path);\n                  }\n                } catch (err) {\n                  _iterator7.e(err);\n                } finally {\n                  _iterator7.f();\n                }\n              } else {\n                commonMap = new Map();\n                var map = /** @type {Map<string, T>} */snapshotEntries;\n                var _iterator8 = _createForOfIteratorHelper(map),\n                  _step8;\n                try {\n                  for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                    var _step8$value = _slicedToArray(_step8.value, 2),\n                      _path2 = _step8$value[0],\n                      value = _step8$value[1];\n                    if (nonSharedFiles.has(_path2)) continue;\n                    commonMap.set(_path2, value);\n                    snapshotEntries.delete(_path2);\n                  }\n                } catch (err) {\n                  _iterator8.e(err);\n                } finally {\n                  _iterator8.f();\n                }\n              }\n              // Create and attach snapshot\n              var commonSnapshot = new Snapshot();\n              if (this._useStartTime) {\n                commonSnapshot.setMergedStartTime(newSnapshot.startTime, snapshot);\n              }\n              this._set(commonSnapshot, commonMap);\n              newSnapshot.addChild(commonSnapshot);\n              snapshot.addChild(commonSnapshot);\n              // Create optimization entry\n              var newEntry = {\n                snapshot: commonSnapshot,\n                shared: _optimizationEntry.shared + 1,\n                snapshotContent: new Set(commonMap.keys()),\n                children: undefined\n              };\n              if (_optimizationEntry.children === undefined) _optimizationEntry.children = new Set();\n              _optimizationEntry.children.add(newEntry);\n              storeOptimizationEntry(newEntry);\n              this._statSharedSnapshots++;\n            }\n          } else {\n            // It's a unshared snapshot\n            // We can extract a common shared snapshot\n            // with all common files\n            var _snapshotEntries = this._get(snapshot);\n            if (_snapshotEntries === undefined) {\n              // Incomplete snapshot, that can't be used\n              continue optimizationEntries;\n            }\n            var _commonMap = void 0;\n            if (this._isSet) {\n              _commonMap = new Set();\n              var set = /** @type {Set<string>} */_snapshotEntries;\n              if (capturedFiles.size < set.size) {\n                var _iterator9 = _createForOfIteratorHelper(capturedFiles),\n                  _step9;\n                try {\n                  for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                    var _path4 = _step9.value;\n                    if (set.has(_path4)) _commonMap.add(_path4);\n                  }\n                } catch (err) {\n                  _iterator9.e(err);\n                } finally {\n                  _iterator9.f();\n                }\n              } else {\n                var _iterator10 = _createForOfIteratorHelper(set),\n                  _step10;\n                try {\n                  for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                    var _path5 = _step10.value;\n                    if (capturedFiles.has(_path5)) _commonMap.add(_path5);\n                  }\n                } catch (err) {\n                  _iterator10.e(err);\n                } finally {\n                  _iterator10.f();\n                }\n              }\n            } else {\n              _commonMap = new Map();\n              var _map = /** @type {Map<string, T>} */_snapshotEntries;\n              var _iterator11 = _createForOfIteratorHelper(capturedFiles),\n                _step11;\n              try {\n                for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                  var _path6 = _step11.value;\n                  var ts = _map.get(_path6);\n                  if (ts === undefined) continue;\n                  _commonMap.set(_path6, ts);\n                }\n              } catch (err) {\n                _iterator11.e(err);\n              } finally {\n                _iterator11.f();\n              }\n            }\n            if (_commonMap.size < MIN_COMMON_SNAPSHOT_SIZE) {\n              // Common part it too small\n              continue optimizationEntries;\n            }\n            // Create and attach snapshot\n            var _commonSnapshot = new Snapshot();\n            if (this._useStartTime) {\n              _commonSnapshot.setMergedStartTime(newSnapshot.startTime, snapshot);\n            }\n            this._set(_commonSnapshot, _commonMap);\n            newSnapshot.addChild(_commonSnapshot);\n            snapshot.addChild(_commonSnapshot);\n            // Remove files from snapshot\n            var _iterator12 = _createForOfIteratorHelper(_commonMap.keys()),\n              _step12;\n            try {\n              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                var _path7 = _step12.value;\n                _snapshotEntries.delete(_path7);\n              }\n            } catch (err) {\n              _iterator12.e(err);\n            } finally {\n              _iterator12.f();\n            }\n            var _sharedCount = _commonMap.size;\n            this._statItemsUnshared -= _sharedCount;\n            this._statItemsShared += _sharedCount;\n            // Create optimization entry\n            storeOptimizationEntry({\n              snapshot: _commonSnapshot,\n              shared: 2,\n              snapshotContent: new Set(_commonMap.keys()),\n              children: undefined\n            });\n            this._statSharedSnapshots++;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      var unshared = capturedFiles.size;\n      this._statItemsUnshared += unshared;\n      this._statItemsShared += capturedFilesSize - unshared;\n    }\n  }]);\n  return SnapshotOptimization;\n}();\nvar parseString = function parseString(str) {\n  if (str[0] === \"'\") str = \"\\\"\".concat(str.slice(1, -1).replace(/\"/g, '\\\\\"'), \"\\\"\");\n  return JSON.parse(str);\n};\n\n/* istanbul ignore next */\n/**\n * @param {number} mtime mtime\n */\nvar applyMtime = function applyMtime(mtime) {\n  if (FS_ACCURACY > 1 && mtime % 2 !== 0) FS_ACCURACY = 1;else if (FS_ACCURACY > 10 && mtime % 20 !== 0) FS_ACCURACY = 10;else if (FS_ACCURACY > 100 && mtime % 200 !== 0) FS_ACCURACY = 100;else if (FS_ACCURACY > 1000 && mtime % 2000 !== 0) FS_ACCURACY = 1000;\n};\n\n/**\n * @template T\n * @template K\n * @param {Map<T, K>} a source map\n * @param {Map<T, K>} b joining map\n * @returns {Map<T, K>} joined map\n */\nvar mergeMaps = function mergeMaps(a, b) {\n  if (!b || b.size === 0) return a;\n  if (!a || a.size === 0) return b;\n  var map = new Map(a);\n  var _iterator13 = _createForOfIteratorHelper(b),\n    _step13;\n  try {\n    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n      var _step13$value = _slicedToArray(_step13.value, 2),\n        key = _step13$value[0],\n        value = _step13$value[1];\n      map.set(key, value);\n    }\n  } catch (err) {\n    _iterator13.e(err);\n  } finally {\n    _iterator13.f();\n  }\n  return map;\n};\n\n/**\n * @template T\n * @template K\n * @param {Set<T, K>} a source map\n * @param {Set<T, K>} b joining map\n * @returns {Set<T, K>} joined map\n */\nvar mergeSets = function mergeSets(a, b) {\n  if (!b || b.size === 0) return a;\n  if (!a || a.size === 0) return b;\n  var map = new Set(a);\n  var _iterator14 = _createForOfIteratorHelper(b),\n    _step14;\n  try {\n    for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n      var item = _step14.value;\n      map.add(item);\n    }\n  } catch (err) {\n    _iterator14.e(err);\n  } finally {\n    _iterator14.f();\n  }\n  return map;\n};\n\n/**\n * Finding file or directory to manage\n * @param {string} managedPath path that is managing by {@link FileSystemInfo}\n * @param {string} path path to file or directory\n * @returns {string|null} managed item\n * @example\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/package/index.js'\n * ) === '/Users/user/my-project/node_modules/package'\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/package1/node_modules/package2'\n * ) === '/Users/user/my-project/node_modules/package1/node_modules/package2'\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/.bin/script.js'\n * ) === null // hidden files are disallowed as managed items\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/package'\n * ) === '/Users/user/my-project/node_modules/package'\n */\nvar getManagedItem = function getManagedItem(managedPath, path) {\n  var i = managedPath.length;\n  var slashes = 1;\n  var startingPosition = true;\n  loop: while (i < path.length) {\n    switch (path.charCodeAt(i)) {\n      case 47: // slash\n      case 92:\n        // backslash\n        if (--slashes === 0) break loop;\n        startingPosition = true;\n        break;\n      case 46:\n        // .\n        // hidden files are disallowed as managed items\n        // it's probably .yarn-integrity or .cache\n        if (startingPosition) return null;\n        break;\n      case 64:\n        // @\n        if (!startingPosition) return null;\n        slashes++;\n        break;\n      default:\n        startingPosition = false;\n        break;\n    }\n    i++;\n  }\n  if (i === path.length) slashes--;\n  // return null when path is incomplete\n  if (slashes !== 0) return null;\n  // if (path.slice(i + 1, i + 13) === \"node_modules\")\n  if (path.length >= i + 13 && path.charCodeAt(i + 1) === 110 && path.charCodeAt(i + 2) === 111 && path.charCodeAt(i + 3) === 100 && path.charCodeAt(i + 4) === 101 && path.charCodeAt(i + 5) === 95 && path.charCodeAt(i + 6) === 109 && path.charCodeAt(i + 7) === 111 && path.charCodeAt(i + 8) === 100 && path.charCodeAt(i + 9) === 117 && path.charCodeAt(i + 10) === 108 && path.charCodeAt(i + 11) === 101 && path.charCodeAt(i + 12) === 115) {\n    // if this is the end of the path\n    if (path.length === i + 13) {\n      // return the node_modules directory\n      // it's special\n      return path;\n    }\n    var c = path.charCodeAt(i + 13);\n    // if next symbol is slash or backslash\n    if (c === 47 || c === 92) {\n      // Managed subpath\n      return getManagedItem(path.slice(0, i + 14), path);\n    }\n  }\n  return path.slice(0, i);\n};\n\n/**\n * @template {ContextFileSystemInfoEntry | ContextTimestampAndHash} T\n * @param {T} entry entry\n * @returns {T[\"resolved\"] | undefined} the resolved entry\n */\nvar getResolvedTimestamp = function getResolvedTimestamp(entry) {\n  if (entry === null) return null;\n  if (entry.resolved !== undefined) return entry.resolved;\n  return entry.symlinks === undefined ? entry : undefined;\n};\n\n/**\n * @param {ContextHash} entry entry\n * @returns {string | undefined} the resolved entry\n */\nvar getResolvedHash = function getResolvedHash(entry) {\n  if (entry === null) return null;\n  if (entry.resolved !== undefined) return entry.resolved;\n  return entry.symlinks === undefined ? entry.hash : undefined;\n};\nvar addAll = function addAll(source, target) {\n  var _iterator15 = _createForOfIteratorHelper(source),\n    _step15;\n  try {\n    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n      var key = _step15.value;\n      target.add(key);\n    }\n  } catch (err) {\n    _iterator15.e(err);\n  } finally {\n    _iterator15.f();\n  }\n};\n\n/**\n * Used to access information about the filesystem in a cached way\n */\nvar FileSystemInfo = /*#__PURE__*/function () {\n  /**\n   * @param {InputFileSystem} fs file system\n   * @param {Object} options options\n   * @param {Iterable<string | RegExp>=} options.managedPaths paths that are only managed by a package manager\n   * @param {Iterable<string | RegExp>=} options.immutablePaths paths that are immutable\n   * @param {Logger=} options.logger logger used to log invalid snapshots\n   * @param {string | Hash=} options.hashFunction the hash function to use\n   */\n  function FileSystemInfo(fs) {\n    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref3$managedPaths = _ref3.managedPaths,\n      managedPaths = _ref3$managedPaths === void 0 ? [] : _ref3$managedPaths,\n      _ref3$immutablePaths = _ref3.immutablePaths,\n      immutablePaths = _ref3$immutablePaths === void 0 ? [] : _ref3$immutablePaths,\n      logger = _ref3.logger,\n      _ref3$hashFunction = _ref3.hashFunction,\n      hashFunction = _ref3$hashFunction === void 0 ? \"md4\" : _ref3$hashFunction;\n    _classCallCheck(this, FileSystemInfo);\n    this.fs = fs;\n    this.logger = logger;\n    this._remainingLogs = logger ? 40 : 0;\n    this._loggedPaths = logger ? new Set() : undefined;\n    this._hashFunction = hashFunction;\n    /** @type {WeakMap<Snapshot, boolean | (function(WebpackError=, boolean=): void)[]>} */\n    this._snapshotCache = new WeakMap();\n    this._fileTimestampsOptimization = new SnapshotOptimization(function (s) {\n      return s.hasFileTimestamps();\n    }, function (s) {\n      return s.fileTimestamps;\n    }, function (s, v) {\n      return s.setFileTimestamps(v);\n    });\n    this._fileHashesOptimization = new SnapshotOptimization(function (s) {\n      return s.hasFileHashes();\n    }, function (s) {\n      return s.fileHashes;\n    }, function (s, v) {\n      return s.setFileHashes(v);\n    }, false);\n    this._fileTshsOptimization = new SnapshotOptimization(function (s) {\n      return s.hasFileTshs();\n    }, function (s) {\n      return s.fileTshs;\n    }, function (s, v) {\n      return s.setFileTshs(v);\n    });\n    this._contextTimestampsOptimization = new SnapshotOptimization(function (s) {\n      return s.hasContextTimestamps();\n    }, function (s) {\n      return s.contextTimestamps;\n    }, function (s, v) {\n      return s.setContextTimestamps(v);\n    });\n    this._contextHashesOptimization = new SnapshotOptimization(function (s) {\n      return s.hasContextHashes();\n    }, function (s) {\n      return s.contextHashes;\n    }, function (s, v) {\n      return s.setContextHashes(v);\n    }, false);\n    this._contextTshsOptimization = new SnapshotOptimization(function (s) {\n      return s.hasContextTshs();\n    }, function (s) {\n      return s.contextTshs;\n    }, function (s, v) {\n      return s.setContextTshs(v);\n    });\n    this._missingExistenceOptimization = new SnapshotOptimization(function (s) {\n      return s.hasMissingExistence();\n    }, function (s) {\n      return s.missingExistence;\n    }, function (s, v) {\n      return s.setMissingExistence(v);\n    }, false);\n    this._managedItemInfoOptimization = new SnapshotOptimization(function (s) {\n      return s.hasManagedItemInfo();\n    }, function (s) {\n      return s.managedItemInfo;\n    }, function (s, v) {\n      return s.setManagedItemInfo(v);\n    }, false);\n    this._managedFilesOptimization = new SnapshotOptimization(function (s) {\n      return s.hasManagedFiles();\n    }, function (s) {\n      return s.managedFiles;\n    }, function (s, v) {\n      return s.setManagedFiles(v);\n    }, false, true);\n    this._managedContextsOptimization = new SnapshotOptimization(function (s) {\n      return s.hasManagedContexts();\n    }, function (s) {\n      return s.managedContexts;\n    }, function (s, v) {\n      return s.setManagedContexts(v);\n    }, false, true);\n    this._managedMissingOptimization = new SnapshotOptimization(function (s) {\n      return s.hasManagedMissing();\n    }, function (s) {\n      return s.managedMissing;\n    }, function (s, v) {\n      return s.setManagedMissing(v);\n    }, false, true);\n    /** @type {StackedCacheMap<string, FileSystemInfoEntry | \"ignore\" | null>} */\n    this._fileTimestamps = new StackedCacheMap();\n    /** @type {Map<string, string>} */\n    this._fileHashes = new Map();\n    /** @type {Map<string, TimestampAndHash | string>} */\n    this._fileTshs = new Map();\n    /** @type {StackedCacheMap<string, ContextFileSystemInfoEntry | \"ignore\" | null>} */\n    this._contextTimestamps = new StackedCacheMap();\n    /** @type {Map<string, ContextHash>} */\n    this._contextHashes = new Map();\n    /** @type {Map<string, ContextTimestampAndHash>} */\n    this._contextTshs = new Map();\n    /** @type {Map<string, string>} */\n    this._managedItems = new Map();\n    /** @type {AsyncQueue<string, string, FileSystemInfoEntry | null>} */\n    this.fileTimestampQueue = new AsyncQueue({\n      name: \"file timestamp\",\n      parallelism: 30,\n      processor: this._readFileTimestamp.bind(this)\n    });\n    /** @type {AsyncQueue<string, string, string | null>} */\n    this.fileHashQueue = new AsyncQueue({\n      name: \"file hash\",\n      parallelism: 10,\n      processor: this._readFileHash.bind(this)\n    });\n    /** @type {AsyncQueue<string, string, ContextFileSystemInfoEntry | null>} */\n    this.contextTimestampQueue = new AsyncQueue({\n      name: \"context timestamp\",\n      parallelism: 2,\n      processor: this._readContextTimestamp.bind(this)\n    });\n    /** @type {AsyncQueue<string, string, ContextHash | null>} */\n    this.contextHashQueue = new AsyncQueue({\n      name: \"context hash\",\n      parallelism: 2,\n      processor: this._readContextHash.bind(this)\n    });\n    /** @type {AsyncQueue<string, string, ContextTimestampAndHash | null>} */\n    this.contextTshQueue = new AsyncQueue({\n      name: \"context hash and timestamp\",\n      parallelism: 2,\n      processor: this._readContextTimestampAndHash.bind(this)\n    });\n    /** @type {AsyncQueue<string, string, string | null>} */\n    this.managedItemQueue = new AsyncQueue({\n      name: \"managed item info\",\n      parallelism: 10,\n      processor: this._getManagedItemInfo.bind(this)\n    });\n    /** @type {AsyncQueue<string, string, Set<string>>} */\n    this.managedItemDirectoryQueue = new AsyncQueue({\n      name: \"managed item directory info\",\n      parallelism: 10,\n      processor: this._getManagedItemDirectoryInfo.bind(this)\n    });\n    this.managedPaths = Array.from(managedPaths);\n    this.managedPathsWithSlash = /** @type {string[]} */this.managedPaths.filter(function (p) {\n      return typeof p === \"string\";\n    }).map(function (p) {\n      return join(fs, p, \"_\").slice(0, -1);\n    });\n    this.managedPathsRegExps = /** @type {RegExp[]} */\n    this.managedPaths.filter(function (p) {\n      return typeof p !== \"string\";\n    });\n    this.immutablePaths = Array.from(immutablePaths);\n    this.immutablePathsWithSlash = /** @type {string[]} */this.immutablePaths.filter(function (p) {\n      return typeof p === \"string\";\n    }).map(function (p) {\n      return join(fs, p, \"_\").slice(0, -1);\n    });\n    this.immutablePathsRegExps = /** @type {RegExp[]} */\n    this.immutablePaths.filter(function (p) {\n      return typeof p !== \"string\";\n    });\n    this._cachedDeprecatedFileTimestamps = undefined;\n    this._cachedDeprecatedContextTimestamps = undefined;\n    this._warnAboutExperimentalEsmTracking = false;\n    this._statCreatedSnapshots = 0;\n    this._statTestedSnapshotsCached = 0;\n    this._statTestedSnapshotsNotCached = 0;\n    this._statTestedChildrenCached = 0;\n    this._statTestedChildrenNotCached = 0;\n    this._statTestedEntries = 0;\n  }\n  _createClass(FileSystemInfo, [{\n    key: \"logStatistics\",\n    value: function logStatistics() {\n      var _this3 = this;\n      var logWhenMessage = function logWhenMessage(header, message) {\n        if (message) {\n          _this3.logger.log(\"\".concat(header, \": \").concat(message));\n        }\n      };\n      this.logger.log(\"\".concat(this._statCreatedSnapshots, \" new snapshots created\"));\n      this.logger.log(\"\".concat(this._statTestedSnapshotsNotCached && Math.round(this._statTestedSnapshotsNotCached * 100 / (this._statTestedSnapshotsCached + this._statTestedSnapshotsNotCached)), \"% root snapshot uncached (\").concat(this._statTestedSnapshotsNotCached, \" / \").concat(this._statTestedSnapshotsCached + this._statTestedSnapshotsNotCached, \")\"));\n      this.logger.log(\"\".concat(this._statTestedChildrenNotCached && Math.round(this._statTestedChildrenNotCached * 100 / (this._statTestedChildrenCached + this._statTestedChildrenNotCached)), \"% children snapshot uncached (\").concat(this._statTestedChildrenNotCached, \" / \").concat(this._statTestedChildrenCached + this._statTestedChildrenNotCached, \")\"));\n      this.logger.log(\"\".concat(this._statTestedEntries, \" entries tested\"));\n      this.logger.log(\"File info in cache: \".concat(this._fileTimestamps.size, \" timestamps \").concat(this._fileHashes.size, \" hashes \").concat(this._fileTshs.size, \" timestamp hash combinations\"));\n      logWhenMessage(\"File timestamp snapshot optimization\", this._fileTimestampsOptimization.getStatisticMessage());\n      logWhenMessage(\"File hash snapshot optimization\", this._fileHashesOptimization.getStatisticMessage());\n      logWhenMessage(\"File timestamp hash combination snapshot optimization\", this._fileTshsOptimization.getStatisticMessage());\n      this.logger.log(\"Directory info in cache: \".concat(this._contextTimestamps.size, \" timestamps \").concat(this._contextHashes.size, \" hashes \").concat(this._contextTshs.size, \" timestamp hash combinations\"));\n      logWhenMessage(\"Directory timestamp snapshot optimization\", this._contextTimestampsOptimization.getStatisticMessage());\n      logWhenMessage(\"Directory hash snapshot optimization\", this._contextHashesOptimization.getStatisticMessage());\n      logWhenMessage(\"Directory timestamp hash combination snapshot optimization\", this._contextTshsOptimization.getStatisticMessage());\n      logWhenMessage(\"Missing items snapshot optimization\", this._missingExistenceOptimization.getStatisticMessage());\n      this.logger.log(\"Managed items info in cache: \".concat(this._managedItems.size, \" items\"));\n      logWhenMessage(\"Managed items snapshot optimization\", this._managedItemInfoOptimization.getStatisticMessage());\n      logWhenMessage(\"Managed files snapshot optimization\", this._managedFilesOptimization.getStatisticMessage());\n      logWhenMessage(\"Managed contexts snapshot optimization\", this._managedContextsOptimization.getStatisticMessage());\n      logWhenMessage(\"Managed missing snapshot optimization\", this._managedMissingOptimization.getStatisticMessage());\n    }\n  }, {\n    key: \"_log\",\n    value: function _log(path, reason) {\n      var _this$logger;\n      var key = path + reason;\n      if (this._loggedPaths.has(key)) return;\n      this._loggedPaths.add(key);\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n      (_this$logger = this.logger).debug.apply(_this$logger, [\"\".concat(path, \" invalidated because \").concat(reason)].concat(args));\n      if (--this._remainingLogs === 0) {\n        this.logger.debug(\"Logging limit has been reached and no further logging will be emitted by FileSystemInfo\");\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._remainingLogs = this.logger ? 40 : 0;\n      if (this._loggedPaths !== undefined) this._loggedPaths.clear();\n      this._snapshotCache = new WeakMap();\n      this._fileTimestampsOptimization.clear();\n      this._fileHashesOptimization.clear();\n      this._fileTshsOptimization.clear();\n      this._contextTimestampsOptimization.clear();\n      this._contextHashesOptimization.clear();\n      this._contextTshsOptimization.clear();\n      this._missingExistenceOptimization.clear();\n      this._managedItemInfoOptimization.clear();\n      this._managedFilesOptimization.clear();\n      this._managedContextsOptimization.clear();\n      this._managedMissingOptimization.clear();\n      this._fileTimestamps.clear();\n      this._fileHashes.clear();\n      this._fileTshs.clear();\n      this._contextTimestamps.clear();\n      this._contextHashes.clear();\n      this._contextTshs.clear();\n      this._managedItems.clear();\n      this._managedItems.clear();\n      this._cachedDeprecatedFileTimestamps = undefined;\n      this._cachedDeprecatedContextTimestamps = undefined;\n      this._statCreatedSnapshots = 0;\n      this._statTestedSnapshotsCached = 0;\n      this._statTestedSnapshotsNotCached = 0;\n      this._statTestedChildrenCached = 0;\n      this._statTestedChildrenNotCached = 0;\n      this._statTestedEntries = 0;\n    }\n\n    /**\n     * @param {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} map timestamps\n     * @param {boolean=} immutable if 'map' is immutable and FileSystemInfo can keep referencing it\n     * @returns {void}\n     */\n  }, {\n    key: \"addFileTimestamps\",\n    value: function addFileTimestamps(map, immutable) {\n      this._fileTimestamps.addAll(map, immutable);\n      this._cachedDeprecatedFileTimestamps = undefined;\n    }\n\n    /**\n     * @param {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} map timestamps\n     * @param {boolean=} immutable if 'map' is immutable and FileSystemInfo can keep referencing it\n     * @returns {void}\n     */\n  }, {\n    key: \"addContextTimestamps\",\n    value: function addContextTimestamps(map, immutable) {\n      this._contextTimestamps.addAll(map, immutable);\n      this._cachedDeprecatedContextTimestamps = undefined;\n    }\n\n    /**\n     * @param {string} path file path\n     * @param {function((WebpackError | null)=, (FileSystemInfoEntry | \"ignore\" | null)=): void} callback callback function\n     * @returns {void}\n     */\n  }, {\n    key: \"getFileTimestamp\",\n    value: function getFileTimestamp(path, callback) {\n      var cache = this._fileTimestamps.get(path);\n      if (cache !== undefined) return callback(null, cache);\n      this.fileTimestampQueue.add(path, callback);\n    }\n\n    /**\n     * @param {string} path context path\n     * @param {function((WebpackError | null)=, (ResolvedContextFileSystemInfoEntry | \"ignore\" | null)=): void} callback callback function\n     * @returns {void}\n     */\n  }, {\n    key: \"getContextTimestamp\",\n    value: function getContextTimestamp(path, callback) {\n      var _this4 = this;\n      var cache = this._contextTimestamps.get(path);\n      if (cache !== undefined) {\n        if (cache === \"ignore\") return callback(null, \"ignore\");\n        var resolved = getResolvedTimestamp(cache);\n        if (resolved !== undefined) return callback(null, resolved);\n        return this._resolveContextTimestamp(cache, callback);\n      }\n      this.contextTimestampQueue.add(path, function (err, entry) {\n        if (err) return callback(err);\n        var resolved = getResolvedTimestamp(entry);\n        if (resolved !== undefined) return callback(null, resolved);\n        _this4._resolveContextTimestamp(entry, callback);\n      });\n    }\n\n    /**\n     * @param {string} path context path\n     * @param {function((WebpackError | null)=, (ContextFileSystemInfoEntry | \"ignore\" | null)=): void} callback callback function\n     * @returns {void}\n     */\n  }, {\n    key: \"_getUnresolvedContextTimestamp\",\n    value: function _getUnresolvedContextTimestamp(path, callback) {\n      var cache = this._contextTimestamps.get(path);\n      if (cache !== undefined) return callback(null, cache);\n      this.contextTimestampQueue.add(path, callback);\n    }\n\n    /**\n     * @param {string} path file path\n     * @param {function((WebpackError | null)=, string=): void} callback callback function\n     * @returns {void}\n     */\n  }, {\n    key: \"getFileHash\",\n    value: function getFileHash(path, callback) {\n      var cache = this._fileHashes.get(path);\n      if (cache !== undefined) return callback(null, cache);\n      this.fileHashQueue.add(path, callback);\n    }\n\n    /**\n     * @param {string} path context path\n     * @param {function((WebpackError | null)=, string=): void} callback callback function\n     * @returns {void}\n     */\n  }, {\n    key: \"getContextHash\",\n    value: function getContextHash(path, callback) {\n      var _this5 = this;\n      var cache = this._contextHashes.get(path);\n      if (cache !== undefined) {\n        var resolved = getResolvedHash(cache);\n        if (resolved !== undefined) return callback(null, resolved);\n        return this._resolveContextHash(cache, callback);\n      }\n      this.contextHashQueue.add(path, function (err, entry) {\n        if (err) return callback(err);\n        var resolved = getResolvedHash(entry);\n        if (resolved !== undefined) return callback(null, resolved);\n        _this5._resolveContextHash(entry, callback);\n      });\n    }\n\n    /**\n     * @param {string} path context path\n     * @param {function((WebpackError | null)=, ContextHash=): void} callback callback function\n     * @returns {void}\n     */\n  }, {\n    key: \"_getUnresolvedContextHash\",\n    value: function _getUnresolvedContextHash(path, callback) {\n      var cache = this._contextHashes.get(path);\n      if (cache !== undefined) return callback(null, cache);\n      this.contextHashQueue.add(path, callback);\n    }\n\n    /**\n     * @param {string} path context path\n     * @param {function((WebpackError | null)=, ResolvedContextTimestampAndHash=): void} callback callback function\n     * @returns {void}\n     */\n  }, {\n    key: \"getContextTsh\",\n    value: function getContextTsh(path, callback) {\n      var _this6 = this;\n      var cache = this._contextTshs.get(path);\n      if (cache !== undefined) {\n        var resolved = getResolvedTimestamp(cache);\n        if (resolved !== undefined) return callback(null, resolved);\n        return this._resolveContextTsh(cache, callback);\n      }\n      this.contextTshQueue.add(path, function (err, entry) {\n        if (err) return callback(err);\n        var resolved = getResolvedTimestamp(entry);\n        if (resolved !== undefined) return callback(null, resolved);\n        _this6._resolveContextTsh(entry, callback);\n      });\n    }\n\n    /**\n     * @param {string} path context path\n     * @param {function((WebpackError | null)=, ContextTimestampAndHash=): void} callback callback function\n     * @returns {void}\n     */\n  }, {\n    key: \"_getUnresolvedContextTsh\",\n    value: function _getUnresolvedContextTsh(path, callback) {\n      var cache = this._contextTshs.get(path);\n      if (cache !== undefined) return callback(null, cache);\n      this.contextTshQueue.add(path, callback);\n    }\n  }, {\n    key: \"_createBuildDependenciesResolvers\",\n    value: function _createBuildDependenciesResolvers() {\n      var resolveContext = createResolver({\n        resolveToContext: true,\n        exportsFields: [],\n        fileSystem: this.fs\n      });\n      var resolveCjs = createResolver({\n        extensions: [\".js\", \".json\", \".node\"],\n        conditionNames: [\"require\", \"node\"],\n        exportsFields: [\"exports\"],\n        fileSystem: this.fs\n      });\n      var resolveCjsAsChild = createResolver({\n        extensions: [\".js\", \".json\", \".node\"],\n        conditionNames: [\"require\", \"node\"],\n        exportsFields: [],\n        fileSystem: this.fs\n      });\n      var resolveEsm = createResolver({\n        extensions: [\".js\", \".json\", \".node\"],\n        fullySpecified: true,\n        conditionNames: [\"import\", \"node\"],\n        exportsFields: [\"exports\"],\n        fileSystem: this.fs\n      });\n      return {\n        resolveContext: resolveContext,\n        resolveEsm: resolveEsm,\n        resolveCjs: resolveCjs,\n        resolveCjsAsChild: resolveCjsAsChild\n      };\n    }\n\n    /**\n     * @param {string} context context directory\n     * @param {Iterable<string>} deps dependencies\n     * @param {function((Error | null)=, ResolveBuildDependenciesResult=): void} callback callback function\n     * @returns {void}\n     */\n  }, {\n    key: \"resolveBuildDependencies\",\n    value: function resolveBuildDependencies(context, deps, callback) {\n      var _this7 = this;\n      var _this$_createBuildDep = this._createBuildDependenciesResolvers(),\n        resolveContext = _this$_createBuildDep.resolveContext,\n        resolveEsm = _this$_createBuildDep.resolveEsm,\n        resolveCjs = _this$_createBuildDep.resolveCjs,\n        resolveCjsAsChild = _this$_createBuildDep.resolveCjsAsChild;\n\n      /** @type {Set<string>} */\n      var files = new Set();\n      /** @type {Set<string>} */\n      var fileSymlinks = new Set();\n      /** @type {Set<string>} */\n      var directories = new Set();\n      /** @type {Set<string>} */\n      var directorySymlinks = new Set();\n      /** @type {Set<string>} */\n      var missing = new Set();\n      /** @type {Set<string>} */\n      var resolveFiles = new Set();\n      /** @type {Set<string>} */\n      var resolveDirectories = new Set();\n      /** @type {Set<string>} */\n      var resolveMissing = new Set();\n      /** @type {Map<string, string | false>} */\n      var resolveResults = new Map();\n      var invalidResolveResults = new Set();\n      var resolverContext = {\n        fileDependencies: resolveFiles,\n        contextDependencies: resolveDirectories,\n        missingDependencies: resolveMissing\n      };\n      var expectedToString = function expectedToString(expected) {\n        return expected ? \" (expected \".concat(expected, \")\") : \"\";\n      };\n      var jobToString = function jobToString(job) {\n        switch (job.type) {\n          case RBDT_RESOLVE_CJS:\n            return \"resolve commonjs \".concat(job.path).concat(expectedToString(job.expected));\n          case RBDT_RESOLVE_ESM:\n            return \"resolve esm \".concat(job.path).concat(expectedToString(job.expected));\n          case RBDT_RESOLVE_DIRECTORY:\n            return \"resolve directory \".concat(job.path);\n          case RBDT_RESOLVE_CJS_FILE:\n            return \"resolve commonjs file \".concat(job.path).concat(expectedToString(job.expected));\n          case RBDT_RESOLVE_ESM_FILE:\n            return \"resolve esm file \".concat(job.path).concat(expectedToString(job.expected));\n          case RBDT_DIRECTORY:\n            return \"directory \".concat(job.path);\n          case RBDT_FILE:\n            return \"file \".concat(job.path);\n          case RBDT_DIRECTORY_DEPENDENCIES:\n            return \"directory dependencies \".concat(job.path);\n          case RBDT_FILE_DEPENDENCIES:\n            return \"file dependencies \".concat(job.path);\n        }\n        return \"unknown \".concat(job.type, \" \").concat(job.path);\n      };\n      var pathToString = function pathToString(job) {\n        var result = \" at \".concat(jobToString(job));\n        job = job.issuer;\n        while (job !== undefined) {\n          result += \"\\n at \".concat(jobToString(job));\n          job = job.issuer;\n        }\n        return result;\n      };\n      processAsyncTree(Array.from(deps, function (dep) {\n        return {\n          type: RBDT_RESOLVE_CJS,\n          context: context,\n          path: dep,\n          expected: undefined,\n          issuer: undefined\n        };\n      }), 20, function (job, push, callback) {\n        var type = job.type,\n          context = job.context,\n          path = job.path,\n          expected = job.expected;\n        var resolveDirectory = function resolveDirectory(path) {\n          var key = \"d\\n\".concat(context, \"\\n\").concat(path);\n          if (resolveResults.has(key)) {\n            return callback();\n          }\n          resolveResults.set(key, undefined);\n          resolveContext(context, path, resolverContext, function (err, _, result) {\n            if (err) {\n              if (expected === false) {\n                resolveResults.set(key, false);\n                return callback();\n              }\n              invalidResolveResults.add(key);\n              err.message += \"\\nwhile resolving '\".concat(path, \"' in \").concat(context, \" to a directory\");\n              return callback(err);\n            }\n            var resultPath = result.path;\n            resolveResults.set(key, resultPath);\n            push({\n              type: RBDT_DIRECTORY,\n              context: undefined,\n              path: resultPath,\n              expected: undefined,\n              issuer: job\n            });\n            callback();\n          });\n        };\n        var resolveFile = function resolveFile(path, symbol, resolve) {\n          var key = \"\".concat(symbol, \"\\n\").concat(context, \"\\n\").concat(path);\n          if (resolveResults.has(key)) {\n            return callback();\n          }\n          resolveResults.set(key, undefined);\n          resolve(context, path, resolverContext, function (err, _, result) {\n            if (typeof expected === \"string\") {\n              if (!err && result && result.path === expected) {\n                resolveResults.set(key, result.path);\n              } else {\n                invalidResolveResults.add(key);\n                _this7.logger.warn(\"Resolving '\".concat(path, \"' in \").concat(context, \" for build dependencies doesn't lead to expected result '\").concat(expected, \"', but to '\").concat(err || result && result.path, \"' instead. Resolving dependencies are ignored for this path.\\n\").concat(pathToString(job)));\n              }\n            } else {\n              if (err) {\n                if (expected === false) {\n                  resolveResults.set(key, false);\n                  return callback();\n                }\n                invalidResolveResults.add(key);\n                err.message += \"\\nwhile resolving '\".concat(path, \"' in \").concat(context, \" as file\\n\").concat(pathToString(job));\n                return callback(err);\n              }\n              var resultPath = result.path;\n              resolveResults.set(key, resultPath);\n              push({\n                type: RBDT_FILE,\n                context: undefined,\n                path: resultPath,\n                expected: undefined,\n                issuer: job\n              });\n            }\n            callback();\n          });\n        };\n        switch (type) {\n          case RBDT_RESOLVE_CJS:\n            {\n              var isDirectory = /[\\\\/]$/.test(path);\n              if (isDirectory) {\n                resolveDirectory(path.slice(0, path.length - 1));\n              } else {\n                resolveFile(path, \"f\", resolveCjs);\n              }\n              break;\n            }\n          case RBDT_RESOLVE_ESM:\n            {\n              var _isDirectory = /[\\\\/]$/.test(path);\n              if (_isDirectory) {\n                resolveDirectory(path.slice(0, path.length - 1));\n              } else {\n                resolveFile(path);\n              }\n              break;\n            }\n          case RBDT_RESOLVE_DIRECTORY:\n            {\n              resolveDirectory(path);\n              break;\n            }\n          case RBDT_RESOLVE_CJS_FILE:\n            {\n              resolveFile(path, \"f\", resolveCjs);\n              break;\n            }\n          case RBDT_RESOLVE_CJS_FILE_AS_CHILD:\n            {\n              resolveFile(path, \"c\", resolveCjsAsChild);\n              break;\n            }\n          case RBDT_RESOLVE_ESM_FILE:\n            {\n              resolveFile(path, \"e\", resolveEsm);\n              break;\n            }\n          case RBDT_FILE:\n            {\n              if (files.has(path)) {\n                callback();\n                break;\n              }\n              files.add(path);\n              _this7.fs.realpath(path, function (err, _realPath) {\n                if (err) return callback(err);\n                var realPath = /** @type {string} */_realPath;\n                if (realPath !== path) {\n                  fileSymlinks.add(path);\n                  resolveFiles.add(path);\n                  if (files.has(realPath)) return callback();\n                  files.add(realPath);\n                }\n                push({\n                  type: RBDT_FILE_DEPENDENCIES,\n                  context: undefined,\n                  path: realPath,\n                  expected: undefined,\n                  issuer: job\n                });\n                callback();\n              });\n              break;\n            }\n          case RBDT_DIRECTORY:\n            {\n              if (directories.has(path)) {\n                callback();\n                break;\n              }\n              directories.add(path);\n              _this7.fs.realpath(path, function (err, _realPath) {\n                if (err) return callback(err);\n                var realPath = /** @type {string} */_realPath;\n                if (realPath !== path) {\n                  directorySymlinks.add(path);\n                  resolveFiles.add(path);\n                  if (directories.has(realPath)) return callback();\n                  directories.add(realPath);\n                }\n                push({\n                  type: RBDT_DIRECTORY_DEPENDENCIES,\n                  context: undefined,\n                  path: realPath,\n                  expected: undefined,\n                  issuer: job\n                });\n                callback();\n              });\n              break;\n            }\n          case RBDT_FILE_DEPENDENCIES:\n            {\n              // Check for known files without dependencies\n              if (/\\.json5?$|\\.yarn-integrity$|yarn\\.lock$|\\.ya?ml/.test(path)) {\n                process.nextTick(callback);\n                break;\n              }\n              // Check commonjs cache for the module\n              /** @type {NodeModule} */\n              var _module = require.cache[path];\n              if (_module && Array.isArray(_module.children)) {\n                var _iterator16 = _createForOfIteratorHelper(_module.children),\n                  _step16;\n                try {\n                  children: for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                    var child = _step16.value;\n                    var childPath = child.filename;\n                    if (childPath) {\n                      push({\n                        type: RBDT_FILE,\n                        context: undefined,\n                        path: childPath,\n                        expected: undefined,\n                        issuer: job\n                      });\n                      var _context = dirname(_this7.fs, path);\n                      var _iterator17 = _createForOfIteratorHelper(_module.paths),\n                        _step17;\n                      try {\n                        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n                          var modulePath = _step17.value;\n                          if (childPath.startsWith(modulePath)) {\n                            var subPath = childPath.slice(modulePath.length + 1);\n                            var packageMatch = /^(@[^\\\\/]+[\\\\/])[^\\\\/]+/.exec(subPath);\n                            if (packageMatch) {\n                              push({\n                                type: RBDT_FILE,\n                                context: undefined,\n                                path: modulePath + childPath[modulePath.length] + packageMatch[0] + childPath[modulePath.length] + \"package.json\",\n                                expected: false,\n                                issuer: job\n                              });\n                            }\n                            var _request = subPath.replace(/\\\\/g, \"/\");\n                            if (_request.endsWith(\".js\")) _request = _request.slice(0, -3);\n                            push({\n                              type: RBDT_RESOLVE_CJS_FILE_AS_CHILD,\n                              context: _context,\n                              path: _request,\n                              expected: child.filename,\n                              issuer: job\n                            });\n                            continue children;\n                          }\n                        }\n                      } catch (err) {\n                        _iterator17.e(err);\n                      } finally {\n                        _iterator17.f();\n                      }\n                      var request = relative(_this7.fs, _context, childPath);\n                      if (request.endsWith(\".js\")) request = request.slice(0, -3);\n                      request = request.replace(/\\\\/g, \"/\");\n                      if (!request.startsWith(\"../\") && !isAbsolute(request)) {\n                        request = \"./\".concat(request);\n                      }\n                      push({\n                        type: RBDT_RESOLVE_CJS_FILE,\n                        context: _context,\n                        path: request,\n                        expected: child.filename,\n                        issuer: job\n                      });\n                    }\n                  }\n                } catch (err) {\n                  _iterator16.e(err);\n                } finally {\n                  _iterator16.f();\n                }\n              } else if (supportsEsm && /\\.m?js$/.test(path)) {\n                if (!_this7._warnAboutExperimentalEsmTracking) {\n                  _this7.logger.log(\"Node.js doesn't offer a (nice) way to introspect the ESM dependency graph yet.\\n\" + \"Until a full solution is available webpack uses an experimental ESM tracking based on parsing.\\n\" + \"As best effort webpack parses the ESM files to guess dependencies. But this can lead to expensive and incorrect tracking.\");\n                  _this7._warnAboutExperimentalEsmTracking = true;\n                }\n                var lexer = require(\"es-module-lexer\");\n                lexer.init.then(function () {\n                  _this7.fs.readFile(path, function (err, content) {\n                    if (err) return callback(err);\n                    try {\n                      var _context2 = dirname(_this7.fs, path);\n                      var source = content.toString();\n                      var _lexer$parse = lexer.parse(source),\n                        _lexer$parse2 = _slicedToArray(_lexer$parse, 1),\n                        imports = _lexer$parse2[0];\n                      var _iterator18 = _createForOfIteratorHelper(imports),\n                        _step18;\n                      try {\n                        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n                          var imp = _step18.value;\n                          try {\n                            var dependency = void 0;\n                            if (imp.d === -1) {\n                              // import ... from \"...\"\n                              dependency = parseString(source.substring(imp.s - 1, imp.e + 1));\n                            } else if (imp.d > -1) {\n                              // import()\n                              var expr = source.substring(imp.s, imp.e).trim();\n                              dependency = parseString(expr);\n                            } else {\n                              // e.g. import.meta\n                              continue;\n                            }\n\n                            // we should not track Node.js build dependencies\n                            if (dependency.startsWith(\"node:\")) continue;\n                            if (builtinModules.has(dependency)) continue;\n                            push({\n                              type: RBDT_RESOLVE_ESM_FILE,\n                              context: _context2,\n                              path: dependency,\n                              expected: undefined,\n                              issuer: job\n                            });\n                          } catch (e) {\n                            _this7.logger.warn(\"Parsing of \".concat(path, \" for build dependencies failed at 'import(\").concat(source.substring(imp.s, imp.e), \")'.\\n\") + \"Build dependencies behind this expression are ignored and might cause incorrect cache invalidation.\");\n                            _this7.logger.debug(pathToString(job));\n                            _this7.logger.debug(e.stack);\n                          }\n                        }\n                      } catch (err) {\n                        _iterator18.e(err);\n                      } finally {\n                        _iterator18.f();\n                      }\n                    } catch (e) {\n                      _this7.logger.warn(\"Parsing of \".concat(path, \" for build dependencies failed and all dependencies of this file are ignored, which might cause incorrect cache invalidation..\"));\n                      _this7.logger.debug(pathToString(job));\n                      _this7.logger.debug(e.stack);\n                    }\n                    process.nextTick(callback);\n                  });\n                }, callback);\n                break;\n              } else {\n                _this7.logger.log(\"Assuming \".concat(path, \" has no dependencies as we were unable to assign it to any module system.\"));\n                _this7.logger.debug(pathToString(job));\n              }\n              process.nextTick(callback);\n              break;\n            }\n          case RBDT_DIRECTORY_DEPENDENCIES:\n            {\n              var match = /(^.+[\\\\/]node_modules[\\\\/](?:@[^\\\\/]+[\\\\/])?[^\\\\/]+)/.exec(path);\n              var packagePath = match ? match[1] : path;\n              var packageJson = join(_this7.fs, packagePath, \"package.json\");\n              _this7.fs.readFile(packageJson, function (err, content) {\n                if (err) {\n                  if (err.code === \"ENOENT\") {\n                    resolveMissing.add(packageJson);\n                    var parent = dirname(_this7.fs, packagePath);\n                    if (parent !== packagePath) {\n                      push({\n                        type: RBDT_DIRECTORY_DEPENDENCIES,\n                        context: undefined,\n                        path: parent,\n                        expected: undefined,\n                        issuer: job\n                      });\n                    }\n                    callback();\n                    return;\n                  }\n                  return callback(err);\n                }\n                resolveFiles.add(packageJson);\n                var packageData;\n                try {\n                  packageData = JSON.parse(content.toString(\"utf-8\"));\n                } catch (e) {\n                  return callback(e);\n                }\n                var depsObject = packageData.dependencies;\n                var optionalDepsObject = packageData.optionalDependencies;\n                var allDeps = new Set();\n                var optionalDeps = new Set();\n                if (typeof depsObject === \"object\" && depsObject) {\n                  for (var _i = 0, _Object$keys = Object.keys(depsObject); _i < _Object$keys.length; _i++) {\n                    var dep = _Object$keys[_i];\n                    allDeps.add(dep);\n                  }\n                }\n                if (typeof optionalDepsObject === \"object\" && optionalDepsObject) {\n                  for (var _i2 = 0, _Object$keys2 = Object.keys(optionalDepsObject); _i2 < _Object$keys2.length; _i2++) {\n                    var _dep = _Object$keys2[_i2];\n                    allDeps.add(_dep);\n                    optionalDeps.add(_dep);\n                  }\n                }\n                var _iterator19 = _createForOfIteratorHelper(allDeps),\n                  _step19;\n                try {\n                  for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                    var _dep2 = _step19.value;\n                    push({\n                      type: RBDT_RESOLVE_DIRECTORY,\n                      context: packagePath,\n                      path: _dep2,\n                      expected: !optionalDeps.has(_dep2),\n                      issuer: job\n                    });\n                  }\n                } catch (err) {\n                  _iterator19.e(err);\n                } finally {\n                  _iterator19.f();\n                }\n                callback();\n              });\n              break;\n            }\n        }\n      }, function (err) {\n        if (err) return callback(err);\n        var _iterator20 = _createForOfIteratorHelper(fileSymlinks),\n          _step20;\n        try {\n          for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n            var l = _step20.value;\n            files.delete(l);\n          }\n        } catch (err) {\n          _iterator20.e(err);\n        } finally {\n          _iterator20.f();\n        }\n        var _iterator21 = _createForOfIteratorHelper(directorySymlinks),\n          _step21;\n        try {\n          for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n            var _l = _step21.value;\n            directories.delete(_l);\n          }\n        } catch (err) {\n          _iterator21.e(err);\n        } finally {\n          _iterator21.f();\n        }\n        var _iterator22 = _createForOfIteratorHelper(invalidResolveResults),\n          _step22;\n        try {\n          for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n            var k = _step22.value;\n            resolveResults.delete(k);\n          }\n        } catch (err) {\n          _iterator22.e(err);\n        } finally {\n          _iterator22.f();\n        }\n        callback(null, {\n          files: files,\n          directories: directories,\n          missing: missing,\n          resolveResults: resolveResults,\n          resolveDependencies: {\n            files: resolveFiles,\n            directories: resolveDirectories,\n            missing: resolveMissing\n          }\n        });\n      });\n    }\n\n    /**\n     * @param {Map<string, string | false>} resolveResults results from resolving\n     * @param {function((Error | null)=, boolean=): void} callback callback with true when resolveResults resolve the same way\n     * @returns {void}\n     */\n  }, {\n    key: \"checkResolveResultsValid\",\n    value: function checkResolveResultsValid(resolveResults, callback) {\n      var _this$_createBuildDep2 = this._createBuildDependenciesResolvers(),\n        resolveCjs = _this$_createBuildDep2.resolveCjs,\n        resolveCjsAsChild = _this$_createBuildDep2.resolveCjsAsChild,\n        resolveEsm = _this$_createBuildDep2.resolveEsm,\n        resolveContext = _this$_createBuildDep2.resolveContext;\n      asyncLib.eachLimit(resolveResults, 20, function (_ref4, callback) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n          key = _ref5[0],\n          expectedResult = _ref5[1];\n        var _key$split = key.split(\"\\n\"),\n          _key$split2 = _slicedToArray(_key$split, 3),\n          type = _key$split2[0],\n          context = _key$split2[1],\n          path = _key$split2[2];\n        switch (type) {\n          case \"d\":\n            resolveContext(context, path, {}, function (err, _, result) {\n              if (expectedResult === false) return callback(err ? undefined : INVALID);\n              if (err) return callback(err);\n              var resultPath = result.path;\n              if (resultPath !== expectedResult) return callback(INVALID);\n              callback();\n            });\n            break;\n          case \"f\":\n            resolveCjs(context, path, {}, function (err, _, result) {\n              if (expectedResult === false) return callback(err ? undefined : INVALID);\n              if (err) return callback(err);\n              var resultPath = result.path;\n              if (resultPath !== expectedResult) return callback(INVALID);\n              callback();\n            });\n            break;\n          case \"c\":\n            resolveCjsAsChild(context, path, {}, function (err, _, result) {\n              if (expectedResult === false) return callback(err ? undefined : INVALID);\n              if (err) return callback(err);\n              var resultPath = result.path;\n              if (resultPath !== expectedResult) return callback(INVALID);\n              callback();\n            });\n            break;\n          case \"e\":\n            resolveEsm(context, path, {}, function (err, _, result) {\n              if (expectedResult === false) return callback(err ? undefined : INVALID);\n              if (err) return callback(err);\n              var resultPath = result.path;\n              if (resultPath !== expectedResult) return callback(INVALID);\n              callback();\n            });\n            break;\n          default:\n            callback(new Error(\"Unexpected type in resolve result key\"));\n            break;\n        }\n      },\n      /**\n       * @param {Error | typeof INVALID=} err error or invalid flag\n       * @returns {void}\n       */\n      function (err) {\n        if (err === INVALID) {\n          return callback(null, false);\n        }\n        if (err) {\n          return callback(err);\n        }\n        return callback(null, true);\n      });\n    }\n\n    /**\n     *\n     * @param {number} startTime when processing the files has started\n     * @param {Iterable<string>} files all files\n     * @param {Iterable<string>} directories all directories\n     * @param {Iterable<string>} missing all missing files or directories\n     * @param {Object} options options object (for future extensions)\n     * @param {boolean=} options.hash should use hash to snapshot\n     * @param {boolean=} options.timestamp should use timestamp to snapshot\n     * @param {function((WebpackError | null)=, (Snapshot | null)=): void} callback callback function\n     * @returns {void}\n     */\n  }, {\n    key: \"createSnapshot\",\n    value: function createSnapshot(startTime, files, directories, missing, options, callback) {\n      var _this8 = this;\n      /** @type {Map<string, FileSystemInfoEntry | null>} */\n      var fileTimestamps = new Map();\n      /** @type {Map<string, string | null>} */\n      var fileHashes = new Map();\n      /** @type {Map<string, TimestampAndHash | string | null>} */\n      var fileTshs = new Map();\n      /** @type {Map<string, FileSystemInfoEntry | null>} */\n      var contextTimestamps = new Map();\n      /** @type {Map<string, string | null>} */\n      var contextHashes = new Map();\n      /** @type {Map<string, ResolvedContextTimestampAndHash | null>} */\n      var contextTshs = new Map();\n      /** @type {Map<string, boolean>} */\n      var missingExistence = new Map();\n      /** @type {Map<string, string>} */\n      var managedItemInfo = new Map();\n      /** @type {Set<string>} */\n      var managedFiles = new Set();\n      /** @type {Set<string>} */\n      var managedContexts = new Set();\n      /** @type {Set<string>} */\n      var managedMissing = new Set();\n      /** @type {Set<Snapshot>} */\n      var children = new Set();\n      var snapshot = new Snapshot();\n      if (startTime) snapshot.setStartTime(startTime);\n\n      /** @type {Set<string>} */\n      var managedItems = new Set();\n\n      /** 1 = timestamp, 2 = hash, 3 = timestamp + hash */\n      var mode = options && options.hash ? options.timestamp ? 3 : 2 : 1;\n      var jobs = 1;\n      var jobDone = function jobDone() {\n        if (--jobs === 0) {\n          if (fileTimestamps.size !== 0) {\n            snapshot.setFileTimestamps(fileTimestamps);\n          }\n          if (fileHashes.size !== 0) {\n            snapshot.setFileHashes(fileHashes);\n          }\n          if (fileTshs.size !== 0) {\n            snapshot.setFileTshs(fileTshs);\n          }\n          if (contextTimestamps.size !== 0) {\n            snapshot.setContextTimestamps(contextTimestamps);\n          }\n          if (contextHashes.size !== 0) {\n            snapshot.setContextHashes(contextHashes);\n          }\n          if (contextTshs.size !== 0) {\n            snapshot.setContextTshs(contextTshs);\n          }\n          if (missingExistence.size !== 0) {\n            snapshot.setMissingExistence(missingExistence);\n          }\n          if (managedItemInfo.size !== 0) {\n            snapshot.setManagedItemInfo(managedItemInfo);\n          }\n          _this8._managedFilesOptimization.optimize(snapshot, managedFiles);\n          if (managedFiles.size !== 0) {\n            snapshot.setManagedFiles(managedFiles);\n          }\n          _this8._managedContextsOptimization.optimize(snapshot, managedContexts);\n          if (managedContexts.size !== 0) {\n            snapshot.setManagedContexts(managedContexts);\n          }\n          _this8._managedMissingOptimization.optimize(snapshot, managedMissing);\n          if (managedMissing.size !== 0) {\n            snapshot.setManagedMissing(managedMissing);\n          }\n          if (children.size !== 0) {\n            snapshot.setChildren(children);\n          }\n          _this8._snapshotCache.set(snapshot, true);\n          _this8._statCreatedSnapshots++;\n          callback(null, snapshot);\n        }\n      };\n      var jobError = function jobError() {\n        if (jobs > 0) {\n          // large negative number instead of NaN or something else to keep jobs to stay a SMI (v8)\n          jobs = -100000000;\n          callback(null, null);\n        }\n      };\n      var checkManaged = function checkManaged(path, managedSet) {\n        var _iterator23 = _createForOfIteratorHelper(_this8.immutablePathsRegExps),\n          _step23;\n        try {\n          for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n            var immutablePath = _step23.value;\n            if (immutablePath.test(path)) {\n              managedSet.add(path);\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator23.e(err);\n        } finally {\n          _iterator23.f();\n        }\n        var _iterator24 = _createForOfIteratorHelper(_this8.immutablePathsWithSlash),\n          _step24;\n        try {\n          for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n            var _immutablePath = _step24.value;\n            if (path.startsWith(_immutablePath)) {\n              managedSet.add(path);\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator24.e(err);\n        } finally {\n          _iterator24.f();\n        }\n        var _iterator25 = _createForOfIteratorHelper(_this8.managedPathsRegExps),\n          _step25;\n        try {\n          for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n            var managedPath = _step25.value;\n            var match = managedPath.exec(path);\n            if (match) {\n              var managedItem = getManagedItem(match[1], path);\n              if (managedItem) {\n                managedItems.add(managedItem);\n                managedSet.add(path);\n                return true;\n              }\n            }\n          }\n        } catch (err) {\n          _iterator25.e(err);\n        } finally {\n          _iterator25.f();\n        }\n        var _iterator26 = _createForOfIteratorHelper(_this8.managedPathsWithSlash),\n          _step26;\n        try {\n          for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n            var _managedPath = _step26.value;\n            if (path.startsWith(_managedPath)) {\n              var _managedItem = getManagedItem(_managedPath, path);\n              if (_managedItem) {\n                managedItems.add(_managedItem);\n                managedSet.add(path);\n                return true;\n              }\n            }\n          }\n        } catch (err) {\n          _iterator26.e(err);\n        } finally {\n          _iterator26.f();\n        }\n        return false;\n      };\n      var captureNonManaged = function captureNonManaged(items, managedSet) {\n        var capturedItems = new Set();\n        var _iterator27 = _createForOfIteratorHelper(items),\n          _step27;\n        try {\n          for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n            var path = _step27.value;\n            if (!checkManaged(path, managedSet)) capturedItems.add(path);\n          }\n        } catch (err) {\n          _iterator27.e(err);\n        } finally {\n          _iterator27.f();\n        }\n        return capturedItems;\n      };\n      var processCapturedFiles = function processCapturedFiles(capturedFiles) {\n        switch (mode) {\n          case 3:\n            _this8._fileTshsOptimization.optimize(snapshot, capturedFiles);\n            var _iterator28 = _createForOfIteratorHelper(capturedFiles),\n              _step28;\n            try {\n              var _loop = function _loop() {\n                var path = _step28.value;\n                var cache = _this8._fileTshs.get(path);\n                if (cache !== undefined) {\n                  fileTshs.set(path, cache);\n                } else {\n                  jobs++;\n                  _this8._getFileTimestampAndHash(path, function (err, entry) {\n                    if (err) {\n                      if (_this8.logger) {\n                        _this8.logger.debug(\"Error snapshotting file timestamp hash combination of \".concat(path, \": \").concat(err.stack));\n                      }\n                      jobError();\n                    } else {\n                      fileTshs.set(path, entry);\n                      jobDone();\n                    }\n                  });\n                }\n              };\n              for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n                _loop();\n              }\n            } catch (err) {\n              _iterator28.e(err);\n            } finally {\n              _iterator28.f();\n            }\n            break;\n          case 2:\n            _this8._fileHashesOptimization.optimize(snapshot, capturedFiles);\n            var _iterator29 = _createForOfIteratorHelper(capturedFiles),\n              _step29;\n            try {\n              var _loop2 = function _loop2() {\n                var path = _step29.value;\n                var cache = _this8._fileHashes.get(path);\n                if (cache !== undefined) {\n                  fileHashes.set(path, cache);\n                } else {\n                  jobs++;\n                  _this8.fileHashQueue.add(path, function (err, entry) {\n                    if (err) {\n                      if (_this8.logger) {\n                        _this8.logger.debug(\"Error snapshotting file hash of \".concat(path, \": \").concat(err.stack));\n                      }\n                      jobError();\n                    } else {\n                      fileHashes.set(path, entry);\n                      jobDone();\n                    }\n                  });\n                }\n              };\n              for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n                _loop2();\n              }\n            } catch (err) {\n              _iterator29.e(err);\n            } finally {\n              _iterator29.f();\n            }\n            break;\n          case 1:\n            _this8._fileTimestampsOptimization.optimize(snapshot, capturedFiles);\n            var _iterator30 = _createForOfIteratorHelper(capturedFiles),\n              _step30;\n            try {\n              var _loop3 = function _loop3() {\n                var path = _step30.value;\n                var cache = _this8._fileTimestamps.get(path);\n                if (cache !== undefined) {\n                  if (cache !== \"ignore\") {\n                    fileTimestamps.set(path, cache);\n                  }\n                } else {\n                  jobs++;\n                  _this8.fileTimestampQueue.add(path, function (err, entry) {\n                    if (err) {\n                      if (_this8.logger) {\n                        _this8.logger.debug(\"Error snapshotting file timestamp of \".concat(path, \": \").concat(err.stack));\n                      }\n                      jobError();\n                    } else {\n                      fileTimestamps.set(path, entry);\n                      jobDone();\n                    }\n                  });\n                }\n              };\n              for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n                _loop3();\n              }\n            } catch (err) {\n              _iterator30.e(err);\n            } finally {\n              _iterator30.f();\n            }\n            break;\n        }\n      };\n      if (files) {\n        processCapturedFiles(captureNonManaged(files, managedFiles));\n      }\n      var processCapturedDirectories = function processCapturedDirectories(capturedDirectories) {\n        switch (mode) {\n          case 3:\n            _this8._contextTshsOptimization.optimize(snapshot, capturedDirectories);\n            var _iterator31 = _createForOfIteratorHelper(capturedDirectories),\n              _step31;\n            try {\n              var _loop4 = function _loop4() {\n                var path = _step31.value;\n                var cache = _this8._contextTshs.get(path);\n                /** @type {ResolvedContextTimestampAndHash} */\n                var resolved;\n                if (cache !== undefined && (resolved = getResolvedTimestamp(cache)) !== undefined) {\n                  contextTshs.set(path, resolved);\n                } else {\n                  jobs++;\n                  /**\n                   * @param {Error=} err error\n                   * @param {ResolvedContextTimestampAndHash=} entry entry\n                   * @returns {void}\n                   */\n                  var _callback = function _callback(err, entry) {\n                    if (err) {\n                      if (_this8.logger) {\n                        _this8.logger.debug(\"Error snapshotting context timestamp hash combination of \".concat(path, \": \").concat(err.stack));\n                      }\n                      jobError();\n                    } else {\n                      contextTshs.set(path, entry);\n                      jobDone();\n                    }\n                  };\n                  if (cache !== undefined) {\n                    _this8._resolveContextTsh(cache, _callback);\n                  } else {\n                    _this8.getContextTsh(path, _callback);\n                  }\n                }\n              };\n              for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n                _loop4();\n              }\n            } catch (err) {\n              _iterator31.e(err);\n            } finally {\n              _iterator31.f();\n            }\n            break;\n          case 2:\n            _this8._contextHashesOptimization.optimize(snapshot, capturedDirectories);\n            var _iterator32 = _createForOfIteratorHelper(capturedDirectories),\n              _step32;\n            try {\n              var _loop5 = function _loop5() {\n                var path = _step32.value;\n                var cache = _this8._contextHashes.get(path);\n                var resolved;\n                if (cache !== undefined && (resolved = getResolvedHash(cache)) !== undefined) {\n                  contextHashes.set(path, resolved);\n                } else {\n                  jobs++;\n                  var _callback2 = function _callback2(err, entry) {\n                    if (err) {\n                      if (_this8.logger) {\n                        _this8.logger.debug(\"Error snapshotting context hash of \".concat(path, \": \").concat(err.stack));\n                      }\n                      jobError();\n                    } else {\n                      contextHashes.set(path, entry);\n                      jobDone();\n                    }\n                  };\n                  if (cache !== undefined) {\n                    _this8._resolveContextHash(cache, _callback2);\n                  } else {\n                    _this8.getContextHash(path, _callback2);\n                  }\n                }\n              };\n              for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n                _loop5();\n              }\n            } catch (err) {\n              _iterator32.e(err);\n            } finally {\n              _iterator32.f();\n            }\n            break;\n          case 1:\n            _this8._contextTimestampsOptimization.optimize(snapshot, capturedDirectories);\n            var _iterator33 = _createForOfIteratorHelper(capturedDirectories),\n              _step33;\n            try {\n              var _loop6 = function _loop6() {\n                var path = _step33.value;\n                var cache = _this8._contextTimestamps.get(path);\n                if (cache === \"ignore\") return \"continue\";\n                var resolved;\n                if (cache !== undefined && (resolved = getResolvedTimestamp(cache)) !== undefined) {\n                  contextTimestamps.set(path, resolved);\n                } else {\n                  jobs++;\n                  /**\n                   * @param {Error=} err error\n                   * @param {ResolvedContextFileSystemInfoEntry=} entry entry\n                   * @returns {void}\n                   */\n                  var _callback3 = function _callback3(err, entry) {\n                    if (err) {\n                      if (_this8.logger) {\n                        _this8.logger.debug(\"Error snapshotting context timestamp of \".concat(path, \": \").concat(err.stack));\n                      }\n                      jobError();\n                    } else {\n                      contextTimestamps.set(path, entry);\n                      jobDone();\n                    }\n                  };\n                  if (cache !== undefined) {\n                    _this8._resolveContextTimestamp(cache, _callback3);\n                  } else {\n                    _this8.getContextTimestamp(path, _callback3);\n                  }\n                }\n              };\n              for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n                var _ret = _loop6();\n                if (_ret === \"continue\") continue;\n              }\n            } catch (err) {\n              _iterator33.e(err);\n            } finally {\n              _iterator33.f();\n            }\n            break;\n        }\n      };\n      if (directories) {\n        processCapturedDirectories(captureNonManaged(directories, managedContexts));\n      }\n      var processCapturedMissing = function processCapturedMissing(capturedMissing) {\n        _this8._missingExistenceOptimization.optimize(snapshot, capturedMissing);\n        var _iterator34 = _createForOfIteratorHelper(capturedMissing),\n          _step34;\n        try {\n          var _loop7 = function _loop7() {\n            var path = _step34.value;\n            var cache = _this8._fileTimestamps.get(path);\n            if (cache !== undefined) {\n              if (cache !== \"ignore\") {\n                missingExistence.set(path, Boolean(cache));\n              }\n            } else {\n              jobs++;\n              _this8.fileTimestampQueue.add(path, function (err, entry) {\n                if (err) {\n                  if (_this8.logger) {\n                    _this8.logger.debug(\"Error snapshotting missing timestamp of \".concat(path, \": \").concat(err.stack));\n                  }\n                  jobError();\n                } else {\n                  missingExistence.set(path, Boolean(entry));\n                  jobDone();\n                }\n              });\n            }\n          };\n          for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n            _loop7();\n          }\n        } catch (err) {\n          _iterator34.e(err);\n        } finally {\n          _iterator34.f();\n        }\n      };\n      if (missing) {\n        processCapturedMissing(captureNonManaged(missing, managedMissing));\n      }\n      this._managedItemInfoOptimization.optimize(snapshot, managedItems);\n      var _iterator35 = _createForOfIteratorHelper(managedItems),\n        _step35;\n      try {\n        var _loop8 = function _loop8() {\n          var path = _step35.value;\n          var cache = _this8._managedItems.get(path);\n          if (cache !== undefined) {\n            if (!cache.startsWith(\"*\")) {\n              managedFiles.add(join(_this8.fs, path, \"package.json\"));\n            } else if (cache === \"*nested\") {\n              managedMissing.add(join(_this8.fs, path, \"package.json\"));\n            }\n            managedItemInfo.set(path, cache);\n          } else {\n            jobs++;\n            _this8.managedItemQueue.add(path, function (err, entry) {\n              if (err) {\n                if (_this8.logger) {\n                  _this8.logger.debug(\"Error snapshotting managed item \".concat(path, \": \").concat(err.stack));\n                }\n                jobError();\n              } else if (entry) {\n                if (!entry.startsWith(\"*\")) {\n                  managedFiles.add(join(_this8.fs, path, \"package.json\"));\n                } else if (cache === \"*nested\") {\n                  managedMissing.add(join(_this8.fs, path, \"package.json\"));\n                }\n                managedItemInfo.set(path, entry);\n                jobDone();\n              } else {\n                // Fallback to normal snapshotting\n                var _process = function _process(set, fn) {\n                  if (set.size === 0) return;\n                  var captured = new Set();\n                  var _iterator36 = _createForOfIteratorHelper(set),\n                    _step36;\n                  try {\n                    for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n                      var file = _step36.value;\n                      if (file.startsWith(path)) captured.add(file);\n                    }\n                  } catch (err) {\n                    _iterator36.e(err);\n                  } finally {\n                    _iterator36.f();\n                  }\n                  if (captured.size > 0) fn(captured);\n                };\n                _process(managedFiles, processCapturedFiles);\n                _process(managedContexts, processCapturedDirectories);\n                _process(managedMissing, processCapturedMissing);\n                jobDone();\n              }\n            });\n          }\n        };\n        for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n          _loop8();\n        }\n      } catch (err) {\n        _iterator35.e(err);\n      } finally {\n        _iterator35.f();\n      }\n      jobDone();\n    }\n\n    /**\n     * @param {Snapshot} snapshot1 a snapshot\n     * @param {Snapshot} snapshot2 a snapshot\n     * @returns {Snapshot} merged snapshot\n     */\n  }, {\n    key: \"mergeSnapshots\",\n    value: function mergeSnapshots(snapshot1, snapshot2) {\n      var snapshot = new Snapshot();\n      if (snapshot1.hasStartTime() && snapshot2.hasStartTime()) snapshot.setStartTime(Math.min(snapshot1.startTime, snapshot2.startTime));else if (snapshot2.hasStartTime()) snapshot.startTime = snapshot2.startTime;else if (snapshot1.hasStartTime()) snapshot.startTime = snapshot1.startTime;\n      if (snapshot1.hasFileTimestamps() || snapshot2.hasFileTimestamps()) {\n        snapshot.setFileTimestamps(mergeMaps(snapshot1.fileTimestamps, snapshot2.fileTimestamps));\n      }\n      if (snapshot1.hasFileHashes() || snapshot2.hasFileHashes()) {\n        snapshot.setFileHashes(mergeMaps(snapshot1.fileHashes, snapshot2.fileHashes));\n      }\n      if (snapshot1.hasFileTshs() || snapshot2.hasFileTshs()) {\n        snapshot.setFileTshs(mergeMaps(snapshot1.fileTshs, snapshot2.fileTshs));\n      }\n      if (snapshot1.hasContextTimestamps() || snapshot2.hasContextTimestamps()) {\n        snapshot.setContextTimestamps(mergeMaps(snapshot1.contextTimestamps, snapshot2.contextTimestamps));\n      }\n      if (snapshot1.hasContextHashes() || snapshot2.hasContextHashes()) {\n        snapshot.setContextHashes(mergeMaps(snapshot1.contextHashes, snapshot2.contextHashes));\n      }\n      if (snapshot1.hasContextTshs() || snapshot2.hasContextTshs()) {\n        snapshot.setContextTshs(mergeMaps(snapshot1.contextTshs, snapshot2.contextTshs));\n      }\n      if (snapshot1.hasMissingExistence() || snapshot2.hasMissingExistence()) {\n        snapshot.setMissingExistence(mergeMaps(snapshot1.missingExistence, snapshot2.missingExistence));\n      }\n      if (snapshot1.hasManagedItemInfo() || snapshot2.hasManagedItemInfo()) {\n        snapshot.setManagedItemInfo(mergeMaps(snapshot1.managedItemInfo, snapshot2.managedItemInfo));\n      }\n      if (snapshot1.hasManagedFiles() || snapshot2.hasManagedFiles()) {\n        snapshot.setManagedFiles(mergeSets(snapshot1.managedFiles, snapshot2.managedFiles));\n      }\n      if (snapshot1.hasManagedContexts() || snapshot2.hasManagedContexts()) {\n        snapshot.setManagedContexts(mergeSets(snapshot1.managedContexts, snapshot2.managedContexts));\n      }\n      if (snapshot1.hasManagedMissing() || snapshot2.hasManagedMissing()) {\n        snapshot.setManagedMissing(mergeSets(snapshot1.managedMissing, snapshot2.managedMissing));\n      }\n      if (snapshot1.hasChildren() || snapshot2.hasChildren()) {\n        snapshot.setChildren(mergeSets(snapshot1.children, snapshot2.children));\n      }\n      if (this._snapshotCache.get(snapshot1) === true && this._snapshotCache.get(snapshot2) === true) {\n        this._snapshotCache.set(snapshot, true);\n      }\n      return snapshot;\n    }\n\n    /**\n     * @param {Snapshot} snapshot the snapshot made\n     * @param {function((WebpackError | null)=, boolean=): void} callback callback function\n     * @returns {void}\n     */\n  }, {\n    key: \"checkSnapshotValid\",\n    value: function checkSnapshotValid(snapshot, callback) {\n      var cachedResult = this._snapshotCache.get(snapshot);\n      if (cachedResult !== undefined) {\n        this._statTestedSnapshotsCached++;\n        if (typeof cachedResult === \"boolean\") {\n          callback(null, cachedResult);\n        } else {\n          cachedResult.push(callback);\n        }\n        return;\n      }\n      this._statTestedSnapshotsNotCached++;\n      this._checkSnapshotValidNoCache(snapshot, callback);\n    }\n\n    /**\n     * @param {Snapshot} snapshot the snapshot made\n     * @param {function((WebpackError | null)=, boolean=): void} callback callback function\n     * @returns {void}\n     */\n  }, {\n    key: \"_checkSnapshotValidNoCache\",\n    value: function _checkSnapshotValidNoCache(snapshot, callback) {\n      var _this9 = this;\n      /** @type {number | undefined} */\n      var startTime = undefined;\n      if (snapshot.hasStartTime()) {\n        startTime = snapshot.startTime;\n      }\n      var jobs = 1;\n      var jobDone = function jobDone() {\n        if (--jobs === 0) {\n          _this9._snapshotCache.set(snapshot, true);\n          callback(null, true);\n        }\n      };\n      var invalid = function invalid() {\n        if (jobs > 0) {\n          // large negative number instead of NaN or something else to keep jobs to stay a SMI (v8)\n          jobs = -100000000;\n          _this9._snapshotCache.set(snapshot, false);\n          callback(null, false);\n        }\n      };\n      var invalidWithError = function invalidWithError(path, err) {\n        if (_this9._remainingLogs > 0) {\n          _this9._log(path, \"error occurred: %s\", err);\n        }\n        invalid();\n      };\n      /**\n       * @param {string} path file path\n       * @param {string} current current hash\n       * @param {string} snap snapshot hash\n       * @returns {boolean} true, if ok\n       */\n      var checkHash = function checkHash(path, current, snap) {\n        if (current !== snap) {\n          // If hash differ it's invalid\n          if (_this9._remainingLogs > 0) {\n            _this9._log(path, \"hashes differ (%s != %s)\", current, snap);\n          }\n          return false;\n        }\n        return true;\n      };\n      /**\n       * @param {string} path file path\n       * @param {boolean} current current entry\n       * @param {boolean} snap entry from snapshot\n       * @returns {boolean} true, if ok\n       */\n      var checkExistence = function checkExistence(path, current, snap) {\n        if (!current !== !snap) {\n          // If existence of item differs\n          // it's invalid\n          if (_this9._remainingLogs > 0) {\n            _this9._log(path, current ? \"it didn't exist before\" : \"it does no longer exist\");\n          }\n          return false;\n        }\n        return true;\n      };\n      /**\n       * @param {string} path file path\n       * @param {FileSystemInfoEntry} current current entry\n       * @param {FileSystemInfoEntry} snap entry from snapshot\n       * @param {boolean} log log reason\n       * @returns {boolean} true, if ok\n       */\n      var checkFile = function checkFile(path, current, snap) {\n        var log = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n        if (current === snap) return true;\n        if (!checkExistence(path, Boolean(current), Boolean(snap))) return false;\n        if (current) {\n          // For existing items only\n          if (typeof startTime === \"number\" && current.safeTime > startTime) {\n            // If a change happened after starting reading the item\n            // this may no longer be valid\n            if (log && _this9._remainingLogs > 0) {\n              _this9._log(path, \"it may have changed (%d) after the start time of the snapshot (%d)\", current.safeTime, startTime);\n            }\n            return false;\n          }\n          if (snap.timestamp !== undefined && current.timestamp !== snap.timestamp) {\n            // If we have a timestamp (it was a file or symlink) and it differs from current timestamp\n            // it's invalid\n            if (log && _this9._remainingLogs > 0) {\n              _this9._log(path, \"timestamps differ (%d != %d)\", current.timestamp, snap.timestamp);\n            }\n            return false;\n          }\n        }\n        return true;\n      };\n      /**\n       * @param {string} path file path\n       * @param {ResolvedContextFileSystemInfoEntry} current current entry\n       * @param {ResolvedContextFileSystemInfoEntry} snap entry from snapshot\n       * @param {boolean} log log reason\n       * @returns {boolean} true, if ok\n       */\n      var checkContext = function checkContext(path, current, snap) {\n        var log = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n        if (current === snap) return true;\n        if (!checkExistence(path, Boolean(current), Boolean(snap))) return false;\n        if (current) {\n          // For existing items only\n          if (typeof startTime === \"number\" && current.safeTime > startTime) {\n            // If a change happened after starting reading the item\n            // this may no longer be valid\n            if (log && _this9._remainingLogs > 0) {\n              _this9._log(path, \"it may have changed (%d) after the start time of the snapshot (%d)\", current.safeTime, startTime);\n            }\n            return false;\n          }\n          if (snap.timestampHash !== undefined && current.timestampHash !== snap.timestampHash) {\n            // If we have a timestampHash (it was a directory) and it differs from current timestampHash\n            // it's invalid\n            if (log && _this9._remainingLogs > 0) {\n              _this9._log(path, \"timestamps hashes differ (%s != %s)\", current.timestampHash, snap.timestampHash);\n            }\n            return false;\n          }\n        }\n        return true;\n      };\n      if (snapshot.hasChildren()) {\n        var childCallback = function childCallback(err, result) {\n          if (err || !result) return invalid();else jobDone();\n        };\n        var _iterator37 = _createForOfIteratorHelper(snapshot.children),\n          _step37;\n        try {\n          for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {\n            var child = _step37.value;\n            var cache = this._snapshotCache.get(child);\n            if (cache !== undefined) {\n              this._statTestedChildrenCached++;\n              /* istanbul ignore else */\n              if (typeof cache === \"boolean\") {\n                if (cache === false) {\n                  invalid();\n                  return;\n                }\n              } else {\n                jobs++;\n                cache.push(childCallback);\n              }\n            } else {\n              this._statTestedChildrenNotCached++;\n              jobs++;\n              this._checkSnapshotValidNoCache(child, childCallback);\n            }\n          }\n        } catch (err) {\n          _iterator37.e(err);\n        } finally {\n          _iterator37.f();\n        }\n      }\n      if (snapshot.hasFileTimestamps()) {\n        var fileTimestamps = snapshot.fileTimestamps;\n        this._statTestedEntries += fileTimestamps.size;\n        var _iterator38 = _createForOfIteratorHelper(fileTimestamps),\n          _step38;\n        try {\n          var _loop9 = function _loop9() {\n            var _step38$value = _slicedToArray(_step38.value, 2),\n              path = _step38$value[0],\n              ts = _step38$value[1];\n            var cache = _this9._fileTimestamps.get(path);\n            if (cache !== undefined) {\n              if (cache !== \"ignore\" && !checkFile(path, cache, ts)) {\n                invalid();\n                return {\n                  v: void 0\n                };\n              }\n            } else {\n              jobs++;\n              _this9.fileTimestampQueue.add(path, function (err, entry) {\n                if (err) return invalidWithError(path, err);\n                if (!checkFile(path, entry, ts)) {\n                  invalid();\n                } else {\n                  jobDone();\n                }\n              });\n            }\n          };\n          for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {\n            var _ret2 = _loop9();\n            if (typeof _ret2 === \"object\") return _ret2.v;\n          }\n        } catch (err) {\n          _iterator38.e(err);\n        } finally {\n          _iterator38.f();\n        }\n      }\n      var processFileHashSnapshot = function processFileHashSnapshot(path, hash) {\n        var cache = _this9._fileHashes.get(path);\n        if (cache !== undefined) {\n          if (cache !== \"ignore\" && !checkHash(path, cache, hash)) {\n            invalid();\n            return;\n          }\n        } else {\n          jobs++;\n          _this9.fileHashQueue.add(path, function (err, entry) {\n            if (err) return invalidWithError(path, err);\n            if (!checkHash(path, entry, hash)) {\n              invalid();\n            } else {\n              jobDone();\n            }\n          });\n        }\n      };\n      if (snapshot.hasFileHashes()) {\n        var fileHashes = snapshot.fileHashes;\n        this._statTestedEntries += fileHashes.size;\n        var _iterator39 = _createForOfIteratorHelper(fileHashes),\n          _step39;\n        try {\n          for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {\n            var _step39$value = _slicedToArray(_step39.value, 2),\n              path = _step39$value[0],\n              hash = _step39$value[1];\n            processFileHashSnapshot(path, hash);\n          }\n        } catch (err) {\n          _iterator39.e(err);\n        } finally {\n          _iterator39.f();\n        }\n      }\n      if (snapshot.hasFileTshs()) {\n        var fileTshs = snapshot.fileTshs;\n        this._statTestedEntries += fileTshs.size;\n        var _iterator40 = _createForOfIteratorHelper(fileTshs),\n          _step40;\n        try {\n          var _loop10 = function _loop10() {\n            var _step40$value = _slicedToArray(_step40.value, 2),\n              path = _step40$value[0],\n              tsh = _step40$value[1];\n            if (typeof tsh === \"string\") {\n              processFileHashSnapshot(path, tsh);\n            } else {\n              var _cache = _this9._fileTimestamps.get(path);\n              if (_cache !== undefined) {\n                if (_cache === \"ignore\" || !checkFile(path, _cache, tsh, false)) {\n                  processFileHashSnapshot(path, tsh && tsh.hash);\n                }\n              } else {\n                jobs++;\n                _this9.fileTimestampQueue.add(path, function (err, entry) {\n                  if (err) return invalidWithError(path, err);\n                  if (!checkFile(path, entry, tsh, false)) {\n                    processFileHashSnapshot(path, tsh && tsh.hash);\n                  }\n                  jobDone();\n                });\n              }\n            }\n          };\n          for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {\n            _loop10();\n          }\n        } catch (err) {\n          _iterator40.e(err);\n        } finally {\n          _iterator40.f();\n        }\n      }\n      if (snapshot.hasContextTimestamps()) {\n        var contextTimestamps = snapshot.contextTimestamps;\n        this._statTestedEntries += contextTimestamps.size;\n        var _iterator41 = _createForOfIteratorHelper(contextTimestamps),\n          _step41;\n        try {\n          var _loop11 = function _loop11() {\n            var _step41$value = _slicedToArray(_step41.value, 2),\n              path = _step41$value[0],\n              ts = _step41$value[1];\n            var cache = _this9._contextTimestamps.get(path);\n            if (cache === \"ignore\") return \"continue\";\n            var resolved;\n            if (cache !== undefined && (resolved = getResolvedTimestamp(cache)) !== undefined) {\n              if (!checkContext(path, resolved, ts)) {\n                invalid();\n                return {\n                  v: void 0\n                };\n              }\n            } else {\n              jobs++;\n              /**\n               * @param {Error=} err error\n               * @param {ResolvedContextFileSystemInfoEntry=} entry entry\n               * @returns {void}\n               */\n              var _callback4 = function _callback4(err, entry) {\n                if (err) return invalidWithError(path, err);\n                if (!checkContext(path, entry, ts)) {\n                  invalid();\n                } else {\n                  jobDone();\n                }\n              };\n              if (cache !== undefined) {\n                _this9._resolveContextTimestamp(cache, _callback4);\n              } else {\n                _this9.getContextTimestamp(path, _callback4);\n              }\n            }\n          };\n          for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {\n            var _ret3 = _loop11();\n            if (_ret3 === \"continue\") continue;\n            if (typeof _ret3 === \"object\") return _ret3.v;\n          }\n        } catch (err) {\n          _iterator41.e(err);\n        } finally {\n          _iterator41.f();\n        }\n      }\n      var processContextHashSnapshot = function processContextHashSnapshot(path, hash) {\n        var cache = _this9._contextHashes.get(path);\n        var resolved;\n        if (cache !== undefined && (resolved = getResolvedHash(cache)) !== undefined) {\n          if (!checkHash(path, resolved, hash)) {\n            invalid();\n            return;\n          }\n        } else {\n          jobs++;\n          var _callback5 = function _callback5(err, entry) {\n            if (err) return invalidWithError(path, err);\n            if (!checkHash(path, entry, hash)) {\n              invalid();\n            } else {\n              jobDone();\n            }\n          };\n          if (cache !== undefined) {\n            _this9._resolveContextHash(cache, _callback5);\n          } else {\n            _this9.getContextHash(path, _callback5);\n          }\n        }\n      };\n      if (snapshot.hasContextHashes()) {\n        var contextHashes = snapshot.contextHashes;\n        this._statTestedEntries += contextHashes.size;\n        var _iterator42 = _createForOfIteratorHelper(contextHashes),\n          _step42;\n        try {\n          for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {\n            var _step42$value = _slicedToArray(_step42.value, 2),\n              _path8 = _step42$value[0],\n              _hash = _step42$value[1];\n            processContextHashSnapshot(_path8, _hash);\n          }\n        } catch (err) {\n          _iterator42.e(err);\n        } finally {\n          _iterator42.f();\n        }\n      }\n      if (snapshot.hasContextTshs()) {\n        var contextTshs = snapshot.contextTshs;\n        this._statTestedEntries += contextTshs.size;\n        var _iterator43 = _createForOfIteratorHelper(contextTshs),\n          _step43;\n        try {\n          var _loop12 = function _loop12() {\n            var _step43$value = _slicedToArray(_step43.value, 2),\n              path = _step43$value[0],\n              tsh = _step43$value[1];\n            if (typeof tsh === \"string\") {\n              processContextHashSnapshot(path, tsh);\n            } else {\n              var _cache2 = _this9._contextTimestamps.get(path);\n              if (_cache2 === \"ignore\") return \"continue\";\n              var resolved;\n              if (_cache2 !== undefined && (resolved = getResolvedTimestamp(_cache2)) !== undefined) {\n                if (!checkContext(path, resolved, tsh, false)) {\n                  processContextHashSnapshot(path, tsh && tsh.hash);\n                }\n              } else {\n                jobs++;\n                /**\n                 * @param {Error=} err error\n                 * @param {ResolvedContextFileSystemInfoEntry=} entry entry\n                 * @returns {void}\n                 */\n                var _callback6 = function _callback6(err, entry) {\n                  if (err) return invalidWithError(path, err);\n                  if (!checkContext(path, entry, tsh, false)) {\n                    processContextHashSnapshot(path, tsh && tsh.hash);\n                  }\n                  jobDone();\n                };\n                if (_cache2 !== undefined) {\n                  _this9._resolveContextTimestamp(_cache2, _callback6);\n                } else {\n                  _this9.getContextTimestamp(path, _callback6);\n                }\n              }\n            }\n          };\n          for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {\n            var _ret4 = _loop12();\n            if (_ret4 === \"continue\") continue;\n          }\n        } catch (err) {\n          _iterator43.e(err);\n        } finally {\n          _iterator43.f();\n        }\n      }\n      if (snapshot.hasMissingExistence()) {\n        var missingExistence = snapshot.missingExistence;\n        this._statTestedEntries += missingExistence.size;\n        var _iterator44 = _createForOfIteratorHelper(missingExistence),\n          _step44;\n        try {\n          var _loop13 = function _loop13() {\n            var _step44$value = _slicedToArray(_step44.value, 2),\n              path = _step44$value[0],\n              existence = _step44$value[1];\n            var cache = _this9._fileTimestamps.get(path);\n            if (cache !== undefined) {\n              if (cache !== \"ignore\" && !checkExistence(path, Boolean(cache), Boolean(existence))) {\n                invalid();\n                return {\n                  v: void 0\n                };\n              }\n            } else {\n              jobs++;\n              _this9.fileTimestampQueue.add(path, function (err, entry) {\n                if (err) return invalidWithError(path, err);\n                if (!checkExistence(path, Boolean(entry), Boolean(existence))) {\n                  invalid();\n                } else {\n                  jobDone();\n                }\n              });\n            }\n          };\n          for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {\n            var _ret5 = _loop13();\n            if (typeof _ret5 === \"object\") return _ret5.v;\n          }\n        } catch (err) {\n          _iterator44.e(err);\n        } finally {\n          _iterator44.f();\n        }\n      }\n      if (snapshot.hasManagedItemInfo()) {\n        var managedItemInfo = snapshot.managedItemInfo;\n        this._statTestedEntries += managedItemInfo.size;\n        var _iterator45 = _createForOfIteratorHelper(managedItemInfo),\n          _step45;\n        try {\n          var _loop14 = function _loop14() {\n            var _step45$value = _slicedToArray(_step45.value, 2),\n              path = _step45$value[0],\n              info = _step45$value[1];\n            var cache = _this9._managedItems.get(path);\n            if (cache !== undefined) {\n              if (!checkHash(path, cache, info)) {\n                invalid();\n                return {\n                  v: void 0\n                };\n              }\n            } else {\n              jobs++;\n              _this9.managedItemQueue.add(path, function (err, entry) {\n                if (err) return invalidWithError(path, err);\n                if (!checkHash(path, entry, info)) {\n                  invalid();\n                } else {\n                  jobDone();\n                }\n              });\n            }\n          };\n          for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {\n            var _ret6 = _loop14();\n            if (typeof _ret6 === \"object\") return _ret6.v;\n          }\n        } catch (err) {\n          _iterator45.e(err);\n        } finally {\n          _iterator45.f();\n        }\n      }\n      jobDone();\n\n      // if there was an async action\n      // try to join multiple concurrent request for this snapshot\n      if (jobs > 0) {\n        var callbacks = [callback];\n        callback = function callback(err, result) {\n          for (var _i3 = 0, _callbacks = callbacks; _i3 < _callbacks.length; _i3++) {\n            var _callback7 = _callbacks[_i3];\n            _callback7(err, result);\n          }\n        };\n        this._snapshotCache.set(snapshot, callbacks);\n      }\n    }\n  }, {\n    key: \"_readFileTimestamp\",\n    value: function _readFileTimestamp(path, callback) {\n      var _this10 = this;\n      this.fs.stat(path, function (err, stat) {\n        if (err) {\n          if (err.code === \"ENOENT\") {\n            _this10._fileTimestamps.set(path, null);\n            _this10._cachedDeprecatedFileTimestamps = undefined;\n            return callback(null, null);\n          }\n          return callback(err);\n        }\n        var ts;\n        if (stat.isDirectory()) {\n          ts = {\n            safeTime: 0,\n            timestamp: undefined\n          };\n        } else {\n          var mtime = +stat.mtime;\n          if (mtime) applyMtime(mtime);\n          ts = {\n            safeTime: mtime ? mtime + FS_ACCURACY : Infinity,\n            timestamp: mtime\n          };\n        }\n        _this10._fileTimestamps.set(path, ts);\n        _this10._cachedDeprecatedFileTimestamps = undefined;\n        callback(null, ts);\n      });\n    }\n  }, {\n    key: \"_readFileHash\",\n    value: function _readFileHash(path, callback) {\n      var _this11 = this;\n      this.fs.readFile(path, function (err, content) {\n        if (err) {\n          if (err.code === \"EISDIR\") {\n            _this11._fileHashes.set(path, \"directory\");\n            return callback(null, \"directory\");\n          }\n          if (err.code === \"ENOENT\") {\n            _this11._fileHashes.set(path, null);\n            return callback(null, null);\n          }\n          if (err.code === \"ERR_FS_FILE_TOO_LARGE\") {\n            _this11.logger.warn(\"Ignoring \".concat(path, \" for hashing as it's very large\"));\n            _this11._fileHashes.set(path, \"too large\");\n            return callback(null, \"too large\");\n          }\n          return callback(err);\n        }\n        var hash = createHash(_this11._hashFunction);\n        hash.update(content);\n        var digest = /** @type {string} */hash.digest(\"hex\");\n        _this11._fileHashes.set(path, digest);\n        callback(null, digest);\n      });\n    }\n  }, {\n    key: \"_getFileTimestampAndHash\",\n    value: function _getFileTimestampAndHash(path, callback) {\n      var _this12 = this;\n      var continueWithHash = function continueWithHash(hash) {\n        var cache = _this12._fileTimestamps.get(path);\n        if (cache !== undefined) {\n          if (cache !== \"ignore\") {\n            var result = _objectSpread(_objectSpread({}, cache), {}, {\n              hash: hash\n            });\n            _this12._fileTshs.set(path, result);\n            return callback(null, result);\n          } else {\n            _this12._fileTshs.set(path, hash);\n            return callback(null, hash);\n          }\n        } else {\n          _this12.fileTimestampQueue.add(path, function (err, entry) {\n            if (err) {\n              return callback(err);\n            }\n            var result = _objectSpread(_objectSpread({}, entry), {}, {\n              hash: hash\n            });\n            _this12._fileTshs.set(path, result);\n            return callback(null, result);\n          });\n        }\n      };\n      var cache = this._fileHashes.get(path);\n      if (cache !== undefined) {\n        continueWithHash(cache);\n      } else {\n        this.fileHashQueue.add(path, function (err, entry) {\n          if (err) {\n            return callback(err);\n          }\n          continueWithHash(entry);\n        });\n      }\n    }\n\n    /**\n     * @template T\n     * @template ItemType\n     * @param {Object} options options\n     * @param {string} options.path path\n     * @param {function(string): ItemType} options.fromImmutablePath called when context item is an immutable path\n     * @param {function(string): ItemType} options.fromManagedItem called when context item is a managed path\n     * @param {function(string, string, function(Error=, ItemType=): void): void} options.fromSymlink called when context item is a symlink\n     * @param {function(string, IStats, function(Error=, ItemType=): void): void} options.fromFile called when context item is a file\n     * @param {function(string, IStats, function(Error=, ItemType=): void): void} options.fromDirectory called when context item is a directory\n     * @param {function(string[], ItemType[]): T} options.reduce called from all context items\n     * @param {function((Error | null)=, (T)=): void} callback callback\n     */\n  }, {\n    key: \"_readContext\",\n    value: function _readContext(_ref6, callback) {\n      var _this13 = this;\n      var path = _ref6.path,\n        fromImmutablePath = _ref6.fromImmutablePath,\n        fromManagedItem = _ref6.fromManagedItem,\n        fromSymlink = _ref6.fromSymlink,\n        fromFile = _ref6.fromFile,\n        fromDirectory = _ref6.fromDirectory,\n        reduce = _ref6.reduce;\n      this.fs.readdir(path, function (err, _files) {\n        if (err) {\n          if (err.code === \"ENOENT\") {\n            return callback(null, null);\n          }\n          return callback(err);\n        }\n        var files = /** @type {string[]} */_files.map(function (file) {\n          return file.normalize(\"NFC\");\n        }).filter(function (file) {\n          return !/^\\./.test(file);\n        }).sort();\n        asyncLib.map(files, function (file, callback) {\n          var child = join(_this13.fs, path, file);\n          var _iterator46 = _createForOfIteratorHelper(_this13.immutablePathsRegExps),\n            _step46;\n          try {\n            for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {\n              var immutablePath = _step46.value;\n              if (immutablePath.test(path)) {\n                // ignore any immutable path for timestamping\n                return callback(null, fromImmutablePath(path));\n              }\n            }\n          } catch (err) {\n            _iterator46.e(err);\n          } finally {\n            _iterator46.f();\n          }\n          var _iterator47 = _createForOfIteratorHelper(_this13.immutablePathsWithSlash),\n            _step47;\n          try {\n            for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {\n              var _immutablePath2 = _step47.value;\n              if (path.startsWith(_immutablePath2)) {\n                // ignore any immutable path for timestamping\n                return callback(null, fromImmutablePath(path));\n              }\n            }\n          } catch (err) {\n            _iterator47.e(err);\n          } finally {\n            _iterator47.f();\n          }\n          var _iterator48 = _createForOfIteratorHelper(_this13.managedPathsRegExps),\n            _step48;\n          try {\n            for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {\n              var managedPath = _step48.value;\n              var match = managedPath.exec(path);\n              if (match) {\n                var managedItem = getManagedItem(match[1], path);\n                if (managedItem) {\n                  // construct timestampHash from managed info\n                  return _this13.managedItemQueue.add(managedItem, function (err, info) {\n                    if (err) return callback(err);\n                    return callback(null, fromManagedItem(info));\n                  });\n                }\n              }\n            }\n          } catch (err) {\n            _iterator48.e(err);\n          } finally {\n            _iterator48.f();\n          }\n          var _iterator49 = _createForOfIteratorHelper(_this13.managedPathsWithSlash),\n            _step49;\n          try {\n            for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {\n              var _managedPath2 = _step49.value;\n              if (path.startsWith(_managedPath2)) {\n                var _managedItem2 = getManagedItem(_managedPath2, child);\n                if (_managedItem2) {\n                  // construct timestampHash from managed info\n                  return _this13.managedItemQueue.add(_managedItem2, function (err, info) {\n                    if (err) return callback(err);\n                    return callback(null, fromManagedItem(info));\n                  });\n                }\n              }\n            }\n          } catch (err) {\n            _iterator49.e(err);\n          } finally {\n            _iterator49.f();\n          }\n          lstatReadlinkAbsolute(_this13.fs, child, function (err, stat) {\n            if (err) return callback(err);\n            if (typeof stat === \"string\") {\n              return fromSymlink(child, stat, callback);\n            }\n            if (stat.isFile()) {\n              return fromFile(child, stat, callback);\n            }\n            if (stat.isDirectory()) {\n              return fromDirectory(child, stat, callback);\n            }\n            callback(null, null);\n          });\n        }, function (err, results) {\n          if (err) return callback(err);\n          var result = reduce(files, results);\n          callback(null, result);\n        });\n      });\n    }\n  }, {\n    key: \"_readContextTimestamp\",\n    value: function _readContextTimestamp(path, callback) {\n      var _this14 = this;\n      this._readContext({\n        path: path,\n        fromImmutablePath: function fromImmutablePath() {\n          return null;\n        },\n        fromManagedItem: function fromManagedItem(info) {\n          return {\n            safeTime: 0,\n            timestampHash: info\n          };\n        },\n        fromSymlink: function fromSymlink(file, target, callback) {\n          callback(null, {\n            timestampHash: target,\n            symlinks: new Set([target])\n          });\n        },\n        fromFile: function fromFile(file, stat, callback) {\n          // Prefer the cached value over our new stat to report consistent results\n          var cache = _this14._fileTimestamps.get(file);\n          if (cache !== undefined) return callback(null, cache === \"ignore\" ? null : cache);\n          var mtime = +stat.mtime;\n          if (mtime) applyMtime(mtime);\n          var ts = {\n            safeTime: mtime ? mtime + FS_ACCURACY : Infinity,\n            timestamp: mtime\n          };\n          _this14._fileTimestamps.set(file, ts);\n          _this14._cachedDeprecatedFileTimestamps = undefined;\n          callback(null, ts);\n        },\n        fromDirectory: function fromDirectory(directory, stat, callback) {\n          _this14.contextTimestampQueue.increaseParallelism();\n          _this14._getUnresolvedContextTimestamp(directory, function (err, tsEntry) {\n            _this14.contextTimestampQueue.decreaseParallelism();\n            callback(err, tsEntry);\n          });\n        },\n        reduce: function reduce(files, tsEntries) {\n          var symlinks = undefined;\n          var hash = createHash(_this14._hashFunction);\n          var _iterator50 = _createForOfIteratorHelper(files),\n            _step50;\n          try {\n            for (_iterator50.s(); !(_step50 = _iterator50.n()).done;) {\n              var file = _step50.value;\n              hash.update(file);\n            }\n          } catch (err) {\n            _iterator50.e(err);\n          } finally {\n            _iterator50.f();\n          }\n          var safeTime = 0;\n          var _iterator51 = _createForOfIteratorHelper(tsEntries),\n            _step51;\n          try {\n            for (_iterator51.s(); !(_step51 = _iterator51.n()).done;) {\n              var entry = _step51.value;\n              if (!entry) {\n                hash.update(\"n\");\n                continue;\n              }\n              if (entry.timestamp) {\n                hash.update(\"f\");\n                hash.update(\"\".concat(entry.timestamp));\n              } else if (entry.timestampHash) {\n                hash.update(\"d\");\n                hash.update(\"\".concat(entry.timestampHash));\n              }\n              if (entry.symlinks !== undefined) {\n                if (symlinks === undefined) symlinks = new Set();\n                addAll(entry.symlinks, symlinks);\n              }\n              if (entry.safeTime) {\n                safeTime = Math.max(safeTime, entry.safeTime);\n              }\n            }\n          } catch (err) {\n            _iterator51.e(err);\n          } finally {\n            _iterator51.f();\n          }\n          var digest = /** @type {string} */hash.digest(\"hex\");\n          var result = {\n            safeTime: safeTime,\n            timestampHash: digest\n          };\n          if (symlinks) result.symlinks = symlinks;\n          return result;\n        }\n      }, function (err, result) {\n        if (err) return callback(err);\n        _this14._contextTimestamps.set(path, result);\n        _this14._cachedDeprecatedContextTimestamps = undefined;\n        callback(null, result);\n      });\n    }\n\n    /**\n     * @param {ContextFileSystemInfoEntry} entry entry\n     * @param {function((Error | null)=, ResolvedContextFileSystemInfoEntry=): void} callback callback\n     * @returns {void}\n     */\n  }, {\n    key: \"_resolveContextTimestamp\",\n    value: function _resolveContextTimestamp(entry, callback) {\n      var _this15 = this;\n      var hashes = [];\n      var safeTime = 0;\n      processAsyncTree(entry.symlinks, 10, function (target, push, callback) {\n        _this15._getUnresolvedContextTimestamp(target, function (err, entry) {\n          if (err) return callback(err);\n          if (entry && entry !== \"ignore\") {\n            hashes.push(entry.timestampHash);\n            if (entry.safeTime) {\n              safeTime = Math.max(safeTime, entry.safeTime);\n            }\n            if (entry.symlinks !== undefined) {\n              var _iterator52 = _createForOfIteratorHelper(entry.symlinks),\n                _step52;\n              try {\n                for (_iterator52.s(); !(_step52 = _iterator52.n()).done;) {\n                  var _target = _step52.value;\n                  push(_target);\n                }\n              } catch (err) {\n                _iterator52.e(err);\n              } finally {\n                _iterator52.f();\n              }\n            }\n          }\n          callback();\n        });\n      }, function (err) {\n        if (err) return callback(err);\n        var hash = createHash(_this15._hashFunction);\n        hash.update(entry.timestampHash);\n        if (entry.safeTime) {\n          safeTime = Math.max(safeTime, entry.safeTime);\n        }\n        hashes.sort();\n        for (var _i4 = 0, _hashes = hashes; _i4 < _hashes.length; _i4++) {\n          var h = _hashes[_i4];\n          hash.update(h);\n        }\n        callback(null, entry.resolved = {\n          safeTime: safeTime,\n          timestampHash: /** @type {string} */hash.digest(\"hex\")\n        });\n      });\n    }\n  }, {\n    key: \"_readContextHash\",\n    value: function _readContextHash(path, callback) {\n      var _this16 = this;\n      this._readContext({\n        path: path,\n        fromImmutablePath: function fromImmutablePath() {\n          return \"\";\n        },\n        fromManagedItem: function fromManagedItem(info) {\n          return info || \"\";\n        },\n        fromSymlink: function fromSymlink(file, target, callback) {\n          callback(null, {\n            hash: target,\n            symlinks: new Set([target])\n          });\n        },\n        fromFile: function fromFile(file, stat, callback) {\n          return _this16.getFileHash(file, function (err, hash) {\n            callback(err, hash || \"\");\n          });\n        },\n        fromDirectory: function fromDirectory(directory, stat, callback) {\n          _this16.contextHashQueue.increaseParallelism();\n          _this16._getUnresolvedContextHash(directory, function (err, hash) {\n            _this16.contextHashQueue.decreaseParallelism();\n            callback(err, hash || \"\");\n          });\n        },\n        /**\n         * @param {string[]} files files\n         * @param {(string | ContextHash)[]} fileHashes hashes\n         * @returns {ContextHash} reduced hash\n         */\n        reduce: function reduce(files, fileHashes) {\n          var symlinks = undefined;\n          var hash = createHash(_this16._hashFunction);\n          var _iterator53 = _createForOfIteratorHelper(files),\n            _step53;\n          try {\n            for (_iterator53.s(); !(_step53 = _iterator53.n()).done;) {\n              var file = _step53.value;\n              hash.update(file);\n            }\n          } catch (err) {\n            _iterator53.e(err);\n          } finally {\n            _iterator53.f();\n          }\n          var _iterator54 = _createForOfIteratorHelper(fileHashes),\n            _step54;\n          try {\n            for (_iterator54.s(); !(_step54 = _iterator54.n()).done;) {\n              var entry = _step54.value;\n              if (typeof entry === \"string\") {\n                hash.update(entry);\n              } else {\n                hash.update(entry.hash);\n                if (entry.symlinks) {\n                  if (symlinks === undefined) symlinks = new Set();\n                  addAll(entry.symlinks, symlinks);\n                }\n              }\n            }\n          } catch (err) {\n            _iterator54.e(err);\n          } finally {\n            _iterator54.f();\n          }\n          var result = {\n            hash: /** @type {string} */hash.digest(\"hex\")\n          };\n          if (symlinks) result.symlinks = symlinks;\n          return result;\n        }\n      }, function (err, result) {\n        if (err) return callback(err);\n        _this16._contextHashes.set(path, result);\n        return callback(null, result);\n      });\n    }\n\n    /**\n     * @param {ContextHash} entry context hash\n     * @param {function((Error | null)=, string=): void} callback callback\n     * @returns {void}\n     */\n  }, {\n    key: \"_resolveContextHash\",\n    value: function _resolveContextHash(entry, callback) {\n      var _this17 = this;\n      var hashes = [];\n      processAsyncTree(entry.symlinks, 10, function (target, push, callback) {\n        _this17._getUnresolvedContextHash(target, function (err, hash) {\n          if (err) return callback(err);\n          if (hash) {\n            hashes.push(hash.hash);\n            if (hash.symlinks !== undefined) {\n              var _iterator55 = _createForOfIteratorHelper(hash.symlinks),\n                _step55;\n              try {\n                for (_iterator55.s(); !(_step55 = _iterator55.n()).done;) {\n                  var _target2 = _step55.value;\n                  push(_target2);\n                }\n              } catch (err) {\n                _iterator55.e(err);\n              } finally {\n                _iterator55.f();\n              }\n            }\n          }\n          callback();\n        });\n      }, function (err) {\n        if (err) return callback(err);\n        var hash = createHash(_this17._hashFunction);\n        hash.update(entry.hash);\n        hashes.sort();\n        for (var _i5 = 0, _hashes2 = hashes; _i5 < _hashes2.length; _i5++) {\n          var h = _hashes2[_i5];\n          hash.update(h);\n        }\n        callback(null, entry.resolved = /** @type {string} */hash.digest(\"hex\"));\n      });\n    }\n  }, {\n    key: \"_readContextTimestampAndHash\",\n    value: function _readContextTimestampAndHash(path, callback) {\n      var _this18 = this;\n      var finalize = function finalize(timestamp, hash) {\n        var result = timestamp === \"ignore\" ? hash : _objectSpread(_objectSpread({}, timestamp), hash);\n        _this18._contextTshs.set(path, result);\n        callback(null, result);\n      };\n      var cachedHash = this._contextHashes.get(path);\n      var cachedTimestamp = this._contextTimestamps.get(path);\n      if (cachedHash !== undefined) {\n        if (cachedTimestamp !== undefined) {\n          finalize(cachedTimestamp, cachedHash);\n        } else {\n          this.contextTimestampQueue.add(path, function (err, entry) {\n            if (err) return callback(err);\n            finalize(entry, cachedHash);\n          });\n        }\n      } else {\n        if (cachedTimestamp !== undefined) {\n          this.contextHashQueue.add(path, function (err, entry) {\n            if (err) return callback(err);\n            finalize(cachedTimestamp, entry);\n          });\n        } else {\n          this._readContext({\n            path: path,\n            fromImmutablePath: function fromImmutablePath() {\n              return null;\n            },\n            fromManagedItem: function fromManagedItem(info) {\n              return {\n                safeTime: 0,\n                timestampHash: info,\n                hash: info || \"\"\n              };\n            },\n            fromSymlink: function fromSymlink(fle, target, callback) {\n              callback(null, {\n                timestampHash: target,\n                hash: target,\n                symlinks: new Set([target])\n              });\n            },\n            fromFile: function fromFile(file, stat, callback) {\n              _this18._getFileTimestampAndHash(file, callback);\n            },\n            fromDirectory: function fromDirectory(directory, stat, callback) {\n              _this18.contextTshQueue.increaseParallelism();\n              _this18.contextTshQueue.add(directory, function (err, result) {\n                _this18.contextTshQueue.decreaseParallelism();\n                callback(err, result);\n              });\n            },\n            /**\n             * @param {string[]} files files\n             * @param {(Partial<TimestampAndHash> & Partial<ContextTimestampAndHash> | string | null)[]} results results\n             * @returns {ContextTimestampAndHash} tsh\n             */\n            reduce: function reduce(files, results) {\n              var symlinks = undefined;\n              var tsHash = createHash(_this18._hashFunction);\n              var hash = createHash(_this18._hashFunction);\n              var _iterator56 = _createForOfIteratorHelper(files),\n                _step56;\n              try {\n                for (_iterator56.s(); !(_step56 = _iterator56.n()).done;) {\n                  var file = _step56.value;\n                  tsHash.update(file);\n                  hash.update(file);\n                }\n              } catch (err) {\n                _iterator56.e(err);\n              } finally {\n                _iterator56.f();\n              }\n              var safeTime = 0;\n              var _iterator57 = _createForOfIteratorHelper(results),\n                _step57;\n              try {\n                for (_iterator57.s(); !(_step57 = _iterator57.n()).done;) {\n                  var entry = _step57.value;\n                  if (!entry) {\n                    tsHash.update(\"n\");\n                    continue;\n                  }\n                  if (typeof entry === \"string\") {\n                    tsHash.update(\"n\");\n                    hash.update(entry);\n                    continue;\n                  }\n                  if (entry.timestamp) {\n                    tsHash.update(\"f\");\n                    tsHash.update(\"\".concat(entry.timestamp));\n                  } else if (entry.timestampHash) {\n                    tsHash.update(\"d\");\n                    tsHash.update(\"\".concat(entry.timestampHash));\n                  }\n                  if (entry.symlinks !== undefined) {\n                    if (symlinks === undefined) symlinks = new Set();\n                    addAll(entry.symlinks, symlinks);\n                  }\n                  if (entry.safeTime) {\n                    safeTime = Math.max(safeTime, entry.safeTime);\n                  }\n                  hash.update(entry.hash);\n                }\n              } catch (err) {\n                _iterator57.e(err);\n              } finally {\n                _iterator57.f();\n              }\n              var result = {\n                safeTime: safeTime,\n                timestampHash: /** @type {string} */tsHash.digest(\"hex\"),\n                hash: /** @type {string} */hash.digest(\"hex\")\n              };\n              if (symlinks) result.symlinks = symlinks;\n              return result;\n            }\n          }, function (err, result) {\n            if (err) return callback(err);\n            _this18._contextTshs.set(path, result);\n            return callback(null, result);\n          });\n        }\n      }\n    }\n\n    /**\n     * @param {ContextTimestampAndHash} entry entry\n     * @param {function((Error | null)=, ResolvedContextTimestampAndHash=): void} callback callback\n     * @returns {void}\n     */\n  }, {\n    key: \"_resolveContextTsh\",\n    value: function _resolveContextTsh(entry, callback) {\n      var _this19 = this;\n      var hashes = [];\n      var tsHashes = [];\n      var safeTime = 0;\n      processAsyncTree(entry.symlinks, 10, function (target, push, callback) {\n        _this19._getUnresolvedContextTsh(target, function (err, entry) {\n          if (err) return callback(err);\n          if (entry) {\n            hashes.push(entry.hash);\n            if (entry.timestampHash) tsHashes.push(entry.timestampHash);\n            if (entry.safeTime) {\n              safeTime = Math.max(safeTime, entry.safeTime);\n            }\n            if (entry.symlinks !== undefined) {\n              var _iterator58 = _createForOfIteratorHelper(entry.symlinks),\n                _step58;\n              try {\n                for (_iterator58.s(); !(_step58 = _iterator58.n()).done;) {\n                  var _target3 = _step58.value;\n                  push(_target3);\n                }\n              } catch (err) {\n                _iterator58.e(err);\n              } finally {\n                _iterator58.f();\n              }\n            }\n          }\n          callback();\n        });\n      }, function (err) {\n        if (err) return callback(err);\n        var hash = createHash(_this19._hashFunction);\n        var tsHash = createHash(_this19._hashFunction);\n        hash.update(entry.hash);\n        if (entry.timestampHash) tsHash.update(entry.timestampHash);\n        if (entry.safeTime) {\n          safeTime = Math.max(safeTime, entry.safeTime);\n        }\n        hashes.sort();\n        for (var _i6 = 0, _hashes3 = hashes; _i6 < _hashes3.length; _i6++) {\n          var h = _hashes3[_i6];\n          hash.update(h);\n        }\n        tsHashes.sort();\n        for (var _i7 = 0, _tsHashes = tsHashes; _i7 < _tsHashes.length; _i7++) {\n          var _h = _tsHashes[_i7];\n          tsHash.update(_h);\n        }\n        callback(null, entry.resolved = {\n          safeTime: safeTime,\n          timestampHash: /** @type {string} */tsHash.digest(\"hex\"),\n          hash: /** @type {string} */hash.digest(\"hex\")\n        });\n      });\n    }\n  }, {\n    key: \"_getManagedItemDirectoryInfo\",\n    value: function _getManagedItemDirectoryInfo(path, callback) {\n      var _this20 = this;\n      this.fs.readdir(path, function (err, elements) {\n        if (err) {\n          if (err.code === \"ENOENT\" || err.code === \"ENOTDIR\") {\n            return callback(null, EMPTY_SET);\n          }\n          return callback(err);\n        }\n        var set = new Set( /** @type {string[]} */elements.map(function (element) {\n          return join(_this20.fs, path, element);\n        }));\n        callback(null, set);\n      });\n    }\n  }, {\n    key: \"_getManagedItemInfo\",\n    value: function _getManagedItemInfo(path, callback) {\n      var _this21 = this;\n      var dir = dirname(this.fs, path);\n      this.managedItemDirectoryQueue.add(dir, function (err, elements) {\n        if (err) {\n          return callback(err);\n        }\n        if (!elements.has(path)) {\n          // file or directory doesn't exist\n          _this21._managedItems.set(path, \"*missing\");\n          return callback(null, \"*missing\");\n        }\n        // something exists\n        // it may be a file or directory\n        if (path.endsWith(\"node_modules\") && (path.endsWith(\"/node_modules\") || path.endsWith(\"\\\\node_modules\"))) {\n          // we are only interested in existence of this special directory\n          _this21._managedItems.set(path, \"*node_modules\");\n          return callback(null, \"*node_modules\");\n        }\n\n        // we assume it's a directory, as files shouldn't occur in managed paths\n        var packageJsonPath = join(_this21.fs, path, \"package.json\");\n        _this21.fs.readFile(packageJsonPath, function (err, content) {\n          if (err) {\n            if (err.code === \"ENOENT\" || err.code === \"ENOTDIR\") {\n              // no package.json or path is not a directory\n              _this21.fs.readdir(path, function (err, elements) {\n                if (!err && elements.length === 1 && elements[0] === \"node_modules\") {\n                  // This is only a grouping folder e. g. used by yarn\n                  // we are only interested in existence of this special directory\n                  _this21._managedItems.set(path, \"*nested\");\n                  return callback(null, \"*nested\");\n                }\n                _this21.logger.warn(\"Managed item \".concat(path, \" isn't a directory or doesn't contain a package.json (see snapshot.managedPaths option)\"));\n                return callback();\n              });\n              return;\n            }\n            return callback(err);\n          }\n          var data;\n          try {\n            data = JSON.parse(content.toString(\"utf-8\"));\n          } catch (e) {\n            return callback(e);\n          }\n          if (!data.name) {\n            _this21.logger.warn(\"\".concat(packageJsonPath, \" doesn't contain a \\\"name\\\" property (see snapshot.managedPaths option)\"));\n            return callback();\n          }\n          var info = \"\".concat(data.name || \"\", \"@\").concat(data.version || \"\");\n          _this21._managedItems.set(path, info);\n          callback(null, info);\n        });\n      });\n    }\n  }, {\n    key: \"getDeprecatedFileTimestamps\",\n    value: function getDeprecatedFileTimestamps() {\n      if (this._cachedDeprecatedFileTimestamps !== undefined) return this._cachedDeprecatedFileTimestamps;\n      var map = new Map();\n      var _iterator59 = _createForOfIteratorHelper(this._fileTimestamps),\n        _step59;\n      try {\n        for (_iterator59.s(); !(_step59 = _iterator59.n()).done;) {\n          var _step59$value = _slicedToArray(_step59.value, 2),\n            path = _step59$value[0],\n            info = _step59$value[1];\n          if (info) map.set(path, typeof info === \"object\" ? info.safeTime : null);\n        }\n      } catch (err) {\n        _iterator59.e(err);\n      } finally {\n        _iterator59.f();\n      }\n      return this._cachedDeprecatedFileTimestamps = map;\n    }\n  }, {\n    key: \"getDeprecatedContextTimestamps\",\n    value: function getDeprecatedContextTimestamps() {\n      if (this._cachedDeprecatedContextTimestamps !== undefined) return this._cachedDeprecatedContextTimestamps;\n      var map = new Map();\n      var _iterator60 = _createForOfIteratorHelper(this._contextTimestamps),\n        _step60;\n      try {\n        for (_iterator60.s(); !(_step60 = _iterator60.n()).done;) {\n          var _step60$value = _slicedToArray(_step60.value, 2),\n            path = _step60$value[0],\n            info = _step60$value[1];\n          if (info) map.set(path, typeof info === \"object\" ? info.safeTime : null);\n        }\n      } catch (err) {\n        _iterator60.e(err);\n      } finally {\n        _iterator60.f();\n      }\n      return this._cachedDeprecatedContextTimestamps = map;\n    }\n  }]);\n  return FileSystemInfo;\n}();\nmodule.exports = FileSystemInfo;\nmodule.exports.Snapshot = Snapshot;","map":{"version":3,"names":["require","createResolver","create","nodeModule","asyncLib","isAbsolute","AsyncQueue","StackedCacheMap","createHash","join","dirname","relative","lstatReadlinkAbsolute","makeSerializable","processAsyncTree","supportsEsm","process","versions","modules","builtinModules","Set","FS_ACCURACY","EMPTY_SET","RBDT_RESOLVE_CJS","RBDT_RESOLVE_ESM","RBDT_RESOLVE_DIRECTORY","RBDT_RESOLVE_CJS_FILE","RBDT_RESOLVE_CJS_FILE_AS_CHILD","RBDT_RESOLVE_ESM_FILE","RBDT_DIRECTORY","RBDT_FILE","RBDT_DIRECTORY_DEPENDENCIES","RBDT_FILE_DEPENDENCIES","INVALID","Symbol","DONE_ITERATOR_RESULT","keys","next","SnapshotIterator","SnapshotIterable","snapshot","getMaps","state","it","maps","queue","length","map","pop","undefined","result","done","children","size","child","push","iterator","Snapshot","_flags","_cachedFileIterable","_cachedContextIterable","_cachedMissingIterable","startTime","fileTimestamps","fileHashes","fileTshs","contextTimestamps","contextHashes","contextTshs","missingExistence","managedItemInfo","managedFiles","managedContexts","managedMissing","value","hasStartTime","setStartTime","Math","min","hasChildren","setChildren","add","write","hasFileTimestamps","hasFileHashes","hasFileTshs","hasContextTimestamps","hasContextHashes","hasContextTshs","hasMissingExistence","hasManagedItemInfo","hasManagedFiles","hasManagedContexts","hasManagedMissing","read","_createIterable","s","MIN_COMMON_SNAPSHOT_SIZE","SnapshotOptimization","has","get","set","useStartTime","isSet","_has","_get","_set","_useStartTime","_isSet","_map","Map","_statItemsShared","_statItemsUnshared","_statSharedSnapshots","_statReusedSharedSnapshots","total","round","clear","newSnapshot","capturedFiles","increaseSharedAndStoreOptimizationEntry","entry","forEach","shared","storeOptimizationEntry","snapshotContent","path","old","delete","newOptimizationEntry","capturedFilesSize","optimizationEntries","optimizationEntry","nonSharedFiles","snapshotEntries","addChild","sharedCount","commonMap","commonSnapshot","setMergedStartTime","newEntry","ts","unshared","parseString","str","slice","replace","JSON","parse","applyMtime","mtime","mergeMaps","a","b","key","mergeSets","item","getManagedItem","managedPath","i","slashes","startingPosition","loop","charCodeAt","c","getResolvedTimestamp","resolved","symlinks","getResolvedHash","hash","addAll","source","target","FileSystemInfo","fs","managedPaths","immutablePaths","logger","hashFunction","_remainingLogs","_loggedPaths","_hashFunction","_snapshotCache","WeakMap","_fileTimestampsOptimization","v","setFileTimestamps","_fileHashesOptimization","setFileHashes","_fileTshsOptimization","setFileTshs","_contextTimestampsOptimization","setContextTimestamps","_contextHashesOptimization","setContextHashes","_contextTshsOptimization","setContextTshs","_missingExistenceOptimization","setMissingExistence","_managedItemInfoOptimization","setManagedItemInfo","_managedFilesOptimization","setManagedFiles","_managedContextsOptimization","setManagedContexts","_managedMissingOptimization","setManagedMissing","_fileTimestamps","_fileHashes","_fileTshs","_contextTimestamps","_contextHashes","_contextTshs","_managedItems","fileTimestampQueue","name","parallelism","processor","_readFileTimestamp","bind","fileHashQueue","_readFileHash","contextTimestampQueue","_readContextTimestamp","contextHashQueue","_readContextHash","contextTshQueue","_readContextTimestampAndHash","managedItemQueue","_getManagedItemInfo","managedItemDirectoryQueue","_getManagedItemDirectoryInfo","Array","from","managedPathsWithSlash","filter","p","managedPathsRegExps","immutablePathsWithSlash","immutablePathsRegExps","_cachedDeprecatedFileTimestamps","_cachedDeprecatedContextTimestamps","_warnAboutExperimentalEsmTracking","_statCreatedSnapshots","_statTestedSnapshotsCached","_statTestedSnapshotsNotCached","_statTestedChildrenCached","_statTestedChildrenNotCached","_statTestedEntries","logWhenMessage","header","message","log","getStatisticMessage","reason","args","debug","immutable","callback","cache","_resolveContextTimestamp","err","_resolveContextHash","_resolveContextTsh","resolveContext","resolveToContext","exportsFields","fileSystem","resolveCjs","extensions","conditionNames","resolveCjsAsChild","resolveEsm","fullySpecified","context","deps","_createBuildDependenciesResolvers","files","fileSymlinks","directories","directorySymlinks","missing","resolveFiles","resolveDirectories","resolveMissing","resolveResults","invalidResolveResults","resolverContext","fileDependencies","contextDependencies","missingDependencies","expectedToString","expected","jobToString","job","type","pathToString","issuer","dep","resolveDirectory","_","resultPath","resolveFile","symbol","resolve","warn","isDirectory","test","realpath","_realPath","realPath","nextTick","module","isArray","childPath","filename","paths","modulePath","startsWith","subPath","packageMatch","exec","request","endsWith","lexer","init","then","readFile","content","toString","imports","imp","dependency","d","substring","e","expr","trim","stack","match","packagePath","packageJson","code","parent","packageData","depsObject","dependencies","optionalDepsObject","optionalDependencies","allDeps","optionalDeps","Object","l","k","resolveDependencies","eachLimit","expectedResult","split","Error","options","managedItems","mode","timestamp","jobs","jobDone","optimize","jobError","checkManaged","managedSet","immutablePath","managedItem","captureNonManaged","items","capturedItems","processCapturedFiles","_getFileTimestampAndHash","processCapturedDirectories","capturedDirectories","getContextTsh","getContextHash","getContextTimestamp","processCapturedMissing","capturedMissing","Boolean","fn","captured","file","snapshot1","snapshot2","cachedResult","_checkSnapshotValidNoCache","invalid","invalidWithError","_log","checkHash","current","snap","checkExistence","checkFile","safeTime","checkContext","timestampHash","childCallback","processFileHashSnapshot","tsh","processContextHashSnapshot","existence","info","callbacks","stat","Infinity","update","digest","continueWithHash","fromImmutablePath","fromManagedItem","fromSymlink","fromFile","fromDirectory","reduce","readdir","_files","normalize","sort","isFile","results","_readContext","directory","increaseParallelism","_getUnresolvedContextTimestamp","tsEntry","decreaseParallelism","tsEntries","max","hashes","h","getFileHash","_getUnresolvedContextHash","finalize","cachedHash","cachedTimestamp","fle","tsHash","tsHashes","_getUnresolvedContextTsh","elements","element","dir","packageJsonPath","data","version","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/FileSystemInfo.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { create: createResolver } = require(\"enhanced-resolve\");\nconst nodeModule = require(\"module\");\nconst asyncLib = require(\"neo-async\");\nconst { isAbsolute } = require(\"path\");\nconst AsyncQueue = require(\"./util/AsyncQueue\");\nconst StackedCacheMap = require(\"./util/StackedCacheMap\");\nconst createHash = require(\"./util/createHash\");\nconst { join, dirname, relative, lstatReadlinkAbsolute } = require(\"./util/fs\");\nconst makeSerializable = require(\"./util/makeSerializable\");\nconst processAsyncTree = require(\"./util/processAsyncTree\");\n\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/fs\").IStats} IStats */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\nconst supportsEsm = +process.versions.modules >= 83;\n\nconst builtinModules = new Set(nodeModule.builtinModules);\n\nlet FS_ACCURACY = 2000;\n\nconst EMPTY_SET = new Set();\n\nconst RBDT_RESOLVE_CJS = 0;\nconst RBDT_RESOLVE_ESM = 1;\nconst RBDT_RESOLVE_DIRECTORY = 2;\nconst RBDT_RESOLVE_CJS_FILE = 3;\nconst RBDT_RESOLVE_CJS_FILE_AS_CHILD = 4;\nconst RBDT_RESOLVE_ESM_FILE = 5;\nconst RBDT_DIRECTORY = 6;\nconst RBDT_FILE = 7;\nconst RBDT_DIRECTORY_DEPENDENCIES = 8;\nconst RBDT_FILE_DEPENDENCIES = 9;\n\nconst INVALID = Symbol(\"invalid\");\n\n/**\n * @typedef {Object} FileSystemInfoEntry\n * @property {number} safeTime\n * @property {number=} timestamp\n */\n\n/**\n * @typedef {Object} ResolvedContextFileSystemInfoEntry\n * @property {number} safeTime\n * @property {string=} timestampHash\n */\n\n/**\n * @typedef {Object} ContextFileSystemInfoEntry\n * @property {number} safeTime\n * @property {string=} timestampHash\n * @property {ResolvedContextFileSystemInfoEntry=} resolved\n * @property {Set<string>=} symlinks\n */\n\n/**\n * @typedef {Object} TimestampAndHash\n * @property {number} safeTime\n * @property {number=} timestamp\n * @property {string} hash\n */\n\n/**\n * @typedef {Object} ResolvedContextTimestampAndHash\n * @property {number} safeTime\n * @property {string=} timestampHash\n * @property {string} hash\n */\n\n/**\n * @typedef {Object} ContextTimestampAndHash\n * @property {number} safeTime\n * @property {string=} timestampHash\n * @property {string} hash\n * @property {ResolvedContextTimestampAndHash=} resolved\n * @property {Set<string>=} symlinks\n */\n\n/**\n * @typedef {Object} ContextHash\n * @property {string} hash\n * @property {string=} resolved\n * @property {Set<string>=} symlinks\n */\n\n/**\n * @typedef {Object} SnapshotOptimizationEntry\n * @property {Snapshot} snapshot\n * @property {number} shared\n * @property {Set<string>} snapshotContent\n * @property {Set<SnapshotOptimizationEntry>} children\n */\n\n/**\n * @typedef {Object} ResolveBuildDependenciesResult\n * @property {Set<string>} files list of files\n * @property {Set<string>} directories list of directories\n * @property {Set<string>} missing list of missing entries\n * @property {Map<string, string | false>} resolveResults stored resolve results\n * @property {Object} resolveDependencies dependencies of the resolving\n * @property {Set<string>} resolveDependencies.files list of files\n * @property {Set<string>} resolveDependencies.directories list of directories\n * @property {Set<string>} resolveDependencies.missing list of missing entries\n */\n\nconst DONE_ITERATOR_RESULT = new Set().keys().next();\n\n// cspell:word tshs\n// Tsh = Timestamp + Hash\n// Tshs = Timestamp + Hash combinations\n\nclass SnapshotIterator {\n\tconstructor(next) {\n\t\tthis.next = next;\n\t}\n}\n\nclass SnapshotIterable {\n\tconstructor(snapshot, getMaps) {\n\t\tthis.snapshot = snapshot;\n\t\tthis.getMaps = getMaps;\n\t}\n\n\t[Symbol.iterator]() {\n\t\tlet state = 0;\n\t\t/** @type {IterableIterator<string>} */\n\t\tlet it;\n\t\t/** @type {(Snapshot) => (Map<string, any> | Set<string>)[]} */\n\t\tlet getMaps;\n\t\t/** @type {(Map<string, any> | Set<string>)[]} */\n\t\tlet maps;\n\t\t/** @type {Snapshot} */\n\t\tlet snapshot;\n\t\tlet queue;\n\t\treturn new SnapshotIterator(() => {\n\t\t\tfor (;;) {\n\t\t\t\tswitch (state) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tsnapshot = this.snapshot;\n\t\t\t\t\t\tgetMaps = this.getMaps;\n\t\t\t\t\t\tmaps = getMaps(snapshot);\n\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t/* falls through */\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tif (maps.length > 0) {\n\t\t\t\t\t\t\tconst map = maps.pop();\n\t\t\t\t\t\t\tif (map !== undefined) {\n\t\t\t\t\t\t\t\tit = map.keys();\n\t\t\t\t\t\t\t\tstate = 2;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstate = 3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t/* falls through */\n\t\t\t\t\tcase 2: {\n\t\t\t\t\t\tconst result = it.next();\n\t\t\t\t\t\tif (!result.done) return result;\n\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 3: {\n\t\t\t\t\t\tconst children = snapshot.children;\n\t\t\t\t\t\tif (children !== undefined) {\n\t\t\t\t\t\t\tif (children.size === 1) {\n\t\t\t\t\t\t\t\t// shortcut for a single child\n\t\t\t\t\t\t\t\t// avoids allocation of queue\n\t\t\t\t\t\t\t\tfor (const child of children) snapshot = child;\n\t\t\t\t\t\t\t\tmaps = getMaps(snapshot);\n\t\t\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (queue === undefined) queue = [];\n\t\t\t\t\t\t\tfor (const child of children) {\n\t\t\t\t\t\t\t\tqueue.push(child);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (queue !== undefined && queue.length > 0) {\n\t\t\t\t\t\t\tsnapshot = queue.pop();\n\t\t\t\t\t\t\tmaps = getMaps(snapshot);\n\t\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstate = 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* falls through */\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\treturn DONE_ITERATOR_RESULT;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\nclass Snapshot {\n\tconstructor() {\n\t\tthis._flags = 0;\n\t\t/** @type {Iterable<string> | undefined} */\n\t\tthis._cachedFileIterable = undefined;\n\t\t/** @type {Iterable<string> | undefined} */\n\t\tthis._cachedContextIterable = undefined;\n\t\t/** @type {Iterable<string> | undefined} */\n\t\tthis._cachedMissingIterable = undefined;\n\t\t/** @type {number | undefined} */\n\t\tthis.startTime = undefined;\n\t\t/** @type {Map<string, FileSystemInfoEntry | null> | undefined} */\n\t\tthis.fileTimestamps = undefined;\n\t\t/** @type {Map<string, string | null> | undefined} */\n\t\tthis.fileHashes = undefined;\n\t\t/** @type {Map<string, TimestampAndHash | string | null> | undefined} */\n\t\tthis.fileTshs = undefined;\n\t\t/** @type {Map<string, ResolvedContextFileSystemInfoEntry | null> | undefined} */\n\t\tthis.contextTimestamps = undefined;\n\t\t/** @type {Map<string, string | null> | undefined} */\n\t\tthis.contextHashes = undefined;\n\t\t/** @type {Map<string, ResolvedContextTimestampAndHash | null> | undefined} */\n\t\tthis.contextTshs = undefined;\n\t\t/** @type {Map<string, boolean> | undefined} */\n\t\tthis.missingExistence = undefined;\n\t\t/** @type {Map<string, string> | undefined} */\n\t\tthis.managedItemInfo = undefined;\n\t\t/** @type {Set<string> | undefined} */\n\t\tthis.managedFiles = undefined;\n\t\t/** @type {Set<string> | undefined} */\n\t\tthis.managedContexts = undefined;\n\t\t/** @type {Set<string> | undefined} */\n\t\tthis.managedMissing = undefined;\n\t\t/** @type {Set<Snapshot> | undefined} */\n\t\tthis.children = undefined;\n\t}\n\n\thasStartTime() {\n\t\treturn (this._flags & 1) !== 0;\n\t}\n\n\tsetStartTime(value) {\n\t\tthis._flags = this._flags | 1;\n\t\tthis.startTime = value;\n\t}\n\n\tsetMergedStartTime(value, snapshot) {\n\t\tif (value) {\n\t\t\tif (snapshot.hasStartTime()) {\n\t\t\t\tthis.setStartTime(Math.min(value, snapshot.startTime));\n\t\t\t} else {\n\t\t\t\tthis.setStartTime(value);\n\t\t\t}\n\t\t} else {\n\t\t\tif (snapshot.hasStartTime()) this.setStartTime(snapshot.startTime);\n\t\t}\n\t}\n\n\thasFileTimestamps() {\n\t\treturn (this._flags & 2) !== 0;\n\t}\n\n\tsetFileTimestamps(value) {\n\t\tthis._flags = this._flags | 2;\n\t\tthis.fileTimestamps = value;\n\t}\n\n\thasFileHashes() {\n\t\treturn (this._flags & 4) !== 0;\n\t}\n\n\tsetFileHashes(value) {\n\t\tthis._flags = this._flags | 4;\n\t\tthis.fileHashes = value;\n\t}\n\n\thasFileTshs() {\n\t\treturn (this._flags & 8) !== 0;\n\t}\n\n\tsetFileTshs(value) {\n\t\tthis._flags = this._flags | 8;\n\t\tthis.fileTshs = value;\n\t}\n\n\thasContextTimestamps() {\n\t\treturn (this._flags & 0x10) !== 0;\n\t}\n\n\tsetContextTimestamps(value) {\n\t\tthis._flags = this._flags | 0x10;\n\t\tthis.contextTimestamps = value;\n\t}\n\n\thasContextHashes() {\n\t\treturn (this._flags & 0x20) !== 0;\n\t}\n\n\tsetContextHashes(value) {\n\t\tthis._flags = this._flags | 0x20;\n\t\tthis.contextHashes = value;\n\t}\n\n\thasContextTshs() {\n\t\treturn (this._flags & 0x40) !== 0;\n\t}\n\n\tsetContextTshs(value) {\n\t\tthis._flags = this._flags | 0x40;\n\t\tthis.contextTshs = value;\n\t}\n\n\thasMissingExistence() {\n\t\treturn (this._flags & 0x80) !== 0;\n\t}\n\n\tsetMissingExistence(value) {\n\t\tthis._flags = this._flags | 0x80;\n\t\tthis.missingExistence = value;\n\t}\n\n\thasManagedItemInfo() {\n\t\treturn (this._flags & 0x100) !== 0;\n\t}\n\n\tsetManagedItemInfo(value) {\n\t\tthis._flags = this._flags | 0x100;\n\t\tthis.managedItemInfo = value;\n\t}\n\n\thasManagedFiles() {\n\t\treturn (this._flags & 0x200) !== 0;\n\t}\n\n\tsetManagedFiles(value) {\n\t\tthis._flags = this._flags | 0x200;\n\t\tthis.managedFiles = value;\n\t}\n\n\thasManagedContexts() {\n\t\treturn (this._flags & 0x400) !== 0;\n\t}\n\n\tsetManagedContexts(value) {\n\t\tthis._flags = this._flags | 0x400;\n\t\tthis.managedContexts = value;\n\t}\n\n\thasManagedMissing() {\n\t\treturn (this._flags & 0x800) !== 0;\n\t}\n\n\tsetManagedMissing(value) {\n\t\tthis._flags = this._flags | 0x800;\n\t\tthis.managedMissing = value;\n\t}\n\n\thasChildren() {\n\t\treturn (this._flags & 0x1000) !== 0;\n\t}\n\n\tsetChildren(value) {\n\t\tthis._flags = this._flags | 0x1000;\n\t\tthis.children = value;\n\t}\n\n\taddChild(child) {\n\t\tif (!this.hasChildren()) {\n\t\t\tthis.setChildren(new Set());\n\t\t}\n\t\tthis.children.add(child);\n\t}\n\n\tserialize({ write }) {\n\t\twrite(this._flags);\n\t\tif (this.hasStartTime()) write(this.startTime);\n\t\tif (this.hasFileTimestamps()) write(this.fileTimestamps);\n\t\tif (this.hasFileHashes()) write(this.fileHashes);\n\t\tif (this.hasFileTshs()) write(this.fileTshs);\n\t\tif (this.hasContextTimestamps()) write(this.contextTimestamps);\n\t\tif (this.hasContextHashes()) write(this.contextHashes);\n\t\tif (this.hasContextTshs()) write(this.contextTshs);\n\t\tif (this.hasMissingExistence()) write(this.missingExistence);\n\t\tif (this.hasManagedItemInfo()) write(this.managedItemInfo);\n\t\tif (this.hasManagedFiles()) write(this.managedFiles);\n\t\tif (this.hasManagedContexts()) write(this.managedContexts);\n\t\tif (this.hasManagedMissing()) write(this.managedMissing);\n\t\tif (this.hasChildren()) write(this.children);\n\t}\n\n\tdeserialize({ read }) {\n\t\tthis._flags = read();\n\t\tif (this.hasStartTime()) this.startTime = read();\n\t\tif (this.hasFileTimestamps()) this.fileTimestamps = read();\n\t\tif (this.hasFileHashes()) this.fileHashes = read();\n\t\tif (this.hasFileTshs()) this.fileTshs = read();\n\t\tif (this.hasContextTimestamps()) this.contextTimestamps = read();\n\t\tif (this.hasContextHashes()) this.contextHashes = read();\n\t\tif (this.hasContextTshs()) this.contextTshs = read();\n\t\tif (this.hasMissingExistence()) this.missingExistence = read();\n\t\tif (this.hasManagedItemInfo()) this.managedItemInfo = read();\n\t\tif (this.hasManagedFiles()) this.managedFiles = read();\n\t\tif (this.hasManagedContexts()) this.managedContexts = read();\n\t\tif (this.hasManagedMissing()) this.managedMissing = read();\n\t\tif (this.hasChildren()) this.children = read();\n\t}\n\n\t/**\n\t * @param {function(Snapshot): (ReadonlyMap<string, any> | ReadonlySet<string>)[]} getMaps first\n\t * @returns {Iterable<string>} iterable\n\t */\n\t_createIterable(getMaps) {\n\t\treturn new SnapshotIterable(this, getMaps);\n\t}\n\n\t/**\n\t * @returns {Iterable<string>} iterable\n\t */\n\tgetFileIterable() {\n\t\tif (this._cachedFileIterable === undefined) {\n\t\t\tthis._cachedFileIterable = this._createIterable(s => [\n\t\t\t\ts.fileTimestamps,\n\t\t\t\ts.fileHashes,\n\t\t\t\ts.fileTshs,\n\t\t\t\ts.managedFiles\n\t\t\t]);\n\t\t}\n\t\treturn this._cachedFileIterable;\n\t}\n\n\t/**\n\t * @returns {Iterable<string>} iterable\n\t */\n\tgetContextIterable() {\n\t\tif (this._cachedContextIterable === undefined) {\n\t\t\tthis._cachedContextIterable = this._createIterable(s => [\n\t\t\t\ts.contextTimestamps,\n\t\t\t\ts.contextHashes,\n\t\t\t\ts.contextTshs,\n\t\t\t\ts.managedContexts\n\t\t\t]);\n\t\t}\n\t\treturn this._cachedContextIterable;\n\t}\n\n\t/**\n\t * @returns {Iterable<string>} iterable\n\t */\n\tgetMissingIterable() {\n\t\tif (this._cachedMissingIterable === undefined) {\n\t\t\tthis._cachedMissingIterable = this._createIterable(s => [\n\t\t\t\ts.missingExistence,\n\t\t\t\ts.managedMissing\n\t\t\t]);\n\t\t}\n\t\treturn this._cachedMissingIterable;\n\t}\n}\n\nmakeSerializable(Snapshot, \"webpack/lib/FileSystemInfo\", \"Snapshot\");\n\nconst MIN_COMMON_SNAPSHOT_SIZE = 3;\n\n/**\n * @template T\n */\nclass SnapshotOptimization {\n\t/**\n\t * @param {function(Snapshot): boolean} has has value\n\t * @param {function(Snapshot): Map<string, T> | Set<string>} get get value\n\t * @param {function(Snapshot, Map<string, T> | Set<string>): void} set set value\n\t * @param {boolean=} useStartTime use the start time of snapshots\n\t * @param {boolean=} isSet value is an Set instead of a Map\n\t */\n\tconstructor(has, get, set, useStartTime = true, isSet = false) {\n\t\tthis._has = has;\n\t\tthis._get = get;\n\t\tthis._set = set;\n\t\tthis._useStartTime = useStartTime;\n\t\tthis._isSet = isSet;\n\t\t/** @type {Map<string, SnapshotOptimizationEntry>} */\n\t\tthis._map = new Map();\n\t\tthis._statItemsShared = 0;\n\t\tthis._statItemsUnshared = 0;\n\t\tthis._statSharedSnapshots = 0;\n\t\tthis._statReusedSharedSnapshots = 0;\n\t}\n\n\tgetStatisticMessage() {\n\t\tconst total = this._statItemsShared + this._statItemsUnshared;\n\t\tif (total === 0) return undefined;\n\t\treturn `${\n\t\t\tthis._statItemsShared && Math.round((this._statItemsShared * 100) / total)\n\t\t}% (${this._statItemsShared}/${total}) entries shared via ${\n\t\t\tthis._statSharedSnapshots\n\t\t} shared snapshots (${\n\t\t\tthis._statReusedSharedSnapshots + this._statSharedSnapshots\n\t\t} times referenced)`;\n\t}\n\n\tclear() {\n\t\tthis._map.clear();\n\t\tthis._statItemsShared = 0;\n\t\tthis._statItemsUnshared = 0;\n\t\tthis._statSharedSnapshots = 0;\n\t\tthis._statReusedSharedSnapshots = 0;\n\t}\n\n\t/**\n\t * @param {Snapshot} newSnapshot snapshot\n\t * @param {Set<string>} capturedFiles files to snapshot/share\n\t * @returns {void}\n\t */\n\toptimize(newSnapshot, capturedFiles) {\n\t\t/**\n\t\t * @param {SnapshotOptimizationEntry} entry optimization entry\n\t\t * @returns {void}\n\t\t */\n\t\tconst increaseSharedAndStoreOptimizationEntry = entry => {\n\t\t\tif (entry.children !== undefined) {\n\t\t\t\tentry.children.forEach(increaseSharedAndStoreOptimizationEntry);\n\t\t\t}\n\t\t\tentry.shared++;\n\t\t\tstoreOptimizationEntry(entry);\n\t\t};\n\t\t/**\n\t\t * @param {SnapshotOptimizationEntry} entry optimization entry\n\t\t * @returns {void}\n\t\t */\n\t\tconst storeOptimizationEntry = entry => {\n\t\t\tfor (const path of entry.snapshotContent) {\n\t\t\t\tconst old = this._map.get(path);\n\t\t\t\tif (old.shared < entry.shared) {\n\t\t\t\t\tthis._map.set(path, entry);\n\t\t\t\t}\n\t\t\t\tcapturedFiles.delete(path);\n\t\t\t}\n\t\t};\n\n\t\t/** @type {SnapshotOptimizationEntry} */\n\t\tlet newOptimizationEntry = undefined;\n\n\t\tconst capturedFilesSize = capturedFiles.size;\n\n\t\t/** @type {Set<SnapshotOptimizationEntry> | undefined} */\n\t\tconst optimizationEntries = new Set();\n\n\t\tfor (const path of capturedFiles) {\n\t\t\tconst optimizationEntry = this._map.get(path);\n\t\t\tif (optimizationEntry === undefined) {\n\t\t\t\tif (newOptimizationEntry === undefined) {\n\t\t\t\t\tnewOptimizationEntry = {\n\t\t\t\t\t\tsnapshot: newSnapshot,\n\t\t\t\t\t\tshared: 0,\n\t\t\t\t\t\tsnapshotContent: undefined,\n\t\t\t\t\t\tchildren: undefined\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tthis._map.set(path, newOptimizationEntry);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\toptimizationEntries.add(optimizationEntry);\n\t\t\t}\n\t\t}\n\n\t\toptimizationEntries: for (const optimizationEntry of optimizationEntries) {\n\t\t\tconst snapshot = optimizationEntry.snapshot;\n\t\t\tif (optimizationEntry.shared > 0) {\n\t\t\t\t// It's a shared snapshot\n\t\t\t\t// We can't change it, so we can only use it when all files match\n\t\t\t\t// and startTime is compatible\n\t\t\t\tif (\n\t\t\t\t\tthis._useStartTime &&\n\t\t\t\t\tnewSnapshot.startTime &&\n\t\t\t\t\t(!snapshot.startTime || snapshot.startTime > newSnapshot.startTime)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst nonSharedFiles = new Set();\n\t\t\t\tconst snapshotContent = optimizationEntry.snapshotContent;\n\t\t\t\tconst snapshotEntries = this._get(snapshot);\n\t\t\t\tfor (const path of snapshotContent) {\n\t\t\t\t\tif (!capturedFiles.has(path)) {\n\t\t\t\t\t\tif (!snapshotEntries.has(path)) {\n\t\t\t\t\t\t\t// File is not shared and can't be removed from the snapshot\n\t\t\t\t\t\t\t// because it's in a child of the snapshot\n\t\t\t\t\t\t\tcontinue optimizationEntries;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnonSharedFiles.add(path);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nonSharedFiles.size === 0) {\n\t\t\t\t\t// The complete snapshot is shared\n\t\t\t\t\t// add it as child\n\t\t\t\t\tnewSnapshot.addChild(snapshot);\n\t\t\t\t\tincreaseSharedAndStoreOptimizationEntry(optimizationEntry);\n\t\t\t\t\tthis._statReusedSharedSnapshots++;\n\t\t\t\t} else {\n\t\t\t\t\t// Only a part of the snapshot is shared\n\t\t\t\t\tconst sharedCount = snapshotContent.size - nonSharedFiles.size;\n\t\t\t\t\tif (sharedCount < MIN_COMMON_SNAPSHOT_SIZE) {\n\t\t\t\t\t\t// Common part it too small\n\t\t\t\t\t\tcontinue optimizationEntries;\n\t\t\t\t\t}\n\t\t\t\t\t// Extract common timestamps from both snapshots\n\t\t\t\t\tlet commonMap;\n\t\t\t\t\tif (this._isSet) {\n\t\t\t\t\t\tcommonMap = new Set();\n\t\t\t\t\t\tfor (const path of /** @type {Set<string>} */ (snapshotEntries)) {\n\t\t\t\t\t\t\tif (nonSharedFiles.has(path)) continue;\n\t\t\t\t\t\t\tcommonMap.add(path);\n\t\t\t\t\t\t\tsnapshotEntries.delete(path);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommonMap = new Map();\n\t\t\t\t\t\tconst map = /** @type {Map<string, T>} */ (snapshotEntries);\n\t\t\t\t\t\tfor (const [path, value] of map) {\n\t\t\t\t\t\t\tif (nonSharedFiles.has(path)) continue;\n\t\t\t\t\t\t\tcommonMap.set(path, value);\n\t\t\t\t\t\t\tsnapshotEntries.delete(path);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Create and attach snapshot\n\t\t\t\t\tconst commonSnapshot = new Snapshot();\n\t\t\t\t\tif (this._useStartTime) {\n\t\t\t\t\t\tcommonSnapshot.setMergedStartTime(newSnapshot.startTime, snapshot);\n\t\t\t\t\t}\n\t\t\t\t\tthis._set(commonSnapshot, commonMap);\n\t\t\t\t\tnewSnapshot.addChild(commonSnapshot);\n\t\t\t\t\tsnapshot.addChild(commonSnapshot);\n\t\t\t\t\t// Create optimization entry\n\t\t\t\t\tconst newEntry = {\n\t\t\t\t\t\tsnapshot: commonSnapshot,\n\t\t\t\t\t\tshared: optimizationEntry.shared + 1,\n\t\t\t\t\t\tsnapshotContent: new Set(commonMap.keys()),\n\t\t\t\t\t\tchildren: undefined\n\t\t\t\t\t};\n\t\t\t\t\tif (optimizationEntry.children === undefined)\n\t\t\t\t\t\toptimizationEntry.children = new Set();\n\t\t\t\t\toptimizationEntry.children.add(newEntry);\n\t\t\t\t\tstoreOptimizationEntry(newEntry);\n\t\t\t\t\tthis._statSharedSnapshots++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// It's a unshared snapshot\n\t\t\t\t// We can extract a common shared snapshot\n\t\t\t\t// with all common files\n\t\t\t\tconst snapshotEntries = this._get(snapshot);\n\t\t\t\tif (snapshotEntries === undefined) {\n\t\t\t\t\t// Incomplete snapshot, that can't be used\n\t\t\t\t\tcontinue optimizationEntries;\n\t\t\t\t}\n\t\t\t\tlet commonMap;\n\t\t\t\tif (this._isSet) {\n\t\t\t\t\tcommonMap = new Set();\n\t\t\t\t\tconst set = /** @type {Set<string>} */ (snapshotEntries);\n\t\t\t\t\tif (capturedFiles.size < set.size) {\n\t\t\t\t\t\tfor (const path of capturedFiles) {\n\t\t\t\t\t\t\tif (set.has(path)) commonMap.add(path);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const path of set) {\n\t\t\t\t\t\t\tif (capturedFiles.has(path)) commonMap.add(path);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcommonMap = new Map();\n\t\t\t\t\tconst map = /** @type {Map<string, T>} */ (snapshotEntries);\n\t\t\t\t\tfor (const path of capturedFiles) {\n\t\t\t\t\t\tconst ts = map.get(path);\n\t\t\t\t\t\tif (ts === undefined) continue;\n\t\t\t\t\t\tcommonMap.set(path, ts);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (commonMap.size < MIN_COMMON_SNAPSHOT_SIZE) {\n\t\t\t\t\t// Common part it too small\n\t\t\t\t\tcontinue optimizationEntries;\n\t\t\t\t}\n\t\t\t\t// Create and attach snapshot\n\t\t\t\tconst commonSnapshot = new Snapshot();\n\t\t\t\tif (this._useStartTime) {\n\t\t\t\t\tcommonSnapshot.setMergedStartTime(newSnapshot.startTime, snapshot);\n\t\t\t\t}\n\t\t\t\tthis._set(commonSnapshot, commonMap);\n\t\t\t\tnewSnapshot.addChild(commonSnapshot);\n\t\t\t\tsnapshot.addChild(commonSnapshot);\n\t\t\t\t// Remove files from snapshot\n\t\t\t\tfor (const path of commonMap.keys()) snapshotEntries.delete(path);\n\t\t\t\tconst sharedCount = commonMap.size;\n\t\t\t\tthis._statItemsUnshared -= sharedCount;\n\t\t\t\tthis._statItemsShared += sharedCount;\n\t\t\t\t// Create optimization entry\n\t\t\t\tstoreOptimizationEntry({\n\t\t\t\t\tsnapshot: commonSnapshot,\n\t\t\t\t\tshared: 2,\n\t\t\t\t\tsnapshotContent: new Set(commonMap.keys()),\n\t\t\t\t\tchildren: undefined\n\t\t\t\t});\n\t\t\t\tthis._statSharedSnapshots++;\n\t\t\t}\n\t\t}\n\t\tconst unshared = capturedFiles.size;\n\t\tthis._statItemsUnshared += unshared;\n\t\tthis._statItemsShared += capturedFilesSize - unshared;\n\t}\n}\n\nconst parseString = str => {\n\tif (str[0] === \"'\") str = `\"${str.slice(1, -1).replace(/\"/g, '\\\\\"')}\"`;\n\treturn JSON.parse(str);\n};\n\n/* istanbul ignore next */\n/**\n * @param {number} mtime mtime\n */\nconst applyMtime = mtime => {\n\tif (FS_ACCURACY > 1 && mtime % 2 !== 0) FS_ACCURACY = 1;\n\telse if (FS_ACCURACY > 10 && mtime % 20 !== 0) FS_ACCURACY = 10;\n\telse if (FS_ACCURACY > 100 && mtime % 200 !== 0) FS_ACCURACY = 100;\n\telse if (FS_ACCURACY > 1000 && mtime % 2000 !== 0) FS_ACCURACY = 1000;\n};\n\n/**\n * @template T\n * @template K\n * @param {Map<T, K>} a source map\n * @param {Map<T, K>} b joining map\n * @returns {Map<T, K>} joined map\n */\nconst mergeMaps = (a, b) => {\n\tif (!b || b.size === 0) return a;\n\tif (!a || a.size === 0) return b;\n\tconst map = new Map(a);\n\tfor (const [key, value] of b) {\n\t\tmap.set(key, value);\n\t}\n\treturn map;\n};\n\n/**\n * @template T\n * @template K\n * @param {Set<T, K>} a source map\n * @param {Set<T, K>} b joining map\n * @returns {Set<T, K>} joined map\n */\nconst mergeSets = (a, b) => {\n\tif (!b || b.size === 0) return a;\n\tif (!a || a.size === 0) return b;\n\tconst map = new Set(a);\n\tfor (const item of b) {\n\t\tmap.add(item);\n\t}\n\treturn map;\n};\n\n/**\n * Finding file or directory to manage\n * @param {string} managedPath path that is managing by {@link FileSystemInfo}\n * @param {string} path path to file or directory\n * @returns {string|null} managed item\n * @example\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/package/index.js'\n * ) === '/Users/user/my-project/node_modules/package'\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/package1/node_modules/package2'\n * ) === '/Users/user/my-project/node_modules/package1/node_modules/package2'\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/.bin/script.js'\n * ) === null // hidden files are disallowed as managed items\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/package'\n * ) === '/Users/user/my-project/node_modules/package'\n */\nconst getManagedItem = (managedPath, path) => {\n\tlet i = managedPath.length;\n\tlet slashes = 1;\n\tlet startingPosition = true;\n\tloop: while (i < path.length) {\n\t\tswitch (path.charCodeAt(i)) {\n\t\t\tcase 47: // slash\n\t\t\tcase 92: // backslash\n\t\t\t\tif (--slashes === 0) break loop;\n\t\t\t\tstartingPosition = true;\n\t\t\t\tbreak;\n\t\t\tcase 46: // .\n\t\t\t\t// hidden files are disallowed as managed items\n\t\t\t\t// it's probably .yarn-integrity or .cache\n\t\t\t\tif (startingPosition) return null;\n\t\t\t\tbreak;\n\t\t\tcase 64: // @\n\t\t\t\tif (!startingPosition) return null;\n\t\t\t\tslashes++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstartingPosition = false;\n\t\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (i === path.length) slashes--;\n\t// return null when path is incomplete\n\tif (slashes !== 0) return null;\n\t// if (path.slice(i + 1, i + 13) === \"node_modules\")\n\tif (\n\t\tpath.length >= i + 13 &&\n\t\tpath.charCodeAt(i + 1) === 110 &&\n\t\tpath.charCodeAt(i + 2) === 111 &&\n\t\tpath.charCodeAt(i + 3) === 100 &&\n\t\tpath.charCodeAt(i + 4) === 101 &&\n\t\tpath.charCodeAt(i + 5) === 95 &&\n\t\tpath.charCodeAt(i + 6) === 109 &&\n\t\tpath.charCodeAt(i + 7) === 111 &&\n\t\tpath.charCodeAt(i + 8) === 100 &&\n\t\tpath.charCodeAt(i + 9) === 117 &&\n\t\tpath.charCodeAt(i + 10) === 108 &&\n\t\tpath.charCodeAt(i + 11) === 101 &&\n\t\tpath.charCodeAt(i + 12) === 115\n\t) {\n\t\t// if this is the end of the path\n\t\tif (path.length === i + 13) {\n\t\t\t// return the node_modules directory\n\t\t\t// it's special\n\t\t\treturn path;\n\t\t}\n\t\tconst c = path.charCodeAt(i + 13);\n\t\t// if next symbol is slash or backslash\n\t\tif (c === 47 || c === 92) {\n\t\t\t// Managed subpath\n\t\t\treturn getManagedItem(path.slice(0, i + 14), path);\n\t\t}\n\t}\n\treturn path.slice(0, i);\n};\n\n/**\n * @template {ContextFileSystemInfoEntry | ContextTimestampAndHash} T\n * @param {T} entry entry\n * @returns {T[\"resolved\"] | undefined} the resolved entry\n */\nconst getResolvedTimestamp = entry => {\n\tif (entry === null) return null;\n\tif (entry.resolved !== undefined) return entry.resolved;\n\treturn entry.symlinks === undefined ? entry : undefined;\n};\n\n/**\n * @param {ContextHash} entry entry\n * @returns {string | undefined} the resolved entry\n */\nconst getResolvedHash = entry => {\n\tif (entry === null) return null;\n\tif (entry.resolved !== undefined) return entry.resolved;\n\treturn entry.symlinks === undefined ? entry.hash : undefined;\n};\n\nconst addAll = (source, target) => {\n\tfor (const key of source) target.add(key);\n};\n\n/**\n * Used to access information about the filesystem in a cached way\n */\nclass FileSystemInfo {\n\t/**\n\t * @param {InputFileSystem} fs file system\n\t * @param {Object} options options\n\t * @param {Iterable<string | RegExp>=} options.managedPaths paths that are only managed by a package manager\n\t * @param {Iterable<string | RegExp>=} options.immutablePaths paths that are immutable\n\t * @param {Logger=} options.logger logger used to log invalid snapshots\n\t * @param {string | Hash=} options.hashFunction the hash function to use\n\t */\n\tconstructor(\n\t\tfs,\n\t\t{\n\t\t\tmanagedPaths = [],\n\t\t\timmutablePaths = [],\n\t\t\tlogger,\n\t\t\thashFunction = \"md4\"\n\t\t} = {}\n\t) {\n\t\tthis.fs = fs;\n\t\tthis.logger = logger;\n\t\tthis._remainingLogs = logger ? 40 : 0;\n\t\tthis._loggedPaths = logger ? new Set() : undefined;\n\t\tthis._hashFunction = hashFunction;\n\t\t/** @type {WeakMap<Snapshot, boolean | (function(WebpackError=, boolean=): void)[]>} */\n\t\tthis._snapshotCache = new WeakMap();\n\t\tthis._fileTimestampsOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasFileTimestamps(),\n\t\t\ts => s.fileTimestamps,\n\t\t\t(s, v) => s.setFileTimestamps(v)\n\t\t);\n\t\tthis._fileHashesOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasFileHashes(),\n\t\t\ts => s.fileHashes,\n\t\t\t(s, v) => s.setFileHashes(v),\n\t\t\tfalse\n\t\t);\n\t\tthis._fileTshsOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasFileTshs(),\n\t\t\ts => s.fileTshs,\n\t\t\t(s, v) => s.setFileTshs(v)\n\t\t);\n\t\tthis._contextTimestampsOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasContextTimestamps(),\n\t\t\ts => s.contextTimestamps,\n\t\t\t(s, v) => s.setContextTimestamps(v)\n\t\t);\n\t\tthis._contextHashesOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasContextHashes(),\n\t\t\ts => s.contextHashes,\n\t\t\t(s, v) => s.setContextHashes(v),\n\t\t\tfalse\n\t\t);\n\t\tthis._contextTshsOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasContextTshs(),\n\t\t\ts => s.contextTshs,\n\t\t\t(s, v) => s.setContextTshs(v)\n\t\t);\n\t\tthis._missingExistenceOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasMissingExistence(),\n\t\t\ts => s.missingExistence,\n\t\t\t(s, v) => s.setMissingExistence(v),\n\t\t\tfalse\n\t\t);\n\t\tthis._managedItemInfoOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasManagedItemInfo(),\n\t\t\ts => s.managedItemInfo,\n\t\t\t(s, v) => s.setManagedItemInfo(v),\n\t\t\tfalse\n\t\t);\n\t\tthis._managedFilesOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasManagedFiles(),\n\t\t\ts => s.managedFiles,\n\t\t\t(s, v) => s.setManagedFiles(v),\n\t\t\tfalse,\n\t\t\ttrue\n\t\t);\n\t\tthis._managedContextsOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasManagedContexts(),\n\t\t\ts => s.managedContexts,\n\t\t\t(s, v) => s.setManagedContexts(v),\n\t\t\tfalse,\n\t\t\ttrue\n\t\t);\n\t\tthis._managedMissingOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasManagedMissing(),\n\t\t\ts => s.managedMissing,\n\t\t\t(s, v) => s.setManagedMissing(v),\n\t\t\tfalse,\n\t\t\ttrue\n\t\t);\n\t\t/** @type {StackedCacheMap<string, FileSystemInfoEntry | \"ignore\" | null>} */\n\t\tthis._fileTimestamps = new StackedCacheMap();\n\t\t/** @type {Map<string, string>} */\n\t\tthis._fileHashes = new Map();\n\t\t/** @type {Map<string, TimestampAndHash | string>} */\n\t\tthis._fileTshs = new Map();\n\t\t/** @type {StackedCacheMap<string, ContextFileSystemInfoEntry | \"ignore\" | null>} */\n\t\tthis._contextTimestamps = new StackedCacheMap();\n\t\t/** @type {Map<string, ContextHash>} */\n\t\tthis._contextHashes = new Map();\n\t\t/** @type {Map<string, ContextTimestampAndHash>} */\n\t\tthis._contextTshs = new Map();\n\t\t/** @type {Map<string, string>} */\n\t\tthis._managedItems = new Map();\n\t\t/** @type {AsyncQueue<string, string, FileSystemInfoEntry | null>} */\n\t\tthis.fileTimestampQueue = new AsyncQueue({\n\t\t\tname: \"file timestamp\",\n\t\t\tparallelism: 30,\n\t\t\tprocessor: this._readFileTimestamp.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<string, string, string | null>} */\n\t\tthis.fileHashQueue = new AsyncQueue({\n\t\t\tname: \"file hash\",\n\t\t\tparallelism: 10,\n\t\t\tprocessor: this._readFileHash.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<string, string, ContextFileSystemInfoEntry | null>} */\n\t\tthis.contextTimestampQueue = new AsyncQueue({\n\t\t\tname: \"context timestamp\",\n\t\t\tparallelism: 2,\n\t\t\tprocessor: this._readContextTimestamp.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<string, string, ContextHash | null>} */\n\t\tthis.contextHashQueue = new AsyncQueue({\n\t\t\tname: \"context hash\",\n\t\t\tparallelism: 2,\n\t\t\tprocessor: this._readContextHash.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<string, string, ContextTimestampAndHash | null>} */\n\t\tthis.contextTshQueue = new AsyncQueue({\n\t\t\tname: \"context hash and timestamp\",\n\t\t\tparallelism: 2,\n\t\t\tprocessor: this._readContextTimestampAndHash.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<string, string, string | null>} */\n\t\tthis.managedItemQueue = new AsyncQueue({\n\t\t\tname: \"managed item info\",\n\t\t\tparallelism: 10,\n\t\t\tprocessor: this._getManagedItemInfo.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<string, string, Set<string>>} */\n\t\tthis.managedItemDirectoryQueue = new AsyncQueue({\n\t\t\tname: \"managed item directory info\",\n\t\t\tparallelism: 10,\n\t\t\tprocessor: this._getManagedItemDirectoryInfo.bind(this)\n\t\t});\n\t\tthis.managedPaths = Array.from(managedPaths);\n\t\tthis.managedPathsWithSlash = /** @type {string[]} */ (\n\t\t\tthis.managedPaths.filter(p => typeof p === \"string\")\n\t\t).map(p => join(fs, p, \"_\").slice(0, -1));\n\n\t\tthis.managedPathsRegExps = /** @type {RegExp[]} */ (\n\t\t\tthis.managedPaths.filter(p => typeof p !== \"string\")\n\t\t);\n\t\tthis.immutablePaths = Array.from(immutablePaths);\n\t\tthis.immutablePathsWithSlash = /** @type {string[]} */ (\n\t\t\tthis.immutablePaths.filter(p => typeof p === \"string\")\n\t\t).map(p => join(fs, p, \"_\").slice(0, -1));\n\t\tthis.immutablePathsRegExps = /** @type {RegExp[]} */ (\n\t\t\tthis.immutablePaths.filter(p => typeof p !== \"string\")\n\t\t);\n\n\t\tthis._cachedDeprecatedFileTimestamps = undefined;\n\t\tthis._cachedDeprecatedContextTimestamps = undefined;\n\n\t\tthis._warnAboutExperimentalEsmTracking = false;\n\n\t\tthis._statCreatedSnapshots = 0;\n\t\tthis._statTestedSnapshotsCached = 0;\n\t\tthis._statTestedSnapshotsNotCached = 0;\n\t\tthis._statTestedChildrenCached = 0;\n\t\tthis._statTestedChildrenNotCached = 0;\n\t\tthis._statTestedEntries = 0;\n\t}\n\n\tlogStatistics() {\n\t\tconst logWhenMessage = (header, message) => {\n\t\t\tif (message) {\n\t\t\t\tthis.logger.log(`${header}: ${message}`);\n\t\t\t}\n\t\t};\n\t\tthis.logger.log(`${this._statCreatedSnapshots} new snapshots created`);\n\t\tthis.logger.log(\n\t\t\t`${\n\t\t\t\tthis._statTestedSnapshotsNotCached &&\n\t\t\t\tMath.round(\n\t\t\t\t\t(this._statTestedSnapshotsNotCached * 100) /\n\t\t\t\t\t\t(this._statTestedSnapshotsCached +\n\t\t\t\t\t\t\tthis._statTestedSnapshotsNotCached)\n\t\t\t\t)\n\t\t\t}% root snapshot uncached (${this._statTestedSnapshotsNotCached} / ${\n\t\t\t\tthis._statTestedSnapshotsCached + this._statTestedSnapshotsNotCached\n\t\t\t})`\n\t\t);\n\t\tthis.logger.log(\n\t\t\t`${\n\t\t\t\tthis._statTestedChildrenNotCached &&\n\t\t\t\tMath.round(\n\t\t\t\t\t(this._statTestedChildrenNotCached * 100) /\n\t\t\t\t\t\t(this._statTestedChildrenCached + this._statTestedChildrenNotCached)\n\t\t\t\t)\n\t\t\t}% children snapshot uncached (${this._statTestedChildrenNotCached} / ${\n\t\t\t\tthis._statTestedChildrenCached + this._statTestedChildrenNotCached\n\t\t\t})`\n\t\t);\n\t\tthis.logger.log(`${this._statTestedEntries} entries tested`);\n\t\tthis.logger.log(\n\t\t\t`File info in cache: ${this._fileTimestamps.size} timestamps ${this._fileHashes.size} hashes ${this._fileTshs.size} timestamp hash combinations`\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`File timestamp snapshot optimization`,\n\t\t\tthis._fileTimestampsOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`File hash snapshot optimization`,\n\t\t\tthis._fileHashesOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`File timestamp hash combination snapshot optimization`,\n\t\t\tthis._fileTshsOptimization.getStatisticMessage()\n\t\t);\n\t\tthis.logger.log(\n\t\t\t`Directory info in cache: ${this._contextTimestamps.size} timestamps ${this._contextHashes.size} hashes ${this._contextTshs.size} timestamp hash combinations`\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`Directory timestamp snapshot optimization`,\n\t\t\tthis._contextTimestampsOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`Directory hash snapshot optimization`,\n\t\t\tthis._contextHashesOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`Directory timestamp hash combination snapshot optimization`,\n\t\t\tthis._contextTshsOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`Missing items snapshot optimization`,\n\t\t\tthis._missingExistenceOptimization.getStatisticMessage()\n\t\t);\n\t\tthis.logger.log(\n\t\t\t`Managed items info in cache: ${this._managedItems.size} items`\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`Managed items snapshot optimization`,\n\t\t\tthis._managedItemInfoOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`Managed files snapshot optimization`,\n\t\t\tthis._managedFilesOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`Managed contexts snapshot optimization`,\n\t\t\tthis._managedContextsOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t`Managed missing snapshot optimization`,\n\t\t\tthis._managedMissingOptimization.getStatisticMessage()\n\t\t);\n\t}\n\n\t_log(path, reason, ...args) {\n\t\tconst key = path + reason;\n\t\tif (this._loggedPaths.has(key)) return;\n\t\tthis._loggedPaths.add(key);\n\t\tthis.logger.debug(`${path} invalidated because ${reason}`, ...args);\n\t\tif (--this._remainingLogs === 0) {\n\t\t\tthis.logger.debug(\n\t\t\t\t\"Logging limit has been reached and no further logging will be emitted by FileSystemInfo\"\n\t\t\t);\n\t\t}\n\t}\n\n\tclear() {\n\t\tthis._remainingLogs = this.logger ? 40 : 0;\n\t\tif (this._loggedPaths !== undefined) this._loggedPaths.clear();\n\n\t\tthis._snapshotCache = new WeakMap();\n\t\tthis._fileTimestampsOptimization.clear();\n\t\tthis._fileHashesOptimization.clear();\n\t\tthis._fileTshsOptimization.clear();\n\t\tthis._contextTimestampsOptimization.clear();\n\t\tthis._contextHashesOptimization.clear();\n\t\tthis._contextTshsOptimization.clear();\n\t\tthis._missingExistenceOptimization.clear();\n\t\tthis._managedItemInfoOptimization.clear();\n\t\tthis._managedFilesOptimization.clear();\n\t\tthis._managedContextsOptimization.clear();\n\t\tthis._managedMissingOptimization.clear();\n\t\tthis._fileTimestamps.clear();\n\t\tthis._fileHashes.clear();\n\t\tthis._fileTshs.clear();\n\t\tthis._contextTimestamps.clear();\n\t\tthis._contextHashes.clear();\n\t\tthis._contextTshs.clear();\n\t\tthis._managedItems.clear();\n\t\tthis._managedItems.clear();\n\n\t\tthis._cachedDeprecatedFileTimestamps = undefined;\n\t\tthis._cachedDeprecatedContextTimestamps = undefined;\n\n\t\tthis._statCreatedSnapshots = 0;\n\t\tthis._statTestedSnapshotsCached = 0;\n\t\tthis._statTestedSnapshotsNotCached = 0;\n\t\tthis._statTestedChildrenCached = 0;\n\t\tthis._statTestedChildrenNotCached = 0;\n\t\tthis._statTestedEntries = 0;\n\t}\n\n\t/**\n\t * @param {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} map timestamps\n\t * @param {boolean=} immutable if 'map' is immutable and FileSystemInfo can keep referencing it\n\t * @returns {void}\n\t */\n\taddFileTimestamps(map, immutable) {\n\t\tthis._fileTimestamps.addAll(map, immutable);\n\t\tthis._cachedDeprecatedFileTimestamps = undefined;\n\t}\n\n\t/**\n\t * @param {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} map timestamps\n\t * @param {boolean=} immutable if 'map' is immutable and FileSystemInfo can keep referencing it\n\t * @returns {void}\n\t */\n\taddContextTimestamps(map, immutable) {\n\t\tthis._contextTimestamps.addAll(map, immutable);\n\t\tthis._cachedDeprecatedContextTimestamps = undefined;\n\t}\n\n\t/**\n\t * @param {string} path file path\n\t * @param {function((WebpackError | null)=, (FileSystemInfoEntry | \"ignore\" | null)=): void} callback callback function\n\t * @returns {void}\n\t */\n\tgetFileTimestamp(path, callback) {\n\t\tconst cache = this._fileTimestamps.get(path);\n\t\tif (cache !== undefined) return callback(null, cache);\n\t\tthis.fileTimestampQueue.add(path, callback);\n\t}\n\n\t/**\n\t * @param {string} path context path\n\t * @param {function((WebpackError | null)=, (ResolvedContextFileSystemInfoEntry | \"ignore\" | null)=): void} callback callback function\n\t * @returns {void}\n\t */\n\tgetContextTimestamp(path, callback) {\n\t\tconst cache = this._contextTimestamps.get(path);\n\t\tif (cache !== undefined) {\n\t\t\tif (cache === \"ignore\") return callback(null, \"ignore\");\n\t\t\tconst resolved = getResolvedTimestamp(cache);\n\t\t\tif (resolved !== undefined) return callback(null, resolved);\n\t\t\treturn this._resolveContextTimestamp(cache, callback);\n\t\t}\n\t\tthis.contextTimestampQueue.add(path, (err, entry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tconst resolved = getResolvedTimestamp(entry);\n\t\t\tif (resolved !== undefined) return callback(null, resolved);\n\t\t\tthis._resolveContextTimestamp(entry, callback);\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} path context path\n\t * @param {function((WebpackError | null)=, (ContextFileSystemInfoEntry | \"ignore\" | null)=): void} callback callback function\n\t * @returns {void}\n\t */\n\t_getUnresolvedContextTimestamp(path, callback) {\n\t\tconst cache = this._contextTimestamps.get(path);\n\t\tif (cache !== undefined) return callback(null, cache);\n\t\tthis.contextTimestampQueue.add(path, callback);\n\t}\n\n\t/**\n\t * @param {string} path file path\n\t * @param {function((WebpackError | null)=, string=): void} callback callback function\n\t * @returns {void}\n\t */\n\tgetFileHash(path, callback) {\n\t\tconst cache = this._fileHashes.get(path);\n\t\tif (cache !== undefined) return callback(null, cache);\n\t\tthis.fileHashQueue.add(path, callback);\n\t}\n\n\t/**\n\t * @param {string} path context path\n\t * @param {function((WebpackError | null)=, string=): void} callback callback function\n\t * @returns {void}\n\t */\n\tgetContextHash(path, callback) {\n\t\tconst cache = this._contextHashes.get(path);\n\t\tif (cache !== undefined) {\n\t\t\tconst resolved = getResolvedHash(cache);\n\t\t\tif (resolved !== undefined) return callback(null, resolved);\n\t\t\treturn this._resolveContextHash(cache, callback);\n\t\t}\n\t\tthis.contextHashQueue.add(path, (err, entry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tconst resolved = getResolvedHash(entry);\n\t\t\tif (resolved !== undefined) return callback(null, resolved);\n\t\t\tthis._resolveContextHash(entry, callback);\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} path context path\n\t * @param {function((WebpackError | null)=, ContextHash=): void} callback callback function\n\t * @returns {void}\n\t */\n\t_getUnresolvedContextHash(path, callback) {\n\t\tconst cache = this._contextHashes.get(path);\n\t\tif (cache !== undefined) return callback(null, cache);\n\t\tthis.contextHashQueue.add(path, callback);\n\t}\n\n\t/**\n\t * @param {string} path context path\n\t * @param {function((WebpackError | null)=, ResolvedContextTimestampAndHash=): void} callback callback function\n\t * @returns {void}\n\t */\n\tgetContextTsh(path, callback) {\n\t\tconst cache = this._contextTshs.get(path);\n\t\tif (cache !== undefined) {\n\t\t\tconst resolved = getResolvedTimestamp(cache);\n\t\t\tif (resolved !== undefined) return callback(null, resolved);\n\t\t\treturn this._resolveContextTsh(cache, callback);\n\t\t}\n\t\tthis.contextTshQueue.add(path, (err, entry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tconst resolved = getResolvedTimestamp(entry);\n\t\t\tif (resolved !== undefined) return callback(null, resolved);\n\t\t\tthis._resolveContextTsh(entry, callback);\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} path context path\n\t * @param {function((WebpackError | null)=, ContextTimestampAndHash=): void} callback callback function\n\t * @returns {void}\n\t */\n\t_getUnresolvedContextTsh(path, callback) {\n\t\tconst cache = this._contextTshs.get(path);\n\t\tif (cache !== undefined) return callback(null, cache);\n\t\tthis.contextTshQueue.add(path, callback);\n\t}\n\n\t_createBuildDependenciesResolvers() {\n\t\tconst resolveContext = createResolver({\n\t\t\tresolveToContext: true,\n\t\t\texportsFields: [],\n\t\t\tfileSystem: this.fs\n\t\t});\n\t\tconst resolveCjs = createResolver({\n\t\t\textensions: [\".js\", \".json\", \".node\"],\n\t\t\tconditionNames: [\"require\", \"node\"],\n\t\t\texportsFields: [\"exports\"],\n\t\t\tfileSystem: this.fs\n\t\t});\n\t\tconst resolveCjsAsChild = createResolver({\n\t\t\textensions: [\".js\", \".json\", \".node\"],\n\t\t\tconditionNames: [\"require\", \"node\"],\n\t\t\texportsFields: [],\n\t\t\tfileSystem: this.fs\n\t\t});\n\t\tconst resolveEsm = createResolver({\n\t\t\textensions: [\".js\", \".json\", \".node\"],\n\t\t\tfullySpecified: true,\n\t\t\tconditionNames: [\"import\", \"node\"],\n\t\t\texportsFields: [\"exports\"],\n\t\t\tfileSystem: this.fs\n\t\t});\n\t\treturn { resolveContext, resolveEsm, resolveCjs, resolveCjsAsChild };\n\t}\n\n\t/**\n\t * @param {string} context context directory\n\t * @param {Iterable<string>} deps dependencies\n\t * @param {function((Error | null)=, ResolveBuildDependenciesResult=): void} callback callback function\n\t * @returns {void}\n\t */\n\tresolveBuildDependencies(context, deps, callback) {\n\t\tconst { resolveContext, resolveEsm, resolveCjs, resolveCjsAsChild } =\n\t\t\tthis._createBuildDependenciesResolvers();\n\n\t\t/** @type {Set<string>} */\n\t\tconst files = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst fileSymlinks = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst directories = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst directorySymlinks = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst missing = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst resolveFiles = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst resolveDirectories = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst resolveMissing = new Set();\n\t\t/** @type {Map<string, string | false>} */\n\t\tconst resolveResults = new Map();\n\t\tconst invalidResolveResults = new Set();\n\t\tconst resolverContext = {\n\t\t\tfileDependencies: resolveFiles,\n\t\t\tcontextDependencies: resolveDirectories,\n\t\t\tmissingDependencies: resolveMissing\n\t\t};\n\t\tconst expectedToString = expected => {\n\t\t\treturn expected ? ` (expected ${expected})` : \"\";\n\t\t};\n\t\tconst jobToString = job => {\n\t\t\tswitch (job.type) {\n\t\t\t\tcase RBDT_RESOLVE_CJS:\n\t\t\t\t\treturn `resolve commonjs ${job.path}${expectedToString(\n\t\t\t\t\t\tjob.expected\n\t\t\t\t\t)}`;\n\t\t\t\tcase RBDT_RESOLVE_ESM:\n\t\t\t\t\treturn `resolve esm ${job.path}${expectedToString(job.expected)}`;\n\t\t\t\tcase RBDT_RESOLVE_DIRECTORY:\n\t\t\t\t\treturn `resolve directory ${job.path}`;\n\t\t\t\tcase RBDT_RESOLVE_CJS_FILE:\n\t\t\t\t\treturn `resolve commonjs file ${job.path}${expectedToString(\n\t\t\t\t\t\tjob.expected\n\t\t\t\t\t)}`;\n\t\t\t\tcase RBDT_RESOLVE_ESM_FILE:\n\t\t\t\t\treturn `resolve esm file ${job.path}${expectedToString(\n\t\t\t\t\t\tjob.expected\n\t\t\t\t\t)}`;\n\t\t\t\tcase RBDT_DIRECTORY:\n\t\t\t\t\treturn `directory ${job.path}`;\n\t\t\t\tcase RBDT_FILE:\n\t\t\t\t\treturn `file ${job.path}`;\n\t\t\t\tcase RBDT_DIRECTORY_DEPENDENCIES:\n\t\t\t\t\treturn `directory dependencies ${job.path}`;\n\t\t\t\tcase RBDT_FILE_DEPENDENCIES:\n\t\t\t\t\treturn `file dependencies ${job.path}`;\n\t\t\t}\n\t\t\treturn `unknown ${job.type} ${job.path}`;\n\t\t};\n\t\tconst pathToString = job => {\n\t\t\tlet result = ` at ${jobToString(job)}`;\n\t\t\tjob = job.issuer;\n\t\t\twhile (job !== undefined) {\n\t\t\t\tresult += `\\n at ${jobToString(job)}`;\n\t\t\t\tjob = job.issuer;\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\tprocessAsyncTree(\n\t\t\tArray.from(deps, dep => ({\n\t\t\t\ttype: RBDT_RESOLVE_CJS,\n\t\t\t\tcontext,\n\t\t\t\tpath: dep,\n\t\t\t\texpected: undefined,\n\t\t\t\tissuer: undefined\n\t\t\t})),\n\t\t\t20,\n\t\t\t(job, push, callback) => {\n\t\t\t\tconst { type, context, path, expected } = job;\n\t\t\t\tconst resolveDirectory = path => {\n\t\t\t\t\tconst key = `d\\n${context}\\n${path}`;\n\t\t\t\t\tif (resolveResults.has(key)) {\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t}\n\t\t\t\t\tresolveResults.set(key, undefined);\n\t\t\t\t\tresolveContext(context, path, resolverContext, (err, _, result) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tif (expected === false) {\n\t\t\t\t\t\t\t\tresolveResults.set(key, false);\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tinvalidResolveResults.add(key);\n\t\t\t\t\t\t\terr.message += `\\nwhile resolving '${path}' in ${context} to a directory`;\n\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst resultPath = result.path;\n\t\t\t\t\t\tresolveResults.set(key, resultPath);\n\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\ttype: RBDT_DIRECTORY,\n\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\tpath: resultPath,\n\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tconst resolveFile = (path, symbol, resolve) => {\n\t\t\t\t\tconst key = `${symbol}\\n${context}\\n${path}`;\n\t\t\t\t\tif (resolveResults.has(key)) {\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t}\n\t\t\t\t\tresolveResults.set(key, undefined);\n\t\t\t\t\tresolve(context, path, resolverContext, (err, _, result) => {\n\t\t\t\t\t\tif (typeof expected === \"string\") {\n\t\t\t\t\t\t\tif (!err && result && result.path === expected) {\n\t\t\t\t\t\t\t\tresolveResults.set(key, result.path);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tinvalidResolveResults.add(key);\n\t\t\t\t\t\t\t\tthis.logger.warn(\n\t\t\t\t\t\t\t\t\t`Resolving '${path}' in ${context} for build dependencies doesn't lead to expected result '${expected}', but to '${\n\t\t\t\t\t\t\t\t\t\terr || (result && result.path)\n\t\t\t\t\t\t\t\t\t}' instead. Resolving dependencies are ignored for this path.\\n${pathToString(\n\t\t\t\t\t\t\t\t\t\tjob\n\t\t\t\t\t\t\t\t\t)}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tif (expected === false) {\n\t\t\t\t\t\t\t\t\tresolveResults.set(key, false);\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tinvalidResolveResults.add(key);\n\t\t\t\t\t\t\t\terr.message += `\\nwhile resolving '${path}' in ${context} as file\\n${pathToString(\n\t\t\t\t\t\t\t\t\tjob\n\t\t\t\t\t\t\t\t)}`;\n\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst resultPath = result.path;\n\t\t\t\t\t\t\tresolveResults.set(key, resultPath);\n\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\ttype: RBDT_FILE,\n\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\tpath: resultPath,\n\t\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase RBDT_RESOLVE_CJS: {\n\t\t\t\t\t\tconst isDirectory = /[\\\\/]$/.test(path);\n\t\t\t\t\t\tif (isDirectory) {\n\t\t\t\t\t\t\tresolveDirectory(path.slice(0, path.length - 1));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolveFile(path, \"f\", resolveCjs);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_RESOLVE_ESM: {\n\t\t\t\t\t\tconst isDirectory = /[\\\\/]$/.test(path);\n\t\t\t\t\t\tif (isDirectory) {\n\t\t\t\t\t\t\tresolveDirectory(path.slice(0, path.length - 1));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolveFile(path);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_RESOLVE_DIRECTORY: {\n\t\t\t\t\t\tresolveDirectory(path);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_RESOLVE_CJS_FILE: {\n\t\t\t\t\t\tresolveFile(path, \"f\", resolveCjs);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_RESOLVE_CJS_FILE_AS_CHILD: {\n\t\t\t\t\t\tresolveFile(path, \"c\", resolveCjsAsChild);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_RESOLVE_ESM_FILE: {\n\t\t\t\t\t\tresolveFile(path, \"e\", resolveEsm);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_FILE: {\n\t\t\t\t\t\tif (files.has(path)) {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfiles.add(path);\n\t\t\t\t\t\tthis.fs.realpath(path, (err, _realPath) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst realPath = /** @type {string} */ (_realPath);\n\t\t\t\t\t\t\tif (realPath !== path) {\n\t\t\t\t\t\t\t\tfileSymlinks.add(path);\n\t\t\t\t\t\t\t\tresolveFiles.add(path);\n\t\t\t\t\t\t\t\tif (files.has(realPath)) return callback();\n\t\t\t\t\t\t\t\tfiles.add(realPath);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\ttype: RBDT_FILE_DEPENDENCIES,\n\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\tpath: realPath,\n\t\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_DIRECTORY: {\n\t\t\t\t\t\tif (directories.has(path)) {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdirectories.add(path);\n\t\t\t\t\t\tthis.fs.realpath(path, (err, _realPath) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst realPath = /** @type {string} */ (_realPath);\n\t\t\t\t\t\t\tif (realPath !== path) {\n\t\t\t\t\t\t\t\tdirectorySymlinks.add(path);\n\t\t\t\t\t\t\t\tresolveFiles.add(path);\n\t\t\t\t\t\t\t\tif (directories.has(realPath)) return callback();\n\t\t\t\t\t\t\t\tdirectories.add(realPath);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\ttype: RBDT_DIRECTORY_DEPENDENCIES,\n\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\tpath: realPath,\n\t\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_FILE_DEPENDENCIES: {\n\t\t\t\t\t\t// Check for known files without dependencies\n\t\t\t\t\t\tif (/\\.json5?$|\\.yarn-integrity$|yarn\\.lock$|\\.ya?ml/.test(path)) {\n\t\t\t\t\t\t\tprocess.nextTick(callback);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Check commonjs cache for the module\n\t\t\t\t\t\t/** @type {NodeModule} */\n\t\t\t\t\t\tconst module = require.cache[path];\n\t\t\t\t\t\tif (module && Array.isArray(module.children)) {\n\t\t\t\t\t\t\tchildren: for (const child of module.children) {\n\t\t\t\t\t\t\t\tlet childPath = child.filename;\n\t\t\t\t\t\t\t\tif (childPath) {\n\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\ttype: RBDT_FILE,\n\t\t\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\t\t\tpath: childPath,\n\t\t\t\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tconst context = dirname(this.fs, path);\n\t\t\t\t\t\t\t\t\tfor (const modulePath of module.paths) {\n\t\t\t\t\t\t\t\t\t\tif (childPath.startsWith(modulePath)) {\n\t\t\t\t\t\t\t\t\t\t\tlet subPath = childPath.slice(modulePath.length + 1);\n\t\t\t\t\t\t\t\t\t\t\tconst packageMatch = /^(@[^\\\\/]+[\\\\/])[^\\\\/]+/.exec(\n\t\t\t\t\t\t\t\t\t\t\t\tsubPath\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tif (packageMatch) {\n\t\t\t\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: RBDT_FILE,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\t\t\t\t\t\tpath:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodulePath +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tchildPath[modulePath.length] +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpackageMatch[0] +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tchildPath[modulePath.length] +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"package.json\",\n\t\t\t\t\t\t\t\t\t\t\t\t\texpected: false,\n\t\t\t\t\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tlet request = subPath.replace(/\\\\/g, \"/\");\n\t\t\t\t\t\t\t\t\t\t\tif (request.endsWith(\".js\"))\n\t\t\t\t\t\t\t\t\t\t\t\trequest = request.slice(0, -3);\n\t\t\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: RBDT_RESOLVE_CJS_FILE_AS_CHILD,\n\t\t\t\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\t\t\t\tpath: request,\n\t\t\t\t\t\t\t\t\t\t\t\texpected: child.filename,\n\t\t\t\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\tcontinue children;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet request = relative(this.fs, context, childPath);\n\t\t\t\t\t\t\t\t\tif (request.endsWith(\".js\")) request = request.slice(0, -3);\n\t\t\t\t\t\t\t\t\trequest = request.replace(/\\\\/g, \"/\");\n\t\t\t\t\t\t\t\t\tif (!request.startsWith(\"../\") && !isAbsolute(request)) {\n\t\t\t\t\t\t\t\t\t\trequest = `./${request}`;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\ttype: RBDT_RESOLVE_CJS_FILE,\n\t\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\t\tpath: request,\n\t\t\t\t\t\t\t\t\t\texpected: child.filename,\n\t\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (supportsEsm && /\\.m?js$/.test(path)) {\n\t\t\t\t\t\t\tif (!this._warnAboutExperimentalEsmTracking) {\n\t\t\t\t\t\t\t\tthis.logger.log(\n\t\t\t\t\t\t\t\t\t\"Node.js doesn't offer a (nice) way to introspect the ESM dependency graph yet.\\n\" +\n\t\t\t\t\t\t\t\t\t\t\"Until a full solution is available webpack uses an experimental ESM tracking based on parsing.\\n\" +\n\t\t\t\t\t\t\t\t\t\t\"As best effort webpack parses the ESM files to guess dependencies. But this can lead to expensive and incorrect tracking.\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tthis._warnAboutExperimentalEsmTracking = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst lexer = require(\"es-module-lexer\");\n\t\t\t\t\t\t\tlexer.init.then(() => {\n\t\t\t\t\t\t\t\tthis.fs.readFile(path, (err, content) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tconst context = dirname(this.fs, path);\n\t\t\t\t\t\t\t\t\t\tconst source = content.toString();\n\t\t\t\t\t\t\t\t\t\tconst [imports] = lexer.parse(source);\n\t\t\t\t\t\t\t\t\t\tfor (const imp of imports) {\n\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\tlet dependency;\n\t\t\t\t\t\t\t\t\t\t\t\tif (imp.d === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// import ... from \"...\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tdependency = parseString(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource.substring(imp.s - 1, imp.e + 1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (imp.d > -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// import()\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet expr = source.substring(imp.s, imp.e).trim();\n\t\t\t\t\t\t\t\t\t\t\t\t\tdependency = parseString(expr);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// e.g. import.meta\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// we should not track Node.js build dependencies\n\t\t\t\t\t\t\t\t\t\t\t\tif (dependency.startsWith(\"node:\")) continue;\n\t\t\t\t\t\t\t\t\t\t\t\tif (builtinModules.has(dependency)) continue;\n\n\t\t\t\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: RBDT_RESOLVE_ESM_FILE,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\t\t\t\t\tpath: dependency,\n\t\t\t\t\t\t\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.warn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t`Parsing of ${path} for build dependencies failed at 'import(${source.substring(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\timp.s,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\timp.e\n\t\t\t\t\t\t\t\t\t\t\t\t\t)})'.\\n` +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"Build dependencies behind this expression are ignored and might cause incorrect cache invalidation.\"\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.debug(pathToString(job));\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.debug(e.stack);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.warn(\n\t\t\t\t\t\t\t\t\t\t\t`Parsing of ${path} for build dependencies failed and all dependencies of this file are ignored, which might cause incorrect cache invalidation..`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(pathToString(job));\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(e.stack);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tprocess.nextTick(callback);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}, callback);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.logger.log(\n\t\t\t\t\t\t\t\t`Assuming ${path} has no dependencies as we were unable to assign it to any module system.`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tthis.logger.debug(pathToString(job));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprocess.nextTick(callback);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_DIRECTORY_DEPENDENCIES: {\n\t\t\t\t\t\tconst match =\n\t\t\t\t\t\t\t/(^.+[\\\\/]node_modules[\\\\/](?:@[^\\\\/]+[\\\\/])?[^\\\\/]+)/.exec(path);\n\t\t\t\t\t\tconst packagePath = match ? match[1] : path;\n\t\t\t\t\t\tconst packageJson = join(this.fs, packagePath, \"package.json\");\n\t\t\t\t\t\tthis.fs.readFile(packageJson, (err, content) => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\t\t\t\t\tresolveMissing.add(packageJson);\n\t\t\t\t\t\t\t\t\tconst parent = dirname(this.fs, packagePath);\n\t\t\t\t\t\t\t\t\tif (parent !== packagePath) {\n\t\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\t\ttype: RBDT_DIRECTORY_DEPENDENCIES,\n\t\t\t\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\t\t\t\tpath: parent,\n\t\t\t\t\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresolveFiles.add(packageJson);\n\t\t\t\t\t\t\tlet packageData;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tpackageData = JSON.parse(content.toString(\"utf-8\"));\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\treturn callback(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst depsObject = packageData.dependencies;\n\t\t\t\t\t\t\tconst optionalDepsObject = packageData.optionalDependencies;\n\t\t\t\t\t\t\tconst allDeps = new Set();\n\t\t\t\t\t\t\tconst optionalDeps = new Set();\n\t\t\t\t\t\t\tif (typeof depsObject === \"object\" && depsObject) {\n\t\t\t\t\t\t\t\tfor (const dep of Object.keys(depsObject)) {\n\t\t\t\t\t\t\t\t\tallDeps.add(dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\ttypeof optionalDepsObject === \"object\" &&\n\t\t\t\t\t\t\t\toptionalDepsObject\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tfor (const dep of Object.keys(optionalDepsObject)) {\n\t\t\t\t\t\t\t\t\tallDeps.add(dep);\n\t\t\t\t\t\t\t\t\toptionalDeps.add(dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const dep of allDeps) {\n\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\ttype: RBDT_RESOLVE_DIRECTORY,\n\t\t\t\t\t\t\t\t\tcontext: packagePath,\n\t\t\t\t\t\t\t\t\tpath: dep,\n\t\t\t\t\t\t\t\t\texpected: !optionalDeps.has(dep),\n\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tfor (const l of fileSymlinks) files.delete(l);\n\t\t\t\tfor (const l of directorySymlinks) directories.delete(l);\n\t\t\t\tfor (const k of invalidResolveResults) resolveResults.delete(k);\n\t\t\t\tcallback(null, {\n\t\t\t\t\tfiles,\n\t\t\t\t\tdirectories,\n\t\t\t\t\tmissing,\n\t\t\t\t\tresolveResults,\n\t\t\t\t\tresolveDependencies: {\n\t\t\t\t\t\tfiles: resolveFiles,\n\t\t\t\t\t\tdirectories: resolveDirectories,\n\t\t\t\t\t\tmissing: resolveMissing\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {Map<string, string | false>} resolveResults results from resolving\n\t * @param {function((Error | null)=, boolean=): void} callback callback with true when resolveResults resolve the same way\n\t * @returns {void}\n\t */\n\tcheckResolveResultsValid(resolveResults, callback) {\n\t\tconst { resolveCjs, resolveCjsAsChild, resolveEsm, resolveContext } =\n\t\t\tthis._createBuildDependenciesResolvers();\n\t\tasyncLib.eachLimit(\n\t\t\tresolveResults,\n\t\t\t20,\n\t\t\t([key, expectedResult], callback) => {\n\t\t\t\tconst [type, context, path] = key.split(\"\\n\");\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase \"d\":\n\t\t\t\t\t\tresolveContext(context, path, {}, (err, _, result) => {\n\t\t\t\t\t\t\tif (expectedResult === false)\n\t\t\t\t\t\t\t\treturn callback(err ? undefined : INVALID);\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst resultPath = result.path;\n\t\t\t\t\t\t\tif (resultPath !== expectedResult) return callback(INVALID);\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"f\":\n\t\t\t\t\t\tresolveCjs(context, path, {}, (err, _, result) => {\n\t\t\t\t\t\t\tif (expectedResult === false)\n\t\t\t\t\t\t\t\treturn callback(err ? undefined : INVALID);\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst resultPath = result.path;\n\t\t\t\t\t\t\tif (resultPath !== expectedResult) return callback(INVALID);\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"c\":\n\t\t\t\t\t\tresolveCjsAsChild(context, path, {}, (err, _, result) => {\n\t\t\t\t\t\t\tif (expectedResult === false)\n\t\t\t\t\t\t\t\treturn callback(err ? undefined : INVALID);\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst resultPath = result.path;\n\t\t\t\t\t\t\tif (resultPath !== expectedResult) return callback(INVALID);\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"e\":\n\t\t\t\t\t\tresolveEsm(context, path, {}, (err, _, result) => {\n\t\t\t\t\t\t\tif (expectedResult === false)\n\t\t\t\t\t\t\t\treturn callback(err ? undefined : INVALID);\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst resultPath = result.path;\n\t\t\t\t\t\t\tif (resultPath !== expectedResult) return callback(INVALID);\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcallback(new Error(\"Unexpected type in resolve result key\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t},\n\t\t\t/**\n\t\t\t * @param {Error | typeof INVALID=} err error or invalid flag\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\terr => {\n\t\t\t\tif (err === INVALID) {\n\t\t\t\t\treturn callback(null, false);\n\t\t\t\t}\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\t\t\t\treturn callback(null, true);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t *\n\t * @param {number} startTime when processing the files has started\n\t * @param {Iterable<string>} files all files\n\t * @param {Iterable<string>} directories all directories\n\t * @param {Iterable<string>} missing all missing files or directories\n\t * @param {Object} options options object (for future extensions)\n\t * @param {boolean=} options.hash should use hash to snapshot\n\t * @param {boolean=} options.timestamp should use timestamp to snapshot\n\t * @param {function((WebpackError | null)=, (Snapshot | null)=): void} callback callback function\n\t * @returns {void}\n\t */\n\tcreateSnapshot(startTime, files, directories, missing, options, callback) {\n\t\t/** @type {Map<string, FileSystemInfoEntry | null>} */\n\t\tconst fileTimestamps = new Map();\n\t\t/** @type {Map<string, string | null>} */\n\t\tconst fileHashes = new Map();\n\t\t/** @type {Map<string, TimestampAndHash | string | null>} */\n\t\tconst fileTshs = new Map();\n\t\t/** @type {Map<string, FileSystemInfoEntry | null>} */\n\t\tconst contextTimestamps = new Map();\n\t\t/** @type {Map<string, string | null>} */\n\t\tconst contextHashes = new Map();\n\t\t/** @type {Map<string, ResolvedContextTimestampAndHash | null>} */\n\t\tconst contextTshs = new Map();\n\t\t/** @type {Map<string, boolean>} */\n\t\tconst missingExistence = new Map();\n\t\t/** @type {Map<string, string>} */\n\t\tconst managedItemInfo = new Map();\n\t\t/** @type {Set<string>} */\n\t\tconst managedFiles = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst managedContexts = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst managedMissing = new Set();\n\t\t/** @type {Set<Snapshot>} */\n\t\tconst children = new Set();\n\n\t\tconst snapshot = new Snapshot();\n\t\tif (startTime) snapshot.setStartTime(startTime);\n\n\t\t/** @type {Set<string>} */\n\t\tconst managedItems = new Set();\n\n\t\t/** 1 = timestamp, 2 = hash, 3 = timestamp + hash */\n\t\tconst mode = options && options.hash ? (options.timestamp ? 3 : 2) : 1;\n\n\t\tlet jobs = 1;\n\t\tconst jobDone = () => {\n\t\t\tif (--jobs === 0) {\n\t\t\t\tif (fileTimestamps.size !== 0) {\n\t\t\t\t\tsnapshot.setFileTimestamps(fileTimestamps);\n\t\t\t\t}\n\t\t\t\tif (fileHashes.size !== 0) {\n\t\t\t\t\tsnapshot.setFileHashes(fileHashes);\n\t\t\t\t}\n\t\t\t\tif (fileTshs.size !== 0) {\n\t\t\t\t\tsnapshot.setFileTshs(fileTshs);\n\t\t\t\t}\n\t\t\t\tif (contextTimestamps.size !== 0) {\n\t\t\t\t\tsnapshot.setContextTimestamps(contextTimestamps);\n\t\t\t\t}\n\t\t\t\tif (contextHashes.size !== 0) {\n\t\t\t\t\tsnapshot.setContextHashes(contextHashes);\n\t\t\t\t}\n\t\t\t\tif (contextTshs.size !== 0) {\n\t\t\t\t\tsnapshot.setContextTshs(contextTshs);\n\t\t\t\t}\n\t\t\t\tif (missingExistence.size !== 0) {\n\t\t\t\t\tsnapshot.setMissingExistence(missingExistence);\n\t\t\t\t}\n\t\t\t\tif (managedItemInfo.size !== 0) {\n\t\t\t\t\tsnapshot.setManagedItemInfo(managedItemInfo);\n\t\t\t\t}\n\t\t\t\tthis._managedFilesOptimization.optimize(snapshot, managedFiles);\n\t\t\t\tif (managedFiles.size !== 0) {\n\t\t\t\t\tsnapshot.setManagedFiles(managedFiles);\n\t\t\t\t}\n\t\t\t\tthis._managedContextsOptimization.optimize(snapshot, managedContexts);\n\t\t\t\tif (managedContexts.size !== 0) {\n\t\t\t\t\tsnapshot.setManagedContexts(managedContexts);\n\t\t\t\t}\n\t\t\t\tthis._managedMissingOptimization.optimize(snapshot, managedMissing);\n\t\t\t\tif (managedMissing.size !== 0) {\n\t\t\t\t\tsnapshot.setManagedMissing(managedMissing);\n\t\t\t\t}\n\t\t\t\tif (children.size !== 0) {\n\t\t\t\t\tsnapshot.setChildren(children);\n\t\t\t\t}\n\t\t\t\tthis._snapshotCache.set(snapshot, true);\n\t\t\t\tthis._statCreatedSnapshots++;\n\n\t\t\t\tcallback(null, snapshot);\n\t\t\t}\n\t\t};\n\t\tconst jobError = () => {\n\t\t\tif (jobs > 0) {\n\t\t\t\t// large negative number instead of NaN or something else to keep jobs to stay a SMI (v8)\n\t\t\t\tjobs = -100000000;\n\t\t\t\tcallback(null, null);\n\t\t\t}\n\t\t};\n\t\tconst checkManaged = (path, managedSet) => {\n\t\t\tfor (const immutablePath of this.immutablePathsRegExps) {\n\t\t\t\tif (immutablePath.test(path)) {\n\t\t\t\t\tmanagedSet.add(path);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const immutablePath of this.immutablePathsWithSlash) {\n\t\t\t\tif (path.startsWith(immutablePath)) {\n\t\t\t\t\tmanagedSet.add(path);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const managedPath of this.managedPathsRegExps) {\n\t\t\t\tconst match = managedPath.exec(path);\n\t\t\t\tif (match) {\n\t\t\t\t\tconst managedItem = getManagedItem(match[1], path);\n\t\t\t\t\tif (managedItem) {\n\t\t\t\t\t\tmanagedItems.add(managedItem);\n\t\t\t\t\t\tmanagedSet.add(path);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const managedPath of this.managedPathsWithSlash) {\n\t\t\t\tif (path.startsWith(managedPath)) {\n\t\t\t\t\tconst managedItem = getManagedItem(managedPath, path);\n\t\t\t\t\tif (managedItem) {\n\t\t\t\t\t\tmanagedItems.add(managedItem);\n\t\t\t\t\t\tmanagedSet.add(path);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tconst captureNonManaged = (items, managedSet) => {\n\t\t\tconst capturedItems = new Set();\n\t\t\tfor (const path of items) {\n\t\t\t\tif (!checkManaged(path, managedSet)) capturedItems.add(path);\n\t\t\t}\n\t\t\treturn capturedItems;\n\t\t};\n\t\tconst processCapturedFiles = capturedFiles => {\n\t\t\tswitch (mode) {\n\t\t\t\tcase 3:\n\t\t\t\t\tthis._fileTshsOptimization.optimize(snapshot, capturedFiles);\n\t\t\t\t\tfor (const path of capturedFiles) {\n\t\t\t\t\t\tconst cache = this._fileTshs.get(path);\n\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\tfileTshs.set(path, cache);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t\tthis._getFileTimestampAndHash(path, (err, entry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Error snapshotting file timestamp hash combination of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfileTshs.set(path, entry);\n\t\t\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tthis._fileHashesOptimization.optimize(snapshot, capturedFiles);\n\t\t\t\t\tfor (const path of capturedFiles) {\n\t\t\t\t\t\tconst cache = this._fileHashes.get(path);\n\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\tfileHashes.set(path, cache);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t\tthis.fileHashQueue.add(path, (err, entry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Error snapshotting file hash of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfileHashes.set(path, entry);\n\t\t\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tthis._fileTimestampsOptimization.optimize(snapshot, capturedFiles);\n\t\t\t\t\tfor (const path of capturedFiles) {\n\t\t\t\t\t\tconst cache = this._fileTimestamps.get(path);\n\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\tif (cache !== \"ignore\") {\n\t\t\t\t\t\t\t\tfileTimestamps.set(path, cache);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t\tthis.fileTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Error snapshotting file timestamp of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfileTimestamps.set(path, entry);\n\t\t\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\t\tif (files) {\n\t\t\tprocessCapturedFiles(captureNonManaged(files, managedFiles));\n\t\t}\n\t\tconst processCapturedDirectories = capturedDirectories => {\n\t\t\tswitch (mode) {\n\t\t\t\tcase 3:\n\t\t\t\t\tthis._contextTshsOptimization.optimize(snapshot, capturedDirectories);\n\t\t\t\t\tfor (const path of capturedDirectories) {\n\t\t\t\t\t\tconst cache = this._contextTshs.get(path);\n\t\t\t\t\t\t/** @type {ResolvedContextTimestampAndHash} */\n\t\t\t\t\t\tlet resolved;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcache !== undefined &&\n\t\t\t\t\t\t\t(resolved = getResolvedTimestamp(cache)) !== undefined\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontextTshs.set(path, resolved);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {Error=} err error\n\t\t\t\t\t\t\t * @param {ResolvedContextTimestampAndHash=} entry entry\n\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst callback = (err, entry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Error snapshotting context timestamp hash combination of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcontextTshs.set(path, entry);\n\t\t\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\t\tthis._resolveContextTsh(cache, callback);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.getContextTsh(path, callback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tthis._contextHashesOptimization.optimize(\n\t\t\t\t\t\tsnapshot,\n\t\t\t\t\t\tcapturedDirectories\n\t\t\t\t\t);\n\t\t\t\t\tfor (const path of capturedDirectories) {\n\t\t\t\t\t\tconst cache = this._contextHashes.get(path);\n\t\t\t\t\t\tlet resolved;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcache !== undefined &&\n\t\t\t\t\t\t\t(resolved = getResolvedHash(cache)) !== undefined\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontextHashes.set(path, resolved);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t\tconst callback = (err, entry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Error snapshotting context hash of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcontextHashes.set(path, entry);\n\t\t\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\t\tthis._resolveContextHash(cache, callback);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.getContextHash(path, callback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tthis._contextTimestampsOptimization.optimize(\n\t\t\t\t\t\tsnapshot,\n\t\t\t\t\t\tcapturedDirectories\n\t\t\t\t\t);\n\t\t\t\t\tfor (const path of capturedDirectories) {\n\t\t\t\t\t\tconst cache = this._contextTimestamps.get(path);\n\t\t\t\t\t\tif (cache === \"ignore\") continue;\n\t\t\t\t\t\tlet resolved;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcache !== undefined &&\n\t\t\t\t\t\t\t(resolved = getResolvedTimestamp(cache)) !== undefined\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontextTimestamps.set(path, resolved);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {Error=} err error\n\t\t\t\t\t\t\t * @param {ResolvedContextFileSystemInfoEntry=} entry entry\n\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst callback = (err, entry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Error snapshotting context timestamp of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcontextTimestamps.set(path, entry);\n\t\t\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\t\tthis._resolveContextTimestamp(cache, callback);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.getContextTimestamp(path, callback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\t\tif (directories) {\n\t\t\tprocessCapturedDirectories(\n\t\t\t\tcaptureNonManaged(directories, managedContexts)\n\t\t\t);\n\t\t}\n\t\tconst processCapturedMissing = capturedMissing => {\n\t\t\tthis._missingExistenceOptimization.optimize(snapshot, capturedMissing);\n\t\t\tfor (const path of capturedMissing) {\n\t\t\t\tconst cache = this._fileTimestamps.get(path);\n\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\tif (cache !== \"ignore\") {\n\t\t\t\t\t\tmissingExistence.set(path, Boolean(cache));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tjobs++;\n\t\t\t\t\tthis.fileTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t`Error snapshotting missing timestamp of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmissingExistence.set(path, Boolean(entry));\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif (missing) {\n\t\t\tprocessCapturedMissing(captureNonManaged(missing, managedMissing));\n\t\t}\n\t\tthis._managedItemInfoOptimization.optimize(snapshot, managedItems);\n\t\tfor (const path of managedItems) {\n\t\t\tconst cache = this._managedItems.get(path);\n\t\t\tif (cache !== undefined) {\n\t\t\t\tif (!cache.startsWith(\"*\")) {\n\t\t\t\t\tmanagedFiles.add(join(this.fs, path, \"package.json\"));\n\t\t\t\t} else if (cache === \"*nested\") {\n\t\t\t\t\tmanagedMissing.add(join(this.fs, path, \"package.json\"));\n\t\t\t\t}\n\t\t\t\tmanagedItemInfo.set(path, cache);\n\t\t\t} else {\n\t\t\t\tjobs++;\n\t\t\t\tthis.managedItemQueue.add(path, (err, entry) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t`Error snapshotting managed item ${path}: ${err.stack}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjobError();\n\t\t\t\t\t} else if (entry) {\n\t\t\t\t\t\tif (!entry.startsWith(\"*\")) {\n\t\t\t\t\t\t\tmanagedFiles.add(join(this.fs, path, \"package.json\"));\n\t\t\t\t\t\t} else if (cache === \"*nested\") {\n\t\t\t\t\t\t\tmanagedMissing.add(join(this.fs, path, \"package.json\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmanagedItemInfo.set(path, entry);\n\t\t\t\t\t\tjobDone();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Fallback to normal snapshotting\n\t\t\t\t\t\tconst process = (set, fn) => {\n\t\t\t\t\t\t\tif (set.size === 0) return;\n\t\t\t\t\t\t\tconst captured = new Set();\n\t\t\t\t\t\t\tfor (const file of set) {\n\t\t\t\t\t\t\t\tif (file.startsWith(path)) captured.add(file);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (captured.size > 0) fn(captured);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tprocess(managedFiles, processCapturedFiles);\n\t\t\t\t\t\tprocess(managedContexts, processCapturedDirectories);\n\t\t\t\t\t\tprocess(managedMissing, processCapturedMissing);\n\t\t\t\t\t\tjobDone();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tjobDone();\n\t}\n\n\t/**\n\t * @param {Snapshot} snapshot1 a snapshot\n\t * @param {Snapshot} snapshot2 a snapshot\n\t * @returns {Snapshot} merged snapshot\n\t */\n\tmergeSnapshots(snapshot1, snapshot2) {\n\t\tconst snapshot = new Snapshot();\n\t\tif (snapshot1.hasStartTime() && snapshot2.hasStartTime())\n\t\t\tsnapshot.setStartTime(Math.min(snapshot1.startTime, snapshot2.startTime));\n\t\telse if (snapshot2.hasStartTime()) snapshot.startTime = snapshot2.startTime;\n\t\telse if (snapshot1.hasStartTime()) snapshot.startTime = snapshot1.startTime;\n\t\tif (snapshot1.hasFileTimestamps() || snapshot2.hasFileTimestamps()) {\n\t\t\tsnapshot.setFileTimestamps(\n\t\t\t\tmergeMaps(snapshot1.fileTimestamps, snapshot2.fileTimestamps)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasFileHashes() || snapshot2.hasFileHashes()) {\n\t\t\tsnapshot.setFileHashes(\n\t\t\t\tmergeMaps(snapshot1.fileHashes, snapshot2.fileHashes)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasFileTshs() || snapshot2.hasFileTshs()) {\n\t\t\tsnapshot.setFileTshs(mergeMaps(snapshot1.fileTshs, snapshot2.fileTshs));\n\t\t}\n\t\tif (snapshot1.hasContextTimestamps() || snapshot2.hasContextTimestamps()) {\n\t\t\tsnapshot.setContextTimestamps(\n\t\t\t\tmergeMaps(snapshot1.contextTimestamps, snapshot2.contextTimestamps)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasContextHashes() || snapshot2.hasContextHashes()) {\n\t\t\tsnapshot.setContextHashes(\n\t\t\t\tmergeMaps(snapshot1.contextHashes, snapshot2.contextHashes)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasContextTshs() || snapshot2.hasContextTshs()) {\n\t\t\tsnapshot.setContextTshs(\n\t\t\t\tmergeMaps(snapshot1.contextTshs, snapshot2.contextTshs)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasMissingExistence() || snapshot2.hasMissingExistence()) {\n\t\t\tsnapshot.setMissingExistence(\n\t\t\t\tmergeMaps(snapshot1.missingExistence, snapshot2.missingExistence)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasManagedItemInfo() || snapshot2.hasManagedItemInfo()) {\n\t\t\tsnapshot.setManagedItemInfo(\n\t\t\t\tmergeMaps(snapshot1.managedItemInfo, snapshot2.managedItemInfo)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasManagedFiles() || snapshot2.hasManagedFiles()) {\n\t\t\tsnapshot.setManagedFiles(\n\t\t\t\tmergeSets(snapshot1.managedFiles, snapshot2.managedFiles)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasManagedContexts() || snapshot2.hasManagedContexts()) {\n\t\t\tsnapshot.setManagedContexts(\n\t\t\t\tmergeSets(snapshot1.managedContexts, snapshot2.managedContexts)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasManagedMissing() || snapshot2.hasManagedMissing()) {\n\t\t\tsnapshot.setManagedMissing(\n\t\t\t\tmergeSets(snapshot1.managedMissing, snapshot2.managedMissing)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasChildren() || snapshot2.hasChildren()) {\n\t\t\tsnapshot.setChildren(mergeSets(snapshot1.children, snapshot2.children));\n\t\t}\n\t\tif (\n\t\t\tthis._snapshotCache.get(snapshot1) === true &&\n\t\t\tthis._snapshotCache.get(snapshot2) === true\n\t\t) {\n\t\t\tthis._snapshotCache.set(snapshot, true);\n\t\t}\n\t\treturn snapshot;\n\t}\n\n\t/**\n\t * @param {Snapshot} snapshot the snapshot made\n\t * @param {function((WebpackError | null)=, boolean=): void} callback callback function\n\t * @returns {void}\n\t */\n\tcheckSnapshotValid(snapshot, callback) {\n\t\tconst cachedResult = this._snapshotCache.get(snapshot);\n\t\tif (cachedResult !== undefined) {\n\t\t\tthis._statTestedSnapshotsCached++;\n\t\t\tif (typeof cachedResult === \"boolean\") {\n\t\t\t\tcallback(null, cachedResult);\n\t\t\t} else {\n\t\t\t\tcachedResult.push(callback);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis._statTestedSnapshotsNotCached++;\n\t\tthis._checkSnapshotValidNoCache(snapshot, callback);\n\t}\n\n\t/**\n\t * @param {Snapshot} snapshot the snapshot made\n\t * @param {function((WebpackError | null)=, boolean=): void} callback callback function\n\t * @returns {void}\n\t */\n\t_checkSnapshotValidNoCache(snapshot, callback) {\n\t\t/** @type {number | undefined} */\n\t\tlet startTime = undefined;\n\t\tif (snapshot.hasStartTime()) {\n\t\t\tstartTime = snapshot.startTime;\n\t\t}\n\t\tlet jobs = 1;\n\t\tconst jobDone = () => {\n\t\t\tif (--jobs === 0) {\n\t\t\t\tthis._snapshotCache.set(snapshot, true);\n\t\t\t\tcallback(null, true);\n\t\t\t}\n\t\t};\n\t\tconst invalid = () => {\n\t\t\tif (jobs > 0) {\n\t\t\t\t// large negative number instead of NaN or something else to keep jobs to stay a SMI (v8)\n\t\t\t\tjobs = -100000000;\n\t\t\t\tthis._snapshotCache.set(snapshot, false);\n\t\t\t\tcallback(null, false);\n\t\t\t}\n\t\t};\n\t\tconst invalidWithError = (path, err) => {\n\t\t\tif (this._remainingLogs > 0) {\n\t\t\t\tthis._log(path, `error occurred: %s`, err);\n\t\t\t}\n\t\t\tinvalid();\n\t\t};\n\t\t/**\n\t\t * @param {string} path file path\n\t\t * @param {string} current current hash\n\t\t * @param {string} snap snapshot hash\n\t\t * @returns {boolean} true, if ok\n\t\t */\n\t\tconst checkHash = (path, current, snap) => {\n\t\t\tif (current !== snap) {\n\t\t\t\t// If hash differ it's invalid\n\t\t\t\tif (this._remainingLogs > 0) {\n\t\t\t\t\tthis._log(path, `hashes differ (%s != %s)`, current, snap);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\t/**\n\t\t * @param {string} path file path\n\t\t * @param {boolean} current current entry\n\t\t * @param {boolean} snap entry from snapshot\n\t\t * @returns {boolean} true, if ok\n\t\t */\n\t\tconst checkExistence = (path, current, snap) => {\n\t\t\tif (!current !== !snap) {\n\t\t\t\t// If existence of item differs\n\t\t\t\t// it's invalid\n\t\t\t\tif (this._remainingLogs > 0) {\n\t\t\t\t\tthis._log(\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tcurrent ? \"it didn't exist before\" : \"it does no longer exist\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\t/**\n\t\t * @param {string} path file path\n\t\t * @param {FileSystemInfoEntry} current current entry\n\t\t * @param {FileSystemInfoEntry} snap entry from snapshot\n\t\t * @param {boolean} log log reason\n\t\t * @returns {boolean} true, if ok\n\t\t */\n\t\tconst checkFile = (path, current, snap, log = true) => {\n\t\t\tif (current === snap) return true;\n\t\t\tif (!checkExistence(path, Boolean(current), Boolean(snap))) return false;\n\t\t\tif (current) {\n\t\t\t\t// For existing items only\n\t\t\t\tif (typeof startTime === \"number\" && current.safeTime > startTime) {\n\t\t\t\t\t// If a change happened after starting reading the item\n\t\t\t\t\t// this may no longer be valid\n\t\t\t\t\tif (log && this._remainingLogs > 0) {\n\t\t\t\t\t\tthis._log(\n\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t`it may have changed (%d) after the start time of the snapshot (%d)`,\n\t\t\t\t\t\t\tcurrent.safeTime,\n\t\t\t\t\t\t\tstartTime\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tsnap.timestamp !== undefined &&\n\t\t\t\t\tcurrent.timestamp !== snap.timestamp\n\t\t\t\t) {\n\t\t\t\t\t// If we have a timestamp (it was a file or symlink) and it differs from current timestamp\n\t\t\t\t\t// it's invalid\n\t\t\t\t\tif (log && this._remainingLogs > 0) {\n\t\t\t\t\t\tthis._log(\n\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t`timestamps differ (%d != %d)`,\n\t\t\t\t\t\t\tcurrent.timestamp,\n\t\t\t\t\t\t\tsnap.timestamp\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\t/**\n\t\t * @param {string} path file path\n\t\t * @param {ResolvedContextFileSystemInfoEntry} current current entry\n\t\t * @param {ResolvedContextFileSystemInfoEntry} snap entry from snapshot\n\t\t * @param {boolean} log log reason\n\t\t * @returns {boolean} true, if ok\n\t\t */\n\t\tconst checkContext = (path, current, snap, log = true) => {\n\t\t\tif (current === snap) return true;\n\t\t\tif (!checkExistence(path, Boolean(current), Boolean(snap))) return false;\n\t\t\tif (current) {\n\t\t\t\t// For existing items only\n\t\t\t\tif (typeof startTime === \"number\" && current.safeTime > startTime) {\n\t\t\t\t\t// If a change happened after starting reading the item\n\t\t\t\t\t// this may no longer be valid\n\t\t\t\t\tif (log && this._remainingLogs > 0) {\n\t\t\t\t\t\tthis._log(\n\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t`it may have changed (%d) after the start time of the snapshot (%d)`,\n\t\t\t\t\t\t\tcurrent.safeTime,\n\t\t\t\t\t\t\tstartTime\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tsnap.timestampHash !== undefined &&\n\t\t\t\t\tcurrent.timestampHash !== snap.timestampHash\n\t\t\t\t) {\n\t\t\t\t\t// If we have a timestampHash (it was a directory) and it differs from current timestampHash\n\t\t\t\t\t// it's invalid\n\t\t\t\t\tif (log && this._remainingLogs > 0) {\n\t\t\t\t\t\tthis._log(\n\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t`timestamps hashes differ (%s != %s)`,\n\t\t\t\t\t\t\tcurrent.timestampHash,\n\t\t\t\t\t\t\tsnap.timestampHash\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\tif (snapshot.hasChildren()) {\n\t\t\tconst childCallback = (err, result) => {\n\t\t\t\tif (err || !result) return invalid();\n\t\t\t\telse jobDone();\n\t\t\t};\n\t\t\tfor (const child of snapshot.children) {\n\t\t\t\tconst cache = this._snapshotCache.get(child);\n\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\tthis._statTestedChildrenCached++;\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif (typeof cache === \"boolean\") {\n\t\t\t\t\t\tif (cache === false) {\n\t\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\tcache.push(childCallback);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._statTestedChildrenNotCached++;\n\t\t\t\t\tjobs++;\n\t\t\t\t\tthis._checkSnapshotValidNoCache(child, childCallback);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (snapshot.hasFileTimestamps()) {\n\t\t\tconst { fileTimestamps } = snapshot;\n\t\t\tthis._statTestedEntries += fileTimestamps.size;\n\t\t\tfor (const [path, ts] of fileTimestamps) {\n\t\t\t\tconst cache = this._fileTimestamps.get(path);\n\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\tif (cache !== \"ignore\" && !checkFile(path, cache, ts)) {\n\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tjobs++;\n\t\t\t\t\tthis.fileTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\t\tif (!checkFile(path, entry, ts)) {\n\t\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst processFileHashSnapshot = (path, hash) => {\n\t\t\tconst cache = this._fileHashes.get(path);\n\t\t\tif (cache !== undefined) {\n\t\t\t\tif (cache !== \"ignore\" && !checkHash(path, cache, hash)) {\n\t\t\t\t\tinvalid();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjobs++;\n\t\t\t\tthis.fileHashQueue.add(path, (err, entry) => {\n\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\tif (!checkHash(path, entry, hash)) {\n\t\t\t\t\t\tinvalid();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjobDone();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t\tif (snapshot.hasFileHashes()) {\n\t\t\tconst { fileHashes } = snapshot;\n\t\t\tthis._statTestedEntries += fileHashes.size;\n\t\t\tfor (const [path, hash] of fileHashes) {\n\t\t\t\tprocessFileHashSnapshot(path, hash);\n\t\t\t}\n\t\t}\n\t\tif (snapshot.hasFileTshs()) {\n\t\t\tconst { fileTshs } = snapshot;\n\t\t\tthis._statTestedEntries += fileTshs.size;\n\t\t\tfor (const [path, tsh] of fileTshs) {\n\t\t\t\tif (typeof tsh === \"string\") {\n\t\t\t\t\tprocessFileHashSnapshot(path, tsh);\n\t\t\t\t} else {\n\t\t\t\t\tconst cache = this._fileTimestamps.get(path);\n\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\tif (cache === \"ignore\" || !checkFile(path, cache, tsh, false)) {\n\t\t\t\t\t\t\tprocessFileHashSnapshot(path, tsh && tsh.hash);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\tthis.fileTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\t\t\tif (!checkFile(path, entry, tsh, false)) {\n\t\t\t\t\t\t\t\tprocessFileHashSnapshot(path, tsh && tsh.hash);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (snapshot.hasContextTimestamps()) {\n\t\t\tconst { contextTimestamps } = snapshot;\n\t\t\tthis._statTestedEntries += contextTimestamps.size;\n\t\t\tfor (const [path, ts] of contextTimestamps) {\n\t\t\t\tconst cache = this._contextTimestamps.get(path);\n\t\t\t\tif (cache === \"ignore\") continue;\n\t\t\t\tlet resolved;\n\t\t\t\tif (\n\t\t\t\t\tcache !== undefined &&\n\t\t\t\t\t(resolved = getResolvedTimestamp(cache)) !== undefined\n\t\t\t\t) {\n\t\t\t\t\tif (!checkContext(path, resolved, ts)) {\n\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tjobs++;\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Error=} err error\n\t\t\t\t\t * @param {ResolvedContextFileSystemInfoEntry=} entry entry\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst callback = (err, entry) => {\n\t\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\t\tif (!checkContext(path, entry, ts)) {\n\t\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\tthis._resolveContextTimestamp(cache, callback);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.getContextTimestamp(path, callback);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst processContextHashSnapshot = (path, hash) => {\n\t\t\tconst cache = this._contextHashes.get(path);\n\t\t\tlet resolved;\n\t\t\tif (\n\t\t\t\tcache !== undefined &&\n\t\t\t\t(resolved = getResolvedHash(cache)) !== undefined\n\t\t\t) {\n\t\t\t\tif (!checkHash(path, resolved, hash)) {\n\t\t\t\t\tinvalid();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjobs++;\n\t\t\t\tconst callback = (err, entry) => {\n\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\tif (!checkHash(path, entry, hash)) {\n\t\t\t\t\t\tinvalid();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjobDone();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\tthis._resolveContextHash(cache, callback);\n\t\t\t\t} else {\n\t\t\t\t\tthis.getContextHash(path, callback);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif (snapshot.hasContextHashes()) {\n\t\t\tconst { contextHashes } = snapshot;\n\t\t\tthis._statTestedEntries += contextHashes.size;\n\t\t\tfor (const [path, hash] of contextHashes) {\n\t\t\t\tprocessContextHashSnapshot(path, hash);\n\t\t\t}\n\t\t}\n\t\tif (snapshot.hasContextTshs()) {\n\t\t\tconst { contextTshs } = snapshot;\n\t\t\tthis._statTestedEntries += contextTshs.size;\n\t\t\tfor (const [path, tsh] of contextTshs) {\n\t\t\t\tif (typeof tsh === \"string\") {\n\t\t\t\t\tprocessContextHashSnapshot(path, tsh);\n\t\t\t\t} else {\n\t\t\t\t\tconst cache = this._contextTimestamps.get(path);\n\t\t\t\t\tif (cache === \"ignore\") continue;\n\t\t\t\t\tlet resolved;\n\t\t\t\t\tif (\n\t\t\t\t\t\tcache !== undefined &&\n\t\t\t\t\t\t(resolved = getResolvedTimestamp(cache)) !== undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (!checkContext(path, resolved, tsh, false)) {\n\t\t\t\t\t\t\tprocessContextHashSnapshot(path, tsh && tsh.hash);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {Error=} err error\n\t\t\t\t\t\t * @param {ResolvedContextFileSystemInfoEntry=} entry entry\n\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst callback = (err, entry) => {\n\t\t\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\t\t\tif (!checkContext(path, entry, tsh, false)) {\n\t\t\t\t\t\t\t\tprocessContextHashSnapshot(path, tsh && tsh.hash);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\tthis._resolveContextTimestamp(cache, callback);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.getContextTimestamp(path, callback);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (snapshot.hasMissingExistence()) {\n\t\t\tconst { missingExistence } = snapshot;\n\t\t\tthis._statTestedEntries += missingExistence.size;\n\t\t\tfor (const [path, existence] of missingExistence) {\n\t\t\t\tconst cache = this._fileTimestamps.get(path);\n\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tcache !== \"ignore\" &&\n\t\t\t\t\t\t!checkExistence(path, Boolean(cache), Boolean(existence))\n\t\t\t\t\t) {\n\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tjobs++;\n\t\t\t\t\tthis.fileTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\t\tif (!checkExistence(path, Boolean(entry), Boolean(existence))) {\n\t\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (snapshot.hasManagedItemInfo()) {\n\t\t\tconst { managedItemInfo } = snapshot;\n\t\t\tthis._statTestedEntries += managedItemInfo.size;\n\t\t\tfor (const [path, info] of managedItemInfo) {\n\t\t\t\tconst cache = this._managedItems.get(path);\n\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\tif (!checkHash(path, cache, info)) {\n\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tjobs++;\n\t\t\t\t\tthis.managedItemQueue.add(path, (err, entry) => {\n\t\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\t\tif (!checkHash(path, entry, info)) {\n\t\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tjobDone();\n\n\t\t// if there was an async action\n\t\t// try to join multiple concurrent request for this snapshot\n\t\tif (jobs > 0) {\n\t\t\tconst callbacks = [callback];\n\t\t\tcallback = (err, result) => {\n\t\t\t\tfor (const callback of callbacks) callback(err, result);\n\t\t\t};\n\t\t\tthis._snapshotCache.set(snapshot, callbacks);\n\t\t}\n\t}\n\n\t_readFileTimestamp(path, callback) {\n\t\tthis.fs.stat(path, (err, stat) => {\n\t\t\tif (err) {\n\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\tthis._fileTimestamps.set(path, null);\n\t\t\t\t\tthis._cachedDeprecatedFileTimestamps = undefined;\n\t\t\t\t\treturn callback(null, null);\n\t\t\t\t}\n\t\t\t\treturn callback(err);\n\t\t\t}\n\n\t\t\tlet ts;\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\tts = {\n\t\t\t\t\tsafeTime: 0,\n\t\t\t\t\ttimestamp: undefined\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tconst mtime = +stat.mtime;\n\n\t\t\t\tif (mtime) applyMtime(mtime);\n\n\t\t\t\tts = {\n\t\t\t\t\tsafeTime: mtime ? mtime + FS_ACCURACY : Infinity,\n\t\t\t\t\ttimestamp: mtime\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthis._fileTimestamps.set(path, ts);\n\t\t\tthis._cachedDeprecatedFileTimestamps = undefined;\n\n\t\t\tcallback(null, ts);\n\t\t});\n\t}\n\n\t_readFileHash(path, callback) {\n\t\tthis.fs.readFile(path, (err, content) => {\n\t\t\tif (err) {\n\t\t\t\tif (err.code === \"EISDIR\") {\n\t\t\t\t\tthis._fileHashes.set(path, \"directory\");\n\t\t\t\t\treturn callback(null, \"directory\");\n\t\t\t\t}\n\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\tthis._fileHashes.set(path, null);\n\t\t\t\t\treturn callback(null, null);\n\t\t\t\t}\n\t\t\t\tif (err.code === \"ERR_FS_FILE_TOO_LARGE\") {\n\t\t\t\t\tthis.logger.warn(`Ignoring ${path} for hashing as it's very large`);\n\t\t\t\t\tthis._fileHashes.set(path, \"too large\");\n\t\t\t\t\treturn callback(null, \"too large\");\n\t\t\t\t}\n\t\t\t\treturn callback(err);\n\t\t\t}\n\n\t\t\tconst hash = createHash(this._hashFunction);\n\n\t\t\thash.update(content);\n\n\t\t\tconst digest = /** @type {string} */ (hash.digest(\"hex\"));\n\n\t\t\tthis._fileHashes.set(path, digest);\n\n\t\t\tcallback(null, digest);\n\t\t});\n\t}\n\n\t_getFileTimestampAndHash(path, callback) {\n\t\tconst continueWithHash = hash => {\n\t\t\tconst cache = this._fileTimestamps.get(path);\n\t\t\tif (cache !== undefined) {\n\t\t\t\tif (cache !== \"ignore\") {\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\t...cache,\n\t\t\t\t\t\thash\n\t\t\t\t\t};\n\t\t\t\t\tthis._fileTshs.set(path, result);\n\t\t\t\t\treturn callback(null, result);\n\t\t\t\t} else {\n\t\t\t\t\tthis._fileTshs.set(path, hash);\n\t\t\t\t\treturn callback(null, hash);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.fileTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t}\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\t...entry,\n\t\t\t\t\t\thash\n\t\t\t\t\t};\n\t\t\t\t\tthis._fileTshs.set(path, result);\n\t\t\t\t\treturn callback(null, result);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tconst cache = this._fileHashes.get(path);\n\t\tif (cache !== undefined) {\n\t\t\tcontinueWithHash(cache);\n\t\t} else {\n\t\t\tthis.fileHashQueue.add(path, (err, entry) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\t\t\t\tcontinueWithHash(entry);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * @template T\n\t * @template ItemType\n\t * @param {Object} options options\n\t * @param {string} options.path path\n\t * @param {function(string): ItemType} options.fromImmutablePath called when context item is an immutable path\n\t * @param {function(string): ItemType} options.fromManagedItem called when context item is a managed path\n\t * @param {function(string, string, function(Error=, ItemType=): void): void} options.fromSymlink called when context item is a symlink\n\t * @param {function(string, IStats, function(Error=, ItemType=): void): void} options.fromFile called when context item is a file\n\t * @param {function(string, IStats, function(Error=, ItemType=): void): void} options.fromDirectory called when context item is a directory\n\t * @param {function(string[], ItemType[]): T} options.reduce called from all context items\n\t * @param {function((Error | null)=, (T)=): void} callback callback\n\t */\n\t_readContext(\n\t\t{\n\t\t\tpath,\n\t\t\tfromImmutablePath,\n\t\t\tfromManagedItem,\n\t\t\tfromSymlink,\n\t\t\tfromFile,\n\t\t\tfromDirectory,\n\t\t\treduce\n\t\t},\n\t\tcallback\n\t) {\n\t\tthis.fs.readdir(path, (err, _files) => {\n\t\t\tif (err) {\n\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\treturn callback(null, null);\n\t\t\t\t}\n\t\t\t\treturn callback(err);\n\t\t\t}\n\t\t\tconst files = /** @type {string[]} */ (_files)\n\t\t\t\t.map(file => file.normalize(\"NFC\"))\n\t\t\t\t.filter(file => !/^\\./.test(file))\n\t\t\t\t.sort();\n\t\t\tasyncLib.map(\n\t\t\t\tfiles,\n\t\t\t\t(file, callback) => {\n\t\t\t\t\tconst child = join(this.fs, path, file);\n\t\t\t\t\tfor (const immutablePath of this.immutablePathsRegExps) {\n\t\t\t\t\t\tif (immutablePath.test(path)) {\n\t\t\t\t\t\t\t// ignore any immutable path for timestamping\n\t\t\t\t\t\t\treturn callback(null, fromImmutablePath(path));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const immutablePath of this.immutablePathsWithSlash) {\n\t\t\t\t\t\tif (path.startsWith(immutablePath)) {\n\t\t\t\t\t\t\t// ignore any immutable path for timestamping\n\t\t\t\t\t\t\treturn callback(null, fromImmutablePath(path));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const managedPath of this.managedPathsRegExps) {\n\t\t\t\t\t\tconst match = managedPath.exec(path);\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tconst managedItem = getManagedItem(match[1], path);\n\t\t\t\t\t\t\tif (managedItem) {\n\t\t\t\t\t\t\t\t// construct timestampHash from managed info\n\t\t\t\t\t\t\t\treturn this.managedItemQueue.add(managedItem, (err, info) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\treturn callback(null, fromManagedItem(info));\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const managedPath of this.managedPathsWithSlash) {\n\t\t\t\t\t\tif (path.startsWith(managedPath)) {\n\t\t\t\t\t\t\tconst managedItem = getManagedItem(managedPath, child);\n\t\t\t\t\t\t\tif (managedItem) {\n\t\t\t\t\t\t\t\t// construct timestampHash from managed info\n\t\t\t\t\t\t\t\treturn this.managedItemQueue.add(managedItem, (err, info) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\treturn callback(null, fromManagedItem(info));\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlstatReadlinkAbsolute(this.fs, child, (err, stat) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\tif (typeof stat === \"string\") {\n\t\t\t\t\t\t\treturn fromSymlink(child, stat, callback);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (stat.isFile()) {\n\t\t\t\t\t\t\treturn fromFile(child, stat, callback);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\t\treturn fromDirectory(child, stat, callback);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcallback(null, null);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\t(err, results) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tconst result = reduce(files, results);\n\t\t\t\t\tcallback(null, result);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t_readContextTimestamp(path, callback) {\n\t\tthis._readContext(\n\t\t\t{\n\t\t\t\tpath,\n\t\t\t\tfromImmutablePath: () => null,\n\t\t\t\tfromManagedItem: info => ({\n\t\t\t\t\tsafeTime: 0,\n\t\t\t\t\ttimestampHash: info\n\t\t\t\t}),\n\t\t\t\tfromSymlink: (file, target, callback) => {\n\t\t\t\t\tcallback(null, {\n\t\t\t\t\t\ttimestampHash: target,\n\t\t\t\t\t\tsymlinks: new Set([target])\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tfromFile: (file, stat, callback) => {\n\t\t\t\t\t// Prefer the cached value over our new stat to report consistent results\n\t\t\t\t\tconst cache = this._fileTimestamps.get(file);\n\t\t\t\t\tif (cache !== undefined)\n\t\t\t\t\t\treturn callback(null, cache === \"ignore\" ? null : cache);\n\n\t\t\t\t\tconst mtime = +stat.mtime;\n\n\t\t\t\t\tif (mtime) applyMtime(mtime);\n\n\t\t\t\t\tconst ts = {\n\t\t\t\t\t\tsafeTime: mtime ? mtime + FS_ACCURACY : Infinity,\n\t\t\t\t\t\ttimestamp: mtime\n\t\t\t\t\t};\n\n\t\t\t\t\tthis._fileTimestamps.set(file, ts);\n\t\t\t\t\tthis._cachedDeprecatedFileTimestamps = undefined;\n\t\t\t\t\tcallback(null, ts);\n\t\t\t\t},\n\t\t\t\tfromDirectory: (directory, stat, callback) => {\n\t\t\t\t\tthis.contextTimestampQueue.increaseParallelism();\n\t\t\t\t\tthis._getUnresolvedContextTimestamp(directory, (err, tsEntry) => {\n\t\t\t\t\t\tthis.contextTimestampQueue.decreaseParallelism();\n\t\t\t\t\t\tcallback(err, tsEntry);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\treduce: (files, tsEntries) => {\n\t\t\t\t\tlet symlinks = undefined;\n\n\t\t\t\t\tconst hash = createHash(this._hashFunction);\n\n\t\t\t\t\tfor (const file of files) hash.update(file);\n\t\t\t\t\tlet safeTime = 0;\n\t\t\t\t\tfor (const entry of tsEntries) {\n\t\t\t\t\t\tif (!entry) {\n\t\t\t\t\t\t\thash.update(\"n\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (entry.timestamp) {\n\t\t\t\t\t\t\thash.update(\"f\");\n\t\t\t\t\t\t\thash.update(`${entry.timestamp}`);\n\t\t\t\t\t\t} else if (entry.timestampHash) {\n\t\t\t\t\t\t\thash.update(\"d\");\n\t\t\t\t\t\t\thash.update(`${entry.timestampHash}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (entry.symlinks !== undefined) {\n\t\t\t\t\t\t\tif (symlinks === undefined) symlinks = new Set();\n\t\t\t\t\t\t\taddAll(entry.symlinks, symlinks);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (entry.safeTime) {\n\t\t\t\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst digest = /** @type {string} */ (hash.digest(\"hex\"));\n\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\ttimestampHash: digest\n\t\t\t\t\t};\n\t\t\t\t\tif (symlinks) result.symlinks = symlinks;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t},\n\t\t\t(err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tthis._contextTimestamps.set(path, result);\n\t\t\t\tthis._cachedDeprecatedContextTimestamps = undefined;\n\n\t\t\t\tcallback(null, result);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {ContextFileSystemInfoEntry} entry entry\n\t * @param {function((Error | null)=, ResolvedContextFileSystemInfoEntry=): void} callback callback\n\t * @returns {void}\n\t */\n\t_resolveContextTimestamp(entry, callback) {\n\t\tconst hashes = [];\n\t\tlet safeTime = 0;\n\t\tprocessAsyncTree(\n\t\t\tentry.symlinks,\n\t\t\t10,\n\t\t\t(target, push, callback) => {\n\t\t\t\tthis._getUnresolvedContextTimestamp(target, (err, entry) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tif (entry && entry !== \"ignore\") {\n\t\t\t\t\t\thashes.push(entry.timestampHash);\n\t\t\t\t\t\tif (entry.safeTime) {\n\t\t\t\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (entry.symlinks !== undefined) {\n\t\t\t\t\t\t\tfor (const target of entry.symlinks) push(target);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcallback();\n\t\t\t\t});\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\t\thash.update(entry.timestampHash);\n\t\t\t\tif (entry.safeTime) {\n\t\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t\t}\n\t\t\t\thashes.sort();\n\t\t\t\tfor (const h of hashes) {\n\t\t\t\t\thash.update(h);\n\t\t\t\t}\n\t\t\t\tcallback(\n\t\t\t\t\tnull,\n\t\t\t\t\t(entry.resolved = {\n\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\ttimestampHash: /** @type {string} */ (hash.digest(\"hex\"))\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\t_readContextHash(path, callback) {\n\t\tthis._readContext(\n\t\t\t{\n\t\t\t\tpath,\n\t\t\t\tfromImmutablePath: () => \"\",\n\t\t\t\tfromManagedItem: info => info || \"\",\n\t\t\t\tfromSymlink: (file, target, callback) => {\n\t\t\t\t\tcallback(null, {\n\t\t\t\t\t\thash: target,\n\t\t\t\t\t\tsymlinks: new Set([target])\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tfromFile: (file, stat, callback) =>\n\t\t\t\t\tthis.getFileHash(file, (err, hash) => {\n\t\t\t\t\t\tcallback(err, hash || \"\");\n\t\t\t\t\t}),\n\t\t\t\tfromDirectory: (directory, stat, callback) => {\n\t\t\t\t\tthis.contextHashQueue.increaseParallelism();\n\t\t\t\t\tthis._getUnresolvedContextHash(directory, (err, hash) => {\n\t\t\t\t\t\tthis.contextHashQueue.decreaseParallelism();\n\t\t\t\t\t\tcallback(err, hash || \"\");\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * @param {string[]} files files\n\t\t\t\t * @param {(string | ContextHash)[]} fileHashes hashes\n\t\t\t\t * @returns {ContextHash} reduced hash\n\t\t\t\t */\n\t\t\t\treduce: (files, fileHashes) => {\n\t\t\t\t\tlet symlinks = undefined;\n\t\t\t\t\tconst hash = createHash(this._hashFunction);\n\n\t\t\t\t\tfor (const file of files) hash.update(file);\n\t\t\t\t\tfor (const entry of fileHashes) {\n\t\t\t\t\t\tif (typeof entry === \"string\") {\n\t\t\t\t\t\t\thash.update(entry);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thash.update(entry.hash);\n\t\t\t\t\t\t\tif (entry.symlinks) {\n\t\t\t\t\t\t\t\tif (symlinks === undefined) symlinks = new Set();\n\t\t\t\t\t\t\t\taddAll(entry.symlinks, symlinks);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\thash: /** @type {string} */ (hash.digest(\"hex\"))\n\t\t\t\t\t};\n\t\t\t\t\tif (symlinks) result.symlinks = symlinks;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t},\n\t\t\t(err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tthis._contextHashes.set(path, result);\n\t\t\t\treturn callback(null, result);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {ContextHash} entry context hash\n\t * @param {function((Error | null)=, string=): void} callback callback\n\t * @returns {void}\n\t */\n\t_resolveContextHash(entry, callback) {\n\t\tconst hashes = [];\n\t\tprocessAsyncTree(\n\t\t\tentry.symlinks,\n\t\t\t10,\n\t\t\t(target, push, callback) => {\n\t\t\t\tthis._getUnresolvedContextHash(target, (err, hash) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tif (hash) {\n\t\t\t\t\t\thashes.push(hash.hash);\n\t\t\t\t\t\tif (hash.symlinks !== undefined) {\n\t\t\t\t\t\t\tfor (const target of hash.symlinks) push(target);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcallback();\n\t\t\t\t});\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\t\thash.update(entry.hash);\n\t\t\t\thashes.sort();\n\t\t\t\tfor (const h of hashes) {\n\t\t\t\t\thash.update(h);\n\t\t\t\t}\n\t\t\t\tcallback(\n\t\t\t\t\tnull,\n\t\t\t\t\t(entry.resolved = /** @type {string} */ (hash.digest(\"hex\")))\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\t_readContextTimestampAndHash(path, callback) {\n\t\tconst finalize = (timestamp, hash) => {\n\t\t\tconst result =\n\t\t\t\ttimestamp === \"ignore\"\n\t\t\t\t\t? hash\n\t\t\t\t\t: {\n\t\t\t\t\t\t\t...timestamp,\n\t\t\t\t\t\t\t...hash\n\t\t\t\t\t  };\n\t\t\tthis._contextTshs.set(path, result);\n\t\t\tcallback(null, result);\n\t\t};\n\t\tconst cachedHash = this._contextHashes.get(path);\n\t\tconst cachedTimestamp = this._contextTimestamps.get(path);\n\t\tif (cachedHash !== undefined) {\n\t\t\tif (cachedTimestamp !== undefined) {\n\t\t\t\tfinalize(cachedTimestamp, cachedHash);\n\t\t\t} else {\n\t\t\t\tthis.contextTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tfinalize(entry, cachedHash);\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (cachedTimestamp !== undefined) {\n\t\t\t\tthis.contextHashQueue.add(path, (err, entry) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tfinalize(cachedTimestamp, entry);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis._readContext(\n\t\t\t\t\t{\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tfromImmutablePath: () => null,\n\t\t\t\t\t\tfromManagedItem: info => ({\n\t\t\t\t\t\t\tsafeTime: 0,\n\t\t\t\t\t\t\ttimestampHash: info,\n\t\t\t\t\t\t\thash: info || \"\"\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tfromSymlink: (fle, target, callback) => {\n\t\t\t\t\t\t\tcallback(null, {\n\t\t\t\t\t\t\t\ttimestampHash: target,\n\t\t\t\t\t\t\t\thash: target,\n\t\t\t\t\t\t\t\tsymlinks: new Set([target])\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfromFile: (file, stat, callback) => {\n\t\t\t\t\t\t\tthis._getFileTimestampAndHash(file, callback);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfromDirectory: (directory, stat, callback) => {\n\t\t\t\t\t\t\tthis.contextTshQueue.increaseParallelism();\n\t\t\t\t\t\t\tthis.contextTshQueue.add(directory, (err, result) => {\n\t\t\t\t\t\t\t\tthis.contextTshQueue.decreaseParallelism();\n\t\t\t\t\t\t\t\tcallback(err, result);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {string[]} files files\n\t\t\t\t\t\t * @param {(Partial<TimestampAndHash> & Partial<ContextTimestampAndHash> | string | null)[]} results results\n\t\t\t\t\t\t * @returns {ContextTimestampAndHash} tsh\n\t\t\t\t\t\t */\n\t\t\t\t\t\treduce: (files, results) => {\n\t\t\t\t\t\t\tlet symlinks = undefined;\n\n\t\t\t\t\t\t\tconst tsHash = createHash(this._hashFunction);\n\t\t\t\t\t\t\tconst hash = createHash(this._hashFunction);\n\n\t\t\t\t\t\t\tfor (const file of files) {\n\t\t\t\t\t\t\t\ttsHash.update(file);\n\t\t\t\t\t\t\t\thash.update(file);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet safeTime = 0;\n\t\t\t\t\t\t\tfor (const entry of results) {\n\t\t\t\t\t\t\t\tif (!entry) {\n\t\t\t\t\t\t\t\t\ttsHash.update(\"n\");\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (typeof entry === \"string\") {\n\t\t\t\t\t\t\t\t\ttsHash.update(\"n\");\n\t\t\t\t\t\t\t\t\thash.update(entry);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (entry.timestamp) {\n\t\t\t\t\t\t\t\t\ttsHash.update(\"f\");\n\t\t\t\t\t\t\t\t\ttsHash.update(`${entry.timestamp}`);\n\t\t\t\t\t\t\t\t} else if (entry.timestampHash) {\n\t\t\t\t\t\t\t\t\ttsHash.update(\"d\");\n\t\t\t\t\t\t\t\t\ttsHash.update(`${entry.timestampHash}`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (entry.symlinks !== undefined) {\n\t\t\t\t\t\t\t\t\tif (symlinks === undefined) symlinks = new Set();\n\t\t\t\t\t\t\t\t\taddAll(entry.symlinks, symlinks);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (entry.safeTime) {\n\t\t\t\t\t\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\thash.update(entry.hash);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst result = {\n\t\t\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\t\t\ttimestampHash: /** @type {string} */ (tsHash.digest(\"hex\")),\n\t\t\t\t\t\t\t\thash: /** @type {string} */ (hash.digest(\"hex\"))\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (symlinks) result.symlinks = symlinks;\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tthis._contextTshs.set(path, result);\n\t\t\t\t\t\treturn callback(null, result);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {ContextTimestampAndHash} entry entry\n\t * @param {function((Error | null)=, ResolvedContextTimestampAndHash=): void} callback callback\n\t * @returns {void}\n\t */\n\t_resolveContextTsh(entry, callback) {\n\t\tconst hashes = [];\n\t\tconst tsHashes = [];\n\t\tlet safeTime = 0;\n\t\tprocessAsyncTree(\n\t\t\tentry.symlinks,\n\t\t\t10,\n\t\t\t(target, push, callback) => {\n\t\t\t\tthis._getUnresolvedContextTsh(target, (err, entry) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\thashes.push(entry.hash);\n\t\t\t\t\t\tif (entry.timestampHash) tsHashes.push(entry.timestampHash);\n\t\t\t\t\t\tif (entry.safeTime) {\n\t\t\t\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (entry.symlinks !== undefined) {\n\t\t\t\t\t\t\tfor (const target of entry.symlinks) push(target);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcallback();\n\t\t\t\t});\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\t\tconst tsHash = createHash(this._hashFunction);\n\t\t\t\thash.update(entry.hash);\n\t\t\t\tif (entry.timestampHash) tsHash.update(entry.timestampHash);\n\t\t\t\tif (entry.safeTime) {\n\t\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t\t}\n\t\t\t\thashes.sort();\n\t\t\t\tfor (const h of hashes) {\n\t\t\t\t\thash.update(h);\n\t\t\t\t}\n\t\t\t\ttsHashes.sort();\n\t\t\t\tfor (const h of tsHashes) {\n\t\t\t\t\ttsHash.update(h);\n\t\t\t\t}\n\t\t\t\tcallback(\n\t\t\t\t\tnull,\n\t\t\t\t\t(entry.resolved = {\n\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\ttimestampHash: /** @type {string} */ (tsHash.digest(\"hex\")),\n\t\t\t\t\t\thash: /** @type {string} */ (hash.digest(\"hex\"))\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\t_getManagedItemDirectoryInfo(path, callback) {\n\t\tthis.fs.readdir(path, (err, elements) => {\n\t\t\tif (err) {\n\t\t\t\tif (err.code === \"ENOENT\" || err.code === \"ENOTDIR\") {\n\t\t\t\t\treturn callback(null, EMPTY_SET);\n\t\t\t\t}\n\t\t\t\treturn callback(err);\n\t\t\t}\n\t\t\tconst set = new Set(\n\t\t\t\t/** @type {string[]} */ (elements).map(element =>\n\t\t\t\t\tjoin(this.fs, path, element)\n\t\t\t\t)\n\t\t\t);\n\t\t\tcallback(null, set);\n\t\t});\n\t}\n\n\t_getManagedItemInfo(path, callback) {\n\t\tconst dir = dirname(this.fs, path);\n\t\tthis.managedItemDirectoryQueue.add(dir, (err, elements) => {\n\t\t\tif (err) {\n\t\t\t\treturn callback(err);\n\t\t\t}\n\t\t\tif (!elements.has(path)) {\n\t\t\t\t// file or directory doesn't exist\n\t\t\t\tthis._managedItems.set(path, \"*missing\");\n\t\t\t\treturn callback(null, \"*missing\");\n\t\t\t}\n\t\t\t// something exists\n\t\t\t// it may be a file or directory\n\t\t\tif (\n\t\t\t\tpath.endsWith(\"node_modules\") &&\n\t\t\t\t(path.endsWith(\"/node_modules\") || path.endsWith(\"\\\\node_modules\"))\n\t\t\t) {\n\t\t\t\t// we are only interested in existence of this special directory\n\t\t\t\tthis._managedItems.set(path, \"*node_modules\");\n\t\t\t\treturn callback(null, \"*node_modules\");\n\t\t\t}\n\n\t\t\t// we assume it's a directory, as files shouldn't occur in managed paths\n\t\t\tconst packageJsonPath = join(this.fs, path, \"package.json\");\n\t\t\tthis.fs.readFile(packageJsonPath, (err, content) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (err.code === \"ENOENT\" || err.code === \"ENOTDIR\") {\n\t\t\t\t\t\t// no package.json or path is not a directory\n\t\t\t\t\t\tthis.fs.readdir(path, (err, elements) => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!err &&\n\t\t\t\t\t\t\t\telements.length === 1 &&\n\t\t\t\t\t\t\t\telements[0] === \"node_modules\"\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t// This is only a grouping folder e. g. used by yarn\n\t\t\t\t\t\t\t\t// we are only interested in existence of this special directory\n\t\t\t\t\t\t\t\tthis._managedItems.set(path, \"*nested\");\n\t\t\t\t\t\t\t\treturn callback(null, \"*nested\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.logger.warn(\n\t\t\t\t\t\t\t\t`Managed item ${path} isn't a directory or doesn't contain a package.json (see snapshot.managedPaths option)`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\t\t\t\tlet data;\n\t\t\t\ttry {\n\t\t\t\t\tdata = JSON.parse(content.toString(\"utf-8\"));\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn callback(e);\n\t\t\t\t}\n\t\t\t\tif (!data.name) {\n\t\t\t\t\tthis.logger.warn(\n\t\t\t\t\t\t`${packageJsonPath} doesn't contain a \"name\" property (see snapshot.managedPaths option)`\n\t\t\t\t\t);\n\t\t\t\t\treturn callback();\n\t\t\t\t}\n\t\t\t\tconst info = `${data.name || \"\"}@${data.version || \"\"}`;\n\t\t\t\tthis._managedItems.set(path, info);\n\t\t\t\tcallback(null, info);\n\t\t\t});\n\t\t});\n\t}\n\n\tgetDeprecatedFileTimestamps() {\n\t\tif (this._cachedDeprecatedFileTimestamps !== undefined)\n\t\t\treturn this._cachedDeprecatedFileTimestamps;\n\t\tconst map = new Map();\n\t\tfor (const [path, info] of this._fileTimestamps) {\n\t\t\tif (info) map.set(path, typeof info === \"object\" ? info.safeTime : null);\n\t\t}\n\t\treturn (this._cachedDeprecatedFileTimestamps = map);\n\t}\n\n\tgetDeprecatedContextTimestamps() {\n\t\tif (this._cachedDeprecatedContextTimestamps !== undefined)\n\t\t\treturn this._cachedDeprecatedContextTimestamps;\n\t\tconst map = new Map();\n\t\tfor (const [path, info] of this._contextTimestamps) {\n\t\t\tif (info) map.set(path, typeof info === \"object\" ? info.safeTime : null);\n\t\t}\n\t\treturn (this._cachedDeprecatedContextTimestamps = map);\n\t}\n}\n\nmodule.exports = FileSystemInfo;\nmodule.exports.Snapshot = Snapshot;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}