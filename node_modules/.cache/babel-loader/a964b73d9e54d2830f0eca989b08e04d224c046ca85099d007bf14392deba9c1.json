{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nvar _objectSpread = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar path = require(\"path\");\nvar DescriptionFileUtils = require(\"./DescriptionFileUtils\");\nvar forEachBail = require(\"./forEachBail\");\nvar _require = require(\"./util/entrypoints\"),\n  processExportsField = _require.processExportsField;\nvar _require2 = require(\"./util/identifier\"),\n  parseIdentifier = _require2.parseIdentifier;\nvar _require3 = require(\"./util/path\"),\n  checkImportsExportsFieldTarget = _require3.checkImportsExportsFieldTarget;\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n/** @typedef {import(\"./util/entrypoints\").ExportsField} ExportsField */\n/** @typedef {import(\"./util/entrypoints\").FieldProcessor} FieldProcessor */\n\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   * @param {string | ResolveStepHook} source source\n   * @param {Set<string>} conditionNames condition names\n   * @param {string | string[]} fieldNamePath name path\n   * @param {string | ResolveStepHook} target target\n   */\n  function ExportsFieldPlugin(source, conditionNames, fieldNamePath, target) {\n    _classCallCheck(this, ExportsFieldPlugin);\n    this.source = source;\n    this.target = target;\n    this.conditionNames = conditionNames;\n    this.fieldName = fieldNamePath;\n    /** @type {WeakMap<any, FieldProcessor>} */\n    this.fieldProcessorCache = new WeakMap();\n  }\n\n  /**\n   * @param {Resolver} resolver the resolver\n   * @returns {void}\n   */\n  _createClass(ExportsFieldPlugin, [{\n    key: \"apply\",\n    value: function apply(resolver) {\n      var _this = this;\n      var target = resolver.ensureHook(this.target);\n      resolver.getHook(this.source).tapAsync(\"ExportsFieldPlugin\", function (request, resolveContext, callback) {\n        // When there is no description file, abort\n        if (!request.descriptionFilePath) return callback();\n        if (\n        // When the description file is inherited from parent, abort\n        // (There is no description file inside of this package)\n        request.relativePath !== \".\" || request.request === undefined) return callback();\n        var remainingRequest = request.query || request.fragment ? (request.request === \".\" ? \"./\" : request.request) + request.query + request.fragment : request.request;\n        /** @type {ExportsField|null} */\n        var exportsField = DescriptionFileUtils.getField(request.descriptionFileData, _this.fieldName);\n        if (!exportsField) return callback();\n        if (request.directory) {\n          return callback(new Error(\"Resolving to directories is not possible with the exports field (request was \".concat(remainingRequest, \"/)\")));\n        }\n        var paths;\n        try {\n          // We attach the cache to the description file instead of the exportsField value\n          // because we use a WeakMap and the exportsField could be a string too.\n          // Description file is always an object when exports field can be accessed.\n          var fieldProcessor = _this.fieldProcessorCache.get(request.descriptionFileData);\n          if (fieldProcessor === undefined) {\n            fieldProcessor = processExportsField(exportsField);\n            _this.fieldProcessorCache.set(request.descriptionFileData, fieldProcessor);\n          }\n          paths = fieldProcessor(remainingRequest, _this.conditionNames);\n        } catch (err) {\n          if (resolveContext.log) {\n            resolveContext.log(\"Exports field in \".concat(request.descriptionFilePath, \" can't be processed: \").concat(err));\n          }\n          return callback(err);\n        }\n        if (paths.length === 0) {\n          return callback(new Error(\"Package path \".concat(remainingRequest, \" is not exported from package \").concat(request.descriptionFileRoot, \" (see exports field in \").concat(request.descriptionFilePath, \")\")));\n        }\n        forEachBail(paths, function (p, callback) {\n          var parsedIdentifier = parseIdentifier(p);\n          if (!parsedIdentifier) return callback();\n          var _parsedIdentifier = _slicedToArray(parsedIdentifier, 3),\n            relativePath = _parsedIdentifier[0],\n            query = _parsedIdentifier[1],\n            fragment = _parsedIdentifier[2];\n          var error = checkImportsExportsFieldTarget(relativePath);\n          if (error) {\n            return callback(error);\n          }\n          var obj = _objectSpread(_objectSpread({}, request), {}, {\n            request: undefined,\n            path: path.join( /** @type {string} */request.descriptionFileRoot, relativePath),\n            relativePath: relativePath,\n            query: query,\n            fragment: fragment\n          });\n          resolver.doResolve(target, obj, \"using exports field: \" + p, resolveContext, callback);\n        }, function (err, result) {\n          return callback(err, result || null);\n        });\n      });\n    }\n  }]);\n  return ExportsFieldPlugin;\n}();","map":{"version":3,"names":["path","require","DescriptionFileUtils","forEachBail","processExportsField","parseIdentifier","checkImportsExportsFieldTarget","module","exports","source","conditionNames","fieldNamePath","target","fieldName","fieldProcessorCache","WeakMap","resolver","ensureHook","getHook","tapAsync","request","resolveContext","callback","descriptionFilePath","relativePath","undefined","remainingRequest","query","fragment","exportsField","getField","descriptionFileData","directory","Error","paths","fieldProcessor","get","set","err","log","length","descriptionFileRoot","p","parsedIdentifier","error","obj","join","doResolve","result"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/enhanced-resolve/lib/ExportsFieldPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\nconst forEachBail = require(\"./forEachBail\");\nconst { processExportsField } = require(\"./util/entrypoints\");\nconst { parseIdentifier } = require(\"./util/identifier\");\nconst { checkImportsExportsFieldTarget } = require(\"./util/path\");\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n/** @typedef {import(\"./util/entrypoints\").ExportsField} ExportsField */\n/** @typedef {import(\"./util/entrypoints\").FieldProcessor} FieldProcessor */\n\nmodule.exports = class ExportsFieldPlugin {\n\t/**\n\t * @param {string | ResolveStepHook} source source\n\t * @param {Set<string>} conditionNames condition names\n\t * @param {string | string[]} fieldNamePath name path\n\t * @param {string | ResolveStepHook} target target\n\t */\n\tconstructor(source, conditionNames, fieldNamePath, target) {\n\t\tthis.source = source;\n\t\tthis.target = target;\n\t\tthis.conditionNames = conditionNames;\n\t\tthis.fieldName = fieldNamePath;\n\t\t/** @type {WeakMap<any, FieldProcessor>} */\n\t\tthis.fieldProcessorCache = new WeakMap();\n\t}\n\n\t/**\n\t * @param {Resolver} resolver the resolver\n\t * @returns {void}\n\t */\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ExportsFieldPlugin\", (request, resolveContext, callback) => {\n\t\t\t\t// When there is no description file, abort\n\t\t\t\tif (!request.descriptionFilePath) return callback();\n\t\t\t\tif (\n\t\t\t\t\t// When the description file is inherited from parent, abort\n\t\t\t\t\t// (There is no description file inside of this package)\n\t\t\t\t\trequest.relativePath !== \".\" ||\n\t\t\t\t\trequest.request === undefined\n\t\t\t\t)\n\t\t\t\t\treturn callback();\n\n\t\t\t\tconst remainingRequest =\n\t\t\t\t\trequest.query || request.fragment\n\t\t\t\t\t\t? (request.request === \".\" ? \"./\" : request.request) +\n\t\t\t\t\t\t  request.query +\n\t\t\t\t\t\t  request.fragment\n\t\t\t\t\t\t: request.request;\n\t\t\t\t/** @type {ExportsField|null} */\n\t\t\t\tconst exportsField = DescriptionFileUtils.getField(\n\t\t\t\t\trequest.descriptionFileData,\n\t\t\t\t\tthis.fieldName\n\t\t\t\t);\n\t\t\t\tif (!exportsField) return callback();\n\n\t\t\t\tif (request.directory) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`Resolving to directories is not possible with the exports field (request was ${remainingRequest}/)`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet paths;\n\n\t\t\t\ttry {\n\t\t\t\t\t// We attach the cache to the description file instead of the exportsField value\n\t\t\t\t\t// because we use a WeakMap and the exportsField could be a string too.\n\t\t\t\t\t// Description file is always an object when exports field can be accessed.\n\t\t\t\t\tlet fieldProcessor = this.fieldProcessorCache.get(\n\t\t\t\t\t\trequest.descriptionFileData\n\t\t\t\t\t);\n\t\t\t\t\tif (fieldProcessor === undefined) {\n\t\t\t\t\t\tfieldProcessor = processExportsField(exportsField);\n\t\t\t\t\t\tthis.fieldProcessorCache.set(\n\t\t\t\t\t\t\trequest.descriptionFileData,\n\t\t\t\t\t\t\tfieldProcessor\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpaths = fieldProcessor(remainingRequest, this.conditionNames);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (resolveContext.log) {\n\t\t\t\t\t\tresolveContext.log(\n\t\t\t\t\t\t\t`Exports field in ${request.descriptionFilePath} can't be processed: ${err}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\n\t\t\t\tif (paths.length === 0) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`Package path ${remainingRequest} is not exported from package ${request.descriptionFileRoot} (see exports field in ${request.descriptionFilePath})`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tforEachBail(\n\t\t\t\t\tpaths,\n\t\t\t\t\t(p, callback) => {\n\t\t\t\t\t\tconst parsedIdentifier = parseIdentifier(p);\n\n\t\t\t\t\t\tif (!parsedIdentifier) return callback();\n\n\t\t\t\t\t\tconst [relativePath, query, fragment] = parsedIdentifier;\n\n\t\t\t\t\t\tconst error = checkImportsExportsFieldTarget(relativePath);\n\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\treturn callback(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t...request,\n\t\t\t\t\t\t\trequest: undefined,\n\t\t\t\t\t\t\tpath: path.join(\n\t\t\t\t\t\t\t\t/** @type {string} */ (request.descriptionFileRoot),\n\t\t\t\t\t\t\t\trelativePath\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trelativePath,\n\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\tfragment\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\"using exports field: \" + p,\n\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t(err, result) => callback(err, result || null)\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}