{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _objectSpread = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar LazySet = require(\"../util/LazySet\");\nvar makeSerializable = require(\"../util/makeSerializable\");\n\n/** @typedef {import(\"enhanced-resolve/lib/Resolver\")} Resolver */\n/** @typedef {import(\"../CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../FileSystemInfo\")} FileSystemInfo */\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\nvar CacheEntry = /*#__PURE__*/function () {\n  function CacheEntry(result, snapshot) {\n    _classCallCheck(this, CacheEntry);\n    this.result = result;\n    this.snapshot = snapshot;\n  }\n  _createClass(CacheEntry, [{\n    key: \"serialize\",\n    value: function serialize(_ref) {\n      var write = _ref.write;\n      write(this.result);\n      write(this.snapshot);\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(_ref2) {\n      var read = _ref2.read;\n      this.result = read();\n      this.snapshot = read();\n    }\n  }]);\n  return CacheEntry;\n}();\nmakeSerializable(CacheEntry, \"webpack/lib/cache/ResolverCachePlugin\");\n\n/**\n * @template T\n * @param {Set<T> | LazySet<T>} set set to add items to\n * @param {Set<T> | LazySet<T>} otherSet set to add items from\n * @returns {void}\n */\nvar addAllToSet = function addAllToSet(set, otherSet) {\n  if (set instanceof LazySet) {\n    set.addAll(otherSet);\n  } else {\n    var _iterator = _createForOfIteratorHelper(otherSet),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n        set.add(item);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n};\n\n/**\n * @param {Object} object an object\n * @param {boolean} excludeContext if true, context is not included in string\n * @returns {string} stringified version\n */\nvar objectToString = function objectToString(object, excludeContext) {\n  var str = \"\";\n  for (var key in object) {\n    if (excludeContext && key === \"context\") continue;\n    var value = object[key];\n    if (typeof value === \"object\" && value !== null) {\n      str += \"|\".concat(key, \"=[\").concat(objectToString(value, false), \"|]\");\n    } else {\n      str += \"|\".concat(key, \"=|\").concat(value);\n    }\n  }\n  return str;\n};\nvar ResolverCachePlugin = /*#__PURE__*/function () {\n  function ResolverCachePlugin() {\n    _classCallCheck(this, ResolverCachePlugin);\n  }\n  _createClass(ResolverCachePlugin, [{\n    key: \"apply\",\n    value:\n    /**\n     * Apply the plugin\n     * @param {Compiler} compiler the compiler instance\n     * @returns {void}\n     */\n    function apply(compiler) {\n      var cache = compiler.getCache(\"ResolverCachePlugin\");\n      /** @type {FileSystemInfo} */\n      var fileSystemInfo;\n      var snapshotOptions;\n      var realResolves = 0;\n      var cachedResolves = 0;\n      var cacheInvalidResolves = 0;\n      var concurrentResolves = 0;\n      compiler.hooks.thisCompilation.tap(\"ResolverCachePlugin\", function (compilation) {\n        snapshotOptions = compilation.options.snapshot.resolve;\n        fileSystemInfo = compilation.fileSystemInfo;\n        compilation.hooks.finishModules.tap(\"ResolverCachePlugin\", function () {\n          if (realResolves + cachedResolves > 0) {\n            var logger = compilation.getLogger(\"webpack.ResolverCachePlugin\");\n            logger.log(\"\".concat(Math.round(100 * realResolves / (realResolves + cachedResolves)), \"% really resolved (\").concat(realResolves, \" real resolves with \").concat(cacheInvalidResolves, \" cached but invalid, \").concat(cachedResolves, \" cached valid, \").concat(concurrentResolves, \" concurrent)\"));\n            realResolves = 0;\n            cachedResolves = 0;\n            cacheInvalidResolves = 0;\n            concurrentResolves = 0;\n          }\n        });\n      });\n      /**\n       * @param {ItemCacheFacade} itemCache cache\n       * @param {Resolver} resolver the resolver\n       * @param {Object} resolveContext context for resolving meta info\n       * @param {Object} request the request info object\n       * @param {function((Error | null)=, Object=): void} callback callback function\n       * @returns {void}\n       */\n      var doRealResolve = function doRealResolve(itemCache, resolver, resolveContext, request, callback) {\n        realResolves++;\n        var newRequest = _objectSpread({\n          _ResolverCachePluginCacheMiss: true\n        }, request);\n        var newResolveContext = _objectSpread(_objectSpread({}, resolveContext), {}, {\n          stack: new Set(),\n          missingDependencies: new LazySet(),\n          fileDependencies: new LazySet(),\n          contextDependencies: new LazySet()\n        });\n        var yieldResult;\n        var withYield = false;\n        if (typeof newResolveContext.yield === \"function\") {\n          yieldResult = [];\n          withYield = true;\n          newResolveContext.yield = function (obj) {\n            return yieldResult.push(obj);\n          };\n        }\n        var propagate = function propagate(key) {\n          if (resolveContext[key]) {\n            addAllToSet(resolveContext[key], newResolveContext[key]);\n          }\n        };\n        var resolveTime = Date.now();\n        resolver.doResolve(resolver.hooks.resolve, newRequest, \"Cache miss\", newResolveContext, function (err, result) {\n          propagate(\"fileDependencies\");\n          propagate(\"contextDependencies\");\n          propagate(\"missingDependencies\");\n          if (err) return callback(err);\n          var fileDependencies = newResolveContext.fileDependencies;\n          var contextDependencies = newResolveContext.contextDependencies;\n          var missingDependencies = newResolveContext.missingDependencies;\n          fileSystemInfo.createSnapshot(resolveTime, fileDependencies, contextDependencies, missingDependencies, snapshotOptions, function (err, snapshot) {\n            if (err) return callback(err);\n            var resolveResult = withYield ? yieldResult : result;\n            // since we intercept resolve hook\n            // we still can get result in callback\n            if (withYield && result) yieldResult.push(result);\n            if (!snapshot) {\n              if (resolveResult) return callback(null, resolveResult);\n              return callback();\n            }\n            itemCache.store(new CacheEntry(resolveResult, snapshot), function (storeErr) {\n              if (storeErr) return callback(storeErr);\n              if (resolveResult) return callback(null, resolveResult);\n              callback();\n            });\n          });\n        });\n      };\n      compiler.resolverFactory.hooks.resolver.intercept({\n        factory: function factory(type, hook) {\n          /** @type {Map<string, (function(Error=, Object=): void)[]>} */\n          var activeRequests = new Map();\n          /** @type {Map<string, [function(Error=, Object=): void, function(Error=, Object=): void][]>} */\n          var activeRequestsWithYield = new Map();\n          hook.tap(\"ResolverCachePlugin\",\n          /**\n           * @param {Resolver} resolver the resolver\n           * @param {Object} options resolve options\n           * @param {Object} userOptions resolve options passed by the user\n           * @returns {void}\n           */\n          function (resolver, options, userOptions) {\n            if (options.cache !== true) return;\n            var optionsIdent = objectToString(userOptions, false);\n            var cacheWithContext = options.cacheWithContext !== undefined ? options.cacheWithContext : false;\n            resolver.hooks.resolve.tapAsync({\n              name: \"ResolverCachePlugin\",\n              stage: -100\n            }, function (request, resolveContext, callback) {\n              if (request._ResolverCachePluginCacheMiss || !fileSystemInfo) {\n                return callback();\n              }\n              var withYield = typeof resolveContext.yield === \"function\";\n              var identifier = \"\".concat(type).concat(withYield ? \"|yield\" : \"|default\").concat(optionsIdent).concat(objectToString(request, !cacheWithContext));\n              if (withYield) {\n                var activeRequest = activeRequestsWithYield.get(identifier);\n                if (activeRequest) {\n                  activeRequest[0].push(callback);\n                  activeRequest[1].push(resolveContext.yield);\n                  return;\n                }\n              } else {\n                var _activeRequest = activeRequests.get(identifier);\n                if (_activeRequest) {\n                  _activeRequest.push(callback);\n                  return;\n                }\n              }\n              var itemCache = cache.getItemCache(identifier, null);\n              var callbacks, yields;\n              var done = withYield ? function (err, result) {\n                if (callbacks === undefined) {\n                  if (err) {\n                    callback(err);\n                  } else {\n                    if (result) {\n                      var _iterator2 = _createForOfIteratorHelper(result),\n                        _step2;\n                      try {\n                        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                          var r = _step2.value;\n                          resolveContext.yield(r);\n                        }\n                      } catch (err) {\n                        _iterator2.e(err);\n                      } finally {\n                        _iterator2.f();\n                      }\n                    }\n                    callback(null, null);\n                  }\n                  yields = undefined;\n                  callbacks = false;\n                } else {\n                  if (err) {\n                    var _iterator3 = _createForOfIteratorHelper(callbacks),\n                      _step3;\n                    try {\n                      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                        var cb = _step3.value;\n                        cb(err);\n                      }\n                    } catch (err) {\n                      _iterator3.e(err);\n                    } finally {\n                      _iterator3.f();\n                    }\n                  } else {\n                    for (var i = 0; i < callbacks.length; i++) {\n                      var _cb = callbacks[i];\n                      var yield_ = yields[i];\n                      if (result) {\n                        var _iterator4 = _createForOfIteratorHelper(result),\n                          _step4;\n                        try {\n                          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                            var _r = _step4.value;\n                            yield_(_r);\n                          }\n                        } catch (err) {\n                          _iterator4.e(err);\n                        } finally {\n                          _iterator4.f();\n                        }\n                      }\n                      _cb(null, null);\n                    }\n                  }\n                  activeRequestsWithYield.delete(identifier);\n                  yields = undefined;\n                  callbacks = false;\n                }\n              } : function (err, result) {\n                if (callbacks === undefined) {\n                  callback(err, result);\n                  callbacks = false;\n                } else {\n                  var _iterator5 = _createForOfIteratorHelper(callbacks),\n                    _step5;\n                  try {\n                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                      var _callback = _step5.value;\n                      _callback(err, result);\n                    }\n                  } catch (err) {\n                    _iterator5.e(err);\n                  } finally {\n                    _iterator5.f();\n                  }\n                  activeRequests.delete(identifier);\n                  callbacks = false;\n                }\n              };\n              /**\n               * @param {Error=} err error if any\n               * @param {CacheEntry=} cacheEntry cache entry\n               * @returns {void}\n               */\n              var processCacheResult = function processCacheResult(err, cacheEntry) {\n                if (err) return done(err);\n                if (cacheEntry) {\n                  var snapshot = cacheEntry.snapshot,\n                    result = cacheEntry.result;\n                  fileSystemInfo.checkSnapshotValid(snapshot, function (err, valid) {\n                    if (err || !valid) {\n                      cacheInvalidResolves++;\n                      return doRealResolve(itemCache, resolver, resolveContext, request, done);\n                    }\n                    cachedResolves++;\n                    if (resolveContext.missingDependencies) {\n                      addAllToSet(resolveContext.missingDependencies, snapshot.getMissingIterable());\n                    }\n                    if (resolveContext.fileDependencies) {\n                      addAllToSet(resolveContext.fileDependencies, snapshot.getFileIterable());\n                    }\n                    if (resolveContext.contextDependencies) {\n                      addAllToSet(resolveContext.contextDependencies, snapshot.getContextIterable());\n                    }\n                    done(null, result);\n                  });\n                } else {\n                  doRealResolve(itemCache, resolver, resolveContext, request, done);\n                }\n              };\n              itemCache.get(processCacheResult);\n              if (withYield && callbacks === undefined) {\n                callbacks = [callback];\n                yields = [resolveContext.yield];\n                activeRequestsWithYield.set(identifier, /** @type {[any, any]} */[callbacks, yields]);\n              } else if (callbacks === undefined) {\n                callbacks = [callback];\n                activeRequests.set(identifier, callbacks);\n              }\n            });\n          });\n          return hook;\n        }\n      });\n    }\n  }]);\n  return ResolverCachePlugin;\n}();\nmodule.exports = ResolverCachePlugin;","map":{"version":3,"names":["LazySet","require","makeSerializable","CacheEntry","result","snapshot","write","read","addAllToSet","set","otherSet","addAll","item","add","objectToString","object","excludeContext","str","key","value","ResolverCachePlugin","compiler","cache","getCache","fileSystemInfo","snapshotOptions","realResolves","cachedResolves","cacheInvalidResolves","concurrentResolves","hooks","thisCompilation","tap","compilation","options","resolve","finishModules","logger","getLogger","log","Math","round","doRealResolve","itemCache","resolver","resolveContext","request","callback","newRequest","_ResolverCachePluginCacheMiss","newResolveContext","stack","Set","missingDependencies","fileDependencies","contextDependencies","yieldResult","withYield","yield","obj","push","propagate","resolveTime","Date","now","doResolve","err","createSnapshot","resolveResult","store","storeErr","resolverFactory","intercept","factory","type","hook","activeRequests","Map","activeRequestsWithYield","userOptions","optionsIdent","cacheWithContext","undefined","tapAsync","name","stage","identifier","activeRequest","get","getItemCache","callbacks","yields","done","r","cb","i","length","yield_","delete","processCacheResult","cacheEntry","checkSnapshotValid","valid","getMissingIterable","getFileIterable","getContextIterable","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/cache/ResolverCachePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst LazySet = require(\"../util/LazySet\");\nconst makeSerializable = require(\"../util/makeSerializable\");\n\n/** @typedef {import(\"enhanced-resolve/lib/Resolver\")} Resolver */\n/** @typedef {import(\"../CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../FileSystemInfo\")} FileSystemInfo */\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n\nclass CacheEntry {\n\tconstructor(result, snapshot) {\n\t\tthis.result = result;\n\t\tthis.snapshot = snapshot;\n\t}\n\n\tserialize({ write }) {\n\t\twrite(this.result);\n\t\twrite(this.snapshot);\n\t}\n\n\tdeserialize({ read }) {\n\t\tthis.result = read();\n\t\tthis.snapshot = read();\n\t}\n}\n\nmakeSerializable(CacheEntry, \"webpack/lib/cache/ResolverCachePlugin\");\n\n/**\n * @template T\n * @param {Set<T> | LazySet<T>} set set to add items to\n * @param {Set<T> | LazySet<T>} otherSet set to add items from\n * @returns {void}\n */\nconst addAllToSet = (set, otherSet) => {\n\tif (set instanceof LazySet) {\n\t\tset.addAll(otherSet);\n\t} else {\n\t\tfor (const item of otherSet) {\n\t\t\tset.add(item);\n\t\t}\n\t}\n};\n\n/**\n * @param {Object} object an object\n * @param {boolean} excludeContext if true, context is not included in string\n * @returns {string} stringified version\n */\nconst objectToString = (object, excludeContext) => {\n\tlet str = \"\";\n\tfor (const key in object) {\n\t\tif (excludeContext && key === \"context\") continue;\n\t\tconst value = object[key];\n\t\tif (typeof value === \"object\" && value !== null) {\n\t\t\tstr += `|${key}=[${objectToString(value, false)}|]`;\n\t\t} else {\n\t\t\tstr += `|${key}=|${value}`;\n\t\t}\n\t}\n\treturn str;\n};\n\nclass ResolverCachePlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst cache = compiler.getCache(\"ResolverCachePlugin\");\n\t\t/** @type {FileSystemInfo} */\n\t\tlet fileSystemInfo;\n\t\tlet snapshotOptions;\n\t\tlet realResolves = 0;\n\t\tlet cachedResolves = 0;\n\t\tlet cacheInvalidResolves = 0;\n\t\tlet concurrentResolves = 0;\n\t\tcompiler.hooks.thisCompilation.tap(\"ResolverCachePlugin\", compilation => {\n\t\t\tsnapshotOptions = compilation.options.snapshot.resolve;\n\t\t\tfileSystemInfo = compilation.fileSystemInfo;\n\t\t\tcompilation.hooks.finishModules.tap(\"ResolverCachePlugin\", () => {\n\t\t\t\tif (realResolves + cachedResolves > 0) {\n\t\t\t\t\tconst logger = compilation.getLogger(\"webpack.ResolverCachePlugin\");\n\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t`${Math.round(\n\t\t\t\t\t\t\t(100 * realResolves) / (realResolves + cachedResolves)\n\t\t\t\t\t\t)}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`\n\t\t\t\t\t);\n\t\t\t\t\trealResolves = 0;\n\t\t\t\t\tcachedResolves = 0;\n\t\t\t\t\tcacheInvalidResolves = 0;\n\t\t\t\t\tconcurrentResolves = 0;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\t/**\n\t\t * @param {ItemCacheFacade} itemCache cache\n\t\t * @param {Resolver} resolver the resolver\n\t\t * @param {Object} resolveContext context for resolving meta info\n\t\t * @param {Object} request the request info object\n\t\t * @param {function((Error | null)=, Object=): void} callback callback function\n\t\t * @returns {void}\n\t\t */\n\t\tconst doRealResolve = (\n\t\t\titemCache,\n\t\t\tresolver,\n\t\t\tresolveContext,\n\t\t\trequest,\n\t\t\tcallback\n\t\t) => {\n\t\t\trealResolves++;\n\t\t\tconst newRequest = {\n\t\t\t\t_ResolverCachePluginCacheMiss: true,\n\t\t\t\t...request\n\t\t\t};\n\t\t\tconst newResolveContext = {\n\t\t\t\t...resolveContext,\n\t\t\t\tstack: new Set(),\n\t\t\t\tmissingDependencies: new LazySet(),\n\t\t\t\tfileDependencies: new LazySet(),\n\t\t\t\tcontextDependencies: new LazySet()\n\t\t\t};\n\t\t\tlet yieldResult;\n\t\t\tlet withYield = false;\n\t\t\tif (typeof newResolveContext.yield === \"function\") {\n\t\t\t\tyieldResult = [];\n\t\t\t\twithYield = true;\n\t\t\t\tnewResolveContext.yield = obj => yieldResult.push(obj);\n\t\t\t}\n\t\t\tconst propagate = key => {\n\t\t\t\tif (resolveContext[key]) {\n\t\t\t\t\taddAllToSet(resolveContext[key], newResolveContext[key]);\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst resolveTime = Date.now();\n\t\t\tresolver.doResolve(\n\t\t\t\tresolver.hooks.resolve,\n\t\t\t\tnewRequest,\n\t\t\t\t\"Cache miss\",\n\t\t\t\tnewResolveContext,\n\t\t\t\t(err, result) => {\n\t\t\t\t\tpropagate(\"fileDependencies\");\n\t\t\t\t\tpropagate(\"contextDependencies\");\n\t\t\t\t\tpropagate(\"missingDependencies\");\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tconst fileDependencies = newResolveContext.fileDependencies;\n\t\t\t\t\tconst contextDependencies = newResolveContext.contextDependencies;\n\t\t\t\t\tconst missingDependencies = newResolveContext.missingDependencies;\n\t\t\t\t\tfileSystemInfo.createSnapshot(\n\t\t\t\t\t\tresolveTime,\n\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\tcontextDependencies,\n\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\tsnapshotOptions,\n\t\t\t\t\t\t(err, snapshot) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst resolveResult = withYield ? yieldResult : result;\n\t\t\t\t\t\t\t// since we intercept resolve hook\n\t\t\t\t\t\t\t// we still can get result in callback\n\t\t\t\t\t\t\tif (withYield && result) yieldResult.push(result);\n\t\t\t\t\t\t\tif (!snapshot) {\n\t\t\t\t\t\t\t\tif (resolveResult) return callback(null, resolveResult);\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titemCache.store(\n\t\t\t\t\t\t\t\tnew CacheEntry(resolveResult, snapshot),\n\t\t\t\t\t\t\t\tstoreErr => {\n\t\t\t\t\t\t\t\t\tif (storeErr) return callback(storeErr);\n\t\t\t\t\t\t\t\t\tif (resolveResult) return callback(null, resolveResult);\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t};\n\t\tcompiler.resolverFactory.hooks.resolver.intercept({\n\t\t\tfactory(type, hook) {\n\t\t\t\t/** @type {Map<string, (function(Error=, Object=): void)[]>} */\n\t\t\t\tconst activeRequests = new Map();\n\t\t\t\t/** @type {Map<string, [function(Error=, Object=): void, function(Error=, Object=): void][]>} */\n\t\t\t\tconst activeRequestsWithYield = new Map();\n\t\t\t\thook.tap(\n\t\t\t\t\t\"ResolverCachePlugin\",\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Resolver} resolver the resolver\n\t\t\t\t\t * @param {Object} options resolve options\n\t\t\t\t\t * @param {Object} userOptions resolve options passed by the user\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\t(resolver, options, userOptions) => {\n\t\t\t\t\t\tif (options.cache !== true) return;\n\t\t\t\t\t\tconst optionsIdent = objectToString(userOptions, false);\n\t\t\t\t\t\tconst cacheWithContext =\n\t\t\t\t\t\t\toptions.cacheWithContext !== undefined\n\t\t\t\t\t\t\t\t? options.cacheWithContext\n\t\t\t\t\t\t\t\t: false;\n\t\t\t\t\t\tresolver.hooks.resolve.tapAsync(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname: \"ResolverCachePlugin\",\n\t\t\t\t\t\t\t\tstage: -100\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t(request, resolveContext, callback) => {\n\t\t\t\t\t\t\t\tif (request._ResolverCachePluginCacheMiss || !fileSystemInfo) {\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst withYield = typeof resolveContext.yield === \"function\";\n\t\t\t\t\t\t\t\tconst identifier = `${type}${\n\t\t\t\t\t\t\t\t\twithYield ? \"|yield\" : \"|default\"\n\t\t\t\t\t\t\t\t}${optionsIdent}${objectToString(request, !cacheWithContext)}`;\n\n\t\t\t\t\t\t\t\tif (withYield) {\n\t\t\t\t\t\t\t\t\tconst activeRequest = activeRequestsWithYield.get(identifier);\n\t\t\t\t\t\t\t\t\tif (activeRequest) {\n\t\t\t\t\t\t\t\t\t\tactiveRequest[0].push(callback);\n\t\t\t\t\t\t\t\t\t\tactiveRequest[1].push(resolveContext.yield);\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst activeRequest = activeRequests.get(identifier);\n\t\t\t\t\t\t\t\t\tif (activeRequest) {\n\t\t\t\t\t\t\t\t\t\tactiveRequest.push(callback);\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst itemCache = cache.getItemCache(identifier, null);\n\t\t\t\t\t\t\t\tlet callbacks, yields;\n\t\t\t\t\t\t\t\tconst done = withYield\n\t\t\t\t\t\t\t\t\t? (err, result) => {\n\t\t\t\t\t\t\t\t\t\t\tif (callbacks === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (result)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (const r of result) resolveContext.yield(r);\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(null, null);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tyields = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\tcallbacks = false;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor (const cb of callbacks) cb(err);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor (let i = 0; i < callbacks.length; i++) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst cb = callbacks[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst yield_ = yields[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (result) for (const r of result) yield_(r);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcb(null, null);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tactiveRequestsWithYield.delete(identifier);\n\t\t\t\t\t\t\t\t\t\t\t\tyields = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\tcallbacks = false;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t: (err, result) => {\n\t\t\t\t\t\t\t\t\t\t\tif (callbacks === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\tcallback(err, result);\n\t\t\t\t\t\t\t\t\t\t\t\tcallbacks = false;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tfor (const callback of callbacks) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(err, result);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tactiveRequests.delete(identifier);\n\t\t\t\t\t\t\t\t\t\t\t\tcallbacks = false;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t  };\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @param {Error=} err error if any\n\t\t\t\t\t\t\t\t * @param {CacheEntry=} cacheEntry cache entry\n\t\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst processCacheResult = (err, cacheEntry) => {\n\t\t\t\t\t\t\t\t\tif (err) return done(err);\n\n\t\t\t\t\t\t\t\t\tif (cacheEntry) {\n\t\t\t\t\t\t\t\t\t\tconst { snapshot, result } = cacheEntry;\n\t\t\t\t\t\t\t\t\t\tfileSystemInfo.checkSnapshotValid(\n\t\t\t\t\t\t\t\t\t\t\tsnapshot,\n\t\t\t\t\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err || !valid) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcacheInvalidResolves++;\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn doRealResolve(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\titemCache,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolver,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdone\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tcachedResolves++;\n\t\t\t\t\t\t\t\t\t\t\t\tif (resolveContext.missingDependencies) {\n\t\t\t\t\t\t\t\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext.missingDependencies,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot.getMissingIterable()\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (resolveContext.fileDependencies) {\n\t\t\t\t\t\t\t\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext.fileDependencies,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot.getFileIterable()\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (resolveContext.contextDependencies) {\n\t\t\t\t\t\t\t\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext.contextDependencies,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot.getContextIterable()\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tdone(null, result);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tdoRealResolve(\n\t\t\t\t\t\t\t\t\t\t\titemCache,\n\t\t\t\t\t\t\t\t\t\t\tresolver,\n\t\t\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t\t\t\tdone\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\titemCache.get(processCacheResult);\n\t\t\t\t\t\t\t\tif (withYield && callbacks === undefined) {\n\t\t\t\t\t\t\t\t\tcallbacks = [callback];\n\t\t\t\t\t\t\t\t\tyields = [resolveContext.yield];\n\t\t\t\t\t\t\t\t\tactiveRequestsWithYield.set(\n\t\t\t\t\t\t\t\t\t\tidentifier,\n\t\t\t\t\t\t\t\t\t\t/** @type {[any, any]} */ ([callbacks, yields])\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else if (callbacks === undefined) {\n\t\t\t\t\t\t\t\t\tcallbacks = [callback];\n\t\t\t\t\t\t\t\t\tactiveRequests.set(identifier, callbacks);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\treturn hook;\n\t\t\t}\n\t\t});\n\t}\n}\n\nmodule.exports = ResolverCachePlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}