{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar path = require(\"path\");\n\n/**\n * @template T\n * @typedef {Object} TreeNode\n * @property {string} filePath\n * @property {TreeNode} parent\n * @property {TreeNode[]} children\n * @property {number} entries\n * @property {boolean} active\n * @property {T[] | T | undefined} value\n */\n\n/**\n * @template T\n * @param {Map<string, T[] | T} plan\n * @param {number} limit\n * @returns {Map<string, Map<T, string>>} the new plan\n */\nmodule.exports = function (plan, limit) {\n  var treeMap = new Map();\n  // Convert to tree\n  var _iterator = _createForOfIteratorHelper(plan),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n        filePath = _step$value[0],\n        value = _step$value[1];\n      treeMap.set(filePath, {\n        filePath: filePath,\n        parent: undefined,\n        children: undefined,\n        entries: 1,\n        active: true,\n        value: value\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var currentCount = treeMap.size;\n  // Create parents and calculate sum of entries\n  var _iterator2 = _createForOfIteratorHelper(treeMap.values()),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _node2 = _step2.value;\n      var parentPath = path.dirname(_node2.filePath);\n      if (parentPath !== _node2.filePath) {\n        var _parent = treeMap.get(parentPath);\n        if (_parent === undefined) {\n          _parent = {\n            filePath: parentPath,\n            parent: undefined,\n            children: [_node2],\n            entries: _node2.entries,\n            active: false,\n            value: undefined\n          };\n          treeMap.set(parentPath, _parent);\n          _node2.parent = _parent;\n        } else {\n          _node2.parent = _parent;\n          if (_parent.children === undefined) {\n            _parent.children = [_node2];\n          } else {\n            _parent.children.push(_node2);\n          }\n          do {\n            _parent.entries += _node2.entries;\n            _parent = _parent.parent;\n          } while (_parent);\n        }\n      }\n    }\n    // Reduce until limit reached\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  while (currentCount > limit) {\n    // Select node that helps reaching the limit most effectively without overmerging\n    var overLimit = currentCount - limit;\n    var bestNode = undefined;\n    var bestCost = Infinity;\n    var _iterator3 = _createForOfIteratorHelper(treeMap.values()),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var node = _step3.value;\n        if (node.entries <= 1 || !node.children || !node.parent) continue;\n        if (node.children.length === 0) continue;\n        if (node.children.length === 1 && !node.value) continue;\n        // Try to select the node with has just a bit more entries than we need to reduce\n        // When just a bit more is over 30% over the limit,\n        // also consider just a bit less entries then we need to reduce\n        var cost = node.entries - 1 >= overLimit ? node.entries - 1 - overLimit : overLimit - node.entries + 1 + limit * 0.3;\n        if (cost < bestCost) {\n          bestNode = node;\n          bestCost = cost;\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    if (!bestNode) break;\n    // Merge all children\n    var reduction = bestNode.entries - 1;\n    bestNode.active = true;\n    bestNode.entries = 1;\n    currentCount -= reduction;\n    var parent = bestNode.parent;\n    while (parent) {\n      parent.entries -= reduction;\n      parent = parent.parent;\n    }\n    var queue = new Set(bestNode.children);\n    var _iterator4 = _createForOfIteratorHelper(queue),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _node = _step4.value;\n        _node.active = false;\n        _node.entries = 0;\n        if (_node.children) {\n          var _iterator5 = _createForOfIteratorHelper(_node.children),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var child = _step5.value;\n              queue.add(child);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n  // Write down new plan\n  var newPlan = new Map();\n  var _iterator6 = _createForOfIteratorHelper(treeMap.values()),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var rootNode = _step6.value;\n      if (!rootNode.active) continue;\n      var map = new Map();\n      var _queue = new Set([rootNode]);\n      var _iterator7 = _createForOfIteratorHelper(_queue),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _node3 = _step7.value;\n          if (_node3.active && _node3 !== rootNode) continue;\n          if (_node3.value) {\n            if (Array.isArray(_node3.value)) {\n              var _iterator8 = _createForOfIteratorHelper(_node3.value),\n                _step8;\n              try {\n                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                  var item = _step8.value;\n                  map.set(item, _node3.filePath);\n                }\n              } catch (err) {\n                _iterator8.e(err);\n              } finally {\n                _iterator8.f();\n              }\n            } else {\n              map.set(_node3.value, _node3.filePath);\n            }\n          }\n          if (_node3.children) {\n            var _iterator9 = _createForOfIteratorHelper(_node3.children),\n              _step9;\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var _child = _step9.value;\n                _queue.add(_child);\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      newPlan.set(rootNode.filePath, map);\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  return newPlan;\n};","map":{"version":3,"names":["path","require","module","exports","plan","limit","treeMap","Map","filePath","value","set","parent","undefined","children","entries","active","currentCount","size","values","node","parentPath","dirname","get","push","overLimit","bestNode","bestCost","Infinity","length","cost","reduction","queue","Set","child","add","newPlan","rootNode","map","Array","isArray","item"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/watchpack/lib/reducePlan.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst path = require(\"path\");\n\n/**\n * @template T\n * @typedef {Object} TreeNode\n * @property {string} filePath\n * @property {TreeNode} parent\n * @property {TreeNode[]} children\n * @property {number} entries\n * @property {boolean} active\n * @property {T[] | T | undefined} value\n */\n\n/**\n * @template T\n * @param {Map<string, T[] | T} plan\n * @param {number} limit\n * @returns {Map<string, Map<T, string>>} the new plan\n */\nmodule.exports = (plan, limit) => {\n\tconst treeMap = new Map();\n\t// Convert to tree\n\tfor (const [filePath, value] of plan) {\n\t\ttreeMap.set(filePath, {\n\t\t\tfilePath,\n\t\t\tparent: undefined,\n\t\t\tchildren: undefined,\n\t\t\tentries: 1,\n\t\t\tactive: true,\n\t\t\tvalue\n\t\t});\n\t}\n\tlet currentCount = treeMap.size;\n\t// Create parents and calculate sum of entries\n\tfor (const node of treeMap.values()) {\n\t\tconst parentPath = path.dirname(node.filePath);\n\t\tif (parentPath !== node.filePath) {\n\t\t\tlet parent = treeMap.get(parentPath);\n\t\t\tif (parent === undefined) {\n\t\t\t\tparent = {\n\t\t\t\t\tfilePath: parentPath,\n\t\t\t\t\tparent: undefined,\n\t\t\t\t\tchildren: [node],\n\t\t\t\t\tentries: node.entries,\n\t\t\t\t\tactive: false,\n\t\t\t\t\tvalue: undefined\n\t\t\t\t};\n\t\t\t\ttreeMap.set(parentPath, parent);\n\t\t\t\tnode.parent = parent;\n\t\t\t} else {\n\t\t\t\tnode.parent = parent;\n\t\t\t\tif (parent.children === undefined) {\n\t\t\t\t\tparent.children = [node];\n\t\t\t\t} else {\n\t\t\t\t\tparent.children.push(node);\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tparent.entries += node.entries;\n\t\t\t\t\tparent = parent.parent;\n\t\t\t\t} while (parent);\n\t\t\t}\n\t\t}\n\t}\n\t// Reduce until limit reached\n\twhile (currentCount > limit) {\n\t\t// Select node that helps reaching the limit most effectively without overmerging\n\t\tconst overLimit = currentCount - limit;\n\t\tlet bestNode = undefined;\n\t\tlet bestCost = Infinity;\n\t\tfor (const node of treeMap.values()) {\n\t\t\tif (node.entries <= 1 || !node.children || !node.parent) continue;\n\t\t\tif (node.children.length === 0) continue;\n\t\t\tif (node.children.length === 1 && !node.value) continue;\n\t\t\t// Try to select the node with has just a bit more entries than we need to reduce\n\t\t\t// When just a bit more is over 30% over the limit,\n\t\t\t// also consider just a bit less entries then we need to reduce\n\t\t\tconst cost =\n\t\t\t\tnode.entries - 1 >= overLimit\n\t\t\t\t\t? node.entries - 1 - overLimit\n\t\t\t\t\t: overLimit - node.entries + 1 + limit * 0.3;\n\t\t\tif (cost < bestCost) {\n\t\t\t\tbestNode = node;\n\t\t\t\tbestCost = cost;\n\t\t\t}\n\t\t}\n\t\tif (!bestNode) break;\n\t\t// Merge all children\n\t\tconst reduction = bestNode.entries - 1;\n\t\tbestNode.active = true;\n\t\tbestNode.entries = 1;\n\t\tcurrentCount -= reduction;\n\t\tlet parent = bestNode.parent;\n\t\twhile (parent) {\n\t\t\tparent.entries -= reduction;\n\t\t\tparent = parent.parent;\n\t\t}\n\t\tconst queue = new Set(bestNode.children);\n\t\tfor (const node of queue) {\n\t\t\tnode.active = false;\n\t\t\tnode.entries = 0;\n\t\t\tif (node.children) {\n\t\t\t\tfor (const child of node.children) queue.add(child);\n\t\t\t}\n\t\t}\n\t}\n\t// Write down new plan\n\tconst newPlan = new Map();\n\tfor (const rootNode of treeMap.values()) {\n\t\tif (!rootNode.active) continue;\n\t\tconst map = new Map();\n\t\tconst queue = new Set([rootNode]);\n\t\tfor (const node of queue) {\n\t\t\tif (node.active && node !== rootNode) continue;\n\t\t\tif (node.value) {\n\t\t\t\tif (Array.isArray(node.value)) {\n\t\t\t\t\tfor (const item of node.value) {\n\t\t\t\t\t\tmap.set(item, node.filePath);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmap.set(node.value, node.filePath);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.children) {\n\t\t\t\tfor (const child of node.children) {\n\t\t\t\t\tqueue.add(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnewPlan.set(rootNode.filePath, map);\n\t}\n\treturn newPlan;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}