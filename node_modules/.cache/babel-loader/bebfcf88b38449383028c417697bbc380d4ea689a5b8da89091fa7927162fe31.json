{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar t = require(\"@webassemblyjs/ast\");\nvar _require = require(\"@webassemblyjs/ast\"),\n  moduleContextFromModuleAST = _require.moduleContextFromModuleAST;\nvar _require2 = require(\"@webassemblyjs/wasm-parser\"),\n  decode = _require2.decode;\nvar Parser = require(\"../Parser\");\nvar StaticExportsDependency = require(\"../dependencies/StaticExportsDependency\");\nvar WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\nvar WebAssemblyImportDependency = require(\"../dependencies/WebAssemblyImportDependency\");\n\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../Parser\").PreparsedAst} PreparsedAst */\n\nvar JS_COMPAT_TYPES = new Set([\"i32\", \"i64\", \"f32\", \"f64\"]);\n\n/**\n * @param {t.Signature} signature the func signature\n * @returns {null | string} the type incompatible with js types\n */\nvar getJsIncompatibleType = function getJsIncompatibleType(signature) {\n  var _iterator = _createForOfIteratorHelper(signature.params),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var param = _step.value;\n      if (!JS_COMPAT_TYPES.has(param.valtype)) {\n        return \"\".concat(param.valtype, \" as parameter\");\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var _iterator2 = _createForOfIteratorHelper(signature.results),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var type = _step2.value;\n      if (!JS_COMPAT_TYPES.has(type)) return \"\".concat(type, \" as result\");\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return null;\n};\n\n/**\n * TODO why are there two different Signature types?\n * @param {t.FuncSignature} signature the func signature\n * @returns {null | string} the type incompatible with js types\n */\nvar getJsIncompatibleTypeOfFuncSignature = function getJsIncompatibleTypeOfFuncSignature(signature) {\n  var _iterator3 = _createForOfIteratorHelper(signature.args),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var param = _step3.value;\n      if (!JS_COMPAT_TYPES.has(param)) {\n        return \"\".concat(param, \" as parameter\");\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  var _iterator4 = _createForOfIteratorHelper(signature.result),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var type = _step4.value;\n      if (!JS_COMPAT_TYPES.has(type)) return \"\".concat(type, \" as result\");\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return null;\n};\nvar decoderOpts = {\n  ignoreCodeSection: true,\n  ignoreDataSection: true,\n  // this will avoid having to lookup with identifiers in the ModuleContext\n  ignoreCustomNameSection: true\n};\nvar WebAssemblyParser = /*#__PURE__*/function (_Parser) {\n  _inherits(WebAssemblyParser, _Parser);\n  var _super = _createSuper(WebAssemblyParser);\n  function WebAssemblyParser(options) {\n    var _this;\n    _classCallCheck(this, WebAssemblyParser);\n    _this = _super.call(this);\n    _this.hooks = Object.freeze({});\n    _this.options = options;\n    return _this;\n  }\n\n  /**\n   * @param {string | Buffer | PreparsedAst} source the source to parse\n   * @param {ParserState} state the parser state\n   * @returns {ParserState} the parser state\n   */\n  _createClass(WebAssemblyParser, [{\n    key: \"parse\",\n    value: function parse(source, state) {\n      if (!Buffer.isBuffer(source)) {\n        throw new Error(\"WebAssemblyParser input must be a Buffer\");\n      }\n\n      // flag it as ESM\n      state.module.buildInfo.strict = true;\n      state.module.buildMeta.exportsType = \"namespace\";\n\n      // parse it\n      var program = decode(source, decoderOpts);\n      var module = program.body[0];\n      var moduleContext = moduleContextFromModuleAST(module);\n\n      // extract imports and exports\n      var exports = [];\n      var jsIncompatibleExports = state.module.buildMeta.jsIncompatibleExports = undefined;\n      var importedGlobals = [];\n      t.traverse(module, {\n        ModuleExport: function ModuleExport(_ref) {\n          var node = _ref.node;\n          var descriptor = node.descr;\n          if (descriptor.exportType === \"Func\") {\n            var funcIdx = descriptor.id.value;\n\n            /** @type {t.FuncSignature} */\n            var funcSignature = moduleContext.getFunction(funcIdx);\n            var incompatibleType = getJsIncompatibleTypeOfFuncSignature(funcSignature);\n            if (incompatibleType) {\n              if (jsIncompatibleExports === undefined) {\n                jsIncompatibleExports = state.module.buildMeta.jsIncompatibleExports = {};\n              }\n              jsIncompatibleExports[node.name] = incompatibleType;\n            }\n          }\n          exports.push(node.name);\n          if (node.descr && node.descr.exportType === \"Global\") {\n            var refNode = importedGlobals[node.descr.id.value];\n            if (refNode) {\n              var dep = new WebAssemblyExportImportedDependency(node.name, refNode.module, refNode.name, refNode.descr.valtype);\n              state.module.addDependency(dep);\n            }\n          }\n        },\n        Global: function Global(_ref2) {\n          var node = _ref2.node;\n          var init = node.init[0];\n          var importNode = null;\n          if (init.id === \"get_global\") {\n            var globalIdx = init.args[0].value;\n            if (globalIdx < importedGlobals.length) {\n              importNode = importedGlobals[globalIdx];\n            }\n          }\n          importedGlobals.push(importNode);\n        },\n        ModuleImport: function ModuleImport(_ref3) {\n          var node = _ref3.node;\n          /** @type {false | string} */\n          var onlyDirectImport = false;\n          if (t.isMemory(node.descr) === true) {\n            onlyDirectImport = \"Memory\";\n          } else if (t.isTable(node.descr) === true) {\n            onlyDirectImport = \"Table\";\n          } else if (t.isFuncImportDescr(node.descr) === true) {\n            var incompatibleType = getJsIncompatibleType(node.descr.signature);\n            if (incompatibleType) {\n              onlyDirectImport = \"Non-JS-compatible Func Signature (\".concat(incompatibleType, \")\");\n            }\n          } else if (t.isGlobalType(node.descr) === true) {\n            var type = node.descr.valtype;\n            if (!JS_COMPAT_TYPES.has(type)) {\n              onlyDirectImport = \"Non-JS-compatible Global Type (\".concat(type, \")\");\n            }\n          }\n          var dep = new WebAssemblyImportDependency(node.module, node.name, node.descr, onlyDirectImport);\n          state.module.addDependency(dep);\n          if (t.isGlobalType(node.descr)) {\n            importedGlobals.push(node);\n          }\n        }\n      });\n      state.module.addDependency(new StaticExportsDependency(exports, false));\n      return state;\n    }\n  }]);\n  return WebAssemblyParser;\n}(Parser);\nmodule.exports = WebAssemblyParser;","map":{"version":3,"names":["t","require","moduleContextFromModuleAST","decode","Parser","StaticExportsDependency","WebAssemblyExportImportedDependency","WebAssemblyImportDependency","JS_COMPAT_TYPES","Set","getJsIncompatibleType","signature","params","param","has","valtype","results","type","getJsIncompatibleTypeOfFuncSignature","args","result","decoderOpts","ignoreCodeSection","ignoreDataSection","ignoreCustomNameSection","WebAssemblyParser","options","hooks","Object","freeze","source","state","Buffer","isBuffer","Error","module","buildInfo","strict","buildMeta","exportsType","program","body","moduleContext","exports","jsIncompatibleExports","undefined","importedGlobals","traverse","ModuleExport","node","descriptor","descr","exportType","funcIdx","id","value","funcSignature","getFunction","incompatibleType","name","push","refNode","dep","addDependency","Global","init","importNode","globalIdx","length","ModuleImport","onlyDirectImport","isMemory","isTable","isFuncImportDescr","isGlobalType"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/wasm-sync/WebAssemblyParser.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst t = require(\"@webassemblyjs/ast\");\nconst { moduleContextFromModuleAST } = require(\"@webassemblyjs/ast\");\nconst { decode } = require(\"@webassemblyjs/wasm-parser\");\nconst Parser = require(\"../Parser\");\nconst StaticExportsDependency = require(\"../dependencies/StaticExportsDependency\");\nconst WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\nconst WebAssemblyImportDependency = require(\"../dependencies/WebAssemblyImportDependency\");\n\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../Parser\").PreparsedAst} PreparsedAst */\n\nconst JS_COMPAT_TYPES = new Set([\"i32\", \"i64\", \"f32\", \"f64\"]);\n\n/**\n * @param {t.Signature} signature the func signature\n * @returns {null | string} the type incompatible with js types\n */\nconst getJsIncompatibleType = signature => {\n\tfor (const param of signature.params) {\n\t\tif (!JS_COMPAT_TYPES.has(param.valtype)) {\n\t\t\treturn `${param.valtype} as parameter`;\n\t\t}\n\t}\n\tfor (const type of signature.results) {\n\t\tif (!JS_COMPAT_TYPES.has(type)) return `${type} as result`;\n\t}\n\treturn null;\n};\n\n/**\n * TODO why are there two different Signature types?\n * @param {t.FuncSignature} signature the func signature\n * @returns {null | string} the type incompatible with js types\n */\nconst getJsIncompatibleTypeOfFuncSignature = signature => {\n\tfor (const param of signature.args) {\n\t\tif (!JS_COMPAT_TYPES.has(param)) {\n\t\t\treturn `${param} as parameter`;\n\t\t}\n\t}\n\tfor (const type of signature.result) {\n\t\tif (!JS_COMPAT_TYPES.has(type)) return `${type} as result`;\n\t}\n\treturn null;\n};\n\nconst decoderOpts = {\n\tignoreCodeSection: true,\n\tignoreDataSection: true,\n\n\t// this will avoid having to lookup with identifiers in the ModuleContext\n\tignoreCustomNameSection: true\n};\n\nclass WebAssemblyParser extends Parser {\n\tconstructor(options) {\n\t\tsuper();\n\t\tthis.hooks = Object.freeze({});\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * @param {string | Buffer | PreparsedAst} source the source to parse\n\t * @param {ParserState} state the parser state\n\t * @returns {ParserState} the parser state\n\t */\n\tparse(source, state) {\n\t\tif (!Buffer.isBuffer(source)) {\n\t\t\tthrow new Error(\"WebAssemblyParser input must be a Buffer\");\n\t\t}\n\n\t\t// flag it as ESM\n\t\tstate.module.buildInfo.strict = true;\n\t\tstate.module.buildMeta.exportsType = \"namespace\";\n\n\t\t// parse it\n\t\tconst program = decode(source, decoderOpts);\n\t\tconst module = program.body[0];\n\n\t\tconst moduleContext = moduleContextFromModuleAST(module);\n\n\t\t// extract imports and exports\n\t\tconst exports = [];\n\t\tlet jsIncompatibleExports = (state.module.buildMeta.jsIncompatibleExports =\n\t\t\tundefined);\n\n\t\tconst importedGlobals = [];\n\t\tt.traverse(module, {\n\t\t\tModuleExport({ node }) {\n\t\t\t\tconst descriptor = node.descr;\n\n\t\t\t\tif (descriptor.exportType === \"Func\") {\n\t\t\t\t\tconst funcIdx = descriptor.id.value;\n\n\t\t\t\t\t/** @type {t.FuncSignature} */\n\t\t\t\t\tconst funcSignature = moduleContext.getFunction(funcIdx);\n\n\t\t\t\t\tconst incompatibleType =\n\t\t\t\t\t\tgetJsIncompatibleTypeOfFuncSignature(funcSignature);\n\n\t\t\t\t\tif (incompatibleType) {\n\t\t\t\t\t\tif (jsIncompatibleExports === undefined) {\n\t\t\t\t\t\t\tjsIncompatibleExports =\n\t\t\t\t\t\t\t\tstate.module.buildMeta.jsIncompatibleExports = {};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjsIncompatibleExports[node.name] = incompatibleType;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\texports.push(node.name);\n\n\t\t\t\tif (node.descr && node.descr.exportType === \"Global\") {\n\t\t\t\t\tconst refNode = importedGlobals[node.descr.id.value];\n\t\t\t\t\tif (refNode) {\n\t\t\t\t\t\tconst dep = new WebAssemblyExportImportedDependency(\n\t\t\t\t\t\t\tnode.name,\n\t\t\t\t\t\t\trefNode.module,\n\t\t\t\t\t\t\trefNode.name,\n\t\t\t\t\t\t\trefNode.descr.valtype\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tstate.module.addDependency(dep);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tGlobal({ node }) {\n\t\t\t\tconst init = node.init[0];\n\n\t\t\t\tlet importNode = null;\n\n\t\t\t\tif (init.id === \"get_global\") {\n\t\t\t\t\tconst globalIdx = init.args[0].value;\n\n\t\t\t\t\tif (globalIdx < importedGlobals.length) {\n\t\t\t\t\t\timportNode = importedGlobals[globalIdx];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\timportedGlobals.push(importNode);\n\t\t\t},\n\n\t\t\tModuleImport({ node }) {\n\t\t\t\t/** @type {false | string} */\n\t\t\t\tlet onlyDirectImport = false;\n\n\t\t\t\tif (t.isMemory(node.descr) === true) {\n\t\t\t\t\tonlyDirectImport = \"Memory\";\n\t\t\t\t} else if (t.isTable(node.descr) === true) {\n\t\t\t\t\tonlyDirectImport = \"Table\";\n\t\t\t\t} else if (t.isFuncImportDescr(node.descr) === true) {\n\t\t\t\t\tconst incompatibleType = getJsIncompatibleType(node.descr.signature);\n\t\t\t\t\tif (incompatibleType) {\n\t\t\t\t\t\tonlyDirectImport = `Non-JS-compatible Func Signature (${incompatibleType})`;\n\t\t\t\t\t}\n\t\t\t\t} else if (t.isGlobalType(node.descr) === true) {\n\t\t\t\t\tconst type = node.descr.valtype;\n\t\t\t\t\tif (!JS_COMPAT_TYPES.has(type)) {\n\t\t\t\t\t\tonlyDirectImport = `Non-JS-compatible Global Type (${type})`;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst dep = new WebAssemblyImportDependency(\n\t\t\t\t\tnode.module,\n\t\t\t\t\tnode.name,\n\t\t\t\t\tnode.descr,\n\t\t\t\t\tonlyDirectImport\n\t\t\t\t);\n\n\t\t\t\tstate.module.addDependency(dep);\n\n\t\t\t\tif (t.isGlobalType(node.descr)) {\n\t\t\t\t\timportedGlobals.push(node);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tstate.module.addDependency(new StaticExportsDependency(exports, false));\n\n\t\treturn state;\n\t}\n}\n\nmodule.exports = WebAssemblyParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}