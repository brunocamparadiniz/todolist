{"ast":null,"code":"\"use strict\";\n\n/**\n * @typedef {[number, boolean]} RangeValue\n */\n\n/**\n * @callback RangeValueCallback\n * @param {RangeValue} rangeValue\n * @returns {boolean}\n */\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar Range = /*#__PURE__*/function () {\n  function Range() {\n    _classCallCheck(this, Range);\n    /** @type {Array<RangeValue>} */\n    this._left = [];\n    /** @type {Array<RangeValue>} */\n\n    this._right = [];\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n  _createClass(Range, [{\n    key: \"left\",\n    value: function left(value) {\n      var exclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this._left.push([value, exclusive]);\n    }\n    /**\n     * @param {number} value\n     * @param {boolean=} exclusive\n     */\n  }, {\n    key: \"right\",\n    value: function right(value) {\n      var exclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this._right.push([value, exclusive]);\n    }\n    /**\n     * @param {boolean} logic is not logic applied\n     * @return {string} \"smart\" range string representation\n     */\n  }, {\n    key: \"format\",\n    value: function format() {\n      var logic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var _Range$getRangeValue = Range.getRangeValue(this._left, logic),\n        _Range$getRangeValue2 = _slicedToArray(_Range$getRangeValue, 2),\n        start = _Range$getRangeValue2[0],\n        leftExclusive = _Range$getRangeValue2[1];\n      var _Range$getRangeValue3 = Range.getRangeValue(this._right, !logic),\n        _Range$getRangeValue4 = _slicedToArray(_Range$getRangeValue3, 2),\n        end = _Range$getRangeValue4[0],\n        rightExclusive = _Range$getRangeValue4[1];\n      if (!Number.isFinite(start) && !Number.isFinite(end)) {\n        return \"\";\n      }\n      var realStart = leftExclusive ? start + 1 : start;\n      var realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6\n\n      if (realStart === realEnd) {\n        return \"should be \".concat(logic ? \"\" : \"!\", \"= \").concat(realStart);\n      } // e.g. 4 < x < ∞\n\n      if (Number.isFinite(start) && !Number.isFinite(end)) {\n        return Range.formatLeft(start, logic, leftExclusive);\n      } // e.g. ∞ < x < 4\n\n      if (!Number.isFinite(start) && Number.isFinite(end)) {\n        return Range.formatRight(end, logic, rightExclusive);\n      }\n      return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\n    }\n  }], [{\n    key: \"getOperator\",\n    value:\n    /**\n     * @param {\"left\" | \"right\"} side\n     * @param {boolean} exclusive\n     * @returns {\">\" | \">=\" | \"<\" | \"<=\"}\n     */\n    function getOperator(side, exclusive) {\n      if (side === \"left\") {\n        return exclusive ? \">\" : \">=\";\n      }\n      return exclusive ? \"<\" : \"<=\";\n    }\n    /**\n     * @param {number} value\n     * @param {boolean} logic is not logic applied\n     * @param {boolean} exclusive is range exclusive\n     * @returns {string}\n     */\n  }, {\n    key: \"formatRight\",\n    value: function formatRight(value, logic, exclusive) {\n      if (logic === false) {\n        return Range.formatLeft(value, !logic, !exclusive);\n      }\n      return \"should be \".concat(Range.getOperator(\"right\", exclusive), \" \").concat(value);\n    }\n    /**\n     * @param {number} value\n     * @param {boolean} logic is not logic applied\n     * @param {boolean} exclusive is range exclusive\n     * @returns {string}\n     */\n  }, {\n    key: \"formatLeft\",\n    value: function formatLeft(value, logic, exclusive) {\n      if (logic === false) {\n        return Range.formatRight(value, !logic, !exclusive);\n      }\n      return \"should be \".concat(Range.getOperator(\"left\", exclusive), \" \").concat(value);\n    }\n    /**\n     * @param {number} start left side value\n     * @param {number} end right side value\n     * @param {boolean} startExclusive is range exclusive from left side\n     * @param {boolean} endExclusive is range exclusive from right side\n     * @param {boolean} logic is not logic applied\n     * @returns {string}\n     */\n  }, {\n    key: \"formatRange\",\n    value: function formatRange(start, end, startExclusive, endExclusive, logic) {\n      var result = \"should be\";\n      result += \" \".concat(Range.getOperator(logic ? \"left\" : \"right\", logic ? startExclusive : !startExclusive), \" \").concat(start, \" \");\n      result += logic ? \"and\" : \"or\";\n      result += \" \".concat(Range.getOperator(logic ? \"right\" : \"left\", logic ? endExclusive : !endExclusive), \" \").concat(end);\n      return result;\n    }\n    /**\n     * @param {Array<RangeValue>} values\n     * @param {boolean} logic is not logic applied\n     * @return {RangeValue} computed value and it's exclusive flag\n     */\n  }, {\n    key: \"getRangeValue\",\n    value: function getRangeValue(values, logic) {\n      var minMax = logic ? Infinity : -Infinity;\n      var j = -1;\n      var predicate = logic ? /** @type {RangeValueCallback} */\n      function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n          value = _ref2[0];\n        return value <= minMax;\n      } : /** @type {RangeValueCallback} */\n      function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 1),\n          value = _ref4[0];\n        return value >= minMax;\n      };\n      for (var i = 0; i < values.length; i++) {\n        if (predicate(values[i])) {\n          var _values$i = _slicedToArray(values[i], 1);\n          minMax = _values$i[0];\n          j = i;\n        }\n      }\n      if (j > -1) {\n        return values[j];\n      }\n      return [Infinity, true];\n    }\n  }]);\n  return Range;\n}();\nmodule.exports = Range;","map":{"version":3,"names":["Range","_left","_right","value","exclusive","push","logic","getRangeValue","start","leftExclusive","end","rightExclusive","Number","isFinite","realStart","realEnd","formatLeft","formatRight","formatRange","side","getOperator","startExclusive","endExclusive","result","values","minMax","Infinity","j","predicate","i","length","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/schema-utils/dist/util/Range.js"],"sourcesContent":["\"use strict\";\n\n/**\n * @typedef {[number, boolean]} RangeValue\n */\n\n/**\n * @callback RangeValueCallback\n * @param {RangeValue} rangeValue\n * @returns {boolean}\n */\nclass Range {\n  /**\n   * @param {\"left\" | \"right\"} side\n   * @param {boolean} exclusive\n   * @returns {\">\" | \">=\" | \"<\" | \"<=\"}\n   */\n  static getOperator(side, exclusive) {\n    if (side === \"left\") {\n      return exclusive ? \">\" : \">=\";\n    }\n\n    return exclusive ? \"<\" : \"<=\";\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n\n  static formatRight(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatLeft(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator(\"right\", exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n\n  static formatLeft(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatRight(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator(\"left\", exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} start left side value\n   * @param {number} end right side value\n   * @param {boolean} startExclusive is range exclusive from left side\n   * @param {boolean} endExclusive is range exclusive from right side\n   * @param {boolean} logic is not logic applied\n   * @returns {string}\n   */\n\n\n  static formatRange(start, end, startExclusive, endExclusive, logic) {\n    let result = \"should be\";\n    result += ` ${Range.getOperator(logic ? \"left\" : \"right\", logic ? startExclusive : !startExclusive)} ${start} `;\n    result += logic ? \"and\" : \"or\";\n    result += ` ${Range.getOperator(logic ? \"right\" : \"left\", logic ? endExclusive : !endExclusive)} ${end}`;\n    return result;\n  }\n  /**\n   * @param {Array<RangeValue>} values\n   * @param {boolean} logic is not logic applied\n   * @return {RangeValue} computed value and it's exclusive flag\n   */\n\n\n  static getRangeValue(values, logic) {\n    let minMax = logic ? Infinity : -Infinity;\n    let j = -1;\n    const predicate = logic ?\n    /** @type {RangeValueCallback} */\n    ([value]) => value <= minMax :\n    /** @type {RangeValueCallback} */\n    ([value]) => value >= minMax;\n\n    for (let i = 0; i < values.length; i++) {\n      if (predicate(values[i])) {\n        [minMax] = values[i];\n        j = i;\n      }\n    }\n\n    if (j > -1) {\n      return values[j];\n    }\n\n    return [Infinity, true];\n  }\n\n  constructor() {\n    /** @type {Array<RangeValue>} */\n    this._left = [];\n    /** @type {Array<RangeValue>} */\n\n    this._right = [];\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  left(value, exclusive = false) {\n    this._left.push([value, exclusive]);\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  right(value, exclusive = false) {\n    this._right.push([value, exclusive]);\n  }\n  /**\n   * @param {boolean} logic is not logic applied\n   * @return {string} \"smart\" range string representation\n   */\n\n\n  format(logic = true) {\n    const [start, leftExclusive] = Range.getRangeValue(this._left, logic);\n    const [end, rightExclusive] = Range.getRangeValue(this._right, !logic);\n\n    if (!Number.isFinite(start) && !Number.isFinite(end)) {\n      return \"\";\n    }\n\n    const realStart = leftExclusive ? start + 1 : start;\n    const realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6\n\n    if (realStart === realEnd) {\n      return `should be ${logic ? \"\" : \"!\"}= ${realStart}`;\n    } // e.g. 4 < x < ∞\n\n\n    if (Number.isFinite(start) && !Number.isFinite(end)) {\n      return Range.formatLeft(start, logic, leftExclusive);\n    } // e.g. ∞ < x < 4\n\n\n    if (!Number.isFinite(start) && Number.isFinite(end)) {\n      return Range.formatRight(end, logic, rightExclusive);\n    }\n\n    return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\n  }\n\n}\n\nmodule.exports = Range;"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAAA,IAKMA,KAAK;EA0FT,iBAAc;IAAA;IACZ;IACA,IAAI,CAACC,KAAK,GAAG,EAAE;IACf;;IAEA,IAAI,CAACC,MAAM,GAAG,EAAE;EAClB;EACA;AACF;AACA;AACA;EAHE;IAAA;IAAA,OAMA,cAAKC,KAAK,EAAqB;MAAA,IAAnBC,SAAS,uEAAG,KAAK;MAC3B,IAAI,CAACH,KAAK,CAACI,IAAI,CAAC,CAACF,KAAK,EAAEC,SAAS,CAAC,CAAC;IACrC;IACA;AACF;AACA;AACA;EAHE;IAAA;IAAA,OAMA,eAAMD,KAAK,EAAqB;MAAA,IAAnBC,SAAS,uEAAG,KAAK;MAC5B,IAAI,CAACF,MAAM,CAACG,IAAI,CAAC,CAACF,KAAK,EAAEC,SAAS,CAAC,CAAC;IACtC;IACA;AACF;AACA;AACA;EAHE;IAAA;IAAA,OAMA,kBAAqB;MAAA,IAAdE,KAAK,uEAAG,IAAI;MACjB,2BAA+BN,KAAK,CAACO,aAAa,CAAC,IAAI,CAACN,KAAK,EAAEK,KAAK,CAAC;QAAA;QAA9DE,KAAK;QAAEC,aAAa;MAC3B,4BAA8BT,KAAK,CAACO,aAAa,CAAC,IAAI,CAACL,MAAM,EAAE,CAACI,KAAK,CAAC;QAAA;QAA/DI,GAAG;QAAEC,cAAc;MAE1B,IAAI,CAACC,MAAM,CAACC,QAAQ,CAACL,KAAK,CAAC,IAAI,CAACI,MAAM,CAACC,QAAQ,CAACH,GAAG,CAAC,EAAE;QACpD,OAAO,EAAE;MACX;MAEA,IAAMI,SAAS,GAAGL,aAAa,GAAGD,KAAK,GAAG,CAAC,GAAGA,KAAK;MACnD,IAAMO,OAAO,GAAGJ,cAAc,GAAGD,GAAG,GAAG,CAAC,GAAGA,GAAG,CAAC,CAAC;;MAEhD,IAAII,SAAS,KAAKC,OAAO,EAAE;QACzB,2BAAoBT,KAAK,GAAG,EAAE,GAAG,GAAG,eAAKQ,SAAS;MACpD,CAAC,CAAC;;MAGF,IAAIF,MAAM,CAACC,QAAQ,CAACL,KAAK,CAAC,IAAI,CAACI,MAAM,CAACC,QAAQ,CAACH,GAAG,CAAC,EAAE;QACnD,OAAOV,KAAK,CAACgB,UAAU,CAACR,KAAK,EAAEF,KAAK,EAAEG,aAAa,CAAC;MACtD,CAAC,CAAC;;MAGF,IAAI,CAACG,MAAM,CAACC,QAAQ,CAACL,KAAK,CAAC,IAAII,MAAM,CAACC,QAAQ,CAACH,GAAG,CAAC,EAAE;QACnD,OAAOV,KAAK,CAACiB,WAAW,CAACP,GAAG,EAAEJ,KAAK,EAAEK,cAAc,CAAC;MACtD;MAEA,OAAOX,KAAK,CAACkB,WAAW,CAACV,KAAK,EAAEE,GAAG,EAAED,aAAa,EAAEE,cAAc,EAAEL,KAAK,CAAC;IAC5E;EAAC;IAAA;IAAA;IAlJD;AACF;AACA;AACA;AACA;IACE,qBAAmBa,IAAI,EAAEf,SAAS,EAAE;MAClC,IAAIe,IAAI,KAAK,MAAM,EAAE;QACnB,OAAOf,SAAS,GAAG,GAAG,GAAG,IAAI;MAC/B;MAEA,OAAOA,SAAS,GAAG,GAAG,GAAG,IAAI;IAC/B;IACA;AACF;AACA;AACA;AACA;AACA;EALE;IAAA;IAAA,OAQA,qBAAmBD,KAAK,EAAEG,KAAK,EAAEF,SAAS,EAAE;MAC1C,IAAIE,KAAK,KAAK,KAAK,EAAE;QACnB,OAAON,KAAK,CAACgB,UAAU,CAACb,KAAK,EAAE,CAACG,KAAK,EAAE,CAACF,SAAS,CAAC;MACpD;MAEA,2BAAoBJ,KAAK,CAACoB,WAAW,CAAC,OAAO,EAAEhB,SAAS,CAAC,cAAID,KAAK;IACpE;IACA;AACF;AACA;AACA;AACA;AACA;EALE;IAAA;IAAA,OAQA,oBAAkBA,KAAK,EAAEG,KAAK,EAAEF,SAAS,EAAE;MACzC,IAAIE,KAAK,KAAK,KAAK,EAAE;QACnB,OAAON,KAAK,CAACiB,WAAW,CAACd,KAAK,EAAE,CAACG,KAAK,EAAE,CAACF,SAAS,CAAC;MACrD;MAEA,2BAAoBJ,KAAK,CAACoB,WAAW,CAAC,MAAM,EAAEhB,SAAS,CAAC,cAAID,KAAK;IACnE;IACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EAPE;IAAA;IAAA,OAUA,qBAAmBK,KAAK,EAAEE,GAAG,EAAEW,cAAc,EAAEC,YAAY,EAAEhB,KAAK,EAAE;MAClE,IAAIiB,MAAM,GAAG,WAAW;MACxBA,MAAM,eAAQvB,KAAK,CAACoB,WAAW,CAACd,KAAK,GAAG,MAAM,GAAG,OAAO,EAAEA,KAAK,GAAGe,cAAc,GAAG,CAACA,cAAc,CAAC,cAAIb,KAAK,MAAG;MAC/Ge,MAAM,IAAIjB,KAAK,GAAG,KAAK,GAAG,IAAI;MAC9BiB,MAAM,eAAQvB,KAAK,CAACoB,WAAW,CAACd,KAAK,GAAG,OAAO,GAAG,MAAM,EAAEA,KAAK,GAAGgB,YAAY,GAAG,CAACA,YAAY,CAAC,cAAIZ,GAAG,CAAE;MACxG,OAAOa,MAAM;IACf;IACA;AACF;AACA;AACA;AACA;EAJE;IAAA;IAAA,OAOA,uBAAqBC,MAAM,EAAElB,KAAK,EAAE;MAClC,IAAImB,MAAM,GAAGnB,KAAK,GAAGoB,QAAQ,GAAG,CAACA,QAAQ;MACzC,IAAIC,CAAC,GAAG,CAAC,CAAC;MACV,IAAMC,SAAS,GAAGtB,KAAK,GACvB;MACA;QAAA;UAAEH,KAAK;QAAA,OAAMA,KAAK,IAAIsB,MAAM;MAAA,IAC5B;MACA;QAAA;UAAEtB,KAAK;QAAA,OAAMA,KAAK,IAAIsB,MAAM;MAAA;MAE5B,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,MAAM,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;QACtC,IAAID,SAAS,CAACJ,MAAM,CAACK,CAAC,CAAC,CAAC,EAAE;UAAA,+BACbL,MAAM,CAACK,CAAC,CAAC;UAAnBJ,MAAM;UACPE,CAAC,GAAGE,CAAC;QACP;MACF;MAEA,IAAIF,CAAC,GAAG,CAAC,CAAC,EAAE;QACV,OAAOH,MAAM,CAACG,CAAC,CAAC;MAClB;MAEA,OAAO,CAACD,QAAQ,EAAE,IAAI,CAAC;IACzB;EAAC;EAAA;AAAA;AA+DHK,MAAM,CAACC,OAAO,GAAGhC,KAAK"},"metadata":{},"sourceType":"script","externalDependencies":[]}