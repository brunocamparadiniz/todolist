{"ast":null,"code":"var _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jridgewell/sourcemap-codec'), require('@jridgewell/resolve-uri')) : typeof define === 'function' && define.amd ? define(['exports', '@jridgewell/sourcemap-codec', '@jridgewell/resolve-uri'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.traceMapping = {}, global.sourcemapCodec, global.resolveURI));\n})(this, function (exports, sourcemapCodec, resolveUri) {\n  'use strict';\n\n  function _interopDefaultLegacy(e) {\n    return e && typeof e === 'object' && 'default' in e ? e : {\n      'default': e\n    };\n  }\n  var resolveUri__default = /*#__PURE__*/_interopDefaultLegacy(resolveUri);\n  function resolve(input, base) {\n    // The base is always treated as a directory, if it's not empty.\n    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n    if (base && !base.endsWith('/')) base += '/';\n    return resolveUri__default[\"default\"](input, base);\n  }\n\n  /**\n   * Removes everything after the last \"/\", but leaves the slash.\n   */\n  function stripFilename(path) {\n    if (!path) return '';\n    var index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n  }\n  var COLUMN = 0;\n  var SOURCES_INDEX = 1;\n  var SOURCE_LINE = 2;\n  var SOURCE_COLUMN = 3;\n  var NAMES_INDEX = 4;\n  var REV_GENERATED_LINE = 1;\n  var REV_GENERATED_COLUMN = 2;\n  function maybeSort(mappings, owned) {\n    var unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n    if (unsortedIndex === mappings.length) return mappings;\n    // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n    // not, we do not want to modify the consumer's input array.\n    if (!owned) mappings = mappings.slice();\n    for (var i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n      mappings[i] = sortSegments(mappings[i], owned);\n    }\n    return mappings;\n  }\n  function nextUnsortedSegmentLine(mappings, start) {\n    for (var i = start; i < mappings.length; i++) {\n      if (!isSorted(mappings[i])) return i;\n    }\n    return mappings.length;\n  }\n  function isSorted(line) {\n    for (var j = 1; j < line.length; j++) {\n      if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function sortSegments(line, owned) {\n    if (!owned) line = line.slice();\n    return line.sort(sortComparator);\n  }\n  function sortComparator(a, b) {\n    return a[COLUMN] - b[COLUMN];\n  }\n  var found = false;\n  /**\n   * A binary search implementation that returns the index if a match is found.\n   * If no match is found, then the left-index (the index associated with the item that comes just\n   * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n   * the next index:\n   *\n   * ```js\n   * const array = [1, 3];\n   * const needle = 2;\n   * const index = binarySearch(array, needle, (item, needle) => item - needle);\n   *\n   * assert.equal(index, 0);\n   * array.splice(index + 1, 0, needle);\n   * assert.deepEqual(array, [1, 2, 3]);\n   * ```\n   */\n  function binarySearch(haystack, needle, low, high) {\n    while (low <= high) {\n      var mid = low + (high - low >> 1);\n      var cmp = haystack[mid][COLUMN] - needle;\n      if (cmp === 0) {\n        found = true;\n        return mid;\n      }\n      if (cmp < 0) {\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n    found = false;\n    return low - 1;\n  }\n  function upperBound(haystack, needle, index) {\n    for (var i = index + 1; i < haystack.length; index = i++) {\n      if (haystack[i][COLUMN] !== needle) break;\n    }\n    return index;\n  }\n  function lowerBound(haystack, needle, index) {\n    for (var i = index - 1; i >= 0; index = i--) {\n      if (haystack[i][COLUMN] !== needle) break;\n    }\n    return index;\n  }\n  function memoizedState() {\n    return {\n      lastKey: -1,\n      lastNeedle: -1,\n      lastIndex: -1\n    };\n  }\n  /**\n   * This overly complicated beast is just to record the last tested line/column and the resulting\n   * index, allowing us to skip a few tests if mappings are monotonically increasing.\n   */\n  function memoizedBinarySearch(haystack, needle, state, key) {\n    var lastKey = state.lastKey,\n      lastNeedle = state.lastNeedle,\n      lastIndex = state.lastIndex;\n    var low = 0;\n    var high = haystack.length - 1;\n    if (key === lastKey) {\n      if (needle === lastNeedle) {\n        found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n        return lastIndex;\n      }\n      if (needle >= lastNeedle) {\n        // lastIndex may be -1 if the previous needle was not found.\n        low = lastIndex === -1 ? 0 : lastIndex;\n      } else {\n        high = lastIndex;\n      }\n    }\n    state.lastKey = key;\n    state.lastNeedle = needle;\n    return state.lastIndex = binarySearch(haystack, needle, low, high);\n  }\n\n  // Rebuilds the original source files, with mappings that are ordered by source line/column instead\n  // of generated line/column.\n  function buildBySources(decoded, memos) {\n    var sources = memos.map(buildNullArray);\n    for (var i = 0; i < decoded.length; i++) {\n      var line = decoded[i];\n      for (var j = 0; j < line.length; j++) {\n        var seg = line[j];\n        if (seg.length === 1) continue;\n        var sourceIndex = seg[SOURCES_INDEX];\n        var sourceLine = seg[SOURCE_LINE];\n        var sourceColumn = seg[SOURCE_COLUMN];\n        var originalSource = sources[sourceIndex];\n        var originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);\n        var memo = memos[sourceIndex];\n        // The binary search either found a match, or it found the left-index just before where the\n        // segment should go. Either way, we want to insert after that. And there may be multiple\n        // generated segments associated with an original location, so there may need to move several\n        // indexes before we find where we need to insert.\n        var index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n        insert(originalLine, memo.lastIndex = index + 1, [sourceColumn, i, seg[COLUMN]]);\n      }\n    }\n    return sources;\n  }\n  function insert(array, index, value) {\n    for (var i = array.length; i > index; i--) {\n      array[i] = array[i - 1];\n    }\n    array[index] = value;\n  }\n  // Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n  // a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n  // Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n  // the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n  // order when iterating with for-in.\n  function buildNullArray() {\n    return {\n      __proto__: null\n    };\n  }\n  var AnyMap = function AnyMap(map, mapUrl) {\n    var parsed = typeof map === 'string' ? JSON.parse(map) : map;\n    if (!('sections' in parsed)) return new TraceMap(parsed, mapUrl);\n    var mappings = [];\n    var sources = [];\n    var sourcesContent = [];\n    var names = [];\n    recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);\n    var joined = {\n      version: 3,\n      file: parsed.file,\n      names: names,\n      sources: sources,\n      sourcesContent: sourcesContent,\n      mappings: mappings\n    };\n    return exports.presortedDecodedMap(joined);\n  };\n  function recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n    var sections = input.sections;\n    for (var i = 0; i < sections.length; i++) {\n      var _sections$i = sections[i],\n        map = _sections$i.map,\n        offset = _sections$i.offset;\n      var sl = stopLine;\n      var sc = stopColumn;\n      if (i + 1 < sections.length) {\n        var nextOffset = sections[i + 1].offset;\n        sl = Math.min(stopLine, lineOffset + nextOffset.line);\n        if (sl === stopLine) {\n          sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n        } else if (sl < stopLine) {\n          sc = columnOffset + nextOffset.column;\n        }\n      }\n      addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n    }\n  }\n  function addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n    if ('sections' in input) return recurse.apply(void 0, arguments);\n    var map = new TraceMap(input, mapUrl);\n    var sourcesOffset = sources.length;\n    var namesOffset = names.length;\n    var decoded = exports.decodedMappings(map);\n    var resolvedSources = map.resolvedSources,\n      contents = map.sourcesContent;\n    append(sources, resolvedSources);\n    append(names, map.names);\n    if (contents) append(sourcesContent, contents);else for (var i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n    for (var _i = 0; _i < decoded.length; _i++) {\n      var lineI = lineOffset + _i;\n      // We can only add so many lines before we step into the range that the next section's map\n      // controls. When we get to the last line, then we'll start checking the segments to see if\n      // they've crossed into the column range. But it may not have any columns that overstep, so we\n      // still need to check that we don't overstep lines, too.\n      if (lineI > stopLine) return;\n      // The out line may already exist in mappings (if we're continuing the line started by a\n      // previous section). Or, we may have jumped ahead several lines to start this section.\n      var out = getLine(mappings, lineI);\n      // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n      // map can be multiple lines), it doesn't.\n      var cOffset = _i === 0 ? columnOffset : 0;\n      var line = decoded[_i];\n      for (var j = 0; j < line.length; j++) {\n        var seg = line[j];\n        var column = cOffset + seg[COLUMN];\n        // If this segment steps into the column range that the next section's map controls, we need\n        // to stop early.\n        if (lineI === stopLine && column >= stopColumn) return;\n        if (seg.length === 1) {\n          out.push([column]);\n          continue;\n        }\n        var sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n        var sourceLine = seg[SOURCE_LINE];\n        var sourceColumn = seg[SOURCE_COLUMN];\n        out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n      }\n    }\n  }\n  function append(arr, other) {\n    for (var i = 0; i < other.length; i++) arr.push(other[i]);\n  }\n  function getLine(arr, index) {\n    for (var i = arr.length; i <= index; i++) arr[i] = [];\n    return arr[index];\n  }\n  var LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\n  var COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n  var LEAST_UPPER_BOUND = -1;\n  var GREATEST_LOWER_BOUND = 1;\n  /**\n   * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n   */\n  exports.encodedMappings = void 0;\n  /**\n   * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n   */\n  exports.decodedMappings = void 0;\n  /**\n   * A low-level API to find the segment associated with a generated line/column (think, from a\n   * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n   */\n  exports.traceSegment = void 0;\n  /**\n   * A higher-level API to find the source/line/column associated with a generated line/column\n   * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n   * `source-map` library.\n   */\n  exports.originalPositionFor = void 0;\n  /**\n   * Finds the generated line/column position of the provided source/line/column source position.\n   */\n  exports.generatedPositionFor = void 0;\n  /**\n   * Finds all generated line/column positions of the provided source/line/column source position.\n   */\n  exports.allGeneratedPositionsFor = void 0;\n  /**\n   * Iterates each mapping in generated position order.\n   */\n  exports.eachMapping = void 0;\n  /**\n   * Retrieves the source content for a particular source, if its found. Returns null if not.\n   */\n  exports.sourceContentFor = void 0;\n  /**\n   * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n   * maps.\n   */\n  exports.presortedDecodedMap = void 0;\n  /**\n   * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n   * a sourcemap, or to JSON.stringify.\n   */\n  exports.decodedMap = void 0;\n  /**\n   * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n   * a sourcemap, or to JSON.stringify.\n   */\n  exports.encodedMap = void 0;\n  var TraceMap = /*#__PURE__*/_createClass(function TraceMap(map, mapUrl) {\n    _classCallCheck(this, TraceMap);\n    var isString = typeof map === 'string';\n    if (!isString && map._decodedMemo) return map;\n    var parsed = isString ? JSON.parse(map) : map;\n    var version = parsed.version,\n      file = parsed.file,\n      names = parsed.names,\n      sourceRoot = parsed.sourceRoot,\n      sources = parsed.sources,\n      sourcesContent = parsed.sourcesContent;\n    this.version = version;\n    this.file = file;\n    this.names = names;\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n    var from = resolve(sourceRoot || '', stripFilename(mapUrl));\n    this.resolvedSources = sources.map(function (s) {\n      return resolve(s || '', from);\n    });\n    var mappings = parsed.mappings;\n    if (typeof mappings === 'string') {\n      this._encoded = mappings;\n      this._decoded = undefined;\n    } else {\n      this._encoded = undefined;\n      this._decoded = maybeSort(mappings, isString);\n    }\n    this._decodedMemo = memoizedState();\n    this._bySources = undefined;\n    this._bySourceMemos = undefined;\n  });\n  (function () {\n    exports.encodedMappings = function (map) {\n      var _a;\n      return (_a = map._encoded) !== null && _a !== void 0 ? _a : map._encoded = sourcemapCodec.encode(map._decoded);\n    };\n    exports.decodedMappings = function (map) {\n      return map._decoded || (map._decoded = sourcemapCodec.decode(map._encoded));\n    };\n    exports.traceSegment = function (map, line, column) {\n      var decoded = exports.decodedMappings(map);\n      // It's common for parent source maps to have pointers to lines that have no\n      // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n      if (line >= decoded.length) return null;\n      var segments = decoded[line];\n      var index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n      return index === -1 ? null : segments[index];\n    };\n    exports.originalPositionFor = function (map, _ref) {\n      var line = _ref.line,\n        column = _ref.column,\n        bias = _ref.bias;\n      line--;\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n      var decoded = exports.decodedMappings(map);\n      // It's common for parent source maps to have pointers to lines that have no\n      // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n      if (line >= decoded.length) return OMapping(null, null, null, null);\n      var segments = decoded[line];\n      var index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n      if (index === -1) return OMapping(null, null, null, null);\n      var segment = segments[index];\n      if (segment.length === 1) return OMapping(null, null, null, null);\n      var names = map.names,\n        resolvedSources = map.resolvedSources;\n      return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n    };\n    exports.allGeneratedPositionsFor = function (map, _ref2) {\n      var source = _ref2.source,\n        line = _ref2.line,\n        column = _ref2.column,\n        bias = _ref2.bias;\n      // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n      return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n    };\n    exports.generatedPositionFor = function (map, _ref3) {\n      var source = _ref3.source,\n        line = _ref3.line,\n        column = _ref3.column,\n        bias = _ref3.bias;\n      return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n    };\n    exports.eachMapping = function (map, cb) {\n      var decoded = exports.decodedMappings(map);\n      var names = map.names,\n        resolvedSources = map.resolvedSources;\n      for (var i = 0; i < decoded.length; i++) {\n        var line = decoded[i];\n        for (var j = 0; j < line.length; j++) {\n          var seg = line[j];\n          var generatedLine = i + 1;\n          var generatedColumn = seg[0];\n          var source = null;\n          var originalLine = null;\n          var originalColumn = null;\n          var name = null;\n          if (seg.length !== 1) {\n            source = resolvedSources[seg[1]];\n            originalLine = seg[2] + 1;\n            originalColumn = seg[3];\n          }\n          if (seg.length === 5) name = names[seg[4]];\n          cb({\n            generatedLine: generatedLine,\n            generatedColumn: generatedColumn,\n            source: source,\n            originalLine: originalLine,\n            originalColumn: originalColumn,\n            name: name\n          });\n        }\n      }\n    };\n    exports.sourceContentFor = function (map, source) {\n      var sources = map.sources,\n        resolvedSources = map.resolvedSources,\n        sourcesContent = map.sourcesContent;\n      if (sourcesContent == null) return null;\n      var index = sources.indexOf(source);\n      if (index === -1) index = resolvedSources.indexOf(source);\n      return index === -1 ? null : sourcesContent[index];\n    };\n    exports.presortedDecodedMap = function (map, mapUrl) {\n      var tracer = new TraceMap(clone(map, []), mapUrl);\n      tracer._decoded = map.mappings;\n      return tracer;\n    };\n    exports.decodedMap = function (map) {\n      return clone(map, exports.decodedMappings(map));\n    };\n    exports.encodedMap = function (map) {\n      return clone(map, exports.encodedMappings(map));\n    };\n    function generatedPosition(map, source, line, column, bias, all) {\n      line--;\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n      var sources = map.sources,\n        resolvedSources = map.resolvedSources;\n      var sourceIndex = sources.indexOf(source);\n      if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n      if (sourceIndex === -1) return all ? [] : GMapping(null, null);\n      var generated = map._bySources || (map._bySources = buildBySources(exports.decodedMappings(map), map._bySourceMemos = sources.map(memoizedState)));\n      var segments = generated[sourceIndex][line];\n      if (segments == null) return all ? [] : GMapping(null, null);\n      var memo = map._bySourceMemos[sourceIndex];\n      if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n      var index = traceSegmentInternal(segments, memo, line, column, bias);\n      if (index === -1) return GMapping(null, null);\n      var segment = segments[index];\n      return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n    }\n  })();\n  function clone(map, mappings) {\n    return {\n      version: map.version,\n      file: map.file,\n      names: map.names,\n      sourceRoot: map.sourceRoot,\n      sources: map.sources,\n      sourcesContent: map.sourcesContent,\n      mappings: mappings\n    };\n  }\n  function OMapping(source, line, column, name) {\n    return {\n      source: source,\n      line: line,\n      column: column,\n      name: name\n    };\n  }\n  function GMapping(line, column) {\n    return {\n      line: line,\n      column: column\n    };\n  }\n  function traceSegmentInternal(segments, memo, line, column, bias) {\n    var index = memoizedBinarySearch(segments, column, memo, line);\n    if (found) {\n      index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n    } else if (bias === LEAST_UPPER_BOUND) index++;\n    if (index === -1 || index === segments.length) return -1;\n    return index;\n  }\n  function sliceGeneratedPositions(segments, memo, line, column, bias) {\n    var min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n    // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n    // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n    // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n    // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n    // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n    // match LEAST_UPPER_BOUND.\n    if (!found && bias === LEAST_UPPER_BOUND) min++;\n    if (min === -1 || min === segments.length) return [];\n    // We may have found the segment that started at an earlier column. If this is the case, then we\n    // need to slice all generated segments that match _that_ column, because all such segments span\n    // to our desired column.\n    var matchedColumn = found ? column : segments[min][COLUMN];\n    // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n    if (!found) min = lowerBound(segments, matchedColumn, min);\n    var max = upperBound(segments, matchedColumn, min);\n    var result = [];\n    for (; min <= max; min++) {\n      var segment = segments[min];\n      result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n    }\n    return result;\n  }\n  exports.AnyMap = AnyMap;\n  exports.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;\n  exports.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;\n  exports.TraceMap = TraceMap;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;EAEc,SAAUA,OAAO,CAACC,KAAa,EAAEC,IAAwB;;;;IAIrE,IAAIA,IAAI,IAAI,CAACA,IAAI,CAACC,QAAQ,CAAC,GAAG,CAAC,EAAED,IAAI,IAAI,GAAG;IAE5C,OAAOE,8BAAU,CAACH,KAAK,EAAEC,IAAI,CAAC;EAChC;;ECTA;;;EAGwB,sBAAa,CAACG,IAA+B;IACnE,IAAI,CAACA,IAAI,EAAE,OAAO,EAAE;IACpB,IAAMC,KAAK,GAAGD,IAAI,CAACE,WAAW,CAAC,GAAG,CAAC;IACnC,OAAOF,IAAI,CAACG,KAAK,CAAC,CAAC,EAAEF,KAAK,GAAG,CAAC,CAAC;EACjC;ECQO,IAAMG,MAAM,GAAG,CAAC;EAChB,IAAMC,aAAa,GAAG,CAAC;EACvB,IAAMC,WAAW,GAAG,CAAC;EACrB,IAAMC,aAAa,GAAG,CAAC;EACvB,IAAMC,WAAW,GAAG,CAAC;EAErB,IAAMC,kBAAkB,GAAG,CAAC;EAC5B,IAAMC,oBAAoB,GAAG,CAAC;EClBvB,SAAUC,SAAS,CAC/BC,QAA8B,EAC9BC,KAAc;IAEd,IAAMC,aAAa,GAAGC,uBAAuB,CAACH,QAAQ,EAAE,CAAC,CAAC;IAC1D,IAAIE,aAAa,KAAKF,QAAQ,CAACI,MAAM,EAAE,OAAOJ,QAAQ;;;IAItD,IAAI,CAACC,KAAK,EAAED,QAAQ,GAAGA,QAAQ,CAACT,KAAK,EAAE;IAEvC,KAAK,IAAIc,CAAC,GAAGH,aAAa,EAAEG,CAAC,GAAGL,QAAQ,CAACI,MAAM,EAAEC,CAAC,GAAGF,uBAAuB,CAACH,QAAQ,EAAEK,CAAC,GAAG,CAAC,CAAC,EAAE;MAC7FL,QAAQ,CAACK,CAAC,CAAC,GAAGC,YAAY,CAACN,QAAQ,CAACK,CAAC,CAAC,EAAEJ,KAAK,CAAC;IAC/C;IACD,OAAOD,QAAQ;EACjB;EAEA,SAASG,uBAAuB,CAACH,QAA8B,EAAEO,KAAa;IAC5E,KAAK,IAAIF,CAAC,GAAGE,KAAK,EAAEF,CAAC,GAAGL,QAAQ,CAACI,MAAM,EAAEC,CAAC,EAAE,EAAE;MAC5C,IAAI,CAACG,QAAQ,CAACR,QAAQ,CAACK,CAAC,CAAC,CAAC,EAAE,OAAOA,CAAC;IACrC;IACD,OAAOL,QAAQ,CAACI,MAAM;EACxB;EAEA,SAASI,QAAQ,CAACC,IAAwB;IACxC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,IAAI,CAACL,MAAM,EAAEM,CAAC,EAAE,EAAE;MACpC,IAAID,IAAI,CAACC,CAAC,CAAC,CAAClB,MAAM,CAAC,GAAGiB,IAAI,CAACC,CAAC,GAAG,CAAC,CAAC,CAAClB,MAAM,CAAC,EAAE;QACzC,OAAO,KAAK;MACb;IACF;IACD,OAAO,IAAI;EACb;EAEA,SAASc,YAAY,CAACG,IAAwB,EAAER,KAAc;IAC5D,IAAI,CAACA,KAAK,EAAEQ,IAAI,GAAGA,IAAI,CAAClB,KAAK,EAAE;IAC/B,OAAOkB,IAAI,CAACE,IAAI,CAACC,cAAc,CAAC;EAClC;EAEA,SAASA,cAAc,CAACC,CAAmB,EAAEC,CAAmB;IAC9D,OAAOD,CAAC,CAACrB,MAAM,CAAC,GAAGsB,CAAC,CAACtB,MAAM,CAAC;EAC9B;ECnCO,IAAIuB,KAAK,GAAG,KAAK;EAExB;;;;;;;;;;;;;;;;EAgBM,SAAUC,YAAY,CAC1BC,QAA+C,EAC/CC,MAAc,EACdC,GAAW,EACXC,IAAY;IAEZ,OAAOD,GAAG,IAAIC,IAAI,EAAE;MAClB,IAAMC,GAAG,GAAGF,GAAG,IAAKC,IAAI,GAAGD,GAAG,IAAK,CAAC,CAAC;MACrC,IAAMG,GAAG,GAAGL,QAAQ,CAACI,GAAG,CAAC,CAAC7B,MAAM,CAAC,GAAG0B,MAAM;MAE1C,IAAII,GAAG,KAAK,CAAC,EAAE;QACbP,KAAK,GAAG,IAAI;QACZ,OAAOM,GAAG;MACX;MAED,IAAIC,GAAG,GAAG,CAAC,EAAE;QACXH,GAAG,GAAGE,GAAG,GAAG,CAAC;MACd,OAAM;QACLD,IAAI,GAAGC,GAAG,GAAG,CAAC;MACf;IACF;IAEDN,KAAK,GAAG,KAAK;IACb,OAAOI,GAAG,GAAG,CAAC;EAChB;WAEgBI,UAAU,CACxBN,QAA+C,EAC/CC,MAAc,EACd7B,KAAa;IAEb,KAAK,IAAIgB,CAAC,GAAGhB,KAAK,GAAG,CAAC,EAAEgB,CAAC,GAAGY,QAAQ,CAACb,MAAM,EAAEf,KAAK,GAAGgB,CAAC,EAAE,EAAE;MACxD,IAAIY,QAAQ,CAACZ,CAAC,CAAC,CAACb,MAAM,CAAC,KAAK0B,MAAM,EAAE;IACrC;IACD,OAAO7B,KAAK;EACd;WAEgBmC,UAAU,CACxBP,QAA+C,EAC/CC,MAAc,EACd7B,KAAa;IAEb,KAAK,IAAIgB,CAAC,GAAGhB,KAAK,GAAG,CAAC,EAAEgB,CAAC,IAAI,CAAC,EAAEhB,KAAK,GAAGgB,CAAC,EAAE,EAAE;MAC3C,IAAIY,QAAQ,CAACZ,CAAC,CAAC,CAACb,MAAM,CAAC,KAAK0B,MAAM,EAAE;IACrC;IACD,OAAO7B,KAAK;EACd;WAEgBoC,aAAa;IAC3B,OAAO;MACLC,OAAO,EAAE,CAAC,CAAC;MACXC,UAAU,EAAE,CAAC,CAAC;MACdC,SAAS,EAAE,CAAC;KACb;EACH;EAEA;;;;EAIM,SAAUC,oBAAoB,CAClCZ,QAA+C,EAC/CC,MAAc,EACdY,KAAgB,EAChBC,GAAW;IAEX,IAAQL,OAAO,GAA4BI,KAAK,CAAxCJ,OAAO;MAAEC,UAAU,GAAgBG,KAAK,CAA/BH,UAAU;MAAEC,SAAS,GAAKE,KAAK,CAAnBF,SAAS;IAEtC,IAAIT,GAAG,GAAG,CAAC;IACX,IAAIC,IAAI,GAAGH,QAAQ,CAACb,MAAM,GAAG,CAAC;IAC9B,IAAI2B,GAAG,KAAKL,OAAO,EAAE;MACnB,IAAIR,MAAM,KAAKS,UAAU,EAAE;QACzBZ,KAAK,GAAGa,SAAS,KAAK,CAAC,CAAC,IAAIX,QAAQ,CAACW,SAAS,CAAC,CAACpC,MAAM,CAAC,KAAK0B,MAAM;QAClE,OAAOU,SAAS;MACjB;MAED,IAAIV,MAAM,IAAIS,UAAU,EAAE;;QAExBR,GAAG,GAAGS,SAAS,KAAK,CAAC,CAAC,GAAG,CAAC,GAAGA,SAAS;MACvC,OAAM;QACLR,IAAI,GAAGQ,SAAS;MACjB;IACF;IACDE,KAAK,CAACJ,OAAO,GAAGK,GAAG;IACnBD,KAAK,CAACH,UAAU,GAAGT,MAAM;IAEzB,OAAQY,KAAK,CAACF,SAAS,GAAGZ,YAAY,CAACC,QAAQ,EAAEC,MAAM,EAAEC,GAAG,EAAEC,IAAI,CAAC;EACrE;;ECvGA;EACA;EACc,SAAUY,cAAc,CACpCC,OAAsC,EACtCC,KAAkB;IAElB,IAAMC,OAAO,GAAaD,KAAK,CAACE,GAAG,CAACC,cAAc,CAAC;IAEnD,KAAK,IAAIhC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4B,OAAO,CAAC7B,MAAM,EAAEC,CAAC,EAAE,EAAE;MACvC,IAAMI,IAAI,GAAGwB,OAAO,CAAC5B,CAAC,CAAC;MACvB,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,IAAI,CAACL,MAAM,EAAEM,CAAC,EAAE,EAAE;QACpC,IAAM4B,GAAG,GAAG7B,IAAI,CAACC,CAAC,CAAC;QACnB,IAAI4B,GAAG,CAAClC,MAAM,KAAK,CAAC,EAAE;QAEtB,IAAMmC,WAAW,GAAGD,GAAG,CAAC7C,aAAa,CAAC;QACtC,IAAM+C,UAAU,GAAGF,GAAG,CAAC5C,WAAW,CAAC;QACnC,IAAM+C,YAAY,GAAGH,GAAG,CAAC3C,aAAa,CAAC;QACvC,IAAM+C,cAAc,GAAGP,OAAO,CAACI,WAAW,CAAC;QAC3C,IAAMI,YAAY,GAAID,cAAc,CAACF,UAAU,CAAzB,mBAAc,CAACA,UAAU,CAAM,KAAE,CAAC;QACxD,IAAMI,IAAI,GAAGV,KAAK,CAACK,WAAW,CAAC;;;;;QAM/B,IAAMlD,KAAK,GAAGkC,UAAU,CACtBoB,YAAY,EACZF,YAAY,EACZZ,oBAAoB,CAACc,YAAY,EAAEF,YAAY,EAAEG,IAAI,EAAEJ,UAAU,CAAC,CACnE;QAEDK,MAAM,CAACF,YAAY,EAAGC,IAAI,CAAChB,SAAS,GAAGvC,KAAK,GAAG,CAAC,EAAG,CAACoD,YAAY,EAAEpC,CAAC,EAAEiC,GAAG,CAAC9C,MAAM,CAAC,CAAC,CAAC;MACnF;IACF;IAED,OAAO2C,OAAO;EAChB;EAEA,SAASU,MAAM,CAAIC,KAAU,EAAEzD,KAAa,EAAE0D,KAAQ;IACpD,KAAK,IAAI1C,CAAC,GAAGyC,KAAK,CAAC1C,MAAM,EAAEC,CAAC,GAAGhB,KAAK,EAAEgB,CAAC,EAAE,EAAE;MACzCyC,KAAK,CAACzC,CAAC,CAAC,GAAGyC,KAAK,CAACzC,CAAC,GAAG,CAAC,CAAC;IACxB;IACDyC,KAAK,CAACzD,KAAK,CAAC,GAAG0D,KAAK;EACtB;EAEA;EACA;EACA;EACA;EACA;EACA,SAASV,cAAc;IACrB,OAAO;MAAEW,SAAS,EAAE;IAAI,CAAO;EACjC;ECxCa,UAAM,GAAW,SAAjBC,MAAM,CAAqBb,GAAG,EAAEc,MAAM;IACjD,IAAMC,MAAM,GACV,OAAOf,GAAG,KAAK,QAAQ,GAAIgB,IAAI,CAACC,KAAK,CAACjB,GAAG,CAA8C,GAAGA,GAAG;IAE/F,IAAI,EAAE,UAAU,IAAIe,MAAM,CAAC,EAAE,OAAO,IAAIG,QAAQ,CAACH,MAAM,EAAED,MAAM,CAAC;IAEhE,IAAMlD,QAAQ,GAAyB,EAAE;IACzC,IAAMmC,OAAO,GAAa,EAAE;IAC5B,IAAMoB,cAAc,GAAsB,EAAE;IAC5C,IAAMC,KAAK,GAAa,EAAE;IAE1BC,OAAO,CAACN,MAAM,EAAED,MAAM,EAAElD,QAAQ,EAAEmC,OAAO,EAAEoB,cAAc,EAAEC,KAAK,EAAE,CAAC,EAAE,CAAC,EAAEE,QAAQ,EAAEA,QAAQ,CAAC;IAE3F,IAAMC,MAAM,GAAqB;MAC/BC,OAAO,EAAE,CAAC;MACVC,IAAI,EAAEV,MAAM,CAACU,IAAI;MACjBL,KAAK,EAALA,KAAK;MACLrB,OAAO,EAAPA,OAAO;MACPoB,cAAc,EAAdA,cAAc;MACdvD,QAAQ,EAARA;KACD;IAED,OAAO8D,2BAAmB,CAACH,MAAM,CAAC;EACpC;EAEA,SAASF,OAAO,CACdzE,KAA6B,EAC7BkE,MAAiC,EACjClD,QAA8B,EAC9BmC,OAAiB,EACjBoB,cAAiC,EACjCC,KAAe,EACfO,UAAkB,EAClBC,YAAoB,EACpBC,QAAgB,EAChBC,UAAkB;IAElB,IAAQC,QAAQ,GAAKnF,KAAK,CAAlBmF,QAAQ;IAChB,KAAK,IAAI9D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8D,QAAQ,CAAC/D,MAAM,EAAEC,CAAC,EAAE,EAAE;MACxC,kBAAwB8D,QAAQ,CAAC9D,CAAC,CAAC;QAA3B+B,GAAG,eAAHA,GAAG;QAAEgC,MAAM,eAANA,MAAM;MAEnB,IAAIC,EAAE,GAAGJ,QAAQ;MACjB,IAAIK,EAAE,GAAGJ,UAAU;MACnB,IAAI7D,CAAC,GAAG,CAAC,GAAG8D,QAAQ,CAAC/D,MAAM,EAAE;QAC3B,IAAMmE,UAAU,GAAGJ,QAAQ,CAAC9D,CAAC,GAAG,CAAC,CAAC,CAAC+D,MAAM;QACzCC,EAAE,GAAGG,IAAI,CAACC,GAAG,CAACR,QAAQ,EAAEF,UAAU,GAAGQ,UAAU,CAAC9D,IAAI,CAAC;QAErD,IAAI4D,EAAE,KAAKJ,QAAQ,EAAE;UACnBK,EAAE,GAAGE,IAAI,CAACC,GAAG,CAACP,UAAU,EAAEF,YAAY,GAAGO,UAAU,CAACG,MAAM,CAAC;QAC5D,OAAM,IAAIL,EAAE,GAAGJ,QAAQ,EAAE;UACxBK,EAAE,GAAGN,YAAY,GAAGO,UAAU,CAACG,MAAM;QACtC;MACF;MAEDC,UAAU,CACRvC,GAAG,EACHc,MAAM,EACNlD,QAAQ,EACRmC,OAAO,EACPoB,cAAc,EACdC,KAAK,EACLO,UAAU,GAAGK,MAAM,CAAC3D,IAAI,EACxBuD,YAAY,GAAGI,MAAM,CAACM,MAAM,EAC5BL,EAAE,EACFC,EAAE,CACH;IACF;EACH;EAEA,SAASK,UAAU,CACjB3F,KAAyB,EACzBkE,MAAiC,EACjClD,QAA8B,EAC9BmC,OAAiB,EACjBoB,cAAiC,EACjCC,KAAe,EACfO,UAAkB,EAClBC,YAAoB,EACpBC,QAAgB,EAChBC,UAAkB;IAElB,IAAI,UAAU,IAAIlF,KAAK,EAAE,OAAOyE,OAAO,eAAKmB,SAAmD,CAAC;IAEhG,IAAMxC,GAAG,GAAG,IAAIkB,QAAQ,CAACtE,KAAK,EAAEkE,MAAM,CAAC;IACvC,IAAM2B,aAAa,GAAG1C,OAAO,CAAC/B,MAAM;IACpC,IAAM0E,WAAW,GAAGtB,KAAK,CAACpD,MAAM;IAChC,IAAM6B,OAAO,GAAG8C,uBAAe,CAAC3C,GAAG,CAAC;IACpC,IAAQ4C,eAAe,GAA+B5C,GAAG,CAAjD4C,eAAe;MAAkBC,QAAQ,GAAK7C,GAAG,CAAhCmB,cAAc;IAEvC2B,MAAM,CAAC/C,OAAO,EAAE6C,eAAe,CAAC;IAChCE,MAAM,CAAC1B,KAAK,EAAEpB,GAAG,CAACoB,KAAK,CAAC;IACxB,IAAIyB,QAAQ,EAAEC,MAAM,CAAC3B,cAAc,EAAE0B,QAAQ,CAAC,CAAC,KAC1C,KAAK,IAAI5E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2E,eAAe,CAAC5E,MAAM,EAAEC,CAAC,EAAE,EAAEkD,cAAc,CAAC4B,IAAI,CAAC,IAAI,CAAC;IAE/E,KAAK,IAAI9E,EAAC,GAAG,CAAC,EAAEA,EAAC,GAAG4B,OAAO,CAAC7B,MAAM,EAAEC,EAAC,EAAE,EAAE;MACvC,IAAM+E,KAAK,GAAGrB,UAAU,GAAG1D,EAAC;;;;;MAM5B,IAAI+E,KAAK,GAAGnB,QAAQ,EAAE;;;MAItB,IAAMoB,GAAG,GAAGC,OAAO,CAACtF,QAAQ,EAAEoF,KAAK,CAAC;;;MAGpC,IAAMG,OAAO,GAAGlF,EAAC,KAAK,CAAC,GAAG2D,YAAY,GAAG,CAAC;MAE1C,IAAMvD,IAAI,GAAGwB,OAAO,CAAC5B,EAAC,CAAC;MACvB,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,IAAI,CAACL,MAAM,EAAEM,CAAC,EAAE,EAAE;QACpC,IAAM4B,GAAG,GAAG7B,IAAI,CAACC,CAAC,CAAC;QACnB,IAAMgE,MAAM,GAAGa,OAAO,GAAGjD,GAAG,CAAC9C,MAAM,CAAC;;;QAIpC,IAAI4F,KAAK,KAAKnB,QAAQ,IAAIS,MAAM,IAAIR,UAAU,EAAE;QAEhD,IAAI5B,GAAG,CAAClC,MAAM,KAAK,CAAC,EAAE;UACpBiF,GAAG,CAACF,IAAI,CAAC,CAACT,MAAM,CAAC,CAAC;UAClB;QACD;QAED,IAAMc,YAAY,GAAGX,aAAa,GAAGvC,GAAG,CAAC7C,aAAa,CAAC;QACvD,IAAM+C,UAAU,GAAGF,GAAG,CAAC5C,WAAW,CAAC;QACnC,IAAM+C,YAAY,GAAGH,GAAG,CAAC3C,aAAa,CAAC;QACvC0F,GAAG,CAACF,IAAI,CACN7C,GAAG,CAAClC,MAAM,KAAK,CAAC,GACZ,CAACsE,MAAM,EAAEc,YAAY,EAAEhD,UAAU,EAAEC,YAAY,CAAC,GAChD,CAACiC,MAAM,EAAEc,YAAY,EAAEhD,UAAU,EAAEC,YAAY,EAAEqC,WAAW,GAAGxC,GAAG,CAAC1C,WAAW,CAAC,CAAC,CACrF;MACF;IACF;EACH;EAEA,SAASsF,MAAM,CAAIO,GAAQ,EAAEC,KAAU;IACrC,KAAK,IAAIrF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqF,KAAK,CAACtF,MAAM,EAAEC,CAAC,EAAE,EAAEoF,GAAG,CAACN,IAAI,CAACO,KAAK,CAACrF,CAAC,CAAC,CAAC;EAC3D;EAEA,SAASiF,OAAO,CAAIG,GAAU,EAAEpG,KAAa;IAC3C,KAAK,IAAIgB,CAAC,GAAGoF,GAAG,CAACrF,MAAM,EAAEC,CAAC,IAAIhB,KAAK,EAAEgB,CAAC,EAAE,EAAEoF,GAAG,CAACpF,CAAC,CAAC,GAAG,EAAE;IACrD,OAAOoF,GAAG,CAACpG,KAAK,CAAC;EACnB;EC7GA,IAAMsG,aAAa,GAAG,uDAAuD;EAC7E,IAAMC,eAAe,GAAG,yEAAyE;EAEpF,qBAAiB,GAAG,CAAC;EAC3B,IAAMC,oBAAoB,GAAG;EAEpC;;;EAGWC;EAEX;;;EAGWf;EAEX;;;;EAIWgB;EAMX;;;;;EAKWC;EAKX;;;EAGWC;EAKX;;;EAGWC;EAEX;;;EAGWC;EAEX;;;EAGWC;EAEX;;;;EAIWtC;EAEX;;;;EAIWuC;EAIX;;;;EAIWC;EAAgD,IAI9ChD,QAAQ,6BAiBnB,kBAAYlB,GAAmB,EAAEc,MAAsB;IAAA;IACrD,IAAMqD,QAAQ,GAAG,OAAOnE,GAAG,KAAK,QAAQ;IAExC,IAAI,CAACmE,QAAQ,IAAKnE,GAAwC,CAACoE,YAAY,EAAE,OAAOpE,GAAe;IAE/F,IAAMe,MAAM,GAAIoD,QAAQ,GAAGnD,IAAI,CAACC,KAAK,CAACjB,GAAG,CAAC,GAAGA,GAA2C;IAExF,IAAQwB,OAAO,GAAuDT,MAAM,CAApES,OAAO;MAAEC,IAAI,GAAiDV,MAAM,CAA3DU,IAAI;MAAEL,KAAK,GAA0CL,MAAM,CAArDK,KAAK;MAAEiD,UAAU,GAA8BtD,MAAM,CAA9CsD,UAAU;MAAEtE,OAAO,GAAqBgB,MAAM,CAAlChB,OAAO;MAAEoB,cAAc,GAAKJ,MAAM,CAAzBI,cAAc;IACjE,IAAI,CAACK,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACL,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACiD,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACtE,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACoB,cAAc,GAAGA,cAAc;IAEpC,IAAMmD,IAAI,GAAG3H,OAAO,CAAC0H,UAAU,IAAI,EAAE,EAAEE,aAAa,CAACzD,MAAM,CAAC,CAAC;IAC7D,IAAI,CAAC8B,eAAe,GAAG7C,OAAO,CAACC,GAAG,CAAC,UAACwE,CAAC;MAAA,OAAK7H,OAAO,CAAC6H,CAAC,IAAI,EAAE,EAAEF,IAAI,CAAC;IAAA,EAAC;IAEjE,IAAQ1G,QAAQ,GAAKmD,MAAM,CAAnBnD,QAAQ;IAChB,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;MAChC,IAAI,CAAC6G,QAAQ,GAAG7G,QAAQ;MACxB,IAAI,CAAC8G,QAAQ,GAAGC,SAAS;IAC1B,OAAM;MACL,IAAI,CAACF,QAAQ,GAAGE,SAAS;MACzB,IAAI,CAACD,QAAQ,GAAG/G,SAAS,CAACC,QAAQ,EAAEuG,QAAQ,CAAC;IAC9C;IAED,IAAI,CAACC,YAAY,GAAG/E,aAAa,EAAE;IACnC,IAAI,CAACuF,UAAU,GAAGD,SAAS;IAC3B,IAAI,CAACE,cAAc,GAAGF,SAAS;GAChC;EAED;IACEjB,uBAAe,GAAG,UAAC1D,GAAG,EAAI;;MACxB,aAAQA,GAAG,CAACyE,QAAQ,mCAAZzE,GAAG,CAACyE,QAAQ,GAAKK,qBAAM,CAAC9E,GAAG,CAAC0E,QAAS,CAAC;IAChD,CAAC;IAED/B,uBAAe,GAAG,UAAC3C,GAAG,EAAI;MACxB,OAAQA,GAAG,CAAC0E,QAAQ,KAAZ1E,GAAG,CAAC0E,QAAQ,GAAKK,qBAAM,CAAC/E,GAAG,CAACyE,QAAS,CAAC;IAChD,CAAC;IAEDd,oBAAY,GAAG,UAAC3D,GAAG,EAAE3B,IAAI,EAAEiE,MAAM,EAAI;MACnC,IAAMzC,OAAO,GAAG8C,uBAAe,CAAC3C,GAAG,CAAC;;;MAIpC,IAAI3B,IAAI,IAAIwB,OAAO,CAAC7B,MAAM,EAAE,OAAO,IAAI;MAEvC,IAAMgH,QAAQ,GAAGnF,OAAO,CAACxB,IAAI,CAAC;MAC9B,IAAMpB,KAAK,GAAGgI,oBAAoB,CAChCD,QAAQ,EACRhF,GAAG,CAACoE,YAAY,EAChB/F,IAAI,EACJiE,MAAM,EACNmB,oBAAoB,CACrB;MAED,OAAOxG,KAAK,KAAK,CAAC,CAAC,GAAG,IAAI,GAAG+H,QAAQ,CAAC/H,KAAK,CAAC;IAC9C,CAAC;IAED2G,2BAAmB,GAAG,UAAC5D,GAAG,QAA4B;MAAA,IAAxB3B,IAAI,QAAJA,IAAI;QAAEiE,MAAM,QAANA,MAAM;QAAE4C,IAAI,QAAJA,IAAI;MAC9C7G,IAAI,EAAE;MACN,IAAIA,IAAI,GAAG,CAAC,EAAE,MAAM,IAAI8G,KAAK,CAAC5B,aAAa,CAAC;MAC5C,IAAIjB,MAAM,GAAG,CAAC,EAAE,MAAM,IAAI6C,KAAK,CAAC3B,eAAe,CAAC;MAEhD,IAAM3D,OAAO,GAAG8C,uBAAe,CAAC3C,GAAG,CAAC;;;MAIpC,IAAI3B,IAAI,IAAIwB,OAAO,CAAC7B,MAAM,EAAE,OAAOoH,QAAQ,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;MAEnE,IAAMJ,QAAQ,GAAGnF,OAAO,CAACxB,IAAI,CAAC;MAC9B,IAAMpB,KAAK,GAAGgI,oBAAoB,CAChCD,QAAQ,EACRhF,GAAG,CAACoE,YAAY,EAChB/F,IAAI,EACJiE,MAAM,EACN4C,IAAI,IAAIzB,oBAAoB,CAC7B;MAED,IAAIxG,KAAK,KAAK,CAAC,CAAC,EAAE,OAAOmI,QAAQ,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;MAEzD,IAAMC,OAAO,GAAGL,QAAQ,CAAC/H,KAAK,CAAC;MAC/B,IAAIoI,OAAO,CAACrH,MAAM,KAAK,CAAC,EAAE,OAAOoH,QAAQ,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;MAEjE,IAAQhE,KAAK,GAAsBpB,GAAG,CAA9BoB,KAAK;QAAEwB,eAAe,GAAK5C,GAAG,CAAvB4C,eAAe;MAC9B,OAAOwC,QAAQ,CACbxC,eAAe,CAACyC,OAAO,CAAChI,aAAa,CAAC,CAAC,EACvCgI,OAAO,CAAC/H,WAAW,CAAC,GAAG,CAAC,EACxB+H,OAAO,CAAC9H,aAAa,CAAC,EACtB8H,OAAO,CAACrH,MAAM,KAAK,CAAC,GAAGoD,KAAK,CAACiE,OAAO,CAAC7H,WAAW,CAAC,CAAC,GAAG,IAAI,CAC1D;IACH,CAAC;IAEDsG,gCAAwB,GAAG,UAAC9D,GAAG,SAAoC;MAAA,IAAhCsF,MAAM,SAANA,MAAM;QAAEjH,IAAI,SAAJA,IAAI;QAAEiE,MAAM,SAANA,MAAM;QAAE4C,IAAI,SAAJA,IAAI;;MAE3D,OAAOK,iBAAiB,CAACvF,GAAG,EAAEsF,MAAM,EAAEjH,IAAI,EAAEiE,MAAM,EAAE4C,IAAI,IAAIM,iBAAiB,EAAE,IAAI,CAAC;IACtF,CAAC;IAED3B,4BAAoB,GAAG,UAAC7D,GAAG,SAAoC;MAAA,IAAhCsF,MAAM,SAANA,MAAM;QAAEjH,IAAI,SAAJA,IAAI;QAAEiE,MAAM,SAANA,MAAM;QAAE4C,IAAI,SAAJA,IAAI;MACvD,OAAOK,iBAAiB,CAACvF,GAAG,EAAEsF,MAAM,EAAEjH,IAAI,EAAEiE,MAAM,EAAE4C,IAAI,IAAIzB,oBAAoB,EAAE,KAAK,CAAC;IAC1F,CAAC;IAEDM,mBAAW,GAAG,UAAC/D,GAAG,EAAEyF,EAAE,EAAI;MACxB,IAAM5F,OAAO,GAAG8C,uBAAe,CAAC3C,GAAG,CAAC;MACpC,IAAQoB,KAAK,GAAsBpB,GAAG,CAA9BoB,KAAK;QAAEwB,eAAe,GAAK5C,GAAG,CAAvB4C,eAAe;MAE9B,KAAK,IAAI3E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4B,OAAO,CAAC7B,MAAM,EAAEC,CAAC,EAAE,EAAE;QACvC,IAAMI,IAAI,GAAGwB,OAAO,CAAC5B,CAAC,CAAC;QACvB,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,IAAI,CAACL,MAAM,EAAEM,CAAC,EAAE,EAAE;UACpC,IAAM4B,GAAG,GAAG7B,IAAI,CAACC,CAAC,CAAC;UAEnB,IAAMoH,aAAa,GAAGzH,CAAC,GAAG,CAAC;UAC3B,IAAM0H,eAAe,GAAGzF,GAAG,CAAC,CAAC,CAAC;UAC9B,IAAIoF,MAAM,GAAG,IAAI;UACjB,IAAI/E,YAAY,GAAG,IAAI;UACvB,IAAIqF,cAAc,GAAG,IAAI;UACzB,IAAIC,IAAI,GAAG,IAAI;UACf,IAAI3F,GAAG,CAAClC,MAAM,KAAK,CAAC,EAAE;YACpBsH,MAAM,GAAG1C,eAAe,CAAC1C,GAAG,CAAC,CAAC,CAAC,CAAC;YAChCK,YAAY,GAAGL,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;YACzB0F,cAAc,GAAG1F,GAAG,CAAC,CAAC,CAAC;UACxB;UACD,IAAIA,GAAG,CAAClC,MAAM,KAAK,CAAC,EAAE6H,IAAI,GAAGzE,KAAK,CAAClB,GAAG,CAAC,CAAC,CAAC,CAAC;UAE1CuF,EAAE,CAAC;YACDC,aAAa,EAAbA,aAAa;YACbC,eAAe,EAAfA,eAAe;YACfL,MAAM,EAANA,MAAM;YACN/E,YAAY,EAAZA,YAAY;YACZqF,cAAc,EAAdA,cAAc;YACdC,IAAI,EAAJA;UACc,EAAC;QAClB;MACF;IACH,CAAC;IAED7B,wBAAgB,GAAG,UAAChE,GAAG,EAAEsF,MAAM,EAAI;MACjC,IAAQvF,OAAO,GAAsCC,GAAG,CAAhDD,OAAO;QAAE6C,eAAe,GAAqB5C,GAAG,CAAvC4C,eAAe;QAAEzB,cAAc,GAAKnB,GAAG,CAAtBmB,cAAc;MAChD,IAAIA,cAAc,IAAI,IAAI,EAAE,OAAO,IAAI;MAEvC,IAAIlE,KAAK,GAAG8C,OAAO,CAAC+F,OAAO,CAACR,MAAM,CAAC;MACnC,IAAIrI,KAAK,KAAK,CAAC,CAAC,EAAEA,KAAK,GAAG2F,eAAe,CAACkD,OAAO,CAACR,MAAM,CAAC;MAEzD,OAAOrI,KAAK,KAAK,CAAC,CAAC,GAAG,IAAI,GAAGkE,cAAc,CAAClE,KAAK,CAAC;IACpD,CAAC;IAEDyE,2BAAmB,GAAG,UAAC1B,GAAG,EAAEc,MAAM,EAAI;MACpC,IAAMiF,MAAM,GAAG,IAAI7E,QAAQ,CAAC8E,KAAK,CAAChG,GAAG,EAAE,EAAE,CAAC,EAAEc,MAAM,CAAC;MACnDiF,MAAM,CAACrB,QAAQ,GAAG1E,GAAG,CAACpC,QAAQ;MAC9B,OAAOmI,MAAM;IACf,CAAC;IAED9B,kBAAU,GAAG,UAACjE,GAAG,EAAI;MACnB,OAAOgG,KAAK,CAAChG,GAAG,EAAE2C,uBAAe,CAAC3C,GAAG,CAAC,CAAC;IACzC,CAAC;IAEDkE,kBAAU,GAAG,UAAClE,GAAG,EAAI;MACnB,OAAOgG,KAAK,CAAChG,GAAG,EAAE0D,uBAAe,CAAC1D,GAAG,CAAC,CAAC;IACzC,CAAC;IAkBD,SAASuF,iBAAiB,CACxBvF,GAAa,EACbsF,MAAc,EACdjH,IAAY,EACZiE,MAAc,EACd4C,IAAU,EACVe,GAAY;MAEZ5H,IAAI,EAAE;MACN,IAAIA,IAAI,GAAG,CAAC,EAAE,MAAM,IAAI8G,KAAK,CAAC5B,aAAa,CAAC;MAC5C,IAAIjB,MAAM,GAAG,CAAC,EAAE,MAAM,IAAI6C,KAAK,CAAC3B,eAAe,CAAC;MAEhD,IAAQzD,OAAO,GAAsBC,GAAG,CAAhCD,OAAO;QAAE6C,eAAe,GAAK5C,GAAG,CAAvB4C,eAAe;MAChC,IAAIzC,WAAW,GAAGJ,OAAO,CAAC+F,OAAO,CAACR,MAAM,CAAC;MACzC,IAAInF,WAAW,KAAK,CAAC,CAAC,EAAEA,WAAW,GAAGyC,eAAe,CAACkD,OAAO,CAACR,MAAM,CAAC;MACrE,IAAInF,WAAW,KAAK,CAAC,CAAC,EAAE,OAAO8F,GAAG,GAAG,EAAE,GAAGC,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;MAE9D,IAAMC,SAAS,GAAInG,GAAG,CAAC4E,UAAU,KAAd5E,GAAG,CAAC4E,UAAU,GAAKhF,cAAc,CAClD+C,uBAAe,CAAC3C,GAAG,CAAC,EACnBA,GAAG,CAAC6E,cAAc,GAAG9E,OAAO,CAACC,GAAG,CAACX,aAAa,CAAC,CACjD,CAAC;MAEF,IAAM2F,QAAQ,GAAGmB,SAAS,CAAChG,WAAW,CAAC,CAAC9B,IAAI,CAAC;MAC7C,IAAI2G,QAAQ,IAAI,IAAI,EAAE,OAAOiB,GAAG,GAAG,EAAE,GAAGC,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;MAE5D,IAAM1F,IAAI,GAAGR,GAAG,CAAC6E,cAAe,CAAC1E,WAAW,CAAC;MAE7C,IAAI8F,GAAG,EAAE,OAAOG,uBAAuB,CAACpB,QAAQ,EAAExE,IAAI,EAAEnC,IAAI,EAAEiE,MAAM,EAAE4C,IAAI,CAAC;MAE3E,IAAMjI,KAAK,GAAGgI,oBAAoB,CAACD,QAAQ,EAAExE,IAAI,EAAEnC,IAAI,EAAEiE,MAAM,EAAE4C,IAAI,CAAC;MACtE,IAAIjI,KAAK,KAAK,CAAC,CAAC,EAAE,OAAOiJ,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;MAE7C,IAAMb,OAAO,GAAGL,QAAQ,CAAC/H,KAAK,CAAC;MAC/B,OAAOiJ,QAAQ,CAACb,OAAO,CAAC5H,kBAAkB,CAAC,GAAG,CAAC,EAAE4H,OAAO,CAAC3H,oBAAoB,CAAC,CAAC;;EAEnF,CAAC;EAGH,SAASsI,KAAK,CACZhG,GAAmD,EACnDpC,QAAW;IAEX,OAAO;MACL4D,OAAO,EAAExB,GAAG,CAACwB,OAAO;MACpBC,IAAI,EAAEzB,GAAG,CAACyB,IAAI;MACdL,KAAK,EAAEpB,GAAG,CAACoB,KAAK;MAChBiD,UAAU,EAAErE,GAAG,CAACqE,UAAU;MAC1BtE,OAAO,EAAEC,GAAG,CAACD,OAAO;MACpBoB,cAAc,EAAEnB,GAAG,CAACmB,cAAc;MAClCvD,QAAQ,EAARA;KACM;EACV;EASA,SAASwH,QAAQ,CACfE,MAAqB,EACrBjH,IAAmB,EACnBiE,MAAqB,EACrBuD,IAAmB;IAEnB,OAAO;MAAEP,MAAM,EAANA,MAAM;MAAEjH,IAAI,EAAJA,IAAI;MAAEiE,MAAM,EAANA,MAAM;MAAEuD,IAAI,EAAJA;IAAI,CAAS;EAC9C;EAIA,SAASK,QAAQ,CACf7H,IAAmB,EACnBiE,MAAqB;IAErB,OAAO;MAAEjE,IAAI,EAAJA,IAAI;MAAEiE,MAAM,EAANA;IAAM,CAAS;EAChC;EAgBA,SAAS2C,oBAAoB,CAC3BD,QAA+C,EAC/CxE,IAAe,EACfnC,IAAY,EACZiE,MAAc,EACd4C,IAAU;IAEV,IAAIjI,KAAK,GAAGwC,oBAAoB,CAACuF,QAAQ,EAAE1C,MAAM,EAAE9B,IAAI,EAAEnC,IAAI,CAAC;IAC9D,IAAIgI,KAAO,EAAE;MACXpJ,KAAK,GAAG,CAACiI,IAAI,KAAKM,iBAAiB,GAAGrG,UAAU,GAAGC,UAAU,EAAE4F,QAAQ,EAAE1C,MAAM,EAAErF,KAAK,CAAC;IACxF,OAAM,IAAIiI,IAAI,KAAKM,iBAAiB,EAAEvI,KAAK,EAAE;IAE9C,IAAIA,KAAK,KAAK,CAAC,CAAC,IAAIA,KAAK,KAAK+H,QAAQ,CAAChH,MAAM,EAAE,OAAO,CAAC,CAAC;IACxD,OAAOf,KAAK;EACd;EAEA,SAASmJ,uBAAuB,CAC9BpB,QAA0B,EAC1BxE,IAAe,EACfnC,IAAY,EACZiE,MAAc,EACd4C,IAAU;IAEV,IAAI7C,GAAG,GAAG4C,oBAAoB,CAACD,QAAQ,EAAExE,IAAI,EAAEnC,IAAI,EAAEiE,MAAM,EAAEmB,oBAAoB,CAAC;;;;;;;IAQlF,IAAI,CAAC4C,KAAO,IAAInB,IAAI,KAAKM,iBAAiB,EAAEnD,GAAG,EAAE;IAEjD,IAAIA,GAAG,KAAK,CAAC,CAAC,IAAIA,GAAG,KAAK2C,QAAQ,CAAChH,MAAM,EAAE,OAAO,EAAE;;;;IAKpD,IAAMsI,aAAa,GAAGD,KAAO,GAAG/D,MAAM,GAAG0C,QAAQ,CAAC3C,GAAG,CAAC,CAACjF,MAAM,CAAC;;IAG9D,IAAI,CAACiJ,KAAO,EAAEhE,GAAG,GAAGjD,UAAU,CAAC4F,QAAQ,EAAEsB,aAAa,EAAEjE,GAAG,CAAC;IAC5D,IAAMkE,GAAG,GAAGpH,UAAU,CAAC6F,QAAQ,EAAEsB,aAAa,EAAEjE,GAAG,CAAC;IAEpD,IAAMmE,MAAM,GAAG,EAAE;IACjB,OAAOnE,GAAG,IAAIkE,GAAG,EAAElE,GAAG,EAAE,EAAE;MACxB,IAAMgD,OAAO,GAAGL,QAAQ,CAAC3C,GAAG,CAAC;MAC7BmE,MAAM,CAACzD,IAAI,CAACmD,QAAQ,CAACb,OAAO,CAAC5H,kBAAkB,CAAC,GAAG,CAAC,EAAE4H,OAAO,CAAC3H,oBAAoB,CAAC,CAAC,CAAC;IACtF;IACD,OAAO8I,MAAM;EACf","names":["resolve","input","base","endsWith","resolveUri","path","index","lastIndexOf","slice","COLUMN","SOURCES_INDEX","SOURCE_LINE","SOURCE_COLUMN","NAMES_INDEX","REV_GENERATED_LINE","REV_GENERATED_COLUMN","maybeSort","mappings","owned","unsortedIndex","nextUnsortedSegmentLine","length","i","sortSegments","start","isSorted","line","j","sort","sortComparator","a","b","found","binarySearch","haystack","needle","low","high","mid","cmp","upperBound","lowerBound","memoizedState","lastKey","lastNeedle","lastIndex","memoizedBinarySearch","state","key","buildBySources","decoded","memos","sources","map","buildNullArray","seg","sourceIndex","sourceLine","sourceColumn","originalSource","originalLine","memo","insert","array","value","__proto__","AnyMap","mapUrl","parsed","JSON","parse","TraceMap","sourcesContent","names","recurse","Infinity","joined","version","file","presortedDecodedMap","lineOffset","columnOffset","stopLine","stopColumn","sections","offset","sl","sc","nextOffset","Math","min","column","addSection","arguments","sourcesOffset","namesOffset","decodedMappings","resolvedSources","contents","append","push","lineI","out","getLine","cOffset","sourcesIndex","arr","other","LINE_GTR_ZERO","COL_GTR_EQ_ZERO","GREATEST_LOWER_BOUND","encodedMappings","traceSegment","originalPositionFor","generatedPositionFor","allGeneratedPositionsFor","eachMapping","sourceContentFor","decodedMap","encodedMap","isString","_decodedMemo","sourceRoot","from","stripFilename","s","_encoded","_decoded","undefined","_bySources","_bySourceMemos","encode","decode","segments","traceSegmentInternal","bias","Error","OMapping","segment","source","generatedPosition","LEAST_UPPER_BOUND","cb","generatedLine","generatedColumn","originalColumn","name","indexOf","tracer","clone","all","GMapping","generated","sliceGeneratedPositions","bsFound","matchedColumn","max","result"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@jridgewell/trace-mapping/src/resolve.ts","/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@jridgewell/trace-mapping/src/strip-filename.ts","/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@jridgewell/trace-mapping/src/sourcemap-segment.ts","/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@jridgewell/trace-mapping/src/sort.ts","/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@jridgewell/trace-mapping/src/binary-search.ts","/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@jridgewell/trace-mapping/src/by-source.ts","/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@jridgewell/trace-mapping/src/any-map.ts","/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@jridgewell/trace-mapping/src/trace-mapping.ts"],"sourcesContent":["import resolveUri from '@jridgewell/resolve-uri';\n\nexport default function resolve(input: string, base: string | undefined): string {\n  // The base is always treated as a directory, if it's not empty.\n  // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n  // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n  if (base && !base.endsWith('/')) base += '/';\n\n  return resolveUri(input, base);\n}\n","/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nexport default function stripFilename(path: string | undefined | null): string {\n  if (!path) return '';\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n","type GeneratedColumn = number;\ntype SourcesIndex = number;\ntype SourceLine = number;\ntype SourceColumn = number;\ntype NamesIndex = number;\n\ntype GeneratedLine = number;\n\nexport type SourceMapSegment =\n  | [GeneratedColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\n\nexport type ReverseSegment = [SourceColumn, GeneratedLine, GeneratedColumn];\n\nexport const COLUMN = 0;\nexport const SOURCES_INDEX = 1;\nexport const SOURCE_LINE = 2;\nexport const SOURCE_COLUMN = 3;\nexport const NAMES_INDEX = 4;\n\nexport const REV_GENERATED_LINE = 1;\nexport const REV_GENERATED_COLUMN = 2;\n","import { COLUMN } from './sourcemap-segment';\n\nimport type { SourceMapSegment } from './sourcemap-segment';\n\nexport default function maybeSort(\n  mappings: SourceMapSegment[][],\n  owned: boolean,\n): SourceMapSegment[][] {\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings;\n\n  // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n  // not, we do not want to modify the consumer's input array.\n  if (!owned) mappings = mappings.slice();\n\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n  return mappings;\n}\n\nfunction nextUnsortedSegmentLine(mappings: SourceMapSegment[][], start: number): number {\n  for (let i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n  return mappings.length;\n}\n\nfunction isSorted(line: SourceMapSegment[]): boolean {\n  for (let j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction sortSegments(line: SourceMapSegment[], owned: boolean): SourceMapSegment[] {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[COLUMN] - b[COLUMN];\n}\n","import type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nimport { COLUMN } from './sourcemap-segment';\n\nexport type MemoState = {\n  lastKey: number;\n  lastNeedle: number;\n  lastIndex: number;\n};\n\nexport let found = false;\n\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nexport function binarySearch(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  low: number,\n  high: number,\n): number {\n  while (low <= high) {\n    const mid = low + ((high - low) >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n\n  found = false;\n  return low - 1;\n}\n\nexport function upperBound(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  index: number,\n): number {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\n\nexport function lowerBound(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  index: number,\n): number {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\n\nexport function memoizedState(): MemoState {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1,\n  };\n}\n\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nexport function memoizedBinarySearch(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  state: MemoState,\n  key: number,\n): number {\n  const { lastKey, lastNeedle, lastIndex } = state;\n\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n\n    if (needle >= lastNeedle) {\n      // lastIndex may be -1 if the previous needle was not found.\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n\n  return (state.lastIndex = binarySearch(haystack, needle, low, high));\n}\n","import { COLUMN, SOURCES_INDEX, SOURCE_LINE, SOURCE_COLUMN } from './sourcemap-segment';\nimport { memoizedBinarySearch, upperBound } from './binary-search';\n\nimport type { ReverseSegment, SourceMapSegment } from './sourcemap-segment';\nimport type { MemoState } from './binary-search';\n\nexport type Source = {\n  __proto__: null;\n  [line: number]: Exclude<ReverseSegment, [number]>[];\n};\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nexport default function buildBySources(\n  decoded: readonly SourceMapSegment[][],\n  memos: MemoState[],\n): Source[] {\n  const sources: Source[] = memos.map(buildNullArray);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      if (seg.length === 1) continue;\n\n      const sourceIndex = seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      const originalSource = sources[sourceIndex];\n      const originalLine = (originalSource[sourceLine] ||= []);\n      const memo = memos[sourceIndex];\n\n      // The binary search either found a match, or it found the left-index just before where the\n      // segment should go. Either way, we want to insert after that. And there may be multiple\n      // generated segments associated with an original location, so there may need to move several\n      // indexes before we find where we need to insert.\n      const index = upperBound(\n        originalLine,\n        sourceColumn,\n        memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine),\n      );\n\n      insert(originalLine, (memo.lastIndex = index + 1), [sourceColumn, i, seg[COLUMN]]);\n    }\n  }\n\n  return sources;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray<T extends { __proto__: null }>(): T {\n  return { __proto__: null } as T;\n}\n","import { TraceMap, presortedDecodedMap, decodedMappings } from './trace-mapping';\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n} from './sourcemap-segment';\n\nimport type {\n  Section,\n  SectionedSourceMap,\n  DecodedSourceMap,\n  SectionedSourceMapInput,\n  Ro,\n} from './types';\nimport type { SourceMapSegment } from './sourcemap-segment';\n\ntype AnyMap = {\n  new (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;\n  (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;\n};\n\nexport const AnyMap: AnyMap = function (map, mapUrl) {\n  const parsed =\n    typeof map === 'string' ? (JSON.parse(map) as Exclude<SectionedSourceMapInput, string>) : map;\n\n  if (!('sections' in parsed)) return new TraceMap(parsed, mapUrl);\n\n  const mappings: SourceMapSegment[][] = [];\n  const sources: string[] = [];\n  const sourcesContent: (string | null)[] = [];\n  const names: string[] = [];\n\n  recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);\n\n  const joined: DecodedSourceMap = {\n    version: 3,\n    file: parsed.file,\n    names,\n    sources,\n    sourcesContent,\n    mappings,\n  };\n\n  return presortedDecodedMap(joined);\n} as AnyMap;\n\nfunction recurse(\n  input: Ro<SectionedSourceMap>,\n  mapUrl: string | null | undefined,\n  mappings: SourceMapSegment[][],\n  sources: string[],\n  sourcesContent: (string | null)[],\n  names: string[],\n  lineOffset: number,\n  columnOffset: number,\n  stopLine: number,\n  stopColumn: number,\n) {\n  const { sections } = input;\n  for (let i = 0; i < sections.length; i++) {\n    const { map, offset } = sections[i];\n\n    let sl = stopLine;\n    let sc = stopColumn;\n    if (i + 1 < sections.length) {\n      const nextOffset = sections[i + 1].offset;\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\n\n      if (sl === stopLine) {\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n      } else if (sl < stopLine) {\n        sc = columnOffset + nextOffset.column;\n      }\n    }\n\n    addSection(\n      map,\n      mapUrl,\n      mappings,\n      sources,\n      sourcesContent,\n      names,\n      lineOffset + offset.line,\n      columnOffset + offset.column,\n      sl,\n      sc,\n    );\n  }\n}\n\nfunction addSection(\n  input: Ro<Section['map']>,\n  mapUrl: string | null | undefined,\n  mappings: SourceMapSegment[][],\n  sources: string[],\n  sourcesContent: (string | null)[],\n  names: string[],\n  lineOffset: number,\n  columnOffset: number,\n  stopLine: number,\n  stopColumn: number,\n) {\n  if ('sections' in input) return recurse(...(arguments as unknown as Parameters<typeof recurse>));\n\n  const map = new TraceMap(input, mapUrl);\n  const sourcesOffset = sources.length;\n  const namesOffset = names.length;\n  const decoded = decodedMappings(map);\n  const { resolvedSources, sourcesContent: contents } = map;\n\n  append(sources, resolvedSources);\n  append(names, map.names);\n  if (contents) append(sourcesContent, contents);\n  else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const lineI = lineOffset + i;\n\n    // We can only add so many lines before we step into the range that the next section's map\n    // controls. When we get to the last line, then we'll start checking the segments to see if\n    // they've crossed into the column range. But it may not have any columns that overstep, so we\n    // still need to check that we don't overstep lines, too.\n    if (lineI > stopLine) return;\n\n    // The out line may already exist in mappings (if we're continuing the line started by a\n    // previous section). Or, we may have jumped ahead several lines to start this section.\n    const out = getLine(mappings, lineI);\n    // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n    // map can be multiple lines), it doesn't.\n    const cOffset = i === 0 ? columnOffset : 0;\n\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const column = cOffset + seg[COLUMN];\n\n      // If this segment steps into the column range that the next section's map controls, we need\n      // to stop early.\n      if (lineI === stopLine && column >= stopColumn) return;\n\n      if (seg.length === 1) {\n        out.push([column]);\n        continue;\n      }\n\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      out.push(\n        seg.length === 4\n          ? [column, sourcesIndex, sourceLine, sourceColumn]\n          : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]],\n      );\n    }\n  }\n}\n\nfunction append<T>(arr: T[], other: T[]) {\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\n}\n\nfunction getLine<T>(arr: T[][], index: number): T[] {\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\n  return arr[index];\n}\n","import { encode, decode } from '@jridgewell/sourcemap-codec';\n\nimport resolve from './resolve';\nimport stripFilename from './strip-filename';\nimport maybeSort from './sort';\nimport buildBySources from './by-source';\nimport {\n  memoizedState,\n  memoizedBinarySearch,\n  upperBound,\n  lowerBound,\n  found as bsFound,\n} from './binary-search';\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n  REV_GENERATED_LINE,\n  REV_GENERATED_COLUMN,\n} from './sourcemap-segment';\n\nimport type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nimport type {\n  SourceMapV3,\n  DecodedSourceMap,\n  EncodedSourceMap,\n  InvalidOriginalMapping,\n  OriginalMapping,\n  InvalidGeneratedMapping,\n  GeneratedMapping,\n  SourceMapInput,\n  Needle,\n  SourceNeedle,\n  SourceMap,\n  EachMapping,\n  Bias,\n} from './types';\nimport type { Source } from './by-source';\nimport type { MemoState } from './binary-search';\n\nexport type { SourceMapSegment } from './sourcemap-segment';\nexport type {\n  SourceMapInput,\n  SectionedSourceMapInput,\n  DecodedSourceMap,\n  EncodedSourceMap,\n  SectionedSourceMap,\n  InvalidOriginalMapping,\n  OriginalMapping as Mapping,\n  OriginalMapping,\n  InvalidGeneratedMapping,\n  GeneratedMapping,\n  EachMapping,\n} from './types';\n\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n\nexport const LEAST_UPPER_BOUND = -1;\nexport const GREATEST_LOWER_BOUND = 1;\n\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nexport let encodedMappings: (map: TraceMap) => EncodedSourceMap['mappings'];\n\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nexport let decodedMappings: (map: TraceMap) => Readonly<DecodedSourceMap['mappings']>;\n\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nexport let traceSegment: (\n  map: TraceMap,\n  line: number,\n  column: number,\n) => Readonly<SourceMapSegment> | null;\n\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nexport let originalPositionFor: (\n  map: TraceMap,\n  needle: Needle,\n) => OriginalMapping | InvalidOriginalMapping;\n\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */\nexport let generatedPositionFor: (\n  map: TraceMap,\n  needle: SourceNeedle,\n) => GeneratedMapping | InvalidGeneratedMapping;\n\n/**\n * Finds all generated line/column positions of the provided source/line/column source position.\n */\nexport let allGeneratedPositionsFor: (map: TraceMap, needle: SourceNeedle) => GeneratedMapping[];\n\n/**\n * Iterates each mapping in generated position order.\n */\nexport let eachMapping: (map: TraceMap, cb: (mapping: EachMapping) => void) => void;\n\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\nexport let sourceContentFor: (map: TraceMap, source: string) => string | null;\n\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nexport let presortedDecodedMap: (map: DecodedSourceMap, mapUrl?: string) => TraceMap;\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport let decodedMap: (\n  map: TraceMap,\n) => Omit<DecodedSourceMap, 'mappings'> & { mappings: readonly SourceMapSegment[][] };\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport let encodedMap: (map: TraceMap) => EncodedSourceMap;\n\nexport { AnyMap } from './any-map';\n\nexport class TraceMap implements SourceMap {\n  declare version: SourceMapV3['version'];\n  declare file: SourceMapV3['file'];\n  declare names: SourceMapV3['names'];\n  declare sourceRoot: SourceMapV3['sourceRoot'];\n  declare sources: SourceMapV3['sources'];\n  declare sourcesContent: SourceMapV3['sourcesContent'];\n\n  declare resolvedSources: string[];\n  private declare _encoded: string | undefined;\n\n  private declare _decoded: SourceMapSegment[][] | undefined;\n  private declare _decodedMemo: MemoState;\n\n  private declare _bySources: Source[] | undefined;\n  private declare _bySourceMemos: MemoState[] | undefined;\n\n  constructor(map: SourceMapInput, mapUrl?: string | null) {\n    const isString = typeof map === 'string';\n\n    if (!isString && (map as unknown as { _decodedMemo: any })._decodedMemo) return map as TraceMap;\n\n    const parsed = (isString ? JSON.parse(map) : map) as DecodedSourceMap | EncodedSourceMap;\n\n    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n    this.version = version;\n    this.file = file;\n    this.names = names;\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n\n    const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n    this.resolvedSources = sources.map((s) => resolve(s || '', from));\n\n    const { mappings } = parsed;\n    if (typeof mappings === 'string') {\n      this._encoded = mappings;\n      this._decoded = undefined;\n    } else {\n      this._encoded = undefined;\n      this._decoded = maybeSort(mappings, isString);\n    }\n\n    this._decodedMemo = memoizedState();\n    this._bySources = undefined;\n    this._bySourceMemos = undefined;\n  }\n\n  static {\n    encodedMappings = (map) => {\n      return (map._encoded ??= encode(map._decoded!));\n    };\n\n    decodedMappings = (map) => {\n      return (map._decoded ||= decode(map._encoded!));\n    };\n\n    traceSegment = (map, line, column) => {\n      const decoded = decodedMappings(map);\n\n      // It's common for parent source maps to have pointers to lines that have no\n      // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n      if (line >= decoded.length) return null;\n\n      const segments = decoded[line];\n      const index = traceSegmentInternal(\n        segments,\n        map._decodedMemo,\n        line,\n        column,\n        GREATEST_LOWER_BOUND,\n      );\n\n      return index === -1 ? null : segments[index];\n    };\n\n    originalPositionFor = (map, { line, column, bias }) => {\n      line--;\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n\n      const decoded = decodedMappings(map);\n\n      // It's common for parent source maps to have pointers to lines that have no\n      // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n      if (line >= decoded.length) return OMapping(null, null, null, null);\n\n      const segments = decoded[line];\n      const index = traceSegmentInternal(\n        segments,\n        map._decodedMemo,\n        line,\n        column,\n        bias || GREATEST_LOWER_BOUND,\n      );\n\n      if (index === -1) return OMapping(null, null, null, null);\n\n      const segment = segments[index];\n      if (segment.length === 1) return OMapping(null, null, null, null);\n\n      const { names, resolvedSources } = map;\n      return OMapping(\n        resolvedSources[segment[SOURCES_INDEX]],\n        segment[SOURCE_LINE] + 1,\n        segment[SOURCE_COLUMN],\n        segment.length === 5 ? names[segment[NAMES_INDEX]] : null,\n      );\n    };\n\n    allGeneratedPositionsFor = (map, { source, line, column, bias }) => {\n      // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n      return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n    };\n\n    generatedPositionFor = (map, { source, line, column, bias }) => {\n      return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n    };\n\n    eachMapping = (map, cb) => {\n      const decoded = decodedMappings(map);\n      const { names, resolvedSources } = map;\n\n      for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n          const seg = line[j];\n\n          const generatedLine = i + 1;\n          const generatedColumn = seg[0];\n          let source = null;\n          let originalLine = null;\n          let originalColumn = null;\n          let name = null;\n          if (seg.length !== 1) {\n            source = resolvedSources[seg[1]];\n            originalLine = seg[2] + 1;\n            originalColumn = seg[3];\n          }\n          if (seg.length === 5) name = names[seg[4]];\n\n          cb({\n            generatedLine,\n            generatedColumn,\n            source,\n            originalLine,\n            originalColumn,\n            name,\n          } as EachMapping);\n        }\n      }\n    };\n\n    sourceContentFor = (map, source) => {\n      const { sources, resolvedSources, sourcesContent } = map;\n      if (sourcesContent == null) return null;\n\n      let index = sources.indexOf(source);\n      if (index === -1) index = resolvedSources.indexOf(source);\n\n      return index === -1 ? null : sourcesContent[index];\n    };\n\n    presortedDecodedMap = (map, mapUrl) => {\n      const tracer = new TraceMap(clone(map, []), mapUrl);\n      tracer._decoded = map.mappings;\n      return tracer;\n    };\n\n    decodedMap = (map) => {\n      return clone(map, decodedMappings(map));\n    };\n\n    encodedMap = (map) => {\n      return clone(map, encodedMappings(map));\n    };\n\n    function generatedPosition(\n      map: TraceMap,\n      source: string,\n      line: number,\n      column: number,\n      bias: Bias,\n      all: false,\n    ): GeneratedMapping | InvalidGeneratedMapping;\n    function generatedPosition(\n      map: TraceMap,\n      source: string,\n      line: number,\n      column: number,\n      bias: Bias,\n      all: true,\n    ): GeneratedMapping[];\n    function generatedPosition(\n      map: TraceMap,\n      source: string,\n      line: number,\n      column: number,\n      bias: Bias,\n      all: boolean,\n    ): GeneratedMapping | InvalidGeneratedMapping | GeneratedMapping[] {\n      line--;\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n\n      const { sources, resolvedSources } = map;\n      let sourceIndex = sources.indexOf(source);\n      if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n      if (sourceIndex === -1) return all ? [] : GMapping(null, null);\n\n      const generated = (map._bySources ||= buildBySources(\n        decodedMappings(map),\n        (map._bySourceMemos = sources.map(memoizedState)),\n      ));\n\n      const segments = generated[sourceIndex][line];\n      if (segments == null) return all ? [] : GMapping(null, null);\n\n      const memo = map._bySourceMemos![sourceIndex];\n\n      if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n\n      const index = traceSegmentInternal(segments, memo, line, column, bias);\n      if (index === -1) return GMapping(null, null);\n\n      const segment = segments[index];\n      return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n    }\n  }\n}\n\nfunction clone<T extends string | readonly SourceMapSegment[][]>(\n  map: TraceMap | DecodedSourceMap | EncodedSourceMap,\n  mappings: T,\n): T extends string ? EncodedSourceMap : DecodedSourceMap {\n  return {\n    version: map.version,\n    file: map.file,\n    names: map.names,\n    sourceRoot: map.sourceRoot,\n    sources: map.sources,\n    sourcesContent: map.sourcesContent,\n    mappings,\n  } as any;\n}\n\nfunction OMapping(source: null, line: null, column: null, name: null): InvalidOriginalMapping;\nfunction OMapping(\n  source: string,\n  line: number,\n  column: number,\n  name: string | null,\n): OriginalMapping;\nfunction OMapping(\n  source: string | null,\n  line: number | null,\n  column: number | null,\n  name: string | null,\n): OriginalMapping | InvalidOriginalMapping {\n  return { source, line, column, name } as any;\n}\n\nfunction GMapping(line: null, column: null): InvalidGeneratedMapping;\nfunction GMapping(line: number, column: number): GeneratedMapping;\nfunction GMapping(\n  line: number | null,\n  column: number | null,\n): GeneratedMapping | InvalidGeneratedMapping {\n  return { line, column } as any;\n}\n\nfunction traceSegmentInternal(\n  segments: SourceMapSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number;\nfunction traceSegmentInternal(\n  segments: ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number;\nfunction traceSegmentInternal(\n  segments: SourceMapSegment[] | ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (bsFound) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\n\nfunction sliceGeneratedPositions(\n  segments: ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): GeneratedMapping[] {\n  let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n\n  // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n  // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n  // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n  // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n  // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n  // match LEAST_UPPER_BOUND.\n  if (!bsFound && bias === LEAST_UPPER_BOUND) min++;\n\n  if (min === -1 || min === segments.length) return [];\n\n  // We may have found the segment that started at an earlier column. If this is the case, then we\n  // need to slice all generated segments that match _that_ column, because all such segments span\n  // to our desired column.\n  const matchedColumn = bsFound ? column : segments[min][COLUMN];\n\n  // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n  if (!bsFound) min = lowerBound(segments, matchedColumn, min);\n  const max = upperBound(segments, matchedColumn, min);\n\n  const result = [];\n  for (; min <= max; min++) {\n    const segment = segments[min];\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n  }\n  return result;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}