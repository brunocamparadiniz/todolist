{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar RuntimeGlobals = require(\"../RuntimeGlobals\");\nvar AMDDefineDependency = require(\"./AMDDefineDependency\");\nvar AMDRequireArrayDependency = require(\"./AMDRequireArrayDependency\");\nvar AMDRequireContextDependency = require(\"./AMDRequireContextDependency\");\nvar AMDRequireItemDependency = require(\"./AMDRequireItemDependency\");\nvar ConstDependency = require(\"./ConstDependency\");\nvar ContextDependencyHelpers = require(\"./ContextDependencyHelpers\");\nvar DynamicExports = require(\"./DynamicExports\");\nvar LocalModuleDependency = require(\"./LocalModuleDependency\");\nvar _require = require(\"./LocalModulesHelpers\"),\n  addLocalModule = _require.addLocalModule,\n  getLocalModule = _require.getLocalModule;\nvar isBoundFunctionExpression = function isBoundFunctionExpression(expr) {\n  if (expr.type !== \"CallExpression\") return false;\n  if (expr.callee.type !== \"MemberExpression\") return false;\n  if (expr.callee.computed) return false;\n  if (expr.callee.object.type !== \"FunctionExpression\") return false;\n  if (expr.callee.property.type !== \"Identifier\") return false;\n  if (expr.callee.property.name !== \"bind\") return false;\n  return true;\n};\nvar isUnboundFunctionExpression = function isUnboundFunctionExpression(expr) {\n  if (expr.type === \"FunctionExpression\") return true;\n  if (expr.type === \"ArrowFunctionExpression\") return true;\n  return false;\n};\nvar isCallable = function isCallable(expr) {\n  if (isUnboundFunctionExpression(expr)) return true;\n  if (isBoundFunctionExpression(expr)) return true;\n  return false;\n};\nvar AMDDefineDependencyParserPlugin = /*#__PURE__*/function () {\n  function AMDDefineDependencyParserPlugin(options) {\n    _classCallCheck(this, AMDDefineDependencyParserPlugin);\n    this.options = options;\n  }\n  _createClass(AMDDefineDependencyParserPlugin, [{\n    key: \"apply\",\n    value: function apply(parser) {\n      parser.hooks.call.for(\"define\").tap(\"AMDDefineDependencyParserPlugin\", this.processCallDefine.bind(this, parser));\n    }\n  }, {\n    key: \"processArray\",\n    value: function processArray(parser, expr, param, identifiers, namedModule) {\n      var _this = this;\n      if (param.isArray()) {\n        param.items.forEach(function (param, idx) {\n          if (param.isString() && [\"require\", \"module\", \"exports\"].includes(param.string)) identifiers[idx] = param.string;\n          var result = _this.processItem(parser, expr, param, namedModule);\n          if (result === undefined) {\n            _this.processContext(parser, expr, param);\n          }\n        });\n        return true;\n      } else if (param.isConstArray()) {\n        var deps = [];\n        param.array.forEach(function (request, idx) {\n          var dep;\n          var localModule;\n          if (request === \"require\") {\n            identifiers[idx] = request;\n            dep = \"__webpack_require__\";\n          } else if ([\"exports\", \"module\"].includes(request)) {\n            identifiers[idx] = request;\n            dep = request;\n          } else if (localModule = getLocalModule(parser.state, request)) {\n            localModule.flagUsed();\n            dep = new LocalModuleDependency(localModule, undefined, false);\n            dep.loc = expr.loc;\n            parser.state.module.addPresentationalDependency(dep);\n          } else {\n            dep = _this.newRequireItemDependency(request);\n            dep.loc = expr.loc;\n            dep.optional = !!parser.scope.inTry;\n            parser.state.current.addDependency(dep);\n          }\n          deps.push(dep);\n        });\n        var dep = this.newRequireArrayDependency(deps, param.range);\n        dep.loc = expr.loc;\n        dep.optional = !!parser.scope.inTry;\n        parser.state.module.addPresentationalDependency(dep);\n        return true;\n      }\n    }\n  }, {\n    key: \"processItem\",\n    value: function processItem(parser, expr, param, namedModule) {\n      var _this2 = this;\n      if (param.isConditional()) {\n        param.options.forEach(function (param) {\n          var result = _this2.processItem(parser, expr, param);\n          if (result === undefined) {\n            _this2.processContext(parser, expr, param);\n          }\n        });\n        return true;\n      } else if (param.isString()) {\n        var dep, localModule;\n        if (param.string === \"require\") {\n          dep = new ConstDependency(\"__webpack_require__\", param.range, [RuntimeGlobals.require]);\n        } else if (param.string === \"exports\") {\n          dep = new ConstDependency(\"exports\", param.range, [RuntimeGlobals.exports]);\n        } else if (param.string === \"module\") {\n          dep = new ConstDependency(\"module\", param.range, [RuntimeGlobals.module]);\n        } else if (localModule = getLocalModule(parser.state, param.string, namedModule)) {\n          localModule.flagUsed();\n          dep = new LocalModuleDependency(localModule, param.range, false);\n        } else {\n          dep = this.newRequireItemDependency(param.string, param.range);\n          dep.optional = !!parser.scope.inTry;\n          parser.state.current.addDependency(dep);\n          return true;\n        }\n        dep.loc = expr.loc;\n        parser.state.module.addPresentationalDependency(dep);\n        return true;\n      }\n    }\n  }, {\n    key: \"processContext\",\n    value: function processContext(parser, expr, param) {\n      var dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, this.options, {\n        category: \"amd\"\n      }, parser);\n      if (!dep) return;\n      dep.loc = expr.loc;\n      dep.optional = !!parser.scope.inTry;\n      parser.state.current.addDependency(dep);\n      return true;\n    }\n  }, {\n    key: \"processCallDefine\",\n    value: function processCallDefine(parser, expr) {\n      var array, fn, obj, namedModule;\n      switch (expr.arguments.length) {\n        case 1:\n          if (isCallable(expr.arguments[0])) {\n            // define(f() {…})\n            fn = expr.arguments[0];\n          } else if (expr.arguments[0].type === \"ObjectExpression\") {\n            // define({…})\n            obj = expr.arguments[0];\n          } else {\n            // define(expr)\n            // unclear if function or object\n            obj = fn = expr.arguments[0];\n          }\n          break;\n        case 2:\n          if (expr.arguments[0].type === \"Literal\") {\n            namedModule = expr.arguments[0].value;\n            // define(\"…\", …)\n            if (isCallable(expr.arguments[1])) {\n              // define(\"…\", f() {…})\n              fn = expr.arguments[1];\n            } else if (expr.arguments[1].type === \"ObjectExpression\") {\n              // define(\"…\", {…})\n              obj = expr.arguments[1];\n            } else {\n              // define(\"…\", expr)\n              // unclear if function or object\n              obj = fn = expr.arguments[1];\n            }\n          } else {\n            array = expr.arguments[0];\n            if (isCallable(expr.arguments[1])) {\n              // define([…], f() {})\n              fn = expr.arguments[1];\n            } else if (expr.arguments[1].type === \"ObjectExpression\") {\n              // define([…], {…})\n              obj = expr.arguments[1];\n            } else {\n              // define([…], expr)\n              // unclear if function or object\n              obj = fn = expr.arguments[1];\n            }\n          }\n          break;\n        case 3:\n          // define(\"…\", […], f() {…})\n          namedModule = expr.arguments[0].value;\n          array = expr.arguments[1];\n          if (isCallable(expr.arguments[2])) {\n            // define(\"…\", […], f() {})\n            fn = expr.arguments[2];\n          } else if (expr.arguments[2].type === \"ObjectExpression\") {\n            // define(\"…\", […], {…})\n            obj = expr.arguments[2];\n          } else {\n            // define(\"…\", […], expr)\n            // unclear if function or object\n            obj = fn = expr.arguments[2];\n          }\n          break;\n        default:\n          return;\n      }\n      DynamicExports.bailout(parser.state);\n      var fnParams = null;\n      var fnParamsOffset = 0;\n      if (fn) {\n        if (isUnboundFunctionExpression(fn)) {\n          fnParams = fn.params;\n        } else if (isBoundFunctionExpression(fn)) {\n          fnParams = fn.callee.object.params;\n          fnParamsOffset = fn.arguments.length - 1;\n          if (fnParamsOffset < 0) {\n            fnParamsOffset = 0;\n          }\n        }\n      }\n      var fnRenames = new Map();\n      if (array) {\n        var identifiers = {};\n        var param = parser.evaluateExpression(array);\n        var result = this.processArray(parser, expr, param, identifiers, namedModule);\n        if (!result) return;\n        if (fnParams) {\n          fnParams = fnParams.slice(fnParamsOffset).filter(function (param, idx) {\n            if (identifiers[idx]) {\n              fnRenames.set(param.name, parser.getVariableInfo(identifiers[idx]));\n              return false;\n            }\n            return true;\n          });\n        }\n      } else {\n        var _identifiers = [\"require\", \"exports\", \"module\"];\n        if (fnParams) {\n          fnParams = fnParams.slice(fnParamsOffset).filter(function (param, idx) {\n            if (_identifiers[idx]) {\n              fnRenames.set(param.name, parser.getVariableInfo(_identifiers[idx]));\n              return false;\n            }\n            return true;\n          });\n        }\n      }\n      var inTry;\n      if (fn && isUnboundFunctionExpression(fn)) {\n        inTry = parser.scope.inTry;\n        parser.inScope(fnParams, function () {\n          var _iterator = _createForOfIteratorHelper(fnRenames),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _step$value = _slicedToArray(_step.value, 2),\n                name = _step$value[0],\n                varInfo = _step$value[1];\n              parser.setVariable(name, varInfo);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          parser.scope.inTry = inTry;\n          if (fn.body.type === \"BlockStatement\") {\n            parser.detectMode(fn.body.body);\n            var prev = parser.prevStatement;\n            parser.preWalkStatement(fn.body);\n            parser.prevStatement = prev;\n            parser.walkStatement(fn.body);\n          } else {\n            parser.walkExpression(fn.body);\n          }\n        });\n      } else if (fn && isBoundFunctionExpression(fn)) {\n        inTry = parser.scope.inTry;\n        parser.inScope(fn.callee.object.params.filter(function (i) {\n          return ![\"require\", \"module\", \"exports\"].includes(i.name);\n        }), function () {\n          var _iterator2 = _createForOfIteratorHelper(fnRenames),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _step2$value = _slicedToArray(_step2.value, 2),\n                name = _step2$value[0],\n                varInfo = _step2$value[1];\n              parser.setVariable(name, varInfo);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          parser.scope.inTry = inTry;\n          if (fn.callee.object.body.type === \"BlockStatement\") {\n            parser.detectMode(fn.callee.object.body.body);\n            var prev = parser.prevStatement;\n            parser.preWalkStatement(fn.callee.object.body);\n            parser.prevStatement = prev;\n            parser.walkStatement(fn.callee.object.body);\n          } else {\n            parser.walkExpression(fn.callee.object.body);\n          }\n        });\n        if (fn.arguments) {\n          parser.walkExpressions(fn.arguments);\n        }\n      } else if (fn || obj) {\n        parser.walkExpression(fn || obj);\n      }\n      var dep = this.newDefineDependency(expr.range, array ? array.range : null, fn ? fn.range : null, obj ? obj.range : null, namedModule ? namedModule : null);\n      dep.loc = expr.loc;\n      if (namedModule) {\n        dep.localModule = addLocalModule(parser.state, namedModule);\n      }\n      parser.state.module.addPresentationalDependency(dep);\n      return true;\n    }\n  }, {\n    key: \"newDefineDependency\",\n    value: function newDefineDependency(range, arrayRange, functionRange, objectRange, namedModule) {\n      return new AMDDefineDependency(range, arrayRange, functionRange, objectRange, namedModule);\n    }\n  }, {\n    key: \"newRequireArrayDependency\",\n    value: function newRequireArrayDependency(depsArray, range) {\n      return new AMDRequireArrayDependency(depsArray, range);\n    }\n  }, {\n    key: \"newRequireItemDependency\",\n    value: function newRequireItemDependency(request, range) {\n      return new AMDRequireItemDependency(request, range);\n    }\n  }]);\n  return AMDDefineDependencyParserPlugin;\n}();\nmodule.exports = AMDDefineDependencyParserPlugin;","map":{"version":3,"names":["RuntimeGlobals","require","AMDDefineDependency","AMDRequireArrayDependency","AMDRequireContextDependency","AMDRequireItemDependency","ConstDependency","ContextDependencyHelpers","DynamicExports","LocalModuleDependency","addLocalModule","getLocalModule","isBoundFunctionExpression","expr","type","callee","computed","object","property","name","isUnboundFunctionExpression","isCallable","AMDDefineDependencyParserPlugin","options","parser","hooks","call","for","tap","processCallDefine","bind","param","identifiers","namedModule","isArray","items","forEach","idx","isString","includes","string","result","processItem","undefined","processContext","isConstArray","deps","array","request","dep","localModule","state","flagUsed","loc","module","addPresentationalDependency","newRequireItemDependency","optional","scope","inTry","current","addDependency","push","newRequireArrayDependency","range","isConditional","exports","create","category","fn","obj","arguments","length","value","bailout","fnParams","fnParamsOffset","params","fnRenames","Map","evaluateExpression","processArray","slice","filter","set","getVariableInfo","inScope","varInfo","setVariable","body","detectMode","prev","prevStatement","preWalkStatement","walkStatement","walkExpression","i","walkExpressions","newDefineDependency","arrayRange","functionRange","objectRange","depsArray"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/dependencies/AMDDefineDependencyParserPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst AMDDefineDependency = require(\"./AMDDefineDependency\");\nconst AMDRequireArrayDependency = require(\"./AMDRequireArrayDependency\");\nconst AMDRequireContextDependency = require(\"./AMDRequireContextDependency\");\nconst AMDRequireItemDependency = require(\"./AMDRequireItemDependency\");\nconst ConstDependency = require(\"./ConstDependency\");\nconst ContextDependencyHelpers = require(\"./ContextDependencyHelpers\");\nconst DynamicExports = require(\"./DynamicExports\");\nconst LocalModuleDependency = require(\"./LocalModuleDependency\");\nconst { addLocalModule, getLocalModule } = require(\"./LocalModulesHelpers\");\n\nconst isBoundFunctionExpression = expr => {\n\tif (expr.type !== \"CallExpression\") return false;\n\tif (expr.callee.type !== \"MemberExpression\") return false;\n\tif (expr.callee.computed) return false;\n\tif (expr.callee.object.type !== \"FunctionExpression\") return false;\n\tif (expr.callee.property.type !== \"Identifier\") return false;\n\tif (expr.callee.property.name !== \"bind\") return false;\n\treturn true;\n};\n\nconst isUnboundFunctionExpression = expr => {\n\tif (expr.type === \"FunctionExpression\") return true;\n\tif (expr.type === \"ArrowFunctionExpression\") return true;\n\treturn false;\n};\n\nconst isCallable = expr => {\n\tif (isUnboundFunctionExpression(expr)) return true;\n\tif (isBoundFunctionExpression(expr)) return true;\n\treturn false;\n};\n\nclass AMDDefineDependencyParserPlugin {\n\tconstructor(options) {\n\t\tthis.options = options;\n\t}\n\n\tapply(parser) {\n\t\tparser.hooks.call\n\t\t\t.for(\"define\")\n\t\t\t.tap(\n\t\t\t\t\"AMDDefineDependencyParserPlugin\",\n\t\t\t\tthis.processCallDefine.bind(this, parser)\n\t\t\t);\n\t}\n\n\tprocessArray(parser, expr, param, identifiers, namedModule) {\n\t\tif (param.isArray()) {\n\t\t\tparam.items.forEach((param, idx) => {\n\t\t\t\tif (\n\t\t\t\t\tparam.isString() &&\n\t\t\t\t\t[\"require\", \"module\", \"exports\"].includes(param.string)\n\t\t\t\t)\n\t\t\t\t\tidentifiers[idx] = param.string;\n\t\t\t\tconst result = this.processItem(parser, expr, param, namedModule);\n\t\t\t\tif (result === undefined) {\n\t\t\t\t\tthis.processContext(parser, expr, param);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t} else if (param.isConstArray()) {\n\t\t\tconst deps = [];\n\t\t\tparam.array.forEach((request, idx) => {\n\t\t\t\tlet dep;\n\t\t\t\tlet localModule;\n\t\t\t\tif (request === \"require\") {\n\t\t\t\t\tidentifiers[idx] = request;\n\t\t\t\t\tdep = \"__webpack_require__\";\n\t\t\t\t} else if ([\"exports\", \"module\"].includes(request)) {\n\t\t\t\t\tidentifiers[idx] = request;\n\t\t\t\t\tdep = request;\n\t\t\t\t} else if ((localModule = getLocalModule(parser.state, request))) {\n\t\t\t\t\tlocalModule.flagUsed();\n\t\t\t\t\tdep = new LocalModuleDependency(localModule, undefined, false);\n\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t} else {\n\t\t\t\t\tdep = this.newRequireItemDependency(request);\n\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\t}\n\t\t\t\tdeps.push(dep);\n\t\t\t});\n\t\t\tconst dep = this.newRequireArrayDependency(deps, param.range);\n\t\t\tdep.loc = expr.loc;\n\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\treturn true;\n\t\t}\n\t}\n\tprocessItem(parser, expr, param, namedModule) {\n\t\tif (param.isConditional()) {\n\t\t\tparam.options.forEach(param => {\n\t\t\t\tconst result = this.processItem(parser, expr, param);\n\t\t\t\tif (result === undefined) {\n\t\t\t\t\tthis.processContext(parser, expr, param);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t} else if (param.isString()) {\n\t\t\tlet dep, localModule;\n\t\t\tif (param.string === \"require\") {\n\t\t\t\tdep = new ConstDependency(\"__webpack_require__\", param.range, [\n\t\t\t\t\tRuntimeGlobals.require\n\t\t\t\t]);\n\t\t\t} else if (param.string === \"exports\") {\n\t\t\t\tdep = new ConstDependency(\"exports\", param.range, [\n\t\t\t\t\tRuntimeGlobals.exports\n\t\t\t\t]);\n\t\t\t} else if (param.string === \"module\") {\n\t\t\t\tdep = new ConstDependency(\"module\", param.range, [\n\t\t\t\t\tRuntimeGlobals.module\n\t\t\t\t]);\n\t\t\t} else if (\n\t\t\t\t(localModule = getLocalModule(parser.state, param.string, namedModule))\n\t\t\t) {\n\t\t\t\tlocalModule.flagUsed();\n\t\t\t\tdep = new LocalModuleDependency(localModule, param.range, false);\n\t\t\t} else {\n\t\t\t\tdep = this.newRequireItemDependency(param.string, param.range);\n\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tdep.loc = expr.loc;\n\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\treturn true;\n\t\t}\n\t}\n\tprocessContext(parser, expr, param) {\n\t\tconst dep = ContextDependencyHelpers.create(\n\t\t\tAMDRequireContextDependency,\n\t\t\tparam.range,\n\t\t\tparam,\n\t\t\texpr,\n\t\t\tthis.options,\n\t\t\t{\n\t\t\t\tcategory: \"amd\"\n\t\t\t},\n\t\t\tparser\n\t\t);\n\t\tif (!dep) return;\n\t\tdep.loc = expr.loc;\n\t\tdep.optional = !!parser.scope.inTry;\n\t\tparser.state.current.addDependency(dep);\n\t\treturn true;\n\t}\n\n\tprocessCallDefine(parser, expr) {\n\t\tlet array, fn, obj, namedModule;\n\t\tswitch (expr.arguments.length) {\n\t\t\tcase 1:\n\t\t\t\tif (isCallable(expr.arguments[0])) {\n\t\t\t\t\t// define(f() {…})\n\t\t\t\t\tfn = expr.arguments[0];\n\t\t\t\t} else if (expr.arguments[0].type === \"ObjectExpression\") {\n\t\t\t\t\t// define({…})\n\t\t\t\t\tobj = expr.arguments[0];\n\t\t\t\t} else {\n\t\t\t\t\t// define(expr)\n\t\t\t\t\t// unclear if function or object\n\t\t\t\t\tobj = fn = expr.arguments[0];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (expr.arguments[0].type === \"Literal\") {\n\t\t\t\t\tnamedModule = expr.arguments[0].value;\n\t\t\t\t\t// define(\"…\", …)\n\t\t\t\t\tif (isCallable(expr.arguments[1])) {\n\t\t\t\t\t\t// define(\"…\", f() {…})\n\t\t\t\t\t\tfn = expr.arguments[1];\n\t\t\t\t\t} else if (expr.arguments[1].type === \"ObjectExpression\") {\n\t\t\t\t\t\t// define(\"…\", {…})\n\t\t\t\t\t\tobj = expr.arguments[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// define(\"…\", expr)\n\t\t\t\t\t\t// unclear if function or object\n\t\t\t\t\t\tobj = fn = expr.arguments[1];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tarray = expr.arguments[0];\n\t\t\t\t\tif (isCallable(expr.arguments[1])) {\n\t\t\t\t\t\t// define([…], f() {})\n\t\t\t\t\t\tfn = expr.arguments[1];\n\t\t\t\t\t} else if (expr.arguments[1].type === \"ObjectExpression\") {\n\t\t\t\t\t\t// define([…], {…})\n\t\t\t\t\t\tobj = expr.arguments[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// define([…], expr)\n\t\t\t\t\t\t// unclear if function or object\n\t\t\t\t\t\tobj = fn = expr.arguments[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t// define(\"…\", […], f() {…})\n\t\t\t\tnamedModule = expr.arguments[0].value;\n\t\t\t\tarray = expr.arguments[1];\n\t\t\t\tif (isCallable(expr.arguments[2])) {\n\t\t\t\t\t// define(\"…\", […], f() {})\n\t\t\t\t\tfn = expr.arguments[2];\n\t\t\t\t} else if (expr.arguments[2].type === \"ObjectExpression\") {\n\t\t\t\t\t// define(\"…\", […], {…})\n\t\t\t\t\tobj = expr.arguments[2];\n\t\t\t\t} else {\n\t\t\t\t\t// define(\"…\", […], expr)\n\t\t\t\t\t// unclear if function or object\n\t\t\t\t\tobj = fn = expr.arguments[2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\t\tDynamicExports.bailout(parser.state);\n\t\tlet fnParams = null;\n\t\tlet fnParamsOffset = 0;\n\t\tif (fn) {\n\t\t\tif (isUnboundFunctionExpression(fn)) {\n\t\t\t\tfnParams = fn.params;\n\t\t\t} else if (isBoundFunctionExpression(fn)) {\n\t\t\t\tfnParams = fn.callee.object.params;\n\t\t\t\tfnParamsOffset = fn.arguments.length - 1;\n\t\t\t\tif (fnParamsOffset < 0) {\n\t\t\t\t\tfnParamsOffset = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet fnRenames = new Map();\n\t\tif (array) {\n\t\t\tconst identifiers = {};\n\t\t\tconst param = parser.evaluateExpression(array);\n\t\t\tconst result = this.processArray(\n\t\t\t\tparser,\n\t\t\t\texpr,\n\t\t\t\tparam,\n\t\t\t\tidentifiers,\n\t\t\t\tnamedModule\n\t\t\t);\n\t\t\tif (!result) return;\n\t\t\tif (fnParams) {\n\t\t\t\tfnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {\n\t\t\t\t\tif (identifiers[idx]) {\n\t\t\t\t\t\tfnRenames.set(param.name, parser.getVariableInfo(identifiers[idx]));\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconst identifiers = [\"require\", \"exports\", \"module\"];\n\t\t\tif (fnParams) {\n\t\t\t\tfnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {\n\t\t\t\t\tif (identifiers[idx]) {\n\t\t\t\t\t\tfnRenames.set(param.name, parser.getVariableInfo(identifiers[idx]));\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tlet inTry;\n\t\tif (fn && isUnboundFunctionExpression(fn)) {\n\t\t\tinTry = parser.scope.inTry;\n\t\t\tparser.inScope(fnParams, () => {\n\t\t\t\tfor (const [name, varInfo] of fnRenames) {\n\t\t\t\t\tparser.setVariable(name, varInfo);\n\t\t\t\t}\n\t\t\t\tparser.scope.inTry = inTry;\n\t\t\t\tif (fn.body.type === \"BlockStatement\") {\n\t\t\t\t\tparser.detectMode(fn.body.body);\n\t\t\t\t\tconst prev = parser.prevStatement;\n\t\t\t\t\tparser.preWalkStatement(fn.body);\n\t\t\t\t\tparser.prevStatement = prev;\n\t\t\t\t\tparser.walkStatement(fn.body);\n\t\t\t\t} else {\n\t\t\t\t\tparser.walkExpression(fn.body);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (fn && isBoundFunctionExpression(fn)) {\n\t\t\tinTry = parser.scope.inTry;\n\t\t\tparser.inScope(\n\t\t\t\tfn.callee.object.params.filter(\n\t\t\t\t\ti => ![\"require\", \"module\", \"exports\"].includes(i.name)\n\t\t\t\t),\n\t\t\t\t() => {\n\t\t\t\t\tfor (const [name, varInfo] of fnRenames) {\n\t\t\t\t\t\tparser.setVariable(name, varInfo);\n\t\t\t\t\t}\n\t\t\t\t\tparser.scope.inTry = inTry;\n\t\t\t\t\tif (fn.callee.object.body.type === \"BlockStatement\") {\n\t\t\t\t\t\tparser.detectMode(fn.callee.object.body.body);\n\t\t\t\t\t\tconst prev = parser.prevStatement;\n\t\t\t\t\t\tparser.preWalkStatement(fn.callee.object.body);\n\t\t\t\t\t\tparser.prevStatement = prev;\n\t\t\t\t\t\tparser.walkStatement(fn.callee.object.body);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparser.walkExpression(fn.callee.object.body);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tif (fn.arguments) {\n\t\t\t\tparser.walkExpressions(fn.arguments);\n\t\t\t}\n\t\t} else if (fn || obj) {\n\t\t\tparser.walkExpression(fn || obj);\n\t\t}\n\n\t\tconst dep = this.newDefineDependency(\n\t\t\texpr.range,\n\t\t\tarray ? array.range : null,\n\t\t\tfn ? fn.range : null,\n\t\t\tobj ? obj.range : null,\n\t\t\tnamedModule ? namedModule : null\n\t\t);\n\t\tdep.loc = expr.loc;\n\t\tif (namedModule) {\n\t\t\tdep.localModule = addLocalModule(parser.state, namedModule);\n\t\t}\n\t\tparser.state.module.addPresentationalDependency(dep);\n\t\treturn true;\n\t}\n\n\tnewDefineDependency(\n\t\trange,\n\t\tarrayRange,\n\t\tfunctionRange,\n\t\tobjectRange,\n\t\tnamedModule\n\t) {\n\t\treturn new AMDDefineDependency(\n\t\t\trange,\n\t\t\tarrayRange,\n\t\t\tfunctionRange,\n\t\t\tobjectRange,\n\t\t\tnamedModule\n\t\t);\n\t}\n\tnewRequireArrayDependency(depsArray, range) {\n\t\treturn new AMDRequireArrayDependency(depsArray, range);\n\t}\n\tnewRequireItemDependency(request, range) {\n\t\treturn new AMDRequireItemDependency(request, range);\n\t}\n}\nmodule.exports = AMDDefineDependencyParserPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}