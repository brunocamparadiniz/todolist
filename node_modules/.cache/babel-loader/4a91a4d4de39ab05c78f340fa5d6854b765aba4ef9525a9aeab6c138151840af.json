{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _inherits = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar fs = require(\"fs\");\nvar path = require(\"path\");\nvar _require = require(\"events\"),\n  EventEmitter = _require.EventEmitter;\nvar reducePlan = require(\"./reducePlan\");\nvar IS_OSX = require(\"os\").platform() === \"darwin\";\nvar IS_WIN = require(\"os\").platform() === \"win32\";\nvar SUPPORTS_RECURSIVE_WATCHING = IS_OSX || IS_WIN;\nvar watcherLimit = +process.env.WATCHPACK_WATCHER_LIMIT || (IS_OSX ? 2000 : 10000);\nvar recursiveWatcherLogging = !!process.env.WATCHPACK_RECURSIVE_WATCHER_LOGGING;\nvar isBatch = false;\nvar watcherCount = 0;\n\n/** @type {Map<Watcher, string>} */\nvar pendingWatchers = new Map();\n\n/** @type {Map<string, RecursiveWatcher>} */\nvar recursiveWatchers = new Map();\n\n/** @type {Map<string, DirectWatcher>} */\nvar directWatchers = new Map();\n\n/** @type {Map<Watcher, RecursiveWatcher | DirectWatcher>} */\nvar underlyingWatcher = new Map();\nvar DirectWatcher = /*#__PURE__*/function () {\n  function DirectWatcher(filePath) {\n    var _this = this;\n    _classCallCheck(this, DirectWatcher);\n    this.filePath = filePath;\n    this.watchers = new Set();\n    this.watcher = undefined;\n    try {\n      var watcher = fs.watch(filePath);\n      this.watcher = watcher;\n      watcher.on(\"change\", function (type, filename) {\n        var _iterator = _createForOfIteratorHelper(_this.watchers),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var w = _step.value;\n            w.emit(\"change\", type, filename);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      });\n      watcher.on(\"error\", function (error) {\n        var _iterator2 = _createForOfIteratorHelper(_this.watchers),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var w = _step2.value;\n            w.emit(\"error\", error);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      });\n    } catch (err) {\n      process.nextTick(function () {\n        var _iterator3 = _createForOfIteratorHelper(_this.watchers),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var w = _step3.value;\n            w.emit(\"error\", err);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      });\n    }\n    watcherCount++;\n  }\n  _createClass(DirectWatcher, [{\n    key: \"add\",\n    value: function add(watcher) {\n      underlyingWatcher.set(watcher, this);\n      this.watchers.add(watcher);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(watcher) {\n      this.watchers.delete(watcher);\n      if (this.watchers.size === 0) {\n        directWatchers.delete(this.filePath);\n        watcherCount--;\n        if (this.watcher) this.watcher.close();\n      }\n    }\n  }, {\n    key: \"getWatchers\",\n    value: function getWatchers() {\n      return this.watchers;\n    }\n  }]);\n  return DirectWatcher;\n}();\nvar RecursiveWatcher = /*#__PURE__*/function () {\n  function RecursiveWatcher(rootPath) {\n    var _this2 = this;\n    _classCallCheck(this, RecursiveWatcher);\n    this.rootPath = rootPath;\n    /** @type {Map<Watcher, string>} */\n    this.mapWatcherToPath = new Map();\n    /** @type {Map<string, Set<Watcher>>} */\n    this.mapPathToWatchers = new Map();\n    this.watcher = undefined;\n    try {\n      var watcher = fs.watch(rootPath, {\n        recursive: true\n      });\n      this.watcher = watcher;\n      watcher.on(\"change\", function (type, filename) {\n        if (!filename) {\n          if (recursiveWatcherLogging) {\n            process.stderr.write(\"[watchpack] dispatch \".concat(type, \" event in recursive watcher (\").concat(_this2.rootPath, \") to all watchers\\n\"));\n          }\n          var _iterator4 = _createForOfIteratorHelper(_this2.mapWatcherToPath.keys()),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var w = _step4.value;\n              w.emit(\"change\", type);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        } else {\n          var dir = path.dirname(filename);\n          var watchers = _this2.mapPathToWatchers.get(dir);\n          if (recursiveWatcherLogging) {\n            process.stderr.write(\"[watchpack] dispatch \".concat(type, \" event in recursive watcher (\").concat(_this2.rootPath, \") for '\").concat(filename, \"' to \").concat(watchers ? watchers.size : 0, \" watchers\\n\"));\n          }\n          if (watchers === undefined) return;\n          var _iterator5 = _createForOfIteratorHelper(watchers),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _w = _step5.value;\n              _w.emit(\"change\", type, path.basename(filename));\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      });\n      watcher.on(\"error\", function (error) {\n        var _iterator6 = _createForOfIteratorHelper(_this2.mapWatcherToPath.keys()),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var w = _step6.value;\n            w.emit(\"error\", error);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      });\n    } catch (err) {\n      process.nextTick(function () {\n        var _iterator7 = _createForOfIteratorHelper(_this2.mapWatcherToPath.keys()),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var w = _step7.value;\n            w.emit(\"error\", err);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      });\n    }\n    watcherCount++;\n    if (recursiveWatcherLogging) {\n      process.stderr.write(\"[watchpack] created recursive watcher at \".concat(rootPath, \"\\n\"));\n    }\n  }\n  _createClass(RecursiveWatcher, [{\n    key: \"add\",\n    value: function add(filePath, watcher) {\n      underlyingWatcher.set(watcher, this);\n      var subpath = filePath.slice(this.rootPath.length + 1) || \".\";\n      this.mapWatcherToPath.set(watcher, subpath);\n      var set = this.mapPathToWatchers.get(subpath);\n      if (set === undefined) {\n        var newSet = new Set();\n        newSet.add(watcher);\n        this.mapPathToWatchers.set(subpath, newSet);\n      } else {\n        set.add(watcher);\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(watcher) {\n      var subpath = this.mapWatcherToPath.get(watcher);\n      if (!subpath) return;\n      this.mapWatcherToPath.delete(watcher);\n      var set = this.mapPathToWatchers.get(subpath);\n      set.delete(watcher);\n      if (set.size === 0) {\n        this.mapPathToWatchers.delete(subpath);\n      }\n      if (this.mapWatcherToPath.size === 0) {\n        recursiveWatchers.delete(this.rootPath);\n        watcherCount--;\n        if (this.watcher) this.watcher.close();\n        if (recursiveWatcherLogging) {\n          process.stderr.write(\"[watchpack] closed recursive watcher at \".concat(this.rootPath, \"\\n\"));\n        }\n      }\n    }\n  }, {\n    key: \"getWatchers\",\n    value: function getWatchers() {\n      return this.mapWatcherToPath;\n    }\n  }]);\n  return RecursiveWatcher;\n}();\nvar Watcher = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Watcher, _EventEmitter);\n  var _super = _createSuper(Watcher);\n  function Watcher() {\n    _classCallCheck(this, Watcher);\n    return _super.apply(this, arguments);\n  }\n  _createClass(Watcher, [{\n    key: \"close\",\n    value: function close() {\n      if (pendingWatchers.has(this)) {\n        pendingWatchers.delete(this);\n        return;\n      }\n      var watcher = underlyingWatcher.get(this);\n      watcher.remove(this);\n      underlyingWatcher.delete(this);\n    }\n  }]);\n  return Watcher;\n}(EventEmitter);\nvar createDirectWatcher = function createDirectWatcher(filePath) {\n  var existing = directWatchers.get(filePath);\n  if (existing !== undefined) return existing;\n  var w = new DirectWatcher(filePath);\n  directWatchers.set(filePath, w);\n  return w;\n};\nvar createRecursiveWatcher = function createRecursiveWatcher(rootPath) {\n  var existing = recursiveWatchers.get(rootPath);\n  if (existing !== undefined) return existing;\n  var w = new RecursiveWatcher(rootPath);\n  recursiveWatchers.set(rootPath, w);\n  return w;\n};\nvar execute = function execute() {\n  /** @type {Map<string, Watcher[] | Watcher>} */\n  var map = new Map();\n  var addWatcher = function addWatcher(watcher, filePath) {\n    var entry = map.get(filePath);\n    if (entry === undefined) {\n      map.set(filePath, watcher);\n    } else if (Array.isArray(entry)) {\n      entry.push(watcher);\n    } else {\n      map.set(filePath, [entry, watcher]);\n    }\n  };\n  var _iterator8 = _createForOfIteratorHelper(pendingWatchers),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var _step8$value = _slicedToArray(_step8.value, 2),\n        watcher = _step8$value[0],\n        _filePath = _step8$value[1];\n      addWatcher(watcher, _filePath);\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  pendingWatchers.clear();\n\n  // Fast case when we are not reaching the limit\n  if (!SUPPORTS_RECURSIVE_WATCHING || watcherLimit - watcherCount >= map.size) {\n    // Create watchers for all entries in the map\n    var _iterator9 = _createForOfIteratorHelper(map),\n      _step9;\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var _step9$value = _slicedToArray(_step9.value, 2),\n          filePath = _step9$value[0],\n          entry = _step9$value[1];\n        var w = createDirectWatcher(filePath);\n        if (Array.isArray(entry)) {\n          var _iterator10 = _createForOfIteratorHelper(entry),\n            _step10;\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var item = _step10.value;\n              w.add(item);\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n        } else {\n          w.add(entry);\n        }\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n    return;\n  }\n\n  // Reconsider existing watchers to improving watch plan\n  var _iterator11 = _createForOfIteratorHelper(recursiveWatchers.values()),\n    _step11;\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var _watcher = _step11.value;\n      var _iterator14 = _createForOfIteratorHelper(_watcher.getWatchers()),\n        _step14;\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var _step14$value = _slicedToArray(_step14.value, 2),\n            _w2 = _step14$value[0],\n            subpath = _step14$value[1];\n          addWatcher(_w2, path.join(_watcher.rootPath, subpath));\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n    }\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n  var _iterator12 = _createForOfIteratorHelper(directWatchers.values()),\n    _step12;\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var _watcher2 = _step12.value;\n      var _iterator15 = _createForOfIteratorHelper(_watcher2.getWatchers()),\n        _step15;\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var _w3 = _step15.value;\n          addWatcher(_w3, _watcher2.filePath);\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n    }\n\n    // Merge map entries to keep watcher limit\n    // Create a 10% buffer to be able to enter fast case more often\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n  var plan = reducePlan(map, watcherLimit * 0.9);\n\n  // Update watchers for all entries in the map\n  var _iterator13 = _createForOfIteratorHelper(plan),\n    _step13;\n  try {\n    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n      var _step13$value = _slicedToArray(_step13.value, 2),\n        _filePath2 = _step13$value[0],\n        _entry = _step13$value[1];\n      if (_entry.size === 1) {\n        var _iterator16 = _createForOfIteratorHelper(_entry),\n          _step16;\n        try {\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            var _step16$value = _slicedToArray(_step16.value, 2),\n              _watcher3 = _step16$value[0],\n              _filePath3 = _step16$value[1];\n            var _w4 = createDirectWatcher(_filePath3);\n            var old = underlyingWatcher.get(_watcher3);\n            if (old === _w4) continue;\n            _w4.add(_watcher3);\n            if (old !== undefined) old.remove(_watcher3);\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n      } else {\n        var filePaths = new Set(_entry.values());\n        if (filePaths.size > 1) {\n          var _w5 = createRecursiveWatcher(_filePath2);\n          var _iterator17 = _createForOfIteratorHelper(_entry),\n            _step17;\n          try {\n            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n              var _step17$value = _slicedToArray(_step17.value, 2),\n                _watcher4 = _step17$value[0],\n                watcherPath = _step17$value[1];\n              var _old = underlyingWatcher.get(_watcher4);\n              if (_old === _w5) continue;\n              _w5.add(watcherPath, _watcher4);\n              if (_old !== undefined) _old.remove(_watcher4);\n            }\n          } catch (err) {\n            _iterator17.e(err);\n          } finally {\n            _iterator17.f();\n          }\n        } else {\n          var _iterator18 = _createForOfIteratorHelper(filePaths),\n            _step18;\n          try {\n            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n              var _filePath4 = _step18.value;\n              var _w6 = createDirectWatcher(_filePath4);\n              var _iterator19 = _createForOfIteratorHelper(_entry.keys()),\n                _step19;\n              try {\n                for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                  var _watcher5 = _step19.value;\n                  var _old2 = underlyingWatcher.get(_watcher5);\n                  if (_old2 === _w6) continue;\n                  _w6.add(_watcher5);\n                  if (_old2 !== undefined) _old2.remove(_watcher5);\n                }\n              } catch (err) {\n                _iterator19.e(err);\n              } finally {\n                _iterator19.f();\n              }\n            }\n          } catch (err) {\n            _iterator18.e(err);\n          } finally {\n            _iterator18.f();\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator13.e(err);\n  } finally {\n    _iterator13.f();\n  }\n};\nexports.watch = function (filePath) {\n  var watcher = new Watcher();\n  // Find an existing watcher\n  var directWatcher = directWatchers.get(filePath);\n  if (directWatcher !== undefined) {\n    directWatcher.add(watcher);\n    return watcher;\n  }\n  var current = filePath;\n  for (;;) {\n    var recursiveWatcher = recursiveWatchers.get(current);\n    if (recursiveWatcher !== undefined) {\n      recursiveWatcher.add(filePath, watcher);\n      return watcher;\n    }\n    var parent = path.dirname(current);\n    if (parent === current) break;\n    current = parent;\n  }\n  // Queue up watcher for creation\n  pendingWatchers.set(watcher, filePath);\n  if (!isBatch) execute();\n  return watcher;\n};\nexports.batch = function (fn) {\n  isBatch = true;\n  try {\n    fn();\n  } finally {\n    isBatch = false;\n    execute();\n  }\n};\nexports.getNumberOfWatchers = function () {\n  return watcherCount;\n};","map":{"version":3,"names":["fs","require","path","EventEmitter","reducePlan","IS_OSX","platform","IS_WIN","SUPPORTS_RECURSIVE_WATCHING","watcherLimit","process","env","WATCHPACK_WATCHER_LIMIT","recursiveWatcherLogging","WATCHPACK_RECURSIVE_WATCHER_LOGGING","isBatch","watcherCount","pendingWatchers","Map","recursiveWatchers","directWatchers","underlyingWatcher","DirectWatcher","filePath","watchers","Set","watcher","undefined","watch","on","type","filename","w","emit","error","err","nextTick","set","add","delete","size","close","RecursiveWatcher","rootPath","mapWatcherToPath","mapPathToWatchers","recursive","stderr","write","keys","dir","dirname","get","basename","subpath","slice","length","newSet","Watcher","has","remove","createDirectWatcher","existing","createRecursiveWatcher","execute","map","addWatcher","entry","Array","isArray","push","clear","item","values","getWatchers","join","plan","old","filePaths","watcherPath","exports","directWatcher","current","recursiveWatcher","parent","batch","fn","getNumberOfWatchers"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/watchpack/lib/watchEventSource.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst { EventEmitter } = require(\"events\");\nconst reducePlan = require(\"./reducePlan\");\n\nconst IS_OSX = require(\"os\").platform() === \"darwin\";\nconst IS_WIN = require(\"os\").platform() === \"win32\";\nconst SUPPORTS_RECURSIVE_WATCHING = IS_OSX || IS_WIN;\n\nconst watcherLimit =\n\t+process.env.WATCHPACK_WATCHER_LIMIT || (IS_OSX ? 2000 : 10000);\n\nconst recursiveWatcherLogging = !!process.env\n\t.WATCHPACK_RECURSIVE_WATCHER_LOGGING;\n\nlet isBatch = false;\nlet watcherCount = 0;\n\n/** @type {Map<Watcher, string>} */\nconst pendingWatchers = new Map();\n\n/** @type {Map<string, RecursiveWatcher>} */\nconst recursiveWatchers = new Map();\n\n/** @type {Map<string, DirectWatcher>} */\nconst directWatchers = new Map();\n\n/** @type {Map<Watcher, RecursiveWatcher | DirectWatcher>} */\nconst underlyingWatcher = new Map();\n\nclass DirectWatcher {\n\tconstructor(filePath) {\n\t\tthis.filePath = filePath;\n\t\tthis.watchers = new Set();\n\t\tthis.watcher = undefined;\n\t\ttry {\n\t\t\tconst watcher = fs.watch(filePath);\n\t\t\tthis.watcher = watcher;\n\t\t\twatcher.on(\"change\", (type, filename) => {\n\t\t\t\tfor (const w of this.watchers) {\n\t\t\t\t\tw.emit(\"change\", type, filename);\n\t\t\t\t}\n\t\t\t});\n\t\t\twatcher.on(\"error\", error => {\n\t\t\t\tfor (const w of this.watchers) {\n\t\t\t\t\tw.emit(\"error\", error);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tfor (const w of this.watchers) {\n\t\t\t\t\tw.emit(\"error\", err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\twatcherCount++;\n\t}\n\n\tadd(watcher) {\n\t\tunderlyingWatcher.set(watcher, this);\n\t\tthis.watchers.add(watcher);\n\t}\n\n\tremove(watcher) {\n\t\tthis.watchers.delete(watcher);\n\t\tif (this.watchers.size === 0) {\n\t\t\tdirectWatchers.delete(this.filePath);\n\t\t\twatcherCount--;\n\t\t\tif (this.watcher) this.watcher.close();\n\t\t}\n\t}\n\n\tgetWatchers() {\n\t\treturn this.watchers;\n\t}\n}\n\nclass RecursiveWatcher {\n\tconstructor(rootPath) {\n\t\tthis.rootPath = rootPath;\n\t\t/** @type {Map<Watcher, string>} */\n\t\tthis.mapWatcherToPath = new Map();\n\t\t/** @type {Map<string, Set<Watcher>>} */\n\t\tthis.mapPathToWatchers = new Map();\n\t\tthis.watcher = undefined;\n\t\ttry {\n\t\t\tconst watcher = fs.watch(rootPath, {\n\t\t\t\trecursive: true\n\t\t\t});\n\t\t\tthis.watcher = watcher;\n\t\t\twatcher.on(\"change\", (type, filename) => {\n\t\t\t\tif (!filename) {\n\t\t\t\t\tif (recursiveWatcherLogging) {\n\t\t\t\t\t\tprocess.stderr.write(\n\t\t\t\t\t\t\t`[watchpack] dispatch ${type} event in recursive watcher (${\n\t\t\t\t\t\t\t\tthis.rootPath\n\t\t\t\t\t\t\t}) to all watchers\\n`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\n\t\t\t\t\t\tw.emit(\"change\", type);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst dir = path.dirname(filename);\n\t\t\t\t\tconst watchers = this.mapPathToWatchers.get(dir);\n\t\t\t\t\tif (recursiveWatcherLogging) {\n\t\t\t\t\t\tprocess.stderr.write(\n\t\t\t\t\t\t\t`[watchpack] dispatch ${type} event in recursive watcher (${\n\t\t\t\t\t\t\t\tthis.rootPath\n\t\t\t\t\t\t\t}) for '${filename}' to ${\n\t\t\t\t\t\t\t\twatchers ? watchers.size : 0\n\t\t\t\t\t\t\t} watchers\\n`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (watchers === undefined) return;\n\t\t\t\t\tfor (const w of watchers) {\n\t\t\t\t\t\tw.emit(\"change\", type, path.basename(filename));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\twatcher.on(\"error\", error => {\n\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\n\t\t\t\t\tw.emit(\"error\", error);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\n\t\t\t\t\tw.emit(\"error\", err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\twatcherCount++;\n\t\tif (recursiveWatcherLogging) {\n\t\t\tprocess.stderr.write(\n\t\t\t\t`[watchpack] created recursive watcher at ${rootPath}\\n`\n\t\t\t);\n\t\t}\n\t}\n\n\tadd(filePath, watcher) {\n\t\tunderlyingWatcher.set(watcher, this);\n\t\tconst subpath = filePath.slice(this.rootPath.length + 1) || \".\";\n\t\tthis.mapWatcherToPath.set(watcher, subpath);\n\t\tconst set = this.mapPathToWatchers.get(subpath);\n\t\tif (set === undefined) {\n\t\t\tconst newSet = new Set();\n\t\t\tnewSet.add(watcher);\n\t\t\tthis.mapPathToWatchers.set(subpath, newSet);\n\t\t} else {\n\t\t\tset.add(watcher);\n\t\t}\n\t}\n\n\tremove(watcher) {\n\t\tconst subpath = this.mapWatcherToPath.get(watcher);\n\t\tif (!subpath) return;\n\t\tthis.mapWatcherToPath.delete(watcher);\n\t\tconst set = this.mapPathToWatchers.get(subpath);\n\t\tset.delete(watcher);\n\t\tif (set.size === 0) {\n\t\t\tthis.mapPathToWatchers.delete(subpath);\n\t\t}\n\t\tif (this.mapWatcherToPath.size === 0) {\n\t\t\trecursiveWatchers.delete(this.rootPath);\n\t\t\twatcherCount--;\n\t\t\tif (this.watcher) this.watcher.close();\n\t\t\tif (recursiveWatcherLogging) {\n\t\t\t\tprocess.stderr.write(\n\t\t\t\t\t`[watchpack] closed recursive watcher at ${this.rootPath}\\n`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetWatchers() {\n\t\treturn this.mapWatcherToPath;\n\t}\n}\n\nclass Watcher extends EventEmitter {\n\tclose() {\n\t\tif (pendingWatchers.has(this)) {\n\t\t\tpendingWatchers.delete(this);\n\t\t\treturn;\n\t\t}\n\t\tconst watcher = underlyingWatcher.get(this);\n\t\twatcher.remove(this);\n\t\tunderlyingWatcher.delete(this);\n\t}\n}\n\nconst createDirectWatcher = filePath => {\n\tconst existing = directWatchers.get(filePath);\n\tif (existing !== undefined) return existing;\n\tconst w = new DirectWatcher(filePath);\n\tdirectWatchers.set(filePath, w);\n\treturn w;\n};\n\nconst createRecursiveWatcher = rootPath => {\n\tconst existing = recursiveWatchers.get(rootPath);\n\tif (existing !== undefined) return existing;\n\tconst w = new RecursiveWatcher(rootPath);\n\trecursiveWatchers.set(rootPath, w);\n\treturn w;\n};\n\nconst execute = () => {\n\t/** @type {Map<string, Watcher[] | Watcher>} */\n\tconst map = new Map();\n\tconst addWatcher = (watcher, filePath) => {\n\t\tconst entry = map.get(filePath);\n\t\tif (entry === undefined) {\n\t\t\tmap.set(filePath, watcher);\n\t\t} else if (Array.isArray(entry)) {\n\t\t\tentry.push(watcher);\n\t\t} else {\n\t\t\tmap.set(filePath, [entry, watcher]);\n\t\t}\n\t};\n\tfor (const [watcher, filePath] of pendingWatchers) {\n\t\taddWatcher(watcher, filePath);\n\t}\n\tpendingWatchers.clear();\n\n\t// Fast case when we are not reaching the limit\n\tif (!SUPPORTS_RECURSIVE_WATCHING || watcherLimit - watcherCount >= map.size) {\n\t\t// Create watchers for all entries in the map\n\t\tfor (const [filePath, entry] of map) {\n\t\t\tconst w = createDirectWatcher(filePath);\n\t\t\tif (Array.isArray(entry)) {\n\t\t\t\tfor (const item of entry) w.add(item);\n\t\t\t} else {\n\t\t\t\tw.add(entry);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t// Reconsider existing watchers to improving watch plan\n\tfor (const watcher of recursiveWatchers.values()) {\n\t\tfor (const [w, subpath] of watcher.getWatchers()) {\n\t\t\taddWatcher(w, path.join(watcher.rootPath, subpath));\n\t\t}\n\t}\n\tfor (const watcher of directWatchers.values()) {\n\t\tfor (const w of watcher.getWatchers()) {\n\t\t\taddWatcher(w, watcher.filePath);\n\t\t}\n\t}\n\n\t// Merge map entries to keep watcher limit\n\t// Create a 10% buffer to be able to enter fast case more often\n\tconst plan = reducePlan(map, watcherLimit * 0.9);\n\n\t// Update watchers for all entries in the map\n\tfor (const [filePath, entry] of plan) {\n\t\tif (entry.size === 1) {\n\t\t\tfor (const [watcher, filePath] of entry) {\n\t\t\t\tconst w = createDirectWatcher(filePath);\n\t\t\t\tconst old = underlyingWatcher.get(watcher);\n\t\t\t\tif (old === w) continue;\n\t\t\t\tw.add(watcher);\n\t\t\t\tif (old !== undefined) old.remove(watcher);\n\t\t\t}\n\t\t} else {\n\t\t\tconst filePaths = new Set(entry.values());\n\t\t\tif (filePaths.size > 1) {\n\t\t\t\tconst w = createRecursiveWatcher(filePath);\n\t\t\t\tfor (const [watcher, watcherPath] of entry) {\n\t\t\t\t\tconst old = underlyingWatcher.get(watcher);\n\t\t\t\t\tif (old === w) continue;\n\t\t\t\t\tw.add(watcherPath, watcher);\n\t\t\t\t\tif (old !== undefined) old.remove(watcher);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const filePath of filePaths) {\n\t\t\t\t\tconst w = createDirectWatcher(filePath);\n\t\t\t\t\tfor (const watcher of entry.keys()) {\n\t\t\t\t\t\tconst old = underlyingWatcher.get(watcher);\n\t\t\t\t\t\tif (old === w) continue;\n\t\t\t\t\t\tw.add(watcher);\n\t\t\t\t\t\tif (old !== undefined) old.remove(watcher);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nexports.watch = filePath => {\n\tconst watcher = new Watcher();\n\t// Find an existing watcher\n\tconst directWatcher = directWatchers.get(filePath);\n\tif (directWatcher !== undefined) {\n\t\tdirectWatcher.add(watcher);\n\t\treturn watcher;\n\t}\n\tlet current = filePath;\n\tfor (;;) {\n\t\tconst recursiveWatcher = recursiveWatchers.get(current);\n\t\tif (recursiveWatcher !== undefined) {\n\t\t\trecursiveWatcher.add(filePath, watcher);\n\t\t\treturn watcher;\n\t\t}\n\t\tconst parent = path.dirname(current);\n\t\tif (parent === current) break;\n\t\tcurrent = parent;\n\t}\n\t// Queue up watcher for creation\n\tpendingWatchers.set(watcher, filePath);\n\tif (!isBatch) execute();\n\treturn watcher;\n};\n\nexports.batch = fn => {\n\tisBatch = true;\n\ttry {\n\t\tfn();\n\t} finally {\n\t\tisBatch = false;\n\t\texecute();\n\t}\n};\n\nexports.getNumberOfWatchers = () => {\n\treturn watcherCount;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}