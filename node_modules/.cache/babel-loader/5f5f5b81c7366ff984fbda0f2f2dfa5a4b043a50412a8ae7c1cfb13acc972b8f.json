{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _objectSpread = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _toConsumableArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _inherits = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _require = require(\"acorn\"),\n  AcornParser = _require.Parser;\nvar _require2 = require(\"acorn-import-assertions\"),\n  importAssertions = _require2.importAssertions;\nvar _require3 = require(\"tapable\"),\n  SyncBailHook = _require3.SyncBailHook,\n  HookMap = _require3.HookMap;\nvar vm = require(\"vm\");\nvar Parser = require(\"../Parser\");\nvar StackedMap = require(\"../util/StackedMap\");\nvar binarySearchBounds = require(\"../util/binarySearchBounds\");\nvar memoize = require(\"../util/memoize\");\nvar BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n\n/** @typedef {import(\"acorn\").Options} AcornOptions */\n/** @typedef {import(\"estree\").ArrayExpression} ArrayExpressionNode */\n/** @typedef {import(\"estree\").BinaryExpression} BinaryExpressionNode */\n/** @typedef {import(\"estree\").BlockStatement} BlockStatementNode */\n/** @typedef {import(\"estree\").SequenceExpression} SequenceExpressionNode */\n/** @typedef {import(\"estree\").CallExpression} CallExpressionNode */\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclarationNode */\n/** @typedef {import(\"estree\").ClassExpression} ClassExpressionNode */\n/** @typedef {import(\"estree\").Comment} CommentNode */\n/** @typedef {import(\"estree\").ConditionalExpression} ConditionalExpressionNode */\n/** @typedef {import(\"estree\").Declaration} DeclarationNode */\n/** @typedef {import(\"estree\").PrivateIdentifier} PrivateIdentifierNode */\n/** @typedef {import(\"estree\").PropertyDefinition} PropertyDefinitionNode */\n/** @typedef {import(\"estree\").Expression} ExpressionNode */\n/** @typedef {import(\"estree\").Identifier} IdentifierNode */\n/** @typedef {import(\"estree\").IfStatement} IfStatementNode */\n/** @typedef {import(\"estree\").LabeledStatement} LabeledStatementNode */\n/** @typedef {import(\"estree\").Literal} LiteralNode */\n/** @typedef {import(\"estree\").LogicalExpression} LogicalExpressionNode */\n/** @typedef {import(\"estree\").ChainExpression} ChainExpressionNode */\n/** @typedef {import(\"estree\").MemberExpression} MemberExpressionNode */\n/** @typedef {import(\"estree\").MetaProperty} MetaPropertyNode */\n/** @typedef {import(\"estree\").MethodDefinition} MethodDefinitionNode */\n/** @typedef {import(\"estree\").ModuleDeclaration} ModuleDeclarationNode */\n/** @typedef {import(\"estree\").NewExpression} NewExpressionNode */\n/** @typedef {import(\"estree\").Node} AnyNode */\n/** @typedef {import(\"estree\").Program} ProgramNode */\n/** @typedef {import(\"estree\").Statement} StatementNode */\n/** @typedef {import(\"estree\").ImportDeclaration} ImportDeclarationNode */\n/** @typedef {import(\"estree\").ExportNamedDeclaration} ExportNamedDeclarationNode */\n/** @typedef {import(\"estree\").ExportDefaultDeclaration} ExportDefaultDeclarationNode */\n/** @typedef {import(\"estree\").ExportAllDeclaration} ExportAllDeclarationNode */\n/** @typedef {import(\"estree\").Super} SuperNode */\n/** @typedef {import(\"estree\").TaggedTemplateExpression} TaggedTemplateExpressionNode */\n/** @typedef {import(\"estree\").TemplateLiteral} TemplateLiteralNode */\n/** @typedef {import(\"estree\").ThisExpression} ThisExpressionNode */\n/** @typedef {import(\"estree\").UnaryExpression} UnaryExpressionNode */\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclaratorNode */\n/** @template T @typedef {import(\"tapable\").AsArray<T>} AsArray<T> */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../Parser\").PreparsedAst} PreparsedAst */\n/** @typedef {{declaredScope: ScopeInfo, freeName: string | true, tagInfo: TagInfo | undefined}} VariableInfoInterface */\n/** @typedef {{ name: string | VariableInfo, rootInfo: string | VariableInfo, getMembers: () => string[], getMembersOptionals: () => boolean[] }} GetInfoResult */\n\nvar EMPTY_ARRAY = [];\nvar ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = 1;\nvar ALLOWED_MEMBER_TYPES_EXPRESSION = 2;\nvar ALLOWED_MEMBER_TYPES_ALL = 3;\n\n// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\n\nvar parser = AcornParser.extend(importAssertions);\nvar VariableInfo = /*#__PURE__*/_createClass(\n/**\n * @param {ScopeInfo} declaredScope scope in which the variable is declared\n * @param {string | true} freeName which free name the variable aliases, or true when none\n * @param {TagInfo | undefined} tagInfo info about tags\n */\nfunction VariableInfo(declaredScope, freeName, tagInfo) {\n  _classCallCheck(this, VariableInfo);\n  this.declaredScope = declaredScope;\n  this.freeName = freeName;\n  this.tagInfo = tagInfo;\n});\n/** @typedef {string | ScopeInfo | VariableInfo} ExportedVariableInfo */\n/** @typedef {LiteralNode | string | null | undefined} ImportSource */\n/** @typedef {Omit<AcornOptions, \"sourceType\" | \"ecmaVersion\"> & { sourceType: \"module\" | \"script\" | \"auto\", ecmaVersion?: AcornOptions[\"ecmaVersion\"] }} ParseOptions */\n/**\n * @typedef {Object} TagInfo\n * @property {any} tag\n * @property {any} data\n * @property {TagInfo | undefined} next\n */\n/**\n * @typedef {Object} ScopeInfo\n * @property {StackedMap<string, VariableInfo | ScopeInfo>} definitions\n * @property {boolean | \"arrow\"} topLevelScope\n * @property {boolean} inShorthand\n * @property {boolean} isStrict\n * @property {boolean} isAsmJs\n * @property {boolean} inTry\n */\nvar joinRanges = function joinRanges(startRange, endRange) {\n  if (!endRange) return startRange;\n  if (!startRange) return endRange;\n  return [startRange[0], endRange[1]];\n};\nvar objectAndMembersToName = function objectAndMembersToName(object, membersReversed) {\n  var name = object;\n  for (var i = membersReversed.length - 1; i >= 0; i--) {\n    name = name + \".\" + membersReversed[i];\n  }\n  return name;\n};\nvar getRootName = function getRootName(expression) {\n  switch (expression.type) {\n    case \"Identifier\":\n      return expression.name;\n    case \"ThisExpression\":\n      return \"this\";\n    case \"MetaProperty\":\n      return \"\".concat(expression.meta.name, \".\").concat(expression.property.name);\n    default:\n      return undefined;\n  }\n};\n\n/** @type {AcornOptions} */\nvar defaultParserOptions = {\n  ranges: true,\n  locations: true,\n  ecmaVersion: \"latest\",\n  sourceType: \"module\",\n  // https://github.com/tc39/proposal-hashbang\n  allowHashBang: true,\n  onComment: null\n};\n\n// regexp to match at least one \"magic comment\"\nvar webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\nvar EMPTY_COMMENT_OPTIONS = {\n  options: null,\n  errors: null\n};\nvar JavascriptParser = /*#__PURE__*/function (_Parser) {\n  _inherits(JavascriptParser, _Parser);\n  var _super = _createSuper(JavascriptParser);\n  /**\n   * @param {\"module\" | \"script\" | \"auto\"} sourceType default source type\n   */\n  function JavascriptParser() {\n    var _this;\n    var sourceType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"auto\";\n    _classCallCheck(this, JavascriptParser);\n    _this = _super.call(this);\n    _this.hooks = Object.freeze({\n      /** @type {HookMap<SyncBailHook<[UnaryExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateTypeof: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      /** @type {HookMap<SyncBailHook<[ExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n      evaluate: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      /** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode | MetaPropertyNode], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateIdentifier: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      /** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateDefinedIdentifier: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      /** @type {HookMap<SyncBailHook<[NewExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateNewExpression: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      /** @type {HookMap<SyncBailHook<[CallExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateCallExpression: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      /** @type {HookMap<SyncBailHook<[CallExpressionNode, BasicEvaluatedExpression | undefined], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateCallExpressionMember: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"param\"]);\n      }),\n      /** @type {HookMap<SyncBailHook<[ExpressionNode | DeclarationNode | PrivateIdentifierNode, number], boolean | void>>} */\n      isPure: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"commentsStartPosition\"]);\n      }),\n      /** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */\n      preStatement: new SyncBailHook([\"statement\"]),\n      /** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */\n      blockPreStatement: new SyncBailHook([\"declaration\"]),\n      /** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */\n      statement: new SyncBailHook([\"statement\"]),\n      /** @type {SyncBailHook<[IfStatementNode], boolean | void>} */\n      statementIf: new SyncBailHook([\"statement\"]),\n      /** @type {SyncBailHook<[ExpressionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */\n      classExtendsExpression: new SyncBailHook([\"expression\", \"classDefinition\"]),\n      /** @type {SyncBailHook<[MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */\n      classBodyElement: new SyncBailHook([\"element\", \"classDefinition\"]),\n      /** @type {SyncBailHook<[ExpressionNode, MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */\n      classBodyValue: new SyncBailHook([\"expression\", \"element\", \"classDefinition\"]),\n      /** @type {HookMap<SyncBailHook<[LabeledStatementNode], boolean | void>>} */\n      label: new HookMap(function () {\n        return new SyncBailHook([\"statement\"]);\n      }),\n      /** @type {SyncBailHook<[ImportDeclarationNode, ImportSource], boolean | void>} */\n      import: new SyncBailHook([\"statement\", \"source\"]),\n      /** @type {SyncBailHook<[ImportDeclarationNode, ImportSource, string, string], boolean | void>} */\n      importSpecifier: new SyncBailHook([\"statement\", \"source\", \"exportName\", \"identifierName\"]),\n      /** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode], boolean | void>} */\n      export: new SyncBailHook([\"statement\"]),\n      /** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource], boolean | void>} */\n      exportImport: new SyncBailHook([\"statement\", \"source\"]),\n      /** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, DeclarationNode], boolean | void>} */\n      exportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n      /** @type {SyncBailHook<[ExportDefaultDeclarationNode, DeclarationNode], boolean | void>} */\n      exportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n      /** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, string, string, number | undefined], boolean | void>} */\n      exportSpecifier: new SyncBailHook([\"statement\", \"identifierName\", \"exportName\", \"index\"]),\n      /** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource, string, string, number | undefined], boolean | void>} */\n      exportImportSpecifier: new SyncBailHook([\"statement\", \"source\", \"identifierName\", \"exportName\", \"index\"]),\n      /** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */\n      preDeclarator: new SyncBailHook([\"declarator\", \"statement\"]),\n      /** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */\n      declarator: new SyncBailHook([\"declarator\", \"statement\"]),\n      /** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n      varDeclaration: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      /** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n      varDeclarationLet: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      /** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n      varDeclarationConst: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      /** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n      varDeclarationVar: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      /** @type {HookMap<SyncBailHook<[IdentifierNode], boolean | void>>} */\n      pattern: new HookMap(function () {\n        return new SyncBailHook([\"pattern\"]);\n      }),\n      /** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n      canRename: new HookMap(function () {\n        return new SyncBailHook([\"initExpression\"]);\n      }),\n      /** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n      rename: new HookMap(function () {\n        return new SyncBailHook([\"initExpression\"]);\n      }),\n      /** @type {HookMap<SyncBailHook<[import(\"estree\").AssignmentExpression], boolean | void>>} */\n      assign: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      /** @type {HookMap<SyncBailHook<[import(\"estree\").AssignmentExpression, string[]], boolean | void>>} */\n      assignMemberChain: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"members\"]);\n      }),\n      /** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n      typeof: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      /** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n      importCall: new SyncBailHook([\"expression\"]),\n      /** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n      topLevelAwait: new SyncBailHook([\"expression\"]),\n      /** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n      call: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      /** Something like \"a.b()\" */\n      /** @type {HookMap<SyncBailHook<[CallExpressionNode, string[], boolean[]], boolean | void>>} */\n      callMemberChain: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"members\", \"membersOptionals\"]);\n      }),\n      /** Something like \"a.b().c.d\" */\n      /** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */\n      memberChainOfCallMemberChain: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"calleeMembers\", \"callExpression\", \"members\"]);\n      }),\n      /** Something like \"a.b().c.d()\"\" */\n      /** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */\n      callMemberChainOfCallMemberChain: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"calleeMembers\", \"innerCallExpression\", \"members\"]);\n      }),\n      /** @type {SyncBailHook<[ChainExpressionNode], boolean | void>} */\n      optionalChaining: new SyncBailHook([\"optionalChaining\"]),\n      /** @type {HookMap<SyncBailHook<[NewExpressionNode], boolean | void>>} */\n      new: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      /** @type {SyncBailHook<[BinaryExpressionNode], boolean | void>} */\n      binaryExpression: new SyncBailHook([\"binaryExpression\"]),\n      /** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n      expression: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      /** @type {HookMap<SyncBailHook<[ExpressionNode, string[], boolean[]], boolean | void>>} */\n      expressionMemberChain: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"members\", \"membersOptionals\"]);\n      }),\n      /** @type {HookMap<SyncBailHook<[ExpressionNode, string[]], boolean | void>>} */\n      unhandledExpressionMemberChain: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"members\"]);\n      }),\n      /** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n      expressionConditionalOperator: new SyncBailHook([\"expression\"]),\n      /** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n      expressionLogicalOperator: new SyncBailHook([\"expression\"]),\n      /** @type {SyncBailHook<[ProgramNode, CommentNode[]], boolean | void>} */\n      program: new SyncBailHook([\"ast\", \"comments\"]),\n      /** @type {SyncBailHook<[ProgramNode, CommentNode[]], boolean | void>} */\n      finish: new SyncBailHook([\"ast\", \"comments\"])\n    });\n    _this.sourceType = sourceType;\n    /** @type {ScopeInfo} */\n    _this.scope = undefined;\n    /** @type {ParserState} */\n    _this.state = undefined;\n    _this.comments = undefined;\n    _this.semicolons = undefined;\n    /** @type {(StatementNode|ExpressionNode)[]} */\n    _this.statementPath = undefined;\n    _this.prevStatement = undefined;\n    _this.currentTagData = undefined;\n    _this._initializeEvaluating();\n    return _this;\n  }\n  _createClass(JavascriptParser, [{\n    key: \"_initializeEvaluating\",\n    value: function _initializeEvaluating() {\n      var _this2 = this;\n      this.hooks.evaluate.for(\"Literal\").tap(\"JavascriptParser\", function (_expr) {\n        var expr = /** @type {LiteralNode} */_expr;\n        switch (typeof expr.value) {\n          case \"number\":\n            return new BasicEvaluatedExpression().setNumber(expr.value).setRange(expr.range);\n          case \"bigint\":\n            return new BasicEvaluatedExpression().setBigInt(expr.value).setRange(expr.range);\n          case \"string\":\n            return new BasicEvaluatedExpression().setString(expr.value).setRange(expr.range);\n          case \"boolean\":\n            return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(expr.range);\n        }\n        if (expr.value === null) {\n          return new BasicEvaluatedExpression().setNull().setRange(expr.range);\n        }\n        if (expr.value instanceof RegExp) {\n          return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluate.for(\"NewExpression\").tap(\"JavascriptParser\", function (_expr) {\n        var expr = /** @type {NewExpressionNode} */_expr;\n        var callee = expr.callee;\n        if (callee.type !== \"Identifier\") return;\n        if (callee.name !== \"RegExp\") {\n          return _this2.callHooksForName(_this2.hooks.evaluateNewExpression, callee.name, expr);\n        } else if (expr.arguments.length > 2 || _this2.getVariableInfo(\"RegExp\") !== \"RegExp\") return;\n        var regExp, flags;\n        var arg1 = expr.arguments[0];\n        if (arg1) {\n          if (arg1.type === \"SpreadElement\") return;\n          var evaluatedRegExp = _this2.evaluateExpression(arg1);\n          if (!evaluatedRegExp) return;\n          regExp = evaluatedRegExp.asString();\n          if (!regExp) return;\n        } else {\n          return new BasicEvaluatedExpression().setRegExp(new RegExp(\"\")).setRange(expr.range);\n        }\n        var arg2 = expr.arguments[1];\n        if (arg2) {\n          if (arg2.type === \"SpreadElement\") return;\n          var evaluatedFlags = _this2.evaluateExpression(arg2);\n          if (!evaluatedFlags) return;\n          if (!evaluatedFlags.isUndefined()) {\n            flags = evaluatedFlags.asString();\n            if (flags === undefined || !BasicEvaluatedExpression.isValidRegExpFlags(flags)) return;\n          }\n        }\n        return new BasicEvaluatedExpression().setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp)).setRange(expr.range);\n      });\n      this.hooks.evaluate.for(\"LogicalExpression\").tap(\"JavascriptParser\", function (_expr) {\n        var expr = /** @type {LogicalExpressionNode} */_expr;\n        var left = _this2.evaluateExpression(expr.left);\n        var returnRight = false;\n        /** @type {boolean|undefined} */\n        var allowedRight;\n        if (expr.operator === \"&&\") {\n          var leftAsBool = left.asBool();\n          if (leftAsBool === false) return left.setRange(expr.range);\n          returnRight = leftAsBool === true;\n          allowedRight = false;\n        } else if (expr.operator === \"||\") {\n          var _leftAsBool = left.asBool();\n          if (_leftAsBool === true) return left.setRange(expr.range);\n          returnRight = _leftAsBool === false;\n          allowedRight = true;\n        } else if (expr.operator === \"??\") {\n          var leftAsNullish = left.asNullish();\n          if (leftAsNullish === false) return left.setRange(expr.range);\n          if (leftAsNullish !== true) return;\n          returnRight = true;\n        } else return;\n        var right = _this2.evaluateExpression(expr.right);\n        if (returnRight) {\n          if (left.couldHaveSideEffects()) right.setSideEffects();\n          return right.setRange(expr.range);\n        }\n        var asBool = right.asBool();\n        if (allowedRight === true && asBool === true) {\n          return new BasicEvaluatedExpression().setRange(expr.range).setTruthy();\n        } else if (allowedRight === false && asBool === false) {\n          return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();\n        }\n      });\n      var valueAsExpression = function valueAsExpression(value, expr, sideEffects) {\n        switch (typeof value) {\n          case \"boolean\":\n            return new BasicEvaluatedExpression().setBoolean(value).setSideEffects(sideEffects).setRange(expr.range);\n          case \"number\":\n            return new BasicEvaluatedExpression().setNumber(value).setSideEffects(sideEffects).setRange(expr.range);\n          case \"bigint\":\n            return new BasicEvaluatedExpression().setBigInt(value).setSideEffects(sideEffects).setRange(expr.range);\n          case \"string\":\n            return new BasicEvaluatedExpression().setString(value).setSideEffects(sideEffects).setRange(expr.range);\n        }\n      };\n      this.hooks.evaluate.for(\"BinaryExpression\").tap(\"JavascriptParser\", function (_expr) {\n        var expr = /** @type {BinaryExpressionNode} */_expr;\n        var handleConstOperation = function handleConstOperation(fn) {\n          var left = _this2.evaluateExpression(expr.left);\n          if (!left.isCompileTimeValue()) return;\n          var right = _this2.evaluateExpression(expr.right);\n          if (!right.isCompileTimeValue()) return;\n          var result = fn(left.asCompileTimeValue(), right.asCompileTimeValue());\n          return valueAsExpression(result, expr, left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        };\n        var isAlwaysDifferent = function isAlwaysDifferent(a, b) {\n          return a === true && b === false || a === false && b === true;\n        };\n        var handleTemplateStringCompare = function handleTemplateStringCompare(left, right, res, eql) {\n          var getPrefix = function getPrefix(parts) {\n            var value = \"\";\n            var _iterator = _createForOfIteratorHelper(parts),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var p = _step.value;\n                var v = p.asString();\n                if (v !== undefined) value += v;else break;\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n            return value;\n          };\n          var getSuffix = function getSuffix(parts) {\n            var value = \"\";\n            for (var i = parts.length - 1; i >= 0; i--) {\n              var v = parts[i].asString();\n              if (v !== undefined) value = v + value;else break;\n            }\n            return value;\n          };\n          var leftPrefix = getPrefix(left.parts);\n          var rightPrefix = getPrefix(right.parts);\n          var leftSuffix = getSuffix(left.parts);\n          var rightSuffix = getSuffix(right.parts);\n          var lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);\n          var lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);\n          if (leftPrefix.slice(0, lenPrefix) !== rightPrefix.slice(0, lenPrefix) || leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)) {\n            return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n          }\n        };\n        var handleStrictEqualityComparison = function handleStrictEqualityComparison(eql) {\n          var left = _this2.evaluateExpression(expr.left);\n          var right = _this2.evaluateExpression(expr.right);\n          var res = new BasicEvaluatedExpression();\n          res.setRange(expr.range);\n          var leftConst = left.isCompileTimeValue();\n          var rightConst = right.isCompileTimeValue();\n          if (leftConst && rightConst) {\n            return res.setBoolean(eql === (left.asCompileTimeValue() === right.asCompileTimeValue())).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n          }\n          if (left.isArray() && right.isArray()) {\n            return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n          }\n          if (left.isTemplateString() && right.isTemplateString()) {\n            return handleTemplateStringCompare(left, right, res, eql);\n          }\n          var leftPrimitive = left.isPrimitiveType();\n          var rightPrimitive = right.isPrimitiveType();\n          if (\n          // Primitive !== Object or\n          // compile-time object types are never equal to something at runtime\n          leftPrimitive === false && (leftConst || rightPrimitive === true) || rightPrimitive === false && (rightConst || leftPrimitive === true) ||\n          // Different nullish or boolish status also means not equal\n          isAlwaysDifferent(left.asBool(), right.asBool()) || isAlwaysDifferent(left.asNullish(), right.asNullish())) {\n            return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n          }\n        };\n        var handleAbstractEqualityComparison = function handleAbstractEqualityComparison(eql) {\n          var left = _this2.evaluateExpression(expr.left);\n          var right = _this2.evaluateExpression(expr.right);\n          var res = new BasicEvaluatedExpression();\n          res.setRange(expr.range);\n          var leftConst = left.isCompileTimeValue();\n          var rightConst = right.isCompileTimeValue();\n          if (leftConst && rightConst) {\n            return res.setBoolean(eql === (\n            // eslint-disable-next-line eqeqeq\n            left.asCompileTimeValue() == right.asCompileTimeValue())).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n          }\n          if (left.isArray() && right.isArray()) {\n            return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n          }\n          if (left.isTemplateString() && right.isTemplateString()) {\n            return handleTemplateStringCompare(left, right, res, eql);\n          }\n        };\n        if (expr.operator === \"+\") {\n          var left = _this2.evaluateExpression(expr.left);\n          var right = _this2.evaluateExpression(expr.right);\n          var res = new BasicEvaluatedExpression();\n          if (left.isString()) {\n            if (right.isString()) {\n              res.setString(left.string + right.string);\n            } else if (right.isNumber()) {\n              res.setString(left.string + right.number);\n            } else if (right.isWrapped() && right.prefix && right.prefix.isString()) {\n              // \"left\" + (\"prefix\" + inner + \"postfix\")\n              // => (\"leftPrefix\" + inner + \"postfix\")\n              res.setWrapped(new BasicEvaluatedExpression().setString(left.string + right.prefix.string).setRange(joinRanges(left.range, right.prefix.range)), right.postfix, right.wrappedInnerExpressions);\n            } else if (right.isWrapped()) {\n              // \"left\" + ([null] + inner + \"postfix\")\n              // => (\"left\" + inner + \"postfix\")\n              res.setWrapped(left, right.postfix, right.wrappedInnerExpressions);\n            } else {\n              // \"left\" + expr\n              // => (\"left\" + expr + \"\")\n              res.setWrapped(left, null, [right]);\n            }\n          } else if (left.isNumber()) {\n            if (right.isString()) {\n              res.setString(left.number + right.string);\n            } else if (right.isNumber()) {\n              res.setNumber(left.number + right.number);\n            } else {\n              return;\n            }\n          } else if (left.isBigInt()) {\n            if (right.isBigInt()) {\n              res.setBigInt(left.bigint + right.bigint);\n            }\n          } else if (left.isWrapped()) {\n            if (left.postfix && left.postfix.isString() && right.isString()) {\n              // (\"prefix\" + inner + \"postfix\") + \"right\"\n              // => (\"prefix\" + inner + \"postfixRight\")\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.string).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n            } else if (left.postfix && left.postfix.isString() && right.isNumber()) {\n              // (\"prefix\" + inner + \"postfix\") + 123\n              // => (\"prefix\" + inner + \"postfix123\")\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.number).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n            } else if (right.isString()) {\n              // (\"prefix\" + inner + [null]) + \"right\"\n              // => (\"prefix\" + inner + \"right\")\n              res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n            } else if (right.isNumber()) {\n              // (\"prefix\" + inner + [null]) + 123\n              // => (\"prefix\" + inner + \"123\")\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(right.number + \"\").setRange(right.range), left.wrappedInnerExpressions);\n            } else if (right.isWrapped()) {\n              // (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n              // (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n              res.setWrapped(left.prefix, right.postfix, left.wrappedInnerExpressions && right.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix] : []).concat(right.prefix ? [right.prefix] : []).concat(right.wrappedInnerExpressions));\n            } else {\n              // (\"prefix\" + inner + postfix) + expr\n              // => (\"prefix\" + inner + postfix + expr + [null])\n              res.setWrapped(left.prefix, null, left.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix, right] : [right]));\n            }\n          } else {\n            if (right.isString()) {\n              // left + \"right\"\n              // => ([null] + left + \"right\")\n              res.setWrapped(null, right, [left]);\n            } else if (right.isWrapped()) {\n              // left + (prefix + inner + \"postfix\")\n              // => ([null] + left + prefix + inner + \"postfix\")\n              res.setWrapped(null, right.postfix, right.wrappedInnerExpressions && (right.prefix ? [left, right.prefix] : [left]).concat(right.wrappedInnerExpressions));\n            } else {\n              return;\n            }\n          }\n          if (left.couldHaveSideEffects() || right.couldHaveSideEffects()) res.setSideEffects();\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"-\") {\n          return handleConstOperation(function (l, r) {\n            return l - r;\n          });\n        } else if (expr.operator === \"*\") {\n          return handleConstOperation(function (l, r) {\n            return l * r;\n          });\n        } else if (expr.operator === \"/\") {\n          return handleConstOperation(function (l, r) {\n            return l / r;\n          });\n        } else if (expr.operator === \"**\") {\n          return handleConstOperation(function (l, r) {\n            return Math.pow(l, r);\n          });\n        } else if (expr.operator === \"===\") {\n          return handleStrictEqualityComparison(true);\n        } else if (expr.operator === \"==\") {\n          return handleAbstractEqualityComparison(true);\n        } else if (expr.operator === \"!==\") {\n          return handleStrictEqualityComparison(false);\n        } else if (expr.operator === \"!=\") {\n          return handleAbstractEqualityComparison(false);\n        } else if (expr.operator === \"&\") {\n          return handleConstOperation(function (l, r) {\n            return l & r;\n          });\n        } else if (expr.operator === \"|\") {\n          return handleConstOperation(function (l, r) {\n            return l | r;\n          });\n        } else if (expr.operator === \"^\") {\n          return handleConstOperation(function (l, r) {\n            return l ^ r;\n          });\n        } else if (expr.operator === \">>>\") {\n          return handleConstOperation(function (l, r) {\n            return l >>> r;\n          });\n        } else if (expr.operator === \">>\") {\n          return handleConstOperation(function (l, r) {\n            return l >> r;\n          });\n        } else if (expr.operator === \"<<\") {\n          return handleConstOperation(function (l, r) {\n            return l << r;\n          });\n        } else if (expr.operator === \"<\") {\n          return handleConstOperation(function (l, r) {\n            return l < r;\n          });\n        } else if (expr.operator === \">\") {\n          return handleConstOperation(function (l, r) {\n            return l > r;\n          });\n        } else if (expr.operator === \"<=\") {\n          return handleConstOperation(function (l, r) {\n            return l <= r;\n          });\n        } else if (expr.operator === \">=\") {\n          return handleConstOperation(function (l, r) {\n            return l >= r;\n          });\n        }\n      });\n      this.hooks.evaluate.for(\"UnaryExpression\").tap(\"JavascriptParser\", function (_expr) {\n        var expr = /** @type {UnaryExpressionNode} */_expr;\n        var handleConstOperation = function handleConstOperation(fn) {\n          var argument = _this2.evaluateExpression(expr.argument);\n          if (!argument.isCompileTimeValue()) return;\n          var result = fn(argument.asCompileTimeValue());\n          return valueAsExpression(result, expr, argument.couldHaveSideEffects());\n        };\n        if (expr.operator === \"typeof\") {\n          switch (expr.argument.type) {\n            case \"Identifier\":\n              {\n                var res = _this2.callHooksForName(_this2.hooks.evaluateTypeof, expr.argument.name, expr);\n                if (res !== undefined) return res;\n                break;\n              }\n            case \"MetaProperty\":\n              {\n                var _res = _this2.callHooksForName(_this2.hooks.evaluateTypeof, getRootName(expr.argument), expr);\n                if (_res !== undefined) return _res;\n                break;\n              }\n            case \"MemberExpression\":\n              {\n                var _res2 = _this2.callHooksForExpression(_this2.hooks.evaluateTypeof, expr.argument, expr);\n                if (_res2 !== undefined) return _res2;\n                break;\n              }\n            case \"ChainExpression\":\n              {\n                var _res3 = _this2.callHooksForExpression(_this2.hooks.evaluateTypeof, expr.argument.expression, expr);\n                if (_res3 !== undefined) return _res3;\n                break;\n              }\n            case \"FunctionExpression\":\n              {\n                return new BasicEvaluatedExpression().setString(\"function\").setRange(expr.range);\n              }\n          }\n          var arg = _this2.evaluateExpression(expr.argument);\n          if (arg.isUnknown()) return;\n          if (arg.isString()) {\n            return new BasicEvaluatedExpression().setString(\"string\").setRange(expr.range);\n          }\n          if (arg.isWrapped()) {\n            return new BasicEvaluatedExpression().setString(\"string\").setSideEffects().setRange(expr.range);\n          }\n          if (arg.isUndefined()) {\n            return new BasicEvaluatedExpression().setString(\"undefined\").setRange(expr.range);\n          }\n          if (arg.isNumber()) {\n            return new BasicEvaluatedExpression().setString(\"number\").setRange(expr.range);\n          }\n          if (arg.isBigInt()) {\n            return new BasicEvaluatedExpression().setString(\"bigint\").setRange(expr.range);\n          }\n          if (arg.isBoolean()) {\n            return new BasicEvaluatedExpression().setString(\"boolean\").setRange(expr.range);\n          }\n          if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {\n            return new BasicEvaluatedExpression().setString(\"object\").setRange(expr.range);\n          }\n          if (arg.isArray()) {\n            return new BasicEvaluatedExpression().setString(\"object\").setSideEffects(arg.couldHaveSideEffects()).setRange(expr.range);\n          }\n        } else if (expr.operator === \"!\") {\n          var argument = _this2.evaluateExpression(expr.argument);\n          var bool = argument.asBool();\n          if (typeof bool !== \"boolean\") return;\n          return new BasicEvaluatedExpression().setBoolean(!bool).setSideEffects(argument.couldHaveSideEffects()).setRange(expr.range);\n        } else if (expr.operator === \"~\") {\n          return handleConstOperation(function (v) {\n            return ~v;\n          });\n        } else if (expr.operator === \"+\") {\n          return handleConstOperation(function (v) {\n            return +v;\n          });\n        } else if (expr.operator === \"-\") {\n          return handleConstOperation(function (v) {\n            return -v;\n          });\n        }\n      });\n      this.hooks.evaluateTypeof.for(\"undefined\").tap(\"JavascriptParser\", function (expr) {\n        return new BasicEvaluatedExpression().setString(\"undefined\").setRange(expr.range);\n      });\n      this.hooks.evaluate.for(\"Identifier\").tap(\"JavascriptParser\", function (expr) {\n        if ( /** @type {IdentifierNode} */expr.name === \"undefined\") {\n          return new BasicEvaluatedExpression().setUndefined().setRange(expr.range);\n        }\n      });\n      /**\n       * @param {string} exprType expression type name\n       * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info\n       * @returns {void}\n       */\n      var tapEvaluateWithVariableInfo = function tapEvaluateWithVariableInfo(exprType, getInfo) {\n        /** @type {ExpressionNode | undefined} */\n        var cachedExpression = undefined;\n        /** @type {GetInfoResult | undefined} */\n        var cachedInfo = undefined;\n        _this2.hooks.evaluate.for(exprType).tap(\"JavascriptParser\", function (expr) {\n          var expression = /** @type {MemberExpressionNode} */expr;\n          var info = getInfo(expr);\n          if (info !== undefined) {\n            return _this2.callHooksForInfoWithFallback(_this2.hooks.evaluateIdentifier, info.name, function (name) {\n              cachedExpression = expression;\n              cachedInfo = info;\n            }, function (name) {\n              var hook = _this2.hooks.evaluateDefinedIdentifier.get(name);\n              if (hook !== undefined) {\n                return hook.call(expression);\n              }\n            }, expression);\n          }\n        });\n        _this2.hooks.evaluate.for(exprType).tap({\n          name: \"JavascriptParser\",\n          stage: 100\n        }, function (expr) {\n          var info = cachedExpression === expr ? cachedInfo : getInfo(expr);\n          if (info !== undefined) {\n            return new BasicEvaluatedExpression().setIdentifier(info.name, info.rootInfo, info.getMembers, info.getMembersOptionals).setRange(expr.range);\n          }\n        });\n        _this2.hooks.finish.tap(\"JavascriptParser\", function () {\n          // Cleanup for GC\n          cachedExpression = cachedInfo = undefined;\n        });\n      };\n      tapEvaluateWithVariableInfo(\"Identifier\", function (expr) {\n        var info = _this2.getVariableInfo( /** @type {IdentifierNode} */expr.name);\n        if (typeof info === \"string\" || info instanceof VariableInfo && typeof info.freeName === \"string\") {\n          return {\n            name: info,\n            rootInfo: info,\n            getMembers: function getMembers() {\n              return [];\n            },\n            getMembersOptionals: function getMembersOptionals() {\n              return [];\n            }\n          };\n        }\n      });\n      tapEvaluateWithVariableInfo(\"ThisExpression\", function (expr) {\n        var info = _this2.getVariableInfo(\"this\");\n        if (typeof info === \"string\" || info instanceof VariableInfo && typeof info.freeName === \"string\") {\n          return {\n            name: info,\n            rootInfo: info,\n            getMembers: function getMembers() {\n              return [];\n            },\n            getMembersOptionals: function getMembersOptionals() {\n              return [];\n            }\n          };\n        }\n      });\n      this.hooks.evaluate.for(\"MetaProperty\").tap(\"JavascriptParser\", function (expr) {\n        var metaProperty = /** @type {MetaPropertyNode} */expr;\n        return _this2.callHooksForName(_this2.hooks.evaluateIdentifier, getRootName(expr), metaProperty);\n      });\n      tapEvaluateWithVariableInfo(\"MemberExpression\", function (expr) {\n        return _this2.getMemberExpressionInfo( /** @type {MemberExpressionNode} */expr, ALLOWED_MEMBER_TYPES_EXPRESSION);\n      });\n      this.hooks.evaluate.for(\"CallExpression\").tap(\"JavascriptParser\", function (_expr) {\n        var expr = /** @type {CallExpressionNode} */_expr;\n        if (expr.callee.type === \"MemberExpression\" && expr.callee.property.type === (expr.callee.computed ? \"Literal\" : \"Identifier\")) {\n          // type Super also possible here\n          var param = _this2.evaluateExpression( /** @type {ExpressionNode} */expr.callee.object);\n          var property = expr.callee.property.type === \"Literal\" ? \"\".concat(expr.callee.property.value) : expr.callee.property.name;\n          var hook = _this2.hooks.evaluateCallExpressionMember.get(property);\n          if (hook !== undefined) {\n            return hook.call(expr, param);\n          }\n        } else if (expr.callee.type === \"Identifier\") {\n          return _this2.callHooksForName(_this2.hooks.evaluateCallExpression, expr.callee.name, expr);\n        }\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"indexOf\").tap(\"JavascriptParser\", function (expr, param) {\n        if (!param.isString()) return;\n        if (expr.arguments.length === 0) return;\n        var _expr$arguments = _slicedToArray(expr.arguments, 2),\n          arg1 = _expr$arguments[0],\n          arg2 = _expr$arguments[1];\n        if (arg1.type === \"SpreadElement\") return;\n        var arg1Eval = _this2.evaluateExpression(arg1);\n        if (!arg1Eval.isString()) return;\n        var arg1Value = arg1Eval.string;\n        var result;\n        if (arg2) {\n          if (arg2.type === \"SpreadElement\") return;\n          var arg2Eval = _this2.evaluateExpression(arg2);\n          if (!arg2Eval.isNumber()) return;\n          result = param.string.indexOf(arg1Value, arg2Eval.number);\n        } else {\n          result = param.string.indexOf(arg1Value);\n        }\n        return new BasicEvaluatedExpression().setNumber(result).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"replace\").tap(\"JavascriptParser\", function (expr, param) {\n        if (!param.isString()) return;\n        if (expr.arguments.length !== 2) return;\n        if (expr.arguments[0].type === \"SpreadElement\") return;\n        if (expr.arguments[1].type === \"SpreadElement\") return;\n        var arg1 = _this2.evaluateExpression(expr.arguments[0]);\n        var arg2 = _this2.evaluateExpression(expr.arguments[1]);\n        if (!arg1.isString() && !arg1.isRegExp()) return;\n        var arg1Value = arg1.regExp || arg1.string;\n        if (!arg2.isString()) return;\n        var arg2Value = arg2.string;\n        return new BasicEvaluatedExpression().setString(param.string.replace(arg1Value, arg2Value)).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);\n      });\n      [\"substr\", \"substring\", \"slice\"].forEach(function (fn) {\n        _this2.hooks.evaluateCallExpressionMember.for(fn).tap(\"JavascriptParser\", function (expr, param) {\n          if (!param.isString()) return;\n          var arg1;\n          var result,\n            str = param.string;\n          switch (expr.arguments.length) {\n            case 1:\n              if (expr.arguments[0].type === \"SpreadElement\") return;\n              arg1 = _this2.evaluateExpression(expr.arguments[0]);\n              if (!arg1.isNumber()) return;\n              result = str[fn](arg1.number);\n              break;\n            case 2:\n              {\n                if (expr.arguments[0].type === \"SpreadElement\") return;\n                if (expr.arguments[1].type === \"SpreadElement\") return;\n                arg1 = _this2.evaluateExpression(expr.arguments[0]);\n                var arg2 = _this2.evaluateExpression(expr.arguments[1]);\n                if (!arg1.isNumber()) return;\n                if (!arg2.isNumber()) return;\n                result = str[fn](arg1.number, arg2.number);\n                break;\n              }\n            default:\n              return;\n          }\n          return new BasicEvaluatedExpression().setString(result).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);\n        });\n      });\n\n      /**\n       * @param {\"cooked\" | \"raw\"} kind kind of values to get\n       * @param {TemplateLiteralNode} templateLiteralExpr TemplateLiteral expr\n       * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n       */\n      var getSimplifiedTemplateResult = function getSimplifiedTemplateResult(kind, templateLiteralExpr) {\n        /** @type {BasicEvaluatedExpression[]} */\n        var quasis = [];\n        /** @type {BasicEvaluatedExpression[]} */\n        var parts = [];\n        for (var i = 0; i < templateLiteralExpr.quasis.length; i++) {\n          var quasiExpr = templateLiteralExpr.quasis[i];\n          var quasi = quasiExpr.value[kind];\n          if (i > 0) {\n            var prevExpr = parts[parts.length - 1];\n            var expr = _this2.evaluateExpression(templateLiteralExpr.expressions[i - 1]);\n            var exprAsString = expr.asString();\n            if (typeof exprAsString === \"string\" && !expr.couldHaveSideEffects()) {\n              // We can merge quasi + expr + quasi when expr\n              // is a const string\n\n              prevExpr.setString(prevExpr.string + exprAsString + quasi);\n              prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);\n              // We unset the expression as it doesn't match to a single expression\n              prevExpr.setExpression(undefined);\n              continue;\n            }\n            parts.push(expr);\n          }\n          var part = new BasicEvaluatedExpression().setString(quasi).setRange(quasiExpr.range).setExpression(quasiExpr);\n          quasis.push(part);\n          parts.push(part);\n        }\n        return {\n          quasis: quasis,\n          parts: parts\n        };\n      };\n      this.hooks.evaluate.for(\"TemplateLiteral\").tap(\"JavascriptParser\", function (_node) {\n        var node = /** @type {TemplateLiteralNode} */_node;\n        var _getSimplifiedTemplat = getSimplifiedTemplateResult(\"cooked\", node),\n          quasis = _getSimplifiedTemplat.quasis,\n          parts = _getSimplifiedTemplat.parts;\n        if (parts.length === 1) {\n          return parts[0].setRange(node.range);\n        }\n        return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"cooked\").setRange(node.range);\n      });\n      this.hooks.evaluate.for(\"TaggedTemplateExpression\").tap(\"JavascriptParser\", function (_node) {\n        var node = /** @type {TaggedTemplateExpressionNode} */_node;\n        var tag = _this2.evaluateExpression(node.tag);\n        if (tag.isIdentifier() && tag.identifier === \"String.raw\") {\n          var _getSimplifiedTemplat2 = getSimplifiedTemplateResult(\"raw\", node.quasi),\n            quasis = _getSimplifiedTemplat2.quasis,\n            parts = _getSimplifiedTemplat2.parts;\n          return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"raw\").setRange(node.range);\n        }\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"concat\").tap(\"JavascriptParser\", function (expr, param) {\n        if (!param.isString() && !param.isWrapped()) return;\n        var stringSuffix = null;\n        var hasUnknownParams = false;\n        var innerExpressions = [];\n        for (var i = expr.arguments.length - 1; i >= 0; i--) {\n          var arg = expr.arguments[i];\n          if (arg.type === \"SpreadElement\") return;\n          var argExpr = _this2.evaluateExpression(arg);\n          if (hasUnknownParams || !argExpr.isString() && !argExpr.isNumber()) {\n            hasUnknownParams = true;\n            innerExpressions.push(argExpr);\n            continue;\n          }\n          var value = argExpr.isString() ? argExpr.string : \"\" + argExpr.number;\n          var newString = value + (stringSuffix ? stringSuffix.string : \"\");\n          var newRange = [argExpr.range[0], (stringSuffix || argExpr).range[1]];\n          stringSuffix = new BasicEvaluatedExpression().setString(newString).setSideEffects(stringSuffix && stringSuffix.couldHaveSideEffects() || argExpr.couldHaveSideEffects()).setRange(newRange);\n        }\n        if (hasUnknownParams) {\n          var prefix = param.isString() ? param : param.prefix;\n          var inner = param.isWrapped() && param.wrappedInnerExpressions ? param.wrappedInnerExpressions.concat(innerExpressions.reverse()) : innerExpressions.reverse();\n          return new BasicEvaluatedExpression().setWrapped(prefix, stringSuffix, inner).setRange(expr.range);\n        } else if (param.isWrapped()) {\n          var postfix = stringSuffix || param.postfix;\n          var _inner = param.wrappedInnerExpressions ? param.wrappedInnerExpressions.concat(innerExpressions.reverse()) : innerExpressions.reverse();\n          return new BasicEvaluatedExpression().setWrapped(param.prefix, postfix, _inner).setRange(expr.range);\n        } else {\n          var _newString = param.string + (stringSuffix ? stringSuffix.string : \"\");\n          return new BasicEvaluatedExpression().setString(_newString).setSideEffects(stringSuffix && stringSuffix.couldHaveSideEffects() || param.couldHaveSideEffects()).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"split\").tap(\"JavascriptParser\", function (expr, param) {\n        if (!param.isString()) return;\n        if (expr.arguments.length !== 1) return;\n        if (expr.arguments[0].type === \"SpreadElement\") return;\n        var result;\n        var arg = _this2.evaluateExpression(expr.arguments[0]);\n        if (arg.isString()) {\n          result = param.string.split(arg.string);\n        } else if (arg.isRegExp()) {\n          result = param.string.split(arg.regExp);\n        } else {\n          return;\n        }\n        return new BasicEvaluatedExpression().setArray(result).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);\n      });\n      this.hooks.evaluate.for(\"ConditionalExpression\").tap(\"JavascriptParser\", function (_expr) {\n        var expr = /** @type {ConditionalExpressionNode} */_expr;\n        var condition = _this2.evaluateExpression(expr.test);\n        var conditionValue = condition.asBool();\n        var res;\n        if (conditionValue === undefined) {\n          var consequent = _this2.evaluateExpression(expr.consequent);\n          var alternate = _this2.evaluateExpression(expr.alternate);\n          res = new BasicEvaluatedExpression();\n          if (consequent.isConditional()) {\n            res.setOptions(consequent.options);\n          } else {\n            res.setOptions([consequent]);\n          }\n          if (alternate.isConditional()) {\n            res.addOptions(alternate.options);\n          } else {\n            res.addOptions([alternate]);\n          }\n        } else {\n          res = _this2.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);\n          if (condition.couldHaveSideEffects()) res.setSideEffects();\n        }\n        res.setRange(expr.range);\n        return res;\n      });\n      this.hooks.evaluate.for(\"ArrayExpression\").tap(\"JavascriptParser\", function (_expr) {\n        var expr = /** @type {ArrayExpressionNode} */_expr;\n        var items = expr.elements.map(function (element) {\n          return element !== null && element.type !== \"SpreadElement\" && _this2.evaluateExpression(element);\n        });\n        if (!items.every(Boolean)) return;\n        return new BasicEvaluatedExpression().setItems(items).setRange(expr.range);\n      });\n      this.hooks.evaluate.for(\"ChainExpression\").tap(\"JavascriptParser\", function (_expr) {\n        var expr = /** @type {ChainExpressionNode} */_expr;\n        /** @type {ExpressionNode[]} */\n        var optionalExpressionsStack = [];\n        /** @type {ExpressionNode|SuperNode} */\n        var next = expr.expression;\n        while (next.type === \"MemberExpression\" || next.type === \"CallExpression\") {\n          if (next.type === \"MemberExpression\") {\n            if (next.optional) {\n              // SuperNode can not be optional\n              optionalExpressionsStack.push( /** @type {ExpressionNode} */next.object);\n            }\n            next = next.object;\n          } else {\n            if (next.optional) {\n              // SuperNode can not be optional\n              optionalExpressionsStack.push( /** @type {ExpressionNode} */next.callee);\n            }\n            next = next.callee;\n          }\n        }\n        while (optionalExpressionsStack.length > 0) {\n          var expression = optionalExpressionsStack.pop();\n          var evaluated = _this2.evaluateExpression(expression);\n          if (evaluated.asNullish()) {\n            return evaluated.setRange(_expr.range);\n          }\n        }\n        return _this2.evaluateExpression(expr.expression);\n      });\n    }\n  }, {\n    key: \"getRenameIdentifier\",\n    value: function getRenameIdentifier(expr) {\n      var result = this.evaluateExpression(expr);\n      if (result.isIdentifier()) {\n        return result.identifier;\n      }\n    }\n\n    /**\n     * @param {ClassExpressionNode | ClassDeclarationNode} classy a class node\n     * @returns {void}\n     */\n  }, {\n    key: \"walkClass\",\n    value: function walkClass(classy) {\n      if (classy.superClass) {\n        if (!this.hooks.classExtendsExpression.call(classy.superClass, classy)) {\n          this.walkExpression(classy.superClass);\n        }\n      }\n      if (classy.body && classy.body.type === \"ClassBody\") {\n        var _iterator2 = _createForOfIteratorHelper( /** @type {TODO} */classy.body.body),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var classElement = _step2.value;\n            if (!this.hooks.classBodyElement.call(classElement, classy)) {\n              if (classElement.computed && classElement.key) {\n                this.walkExpression(classElement.key);\n              }\n              if (classElement.value) {\n                if (!this.hooks.classBodyValue.call(classElement.value, classElement, classy)) {\n                  var wasTopLevel = this.scope.topLevelScope;\n                  this.scope.topLevelScope = false;\n                  this.walkExpression(classElement.value);\n                  this.scope.topLevelScope = wasTopLevel;\n                }\n              } else if (classElement.type === \"StaticBlock\") {\n                var _wasTopLevel = this.scope.topLevelScope;\n                this.scope.topLevelScope = false;\n                this.walkBlockStatement(classElement);\n                this.scope.topLevelScope = _wasTopLevel;\n              }\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n\n    // Pre walking iterates the scope for variable declarations\n  }, {\n    key: \"preWalkStatements\",\n    value: function preWalkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.preWalkStatement(statement);\n      }\n    }\n\n    // Block pre walking iterates the scope for block variable declarations\n  }, {\n    key: \"blockPreWalkStatements\",\n    value: function blockPreWalkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.blockPreWalkStatement(statement);\n      }\n    }\n\n    // Walking iterates the statements and expressions and processes them\n  }, {\n    key: \"walkStatements\",\n    value: function walkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.walkStatement(statement);\n      }\n    }\n  }, {\n    key: \"preWalkStatement\",\n    value: function preWalkStatement(statement) {\n      this.statementPath.push(statement);\n      if (this.hooks.preStatement.call(statement)) {\n        this.prevStatement = this.statementPath.pop();\n        return;\n      }\n      switch (statement.type) {\n        case \"BlockStatement\":\n          this.preWalkBlockStatement(statement);\n          break;\n        case \"DoWhileStatement\":\n          this.preWalkDoWhileStatement(statement);\n          break;\n        case \"ForInStatement\":\n          this.preWalkForInStatement(statement);\n          break;\n        case \"ForOfStatement\":\n          this.preWalkForOfStatement(statement);\n          break;\n        case \"ForStatement\":\n          this.preWalkForStatement(statement);\n          break;\n        case \"FunctionDeclaration\":\n          this.preWalkFunctionDeclaration(statement);\n          break;\n        case \"IfStatement\":\n          this.preWalkIfStatement(statement);\n          break;\n        case \"LabeledStatement\":\n          this.preWalkLabeledStatement(statement);\n          break;\n        case \"SwitchStatement\":\n          this.preWalkSwitchStatement(statement);\n          break;\n        case \"TryStatement\":\n          this.preWalkTryStatement(statement);\n          break;\n        case \"VariableDeclaration\":\n          this.preWalkVariableDeclaration(statement);\n          break;\n        case \"WhileStatement\":\n          this.preWalkWhileStatement(statement);\n          break;\n        case \"WithStatement\":\n          this.preWalkWithStatement(statement);\n          break;\n      }\n      this.prevStatement = this.statementPath.pop();\n    }\n  }, {\n    key: \"blockPreWalkStatement\",\n    value: function blockPreWalkStatement(statement) {\n      this.statementPath.push(statement);\n      if (this.hooks.blockPreStatement.call(statement)) {\n        this.prevStatement = this.statementPath.pop();\n        return;\n      }\n      switch (statement.type) {\n        case \"ImportDeclaration\":\n          this.blockPreWalkImportDeclaration(statement);\n          break;\n        case \"ExportAllDeclaration\":\n          this.blockPreWalkExportAllDeclaration(statement);\n          break;\n        case \"ExportDefaultDeclaration\":\n          this.blockPreWalkExportDefaultDeclaration(statement);\n          break;\n        case \"ExportNamedDeclaration\":\n          this.blockPreWalkExportNamedDeclaration(statement);\n          break;\n        case \"VariableDeclaration\":\n          this.blockPreWalkVariableDeclaration(statement);\n          break;\n        case \"ClassDeclaration\":\n          this.blockPreWalkClassDeclaration(statement);\n          break;\n      }\n      this.prevStatement = this.statementPath.pop();\n    }\n  }, {\n    key: \"walkStatement\",\n    value: function walkStatement(statement) {\n      this.statementPath.push(statement);\n      if (this.hooks.statement.call(statement) !== undefined) {\n        this.prevStatement = this.statementPath.pop();\n        return;\n      }\n      switch (statement.type) {\n        case \"BlockStatement\":\n          this.walkBlockStatement(statement);\n          break;\n        case \"ClassDeclaration\":\n          this.walkClassDeclaration(statement);\n          break;\n        case \"DoWhileStatement\":\n          this.walkDoWhileStatement(statement);\n          break;\n        case \"ExportDefaultDeclaration\":\n          this.walkExportDefaultDeclaration(statement);\n          break;\n        case \"ExportNamedDeclaration\":\n          this.walkExportNamedDeclaration(statement);\n          break;\n        case \"ExpressionStatement\":\n          this.walkExpressionStatement(statement);\n          break;\n        case \"ForInStatement\":\n          this.walkForInStatement(statement);\n          break;\n        case \"ForOfStatement\":\n          this.walkForOfStatement(statement);\n          break;\n        case \"ForStatement\":\n          this.walkForStatement(statement);\n          break;\n        case \"FunctionDeclaration\":\n          this.walkFunctionDeclaration(statement);\n          break;\n        case \"IfStatement\":\n          this.walkIfStatement(statement);\n          break;\n        case \"LabeledStatement\":\n          this.walkLabeledStatement(statement);\n          break;\n        case \"ReturnStatement\":\n          this.walkReturnStatement(statement);\n          break;\n        case \"SwitchStatement\":\n          this.walkSwitchStatement(statement);\n          break;\n        case \"ThrowStatement\":\n          this.walkThrowStatement(statement);\n          break;\n        case \"TryStatement\":\n          this.walkTryStatement(statement);\n          break;\n        case \"VariableDeclaration\":\n          this.walkVariableDeclaration(statement);\n          break;\n        case \"WhileStatement\":\n          this.walkWhileStatement(statement);\n          break;\n        case \"WithStatement\":\n          this.walkWithStatement(statement);\n          break;\n      }\n      this.prevStatement = this.statementPath.pop();\n    }\n\n    /**\n     * Walks a statements that is nested within a parent statement\n     * and can potentially be a non-block statement.\n     * This enforces the nested statement to never be in ASI position.\n     * @param {StatementNode} statement the nested statement\n     * @returns {void}\n     */\n  }, {\n    key: \"walkNestedStatement\",\n    value: function walkNestedStatement(statement) {\n      this.prevStatement = undefined;\n      this.walkStatement(statement);\n    }\n\n    // Real Statements\n  }, {\n    key: \"preWalkBlockStatement\",\n    value: function preWalkBlockStatement(statement) {\n      this.preWalkStatements(statement.body);\n    }\n  }, {\n    key: \"walkBlockStatement\",\n    value: function walkBlockStatement(statement) {\n      var _this3 = this;\n      this.inBlockScope(function () {\n        var body = statement.body;\n        var prev = _this3.prevStatement;\n        _this3.blockPreWalkStatements(body);\n        _this3.prevStatement = prev;\n        _this3.walkStatements(body);\n      });\n    }\n  }, {\n    key: \"walkExpressionStatement\",\n    value: function walkExpressionStatement(statement) {\n      this.walkExpression(statement.expression);\n    }\n  }, {\n    key: \"preWalkIfStatement\",\n    value: function preWalkIfStatement(statement) {\n      this.preWalkStatement(statement.consequent);\n      if (statement.alternate) {\n        this.preWalkStatement(statement.alternate);\n      }\n    }\n  }, {\n    key: \"walkIfStatement\",\n    value: function walkIfStatement(statement) {\n      var result = this.hooks.statementIf.call(statement);\n      if (result === undefined) {\n        this.walkExpression(statement.test);\n        this.walkNestedStatement(statement.consequent);\n        if (statement.alternate) {\n          this.walkNestedStatement(statement.alternate);\n        }\n      } else {\n        if (result) {\n          this.walkNestedStatement(statement.consequent);\n        } else if (statement.alternate) {\n          this.walkNestedStatement(statement.alternate);\n        }\n      }\n    }\n  }, {\n    key: \"preWalkLabeledStatement\",\n    value: function preWalkLabeledStatement(statement) {\n      this.preWalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkLabeledStatement\",\n    value: function walkLabeledStatement(statement) {\n      var hook = this.hooks.label.get(statement.label.name);\n      if (hook !== undefined) {\n        var result = hook.call(statement);\n        if (result === true) return;\n      }\n      this.walkNestedStatement(statement.body);\n    }\n  }, {\n    key: \"preWalkWithStatement\",\n    value: function preWalkWithStatement(statement) {\n      this.preWalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkWithStatement\",\n    value: function walkWithStatement(statement) {\n      this.walkExpression(statement.object);\n      this.walkNestedStatement(statement.body);\n    }\n  }, {\n    key: \"preWalkSwitchStatement\",\n    value: function preWalkSwitchStatement(statement) {\n      this.preWalkSwitchCases(statement.cases);\n    }\n  }, {\n    key: \"walkSwitchStatement\",\n    value: function walkSwitchStatement(statement) {\n      this.walkExpression(statement.discriminant);\n      this.walkSwitchCases(statement.cases);\n    }\n  }, {\n    key: \"walkTerminatingStatement\",\n    value: function walkTerminatingStatement(statement) {\n      if (statement.argument) this.walkExpression(statement.argument);\n    }\n  }, {\n    key: \"walkReturnStatement\",\n    value: function walkReturnStatement(statement) {\n      this.walkTerminatingStatement(statement);\n    }\n  }, {\n    key: \"walkThrowStatement\",\n    value: function walkThrowStatement(statement) {\n      this.walkTerminatingStatement(statement);\n    }\n  }, {\n    key: \"preWalkTryStatement\",\n    value: function preWalkTryStatement(statement) {\n      this.preWalkStatement(statement.block);\n      if (statement.handler) this.preWalkCatchClause(statement.handler);\n      if (statement.finializer) this.preWalkStatement(statement.finializer);\n    }\n  }, {\n    key: \"walkTryStatement\",\n    value: function walkTryStatement(statement) {\n      if (this.scope.inTry) {\n        this.walkStatement(statement.block);\n      } else {\n        this.scope.inTry = true;\n        this.walkStatement(statement.block);\n        this.scope.inTry = false;\n      }\n      if (statement.handler) this.walkCatchClause(statement.handler);\n      if (statement.finalizer) this.walkStatement(statement.finalizer);\n    }\n  }, {\n    key: \"preWalkWhileStatement\",\n    value: function preWalkWhileStatement(statement) {\n      this.preWalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkWhileStatement\",\n    value: function walkWhileStatement(statement) {\n      this.walkExpression(statement.test);\n      this.walkNestedStatement(statement.body);\n    }\n  }, {\n    key: \"preWalkDoWhileStatement\",\n    value: function preWalkDoWhileStatement(statement) {\n      this.preWalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkDoWhileStatement\",\n    value: function walkDoWhileStatement(statement) {\n      this.walkNestedStatement(statement.body);\n      this.walkExpression(statement.test);\n    }\n  }, {\n    key: \"preWalkForStatement\",\n    value: function preWalkForStatement(statement) {\n      if (statement.init) {\n        if (statement.init.type === \"VariableDeclaration\") {\n          this.preWalkStatement(statement.init);\n        }\n      }\n      this.preWalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForStatement\",\n    value: function walkForStatement(statement) {\n      var _this4 = this;\n      this.inBlockScope(function () {\n        if (statement.init) {\n          if (statement.init.type === \"VariableDeclaration\") {\n            _this4.blockPreWalkVariableDeclaration(statement.init);\n            _this4.prevStatement = undefined;\n            _this4.walkStatement(statement.init);\n          } else {\n            _this4.walkExpression(statement.init);\n          }\n        }\n        if (statement.test) {\n          _this4.walkExpression(statement.test);\n        }\n        if (statement.update) {\n          _this4.walkExpression(statement.update);\n        }\n        var body = statement.body;\n        if (body.type === \"BlockStatement\") {\n          // no need to add additional scope\n          var prev = _this4.prevStatement;\n          _this4.blockPreWalkStatements(body.body);\n          _this4.prevStatement = prev;\n          _this4.walkStatements(body.body);\n        } else {\n          _this4.walkNestedStatement(body);\n        }\n      });\n    }\n  }, {\n    key: \"preWalkForInStatement\",\n    value: function preWalkForInStatement(statement) {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.preWalkVariableDeclaration(statement.left);\n      }\n      this.preWalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForInStatement\",\n    value: function walkForInStatement(statement) {\n      var _this5 = this;\n      this.inBlockScope(function () {\n        if (statement.left.type === \"VariableDeclaration\") {\n          _this5.blockPreWalkVariableDeclaration(statement.left);\n          _this5.walkVariableDeclaration(statement.left);\n        } else {\n          _this5.walkPattern(statement.left);\n        }\n        _this5.walkExpression(statement.right);\n        var body = statement.body;\n        if (body.type === \"BlockStatement\") {\n          // no need to add additional scope\n          var prev = _this5.prevStatement;\n          _this5.blockPreWalkStatements(body.body);\n          _this5.prevStatement = prev;\n          _this5.walkStatements(body.body);\n        } else {\n          _this5.walkNestedStatement(body);\n        }\n      });\n    }\n  }, {\n    key: \"preWalkForOfStatement\",\n    value: function preWalkForOfStatement(statement) {\n      if (statement.await && this.scope.topLevelScope === true) {\n        this.hooks.topLevelAwait.call(statement);\n      }\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.preWalkVariableDeclaration(statement.left);\n      }\n      this.preWalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForOfStatement\",\n    value: function walkForOfStatement(statement) {\n      var _this6 = this;\n      this.inBlockScope(function () {\n        if (statement.left.type === \"VariableDeclaration\") {\n          _this6.blockPreWalkVariableDeclaration(statement.left);\n          _this6.walkVariableDeclaration(statement.left);\n        } else {\n          _this6.walkPattern(statement.left);\n        }\n        _this6.walkExpression(statement.right);\n        var body = statement.body;\n        if (body.type === \"BlockStatement\") {\n          // no need to add additional scope\n          var prev = _this6.prevStatement;\n          _this6.blockPreWalkStatements(body.body);\n          _this6.prevStatement = prev;\n          _this6.walkStatements(body.body);\n        } else {\n          _this6.walkNestedStatement(body);\n        }\n      });\n    }\n\n    // Declarations\n  }, {\n    key: \"preWalkFunctionDeclaration\",\n    value: function preWalkFunctionDeclaration(statement) {\n      if (statement.id) {\n        this.defineVariable(statement.id.name);\n      }\n    }\n  }, {\n    key: \"walkFunctionDeclaration\",\n    value: function walkFunctionDeclaration(statement) {\n      var _this7 = this;\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      this.inFunctionScope(true, statement.params, function () {\n        var _iterator3 = _createForOfIteratorHelper(statement.params),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var param = _step3.value;\n            _this7.walkPattern(param);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        if (statement.body.type === \"BlockStatement\") {\n          _this7.detectMode(statement.body.body);\n          var prev = _this7.prevStatement;\n          _this7.preWalkStatement(statement.body);\n          _this7.prevStatement = prev;\n          _this7.walkStatement(statement.body);\n        } else {\n          _this7.walkExpression(statement.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"blockPreWalkImportDeclaration\",\n    value: function blockPreWalkImportDeclaration(statement) {\n      var source = statement.source.value;\n      this.hooks.import.call(statement, source);\n      var _iterator4 = _createForOfIteratorHelper(statement.specifiers),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var specifier = _step4.value;\n          var name = specifier.local.name;\n          switch (specifier.type) {\n            case \"ImportDefaultSpecifier\":\n              if (!this.hooks.importSpecifier.call(statement, source, \"default\", name)) {\n                this.defineVariable(name);\n              }\n              break;\n            case \"ImportSpecifier\":\n              if (!this.hooks.importSpecifier.call(statement, source, specifier.imported.name || specifier.imported.value, name)) {\n                this.defineVariable(name);\n              }\n              break;\n            case \"ImportNamespaceSpecifier\":\n              if (!this.hooks.importSpecifier.call(statement, source, null, name)) {\n                this.defineVariable(name);\n              }\n              break;\n            default:\n              this.defineVariable(name);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"enterDeclaration\",\n    value: function enterDeclaration(declaration, onIdent) {\n      switch (declaration.type) {\n        case \"VariableDeclaration\":\n          var _iterator5 = _createForOfIteratorHelper(declaration.declarations),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var declarator = _step5.value;\n              switch (declarator.type) {\n                case \"VariableDeclarator\":\n                  {\n                    this.enterPattern(declarator.id, onIdent);\n                    break;\n                  }\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n          break;\n        case \"FunctionDeclaration\":\n          this.enterPattern(declaration.id, onIdent);\n          break;\n        case \"ClassDeclaration\":\n          this.enterPattern(declaration.id, onIdent);\n          break;\n      }\n    }\n  }, {\n    key: \"blockPreWalkExportNamedDeclaration\",\n    value: function blockPreWalkExportNamedDeclaration(statement) {\n      var _this8 = this;\n      var source;\n      if (statement.source) {\n        source = statement.source.value;\n        this.hooks.exportImport.call(statement, source);\n      } else {\n        this.hooks.export.call(statement);\n      }\n      if (statement.declaration) {\n        if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n          var prev = this.prevStatement;\n          this.preWalkStatement(statement.declaration);\n          this.prevStatement = prev;\n          this.blockPreWalkStatement(statement.declaration);\n          var index = 0;\n          this.enterDeclaration(statement.declaration, function (def) {\n            _this8.hooks.exportSpecifier.call(statement, def, def, index++);\n          });\n        }\n      }\n      if (statement.specifiers) {\n        for (var specifierIndex = 0; specifierIndex < statement.specifiers.length; specifierIndex++) {\n          var specifier = statement.specifiers[specifierIndex];\n          switch (specifier.type) {\n            case \"ExportSpecifier\":\n              {\n                var name = specifier.exported.name || specifier.exported.value;\n                if (source) {\n                  this.hooks.exportImportSpecifier.call(statement, source, specifier.local.name, name, specifierIndex);\n                } else {\n                  this.hooks.exportSpecifier.call(statement, specifier.local.name, name, specifierIndex);\n                }\n                break;\n              }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"walkExportNamedDeclaration\",\n    value: function walkExportNamedDeclaration(statement) {\n      if (statement.declaration) {\n        this.walkStatement(statement.declaration);\n      }\n    }\n  }, {\n    key: \"blockPreWalkExportDefaultDeclaration\",\n    value: function blockPreWalkExportDefaultDeclaration(statement) {\n      var prev = this.prevStatement;\n      this.preWalkStatement(statement.declaration);\n      this.prevStatement = prev;\n      this.blockPreWalkStatement(statement.declaration);\n      if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n        this.hooks.exportSpecifier.call(statement, statement.declaration.id.name, \"default\", undefined);\n      }\n    }\n  }, {\n    key: \"walkExportDefaultDeclaration\",\n    value: function walkExportDefaultDeclaration(statement) {\n      this.hooks.export.call(statement);\n      if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n        if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n          this.walkStatement(statement.declaration);\n        }\n      } else {\n        // Acorn parses `export default function() {}` as `FunctionDeclaration` and\n        // `export default class {}` as `ClassDeclaration`, both with `id = null`.\n        // These nodes must be treated as expressions.\n        if (statement.declaration.type === \"FunctionDeclaration\" || statement.declaration.type === \"ClassDeclaration\") {\n          this.walkStatement(statement.declaration);\n        } else {\n          this.walkExpression(statement.declaration);\n        }\n        if (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n          this.hooks.exportSpecifier.call(statement, statement.declaration, \"default\", undefined);\n        }\n      }\n    }\n  }, {\n    key: \"blockPreWalkExportAllDeclaration\",\n    value: function blockPreWalkExportAllDeclaration(statement) {\n      var source = statement.source.value;\n      var name = statement.exported ? statement.exported.name : null;\n      this.hooks.exportImport.call(statement, source);\n      this.hooks.exportImportSpecifier.call(statement, source, null, name, 0);\n    }\n  }, {\n    key: \"preWalkVariableDeclaration\",\n    value: function preWalkVariableDeclaration(statement) {\n      if (statement.kind !== \"var\") return;\n      this._preWalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n    }\n  }, {\n    key: \"blockPreWalkVariableDeclaration\",\n    value: function blockPreWalkVariableDeclaration(statement) {\n      if (statement.kind === \"var\") return;\n      var hookMap = statement.kind === \"const\" ? this.hooks.varDeclarationConst : this.hooks.varDeclarationLet;\n      this._preWalkVariableDeclaration(statement, hookMap);\n    }\n  }, {\n    key: \"_preWalkVariableDeclaration\",\n    value: function _preWalkVariableDeclaration(statement, hookMap) {\n      var _this9 = this;\n      var _iterator6 = _createForOfIteratorHelper(statement.declarations),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var declarator = _step6.value;\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                if (!this.hooks.preDeclarator.call(declarator, statement)) {\n                  this.enterPattern(declarator.id, function (name, decl) {\n                    var hook = hookMap.get(name);\n                    if (hook === undefined || !hook.call(decl)) {\n                      hook = _this9.hooks.varDeclaration.get(name);\n                      if (hook === undefined || !hook.call(decl)) {\n                        _this9.defineVariable(name);\n                      }\n                    }\n                  });\n                }\n                break;\n              }\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  }, {\n    key: \"walkVariableDeclaration\",\n    value: function walkVariableDeclaration(statement) {\n      var _iterator7 = _createForOfIteratorHelper(statement.declarations),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var declarator = _step7.value;\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                var renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);\n                if (renameIdentifier && declarator.id.type === \"Identifier\") {\n                  var hook = this.hooks.canRename.get(renameIdentifier);\n                  if (hook !== undefined && hook.call(declarator.init)) {\n                    // renaming with \"var a = b;\"\n                    var _hook = this.hooks.rename.get(renameIdentifier);\n                    if (_hook === undefined || !_hook.call(declarator.init)) {\n                      this.setVariable(declarator.id.name, renameIdentifier);\n                    }\n                    break;\n                  }\n                }\n                if (!this.hooks.declarator.call(declarator, statement)) {\n                  this.walkPattern(declarator.id);\n                  if (declarator.init) this.walkExpression(declarator.init);\n                }\n                break;\n              }\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }, {\n    key: \"blockPreWalkClassDeclaration\",\n    value: function blockPreWalkClassDeclaration(statement) {\n      if (statement.id) {\n        this.defineVariable(statement.id.name);\n      }\n    }\n  }, {\n    key: \"walkClassDeclaration\",\n    value: function walkClassDeclaration(statement) {\n      this.walkClass(statement);\n    }\n  }, {\n    key: \"preWalkSwitchCases\",\n    value: function preWalkSwitchCases(switchCases) {\n      for (var index = 0, len = switchCases.length; index < len; index++) {\n        var switchCase = switchCases[index];\n        this.preWalkStatements(switchCase.consequent);\n      }\n    }\n  }, {\n    key: \"walkSwitchCases\",\n    value: function walkSwitchCases(switchCases) {\n      var _this10 = this;\n      this.inBlockScope(function () {\n        var len = switchCases.length;\n\n        // we need to pre walk all statements first since we can have invalid code\n        // import A from \"module\";\n        // switch(1) {\n        //    case 1:\n        //      console.log(A); // should fail at runtime\n        //    case 2:\n        //      const A = 1;\n        // }\n        for (var index = 0; index < len; index++) {\n          var switchCase = switchCases[index];\n          if (switchCase.consequent.length > 0) {\n            var prev = _this10.prevStatement;\n            _this10.blockPreWalkStatements(switchCase.consequent);\n            _this10.prevStatement = prev;\n          }\n        }\n        for (var _index = 0; _index < len; _index++) {\n          var _switchCase = switchCases[_index];\n          if (_switchCase.test) {\n            _this10.walkExpression(_switchCase.test);\n          }\n          if (_switchCase.consequent.length > 0) {\n            _this10.walkStatements(_switchCase.consequent);\n          }\n        }\n      });\n    }\n  }, {\n    key: \"preWalkCatchClause\",\n    value: function preWalkCatchClause(catchClause) {\n      this.preWalkStatement(catchClause.body);\n    }\n  }, {\n    key: \"walkCatchClause\",\n    value: function walkCatchClause(catchClause) {\n      var _this11 = this;\n      this.inBlockScope(function () {\n        // Error binding is optional in catch clause since ECMAScript 2019\n        if (catchClause.param !== null) {\n          _this11.enterPattern(catchClause.param, function (ident) {\n            _this11.defineVariable(ident);\n          });\n          _this11.walkPattern(catchClause.param);\n        }\n        var prev = _this11.prevStatement;\n        _this11.blockPreWalkStatement(catchClause.body);\n        _this11.prevStatement = prev;\n        _this11.walkStatement(catchClause.body);\n      });\n    }\n  }, {\n    key: \"walkPattern\",\n    value: function walkPattern(pattern) {\n      switch (pattern.type) {\n        case \"ArrayPattern\":\n          this.walkArrayPattern(pattern);\n          break;\n        case \"AssignmentPattern\":\n          this.walkAssignmentPattern(pattern);\n          break;\n        case \"MemberExpression\":\n          this.walkMemberExpression(pattern);\n          break;\n        case \"ObjectPattern\":\n          this.walkObjectPattern(pattern);\n          break;\n        case \"RestElement\":\n          this.walkRestElement(pattern);\n          break;\n      }\n    }\n  }, {\n    key: \"walkAssignmentPattern\",\n    value: function walkAssignmentPattern(pattern) {\n      this.walkExpression(pattern.right);\n      this.walkPattern(pattern.left);\n    }\n  }, {\n    key: \"walkObjectPattern\",\n    value: function walkObjectPattern(pattern) {\n      for (var i = 0, len = pattern.properties.length; i < len; i++) {\n        var prop = pattern.properties[i];\n        if (prop) {\n          if (prop.computed) this.walkExpression(prop.key);\n          if (prop.value) this.walkPattern(prop.value);\n        }\n      }\n    }\n  }, {\n    key: \"walkArrayPattern\",\n    value: function walkArrayPattern(pattern) {\n      for (var i = 0, len = pattern.elements.length; i < len; i++) {\n        var element = pattern.elements[i];\n        if (element) this.walkPattern(element);\n      }\n    }\n  }, {\n    key: \"walkRestElement\",\n    value: function walkRestElement(pattern) {\n      this.walkPattern(pattern.argument);\n    }\n  }, {\n    key: \"walkExpressions\",\n    value: function walkExpressions(expressions) {\n      var _iterator8 = _createForOfIteratorHelper(expressions),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var expression = _step8.value;\n          if (expression) {\n            this.walkExpression(expression);\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  }, {\n    key: \"walkExpression\",\n    value: function walkExpression(expression) {\n      switch (expression.type) {\n        case \"ArrayExpression\":\n          this.walkArrayExpression(expression);\n          break;\n        case \"ArrowFunctionExpression\":\n          this.walkArrowFunctionExpression(expression);\n          break;\n        case \"AssignmentExpression\":\n          this.walkAssignmentExpression(expression);\n          break;\n        case \"AwaitExpression\":\n          this.walkAwaitExpression(expression);\n          break;\n        case \"BinaryExpression\":\n          this.walkBinaryExpression(expression);\n          break;\n        case \"CallExpression\":\n          this.walkCallExpression(expression);\n          break;\n        case \"ChainExpression\":\n          this.walkChainExpression(expression);\n          break;\n        case \"ClassExpression\":\n          this.walkClassExpression(expression);\n          break;\n        case \"ConditionalExpression\":\n          this.walkConditionalExpression(expression);\n          break;\n        case \"FunctionExpression\":\n          this.walkFunctionExpression(expression);\n          break;\n        case \"Identifier\":\n          this.walkIdentifier(expression);\n          break;\n        case \"ImportExpression\":\n          this.walkImportExpression(expression);\n          break;\n        case \"LogicalExpression\":\n          this.walkLogicalExpression(expression);\n          break;\n        case \"MetaProperty\":\n          this.walkMetaProperty(expression);\n          break;\n        case \"MemberExpression\":\n          this.walkMemberExpression(expression);\n          break;\n        case \"NewExpression\":\n          this.walkNewExpression(expression);\n          break;\n        case \"ObjectExpression\":\n          this.walkObjectExpression(expression);\n          break;\n        case \"SequenceExpression\":\n          this.walkSequenceExpression(expression);\n          break;\n        case \"SpreadElement\":\n          this.walkSpreadElement(expression);\n          break;\n        case \"TaggedTemplateExpression\":\n          this.walkTaggedTemplateExpression(expression);\n          break;\n        case \"TemplateLiteral\":\n          this.walkTemplateLiteral(expression);\n          break;\n        case \"ThisExpression\":\n          this.walkThisExpression(expression);\n          break;\n        case \"UnaryExpression\":\n          this.walkUnaryExpression(expression);\n          break;\n        case \"UpdateExpression\":\n          this.walkUpdateExpression(expression);\n          break;\n        case \"YieldExpression\":\n          this.walkYieldExpression(expression);\n          break;\n      }\n    }\n  }, {\n    key: \"walkAwaitExpression\",\n    value: function walkAwaitExpression(expression) {\n      if (this.scope.topLevelScope === true) this.hooks.topLevelAwait.call(expression);\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkArrayExpression\",\n    value: function walkArrayExpression(expression) {\n      if (expression.elements) {\n        this.walkExpressions(expression.elements);\n      }\n    }\n  }, {\n    key: \"walkSpreadElement\",\n    value: function walkSpreadElement(expression) {\n      if (expression.argument) {\n        this.walkExpression(expression.argument);\n      }\n    }\n  }, {\n    key: \"walkObjectExpression\",\n    value: function walkObjectExpression(expression) {\n      for (var propIndex = 0, len = expression.properties.length; propIndex < len; propIndex++) {\n        var prop = expression.properties[propIndex];\n        this.walkProperty(prop);\n      }\n    }\n  }, {\n    key: \"walkProperty\",\n    value: function walkProperty(prop) {\n      if (prop.type === \"SpreadElement\") {\n        this.walkExpression(prop.argument);\n        return;\n      }\n      if (prop.computed) {\n        this.walkExpression(prop.key);\n      }\n      if (prop.shorthand && prop.value && prop.value.type === \"Identifier\") {\n        this.scope.inShorthand = prop.value.name;\n        this.walkIdentifier(prop.value);\n        this.scope.inShorthand = false;\n      } else {\n        this.walkExpression(prop.value);\n      }\n    }\n  }, {\n    key: \"walkFunctionExpression\",\n    value: function walkFunctionExpression(expression) {\n      var _this12 = this;\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      var scopeParams = expression.params;\n\n      // Add function name in scope for recursive calls\n      if (expression.id) {\n        scopeParams.push(expression.id.name);\n      }\n      this.inFunctionScope(true, scopeParams, function () {\n        var _iterator9 = _createForOfIteratorHelper(expression.params),\n          _step9;\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var param = _step9.value;\n            _this12.walkPattern(param);\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n        if (expression.body.type === \"BlockStatement\") {\n          _this12.detectMode(expression.body.body);\n          var prev = _this12.prevStatement;\n          _this12.preWalkStatement(expression.body);\n          _this12.prevStatement = prev;\n          _this12.walkStatement(expression.body);\n        } else {\n          _this12.walkExpression(expression.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"walkArrowFunctionExpression\",\n    value: function walkArrowFunctionExpression(expression) {\n      var _this13 = this;\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = wasTopLevel ? \"arrow\" : false;\n      this.inFunctionScope(false, expression.params, function () {\n        var _iterator10 = _createForOfIteratorHelper(expression.params),\n          _step10;\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var param = _step10.value;\n            _this13.walkPattern(param);\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n        if (expression.body.type === \"BlockStatement\") {\n          _this13.detectMode(expression.body.body);\n          var prev = _this13.prevStatement;\n          _this13.preWalkStatement(expression.body);\n          _this13.prevStatement = prev;\n          _this13.walkStatement(expression.body);\n        } else {\n          _this13.walkExpression(expression.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n\n    /**\n     * @param {SequenceExpressionNode} expression the sequence\n     */\n  }, {\n    key: \"walkSequenceExpression\",\n    value: function walkSequenceExpression(expression) {\n      if (!expression.expressions) return;\n      // We treat sequence expressions like statements when they are one statement level\n      // This has some benefits for optimizations that only work on statement level\n      var currentStatement = this.statementPath[this.statementPath.length - 1];\n      if (currentStatement === expression || currentStatement.type === \"ExpressionStatement\" && currentStatement.expression === expression) {\n        var old = this.statementPath.pop();\n        var _iterator11 = _createForOfIteratorHelper(expression.expressions),\n          _step11;\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var expr = _step11.value;\n            this.statementPath.push(expr);\n            this.walkExpression(expr);\n            this.statementPath.pop();\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n        this.statementPath.push(old);\n      } else {\n        this.walkExpressions(expression.expressions);\n      }\n    }\n  }, {\n    key: \"walkUpdateExpression\",\n    value: function walkUpdateExpression(expression) {\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkUnaryExpression\",\n    value: function walkUnaryExpression(expression) {\n      if (expression.operator === \"typeof\") {\n        var result = this.callHooksForExpression(this.hooks.typeof, expression.argument, expression);\n        if (result === true) return;\n        if (expression.argument.type === \"ChainExpression\") {\n          var _result = this.callHooksForExpression(this.hooks.typeof, expression.argument.expression, expression);\n          if (_result === true) return;\n        }\n      }\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkLeftRightExpression\",\n    value: function walkLeftRightExpression(expression) {\n      this.walkExpression(expression.left);\n      this.walkExpression(expression.right);\n    }\n  }, {\n    key: \"walkBinaryExpression\",\n    value: function walkBinaryExpression(expression) {\n      if (this.hooks.binaryExpression.call(expression) === undefined) {\n        this.walkLeftRightExpression(expression);\n      }\n    }\n  }, {\n    key: \"walkLogicalExpression\",\n    value: function walkLogicalExpression(expression) {\n      var result = this.hooks.expressionLogicalOperator.call(expression);\n      if (result === undefined) {\n        this.walkLeftRightExpression(expression);\n      } else {\n        if (result) {\n          this.walkExpression(expression.right);\n        }\n      }\n    }\n  }, {\n    key: \"walkAssignmentExpression\",\n    value: function walkAssignmentExpression(expression) {\n      var _this14 = this;\n      if (expression.left.type === \"Identifier\") {\n        var renameIdentifier = this.getRenameIdentifier(expression.right);\n        if (renameIdentifier) {\n          if (this.callHooksForInfo(this.hooks.canRename, renameIdentifier, expression.right)) {\n            // renaming \"a = b;\"\n            if (!this.callHooksForInfo(this.hooks.rename, renameIdentifier, expression.right)) {\n              this.setVariable(expression.left.name, typeof renameIdentifier === \"string\" ? this.getVariableInfo(renameIdentifier) : renameIdentifier);\n            }\n            return;\n          }\n        }\n        this.walkExpression(expression.right);\n        this.enterPattern(expression.left, function (name, decl) {\n          if (!_this14.callHooksForName(_this14.hooks.assign, name, expression)) {\n            _this14.walkExpression(expression.left);\n          }\n        });\n        return;\n      }\n      if (expression.left.type.endsWith(\"Pattern\")) {\n        this.walkExpression(expression.right);\n        this.enterPattern(expression.left, function (name, decl) {\n          if (!_this14.callHooksForName(_this14.hooks.assign, name, expression)) {\n            _this14.defineVariable(name);\n          }\n        });\n        this.walkPattern(expression.left);\n      } else if (expression.left.type === \"MemberExpression\") {\n        var exprName = this.getMemberExpressionInfo(expression.left, ALLOWED_MEMBER_TYPES_EXPRESSION);\n        if (exprName) {\n          if (this.callHooksForInfo(this.hooks.assignMemberChain, exprName.rootInfo, expression, exprName.getMembers())) {\n            return;\n          }\n        }\n        this.walkExpression(expression.right);\n        this.walkExpression(expression.left);\n      } else {\n        this.walkExpression(expression.right);\n        this.walkExpression(expression.left);\n      }\n    }\n  }, {\n    key: \"walkConditionalExpression\",\n    value: function walkConditionalExpression(expression) {\n      var result = this.hooks.expressionConditionalOperator.call(expression);\n      if (result === undefined) {\n        this.walkExpression(expression.test);\n        this.walkExpression(expression.consequent);\n        if (expression.alternate) {\n          this.walkExpression(expression.alternate);\n        }\n      } else {\n        if (result) {\n          this.walkExpression(expression.consequent);\n        } else if (expression.alternate) {\n          this.walkExpression(expression.alternate);\n        }\n      }\n    }\n  }, {\n    key: \"walkNewExpression\",\n    value: function walkNewExpression(expression) {\n      var result = this.callHooksForExpression(this.hooks.new, expression.callee, expression);\n      if (result === true) return;\n      this.walkExpression(expression.callee);\n      if (expression.arguments) {\n        this.walkExpressions(expression.arguments);\n      }\n    }\n  }, {\n    key: \"walkYieldExpression\",\n    value: function walkYieldExpression(expression) {\n      if (expression.argument) {\n        this.walkExpression(expression.argument);\n      }\n    }\n  }, {\n    key: \"walkTemplateLiteral\",\n    value: function walkTemplateLiteral(expression) {\n      if (expression.expressions) {\n        this.walkExpressions(expression.expressions);\n      }\n    }\n  }, {\n    key: \"walkTaggedTemplateExpression\",\n    value: function walkTaggedTemplateExpression(expression) {\n      if (expression.tag) {\n        this.walkExpression(expression.tag);\n      }\n      if (expression.quasi && expression.quasi.expressions) {\n        this.walkExpressions(expression.quasi.expressions);\n      }\n    }\n  }, {\n    key: \"walkClassExpression\",\n    value: function walkClassExpression(expression) {\n      this.walkClass(expression);\n    }\n\n    /**\n     * @param {ChainExpressionNode} expression expression\n     */\n  }, {\n    key: \"walkChainExpression\",\n    value: function walkChainExpression(expression) {\n      var result = this.hooks.optionalChaining.call(expression);\n      if (result === undefined) {\n        if (expression.expression.type === \"CallExpression\") {\n          this.walkCallExpression(expression.expression);\n        } else {\n          this.walkMemberExpression(expression.expression);\n        }\n      }\n    }\n  }, {\n    key: \"_walkIIFE\",\n    value: function _walkIIFE(functionExpression, options, currentThis) {\n      var _this15 = this;\n      var getVarInfo = function getVarInfo(argOrThis) {\n        var renameIdentifier = _this15.getRenameIdentifier(argOrThis);\n        if (renameIdentifier) {\n          if (_this15.callHooksForInfo(_this15.hooks.canRename, renameIdentifier, argOrThis)) {\n            if (!_this15.callHooksForInfo(_this15.hooks.rename, renameIdentifier, argOrThis)) {\n              return typeof renameIdentifier === \"string\" ? _this15.getVariableInfo(renameIdentifier) : renameIdentifier;\n            }\n          }\n        }\n        _this15.walkExpression(argOrThis);\n      };\n      var params = functionExpression.params,\n        type = functionExpression.type;\n      var arrow = type === \"ArrowFunctionExpression\";\n      var renameThis = currentThis ? getVarInfo(currentThis) : null;\n      var varInfoForArgs = options.map(getVarInfo);\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = wasTopLevel && arrow ? \"arrow\" : false;\n      var scopeParams = params.filter(function (identifier, idx) {\n        return !varInfoForArgs[idx];\n      });\n\n      // Add function name in scope for recursive calls\n      if (functionExpression.id) {\n        scopeParams.push(functionExpression.id.name);\n      }\n      this.inFunctionScope(true, scopeParams, function () {\n        if (renameThis && !arrow) {\n          _this15.setVariable(\"this\", renameThis);\n        }\n        for (var i = 0; i < varInfoForArgs.length; i++) {\n          var varInfo = varInfoForArgs[i];\n          if (!varInfo) continue;\n          if (!params[i] || params[i].type !== \"Identifier\") continue;\n          _this15.setVariable(params[i].name, varInfo);\n        }\n        if (functionExpression.body.type === \"BlockStatement\") {\n          _this15.detectMode(functionExpression.body.body);\n          var prev = _this15.prevStatement;\n          _this15.preWalkStatement(functionExpression.body);\n          _this15.prevStatement = prev;\n          _this15.walkStatement(functionExpression.body);\n        } else {\n          _this15.walkExpression(functionExpression.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"walkImportExpression\",\n    value: function walkImportExpression(expression) {\n      var result = this.hooks.importCall.call(expression);\n      if (result === true) return;\n      this.walkExpression(expression.source);\n    }\n  }, {\n    key: \"walkCallExpression\",\n    value: function walkCallExpression(expression) {\n      var isSimpleFunction = function isSimpleFunction(fn) {\n        return fn.params.every(function (p) {\n          return p.type === \"Identifier\";\n        });\n      };\n      if (expression.callee.type === \"MemberExpression\" && expression.callee.object.type.endsWith(\"FunctionExpression\") && !expression.callee.computed && (expression.callee.property.name === \"call\" || expression.callee.property.name === \"bind\") && expression.arguments.length > 0 && isSimpleFunction(expression.callee.object)) {\n        // (function(…) { }.call/bind(?, …))\n        this._walkIIFE(expression.callee.object, expression.arguments.slice(1), expression.arguments[0]);\n      } else if (expression.callee.type.endsWith(\"FunctionExpression\") && isSimpleFunction(expression.callee)) {\n        // (function(…) { }(…))\n        this._walkIIFE(expression.callee, expression.arguments, null);\n      } else {\n        if (expression.callee.type === \"MemberExpression\") {\n          var exprInfo = this.getMemberExpressionInfo(expression.callee, ALLOWED_MEMBER_TYPES_CALL_EXPRESSION);\n          if (exprInfo && exprInfo.type === \"call\") {\n            var result = this.callHooksForInfo(this.hooks.callMemberChainOfCallMemberChain, exprInfo.rootInfo, expression, exprInfo.getCalleeMembers(), exprInfo.call, exprInfo.getMembers());\n            if (result === true) return;\n          }\n        }\n        var callee = this.evaluateExpression(expression.callee);\n        if (callee.isIdentifier()) {\n          var result1 = this.callHooksForInfo(this.hooks.callMemberChain, callee.rootInfo, expression, callee.getMembers(), callee.getMembersOptionals ? callee.getMembersOptionals() : callee.getMembers().map(function () {\n            return false;\n          }));\n          if (result1 === true) return;\n          var result2 = this.callHooksForInfo(this.hooks.call, callee.identifier, expression);\n          if (result2 === true) return;\n        }\n        if (expression.callee) {\n          if (expression.callee.type === \"MemberExpression\") {\n            // because of call context we need to walk the call context as expression\n            this.walkExpression(expression.callee.object);\n            if (expression.callee.computed === true) this.walkExpression(expression.callee.property);\n          } else {\n            this.walkExpression(expression.callee);\n          }\n        }\n        if (expression.arguments) this.walkExpressions(expression.arguments);\n      }\n    }\n  }, {\n    key: \"walkMemberExpression\",\n    value: function walkMemberExpression(expression) {\n      var _this16 = this;\n      var exprInfo = this.getMemberExpressionInfo(expression, ALLOWED_MEMBER_TYPES_ALL);\n      if (exprInfo) {\n        switch (exprInfo.type) {\n          case \"expression\":\n            {\n              var result1 = this.callHooksForInfo(this.hooks.expression, exprInfo.name, expression);\n              if (result1 === true) return;\n              var members = exprInfo.getMembers();\n              var membersOptionals = exprInfo.getMembersOptionals();\n              var result2 = this.callHooksForInfo(this.hooks.expressionMemberChain, exprInfo.rootInfo, expression, members, membersOptionals);\n              if (result2 === true) return;\n              this.walkMemberExpressionWithExpressionName(expression, exprInfo.name, exprInfo.rootInfo, members.slice(), function () {\n                return _this16.callHooksForInfo(_this16.hooks.unhandledExpressionMemberChain, exprInfo.rootInfo, expression, members);\n              });\n              return;\n            }\n          case \"call\":\n            {\n              var result = this.callHooksForInfo(this.hooks.memberChainOfCallMemberChain, exprInfo.rootInfo, expression, exprInfo.getCalleeMembers(), exprInfo.call, exprInfo.getMembers());\n              if (result === true) return;\n              // Fast skip over the member chain as we already called memberChainOfCallMemberChain\n              // and call computed property are literals anyway\n              this.walkExpression(exprInfo.call);\n              return;\n            }\n        }\n      }\n      this.walkExpression(expression.object);\n      if (expression.computed === true) this.walkExpression(expression.property);\n    }\n  }, {\n    key: \"walkMemberExpressionWithExpressionName\",\n    value: function walkMemberExpressionWithExpressionName(expression, name, rootInfo, members, onUnhandled) {\n      if (expression.object.type === \"MemberExpression\") {\n        // optimize the case where expression.object is a MemberExpression too.\n        // we can keep info here when calling walkMemberExpression directly\n        var property = expression.property.name || \"\".concat(expression.property.value);\n        name = name.slice(0, -property.length - 1);\n        members.pop();\n        var result = this.callHooksForInfo(this.hooks.expression, name, expression.object);\n        if (result === true) return;\n        this.walkMemberExpressionWithExpressionName(expression.object, name, rootInfo, members, onUnhandled);\n      } else if (!onUnhandled || !onUnhandled()) {\n        this.walkExpression(expression.object);\n      }\n      if (expression.computed === true) this.walkExpression(expression.property);\n    }\n  }, {\n    key: \"walkThisExpression\",\n    value: function walkThisExpression(expression) {\n      this.callHooksForName(this.hooks.expression, \"this\", expression);\n    }\n  }, {\n    key: \"walkIdentifier\",\n    value: function walkIdentifier(expression) {\n      this.callHooksForName(this.hooks.expression, expression.name, expression);\n    }\n\n    /**\n     * @param {MetaPropertyNode} metaProperty meta property\n     */\n  }, {\n    key: \"walkMetaProperty\",\n    value: function walkMetaProperty(metaProperty) {\n      this.hooks.expression.for(getRootName(metaProperty)).call(metaProperty);\n    }\n  }, {\n    key: \"callHooksForExpression\",\n    value: function callHooksForExpression(hookMap, expr) {\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n      return this.callHooksForExpressionWithFallback.apply(this, [hookMap, expr, undefined, undefined].concat(args));\n    }\n\n    /**\n     * @template T\n     * @template R\n     * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n     * @param {MemberExpressionNode} expr expression info\n     * @param {function(string, string | ScopeInfo | VariableInfo, function(): string[]): any} fallback callback when variable in not handled by hooks\n     * @param {function(string): any} defined callback when variable is defined\n     * @param {AsArray<T>} args args for the hook\n     * @returns {R} result of hook\n     */\n  }, {\n    key: \"callHooksForExpressionWithFallback\",\n    value: function callHooksForExpressionWithFallback(hookMap, expr, fallback, defined) {\n      var exprName = this.getMemberExpressionInfo(expr, ALLOWED_MEMBER_TYPES_EXPRESSION);\n      if (exprName !== undefined) {\n        var members = exprName.getMembers();\n        for (var _len2 = arguments.length, args = new Array(_len2 > 4 ? _len2 - 4 : 0), _key2 = 4; _key2 < _len2; _key2++) {\n          args[_key2 - 4] = arguments[_key2];\n        }\n        return this.callHooksForInfoWithFallback.apply(this, [hookMap, members.length === 0 ? exprName.rootInfo : exprName.name, fallback && function (name) {\n          return fallback(name, exprName.rootInfo, exprName.getMembers);\n        }, defined && function () {\n          return defined(exprName.name);\n        }].concat(args));\n      }\n    }\n\n    /**\n     * @template T\n     * @template R\n     * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n     * @param {string} name key in map\n     * @param {AsArray<T>} args args for the hook\n     * @returns {R} result of hook\n     */\n  }, {\n    key: \"callHooksForName\",\n    value: function callHooksForName(hookMap, name) {\n      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        args[_key3 - 2] = arguments[_key3];\n      }\n      return this.callHooksForNameWithFallback.apply(this, [hookMap, name, undefined, undefined].concat(args));\n    }\n\n    /**\n     * @template T\n     * @template R\n     * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks that should be called\n     * @param {ExportedVariableInfo} info variable info\n     * @param  {AsArray<T>} args args for the hook\n     * @returns {R} result of hook\n     */\n  }, {\n    key: \"callHooksForInfo\",\n    value: function callHooksForInfo(hookMap, info) {\n      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n        args[_key4 - 2] = arguments[_key4];\n      }\n      return this.callHooksForInfoWithFallback.apply(this, [hookMap, info, undefined, undefined].concat(args));\n    }\n\n    /**\n     * @template T\n     * @template R\n     * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n     * @param {ExportedVariableInfo} info variable info\n     * @param {function(string): any} fallback callback when variable in not handled by hooks\n     * @param {function(): any} defined callback when variable is defined\n     * @param {AsArray<T>} args args for the hook\n     * @returns {R} result of hook\n     */\n  }, {\n    key: \"callHooksForInfoWithFallback\",\n    value: function callHooksForInfoWithFallback(hookMap, info, fallback, defined) {\n      var name;\n      for (var _len5 = arguments.length, args = new Array(_len5 > 4 ? _len5 - 4 : 0), _key5 = 4; _key5 < _len5; _key5++) {\n        args[_key5 - 4] = arguments[_key5];\n      }\n      if (typeof info === \"string\") {\n        name = info;\n      } else {\n        if (!(info instanceof VariableInfo)) {\n          if (defined !== undefined) {\n            return defined();\n          }\n          return;\n        }\n        var tagInfo = info.tagInfo;\n        while (tagInfo !== undefined) {\n          var _hook2 = hookMap.get(tagInfo.tag);\n          if (_hook2 !== undefined) {\n            this.currentTagData = tagInfo.data;\n            var result = _hook2.call.apply(_hook2, args);\n            this.currentTagData = undefined;\n            if (result !== undefined) return result;\n          }\n          tagInfo = tagInfo.next;\n        }\n        if (info.freeName === true) {\n          if (defined !== undefined) {\n            return defined();\n          }\n          return;\n        }\n        name = info.freeName;\n      }\n      var hook = hookMap.get(name);\n      if (hook !== undefined) {\n        var _result2 = hook.call.apply(hook, args);\n        if (_result2 !== undefined) return _result2;\n      }\n      if (fallback !== undefined) {\n        return fallback(name);\n      }\n    }\n\n    /**\n     * @template T\n     * @template R\n     * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n     * @param {string} name key in map\n     * @param {function(string): any} fallback callback when variable in not handled by hooks\n     * @param {function(): any} defined callback when variable is defined\n     * @param {AsArray<T>} args args for the hook\n     * @returns {R} result of hook\n     */\n  }, {\n    key: \"callHooksForNameWithFallback\",\n    value: function callHooksForNameWithFallback(hookMap, name, fallback, defined) {\n      for (var _len6 = arguments.length, args = new Array(_len6 > 4 ? _len6 - 4 : 0), _key6 = 4; _key6 < _len6; _key6++) {\n        args[_key6 - 4] = arguments[_key6];\n      }\n      return this.callHooksForInfoWithFallback.apply(this, [hookMap, this.getVariableInfo(name), fallback, defined].concat(args));\n    }\n\n    /**\n     * @deprecated\n     * @param {any} params scope params\n     * @param {function(): void} fn inner function\n     * @returns {void}\n     */\n  }, {\n    key: \"inScope\",\n    value: function inScope(params, fn) {\n      var _this17 = this;\n      var oldScope = this.scope;\n      this.scope = {\n        topLevelScope: oldScope.topLevelScope,\n        inTry: false,\n        inShorthand: false,\n        isStrict: oldScope.isStrict,\n        isAsmJs: oldScope.isAsmJs,\n        definitions: oldScope.definitions.createChild()\n      };\n      this.undefineVariable(\"this\");\n      this.enterPatterns(params, function (ident, pattern) {\n        _this17.defineVariable(ident);\n      });\n      fn();\n      this.scope = oldScope;\n    }\n  }, {\n    key: \"inFunctionScope\",\n    value: function inFunctionScope(hasThis, params, fn) {\n      var _this18 = this;\n      var oldScope = this.scope;\n      this.scope = {\n        topLevelScope: oldScope.topLevelScope,\n        inTry: false,\n        inShorthand: false,\n        isStrict: oldScope.isStrict,\n        isAsmJs: oldScope.isAsmJs,\n        definitions: oldScope.definitions.createChild()\n      };\n      if (hasThis) {\n        this.undefineVariable(\"this\");\n      }\n      this.enterPatterns(params, function (ident, pattern) {\n        _this18.defineVariable(ident);\n      });\n      fn();\n      this.scope = oldScope;\n    }\n  }, {\n    key: \"inBlockScope\",\n    value: function inBlockScope(fn) {\n      var oldScope = this.scope;\n      this.scope = {\n        topLevelScope: oldScope.topLevelScope,\n        inTry: oldScope.inTry,\n        inShorthand: false,\n        isStrict: oldScope.isStrict,\n        isAsmJs: oldScope.isAsmJs,\n        definitions: oldScope.definitions.createChild()\n      };\n      fn();\n      this.scope = oldScope;\n    }\n  }, {\n    key: \"detectMode\",\n    value: function detectMode(statements) {\n      var isLiteral = statements.length >= 1 && statements[0].type === \"ExpressionStatement\" && statements[0].expression.type === \"Literal\";\n      if (isLiteral && statements[0].expression.value === \"use strict\") {\n        this.scope.isStrict = true;\n      }\n      if (isLiteral && statements[0].expression.value === \"use asm\") {\n        this.scope.isAsmJs = true;\n      }\n    }\n  }, {\n    key: \"enterPatterns\",\n    value: function enterPatterns(patterns, onIdent) {\n      var _iterator12 = _createForOfIteratorHelper(patterns),\n        _step12;\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var pattern = _step12.value;\n          if (typeof pattern !== \"string\") {\n            this.enterPattern(pattern, onIdent);\n          } else if (pattern) {\n            onIdent(pattern);\n          }\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n    }\n  }, {\n    key: \"enterPattern\",\n    value: function enterPattern(pattern, onIdent) {\n      if (!pattern) return;\n      switch (pattern.type) {\n        case \"ArrayPattern\":\n          this.enterArrayPattern(pattern, onIdent);\n          break;\n        case \"AssignmentPattern\":\n          this.enterAssignmentPattern(pattern, onIdent);\n          break;\n        case \"Identifier\":\n          this.enterIdentifier(pattern, onIdent);\n          break;\n        case \"ObjectPattern\":\n          this.enterObjectPattern(pattern, onIdent);\n          break;\n        case \"RestElement\":\n          this.enterRestElement(pattern, onIdent);\n          break;\n        case \"Property\":\n          if (pattern.shorthand && pattern.value.type === \"Identifier\") {\n            this.scope.inShorthand = pattern.value.name;\n            this.enterIdentifier(pattern.value, onIdent);\n            this.scope.inShorthand = false;\n          } else {\n            this.enterPattern(pattern.value, onIdent);\n          }\n          break;\n      }\n    }\n  }, {\n    key: \"enterIdentifier\",\n    value: function enterIdentifier(pattern, onIdent) {\n      if (!this.callHooksForName(this.hooks.pattern, pattern.name, pattern)) {\n        onIdent(pattern.name, pattern);\n      }\n    }\n  }, {\n    key: \"enterObjectPattern\",\n    value: function enterObjectPattern(pattern, onIdent) {\n      for (var propIndex = 0, len = pattern.properties.length; propIndex < len; propIndex++) {\n        var prop = pattern.properties[propIndex];\n        this.enterPattern(prop, onIdent);\n      }\n    }\n  }, {\n    key: \"enterArrayPattern\",\n    value: function enterArrayPattern(pattern, onIdent) {\n      for (var elementIndex = 0, len = pattern.elements.length; elementIndex < len; elementIndex++) {\n        var element = pattern.elements[elementIndex];\n        this.enterPattern(element, onIdent);\n      }\n    }\n  }, {\n    key: \"enterRestElement\",\n    value: function enterRestElement(pattern, onIdent) {\n      this.enterPattern(pattern.argument, onIdent);\n    }\n  }, {\n    key: \"enterAssignmentPattern\",\n    value: function enterAssignmentPattern(pattern, onIdent) {\n      this.enterPattern(pattern.left, onIdent);\n    }\n\n    /**\n     * @param {ExpressionNode} expression expression node\n     * @returns {BasicEvaluatedExpression} evaluation result\n     */\n  }, {\n    key: \"evaluateExpression\",\n    value: function evaluateExpression(expression) {\n      try {\n        var hook = this.hooks.evaluate.get(expression.type);\n        if (hook !== undefined) {\n          var result = hook.call(expression);\n          if (result !== undefined && result !== null) {\n            result.setExpression(expression);\n            return result;\n          }\n        }\n      } catch (e) {\n        console.warn(e);\n        // ignore error\n      }\n\n      return new BasicEvaluatedExpression().setRange(expression.range).setExpression(expression);\n    }\n  }, {\n    key: \"parseString\",\n    value: function parseString(expression) {\n      switch (expression.type) {\n        case \"BinaryExpression\":\n          if (expression.operator === \"+\") {\n            return this.parseString(expression.left) + this.parseString(expression.right);\n          }\n          break;\n        case \"Literal\":\n          return expression.value + \"\";\n      }\n      throw new Error(expression.type + \" is not supported as parameter for require\");\n    }\n  }, {\n    key: \"parseCalculatedString\",\n    value: function parseCalculatedString(expression) {\n      switch (expression.type) {\n        case \"BinaryExpression\":\n          if (expression.operator === \"+\") {\n            var left = this.parseCalculatedString(expression.left);\n            var right = this.parseCalculatedString(expression.right);\n            if (left.code) {\n              return {\n                range: left.range,\n                value: left.value,\n                code: true,\n                conditional: false\n              };\n            } else if (right.code) {\n              return {\n                range: [left.range[0], right.range ? right.range[1] : left.range[1]],\n                value: left.value + right.value,\n                code: true,\n                conditional: false\n              };\n            } else {\n              return {\n                range: [left.range[0], right.range[1]],\n                value: left.value + right.value,\n                code: false,\n                conditional: false\n              };\n            }\n          }\n          break;\n        case \"ConditionalExpression\":\n          {\n            var consequent = this.parseCalculatedString(expression.consequent);\n            var alternate = this.parseCalculatedString(expression.alternate);\n            var items = [];\n            if (consequent.conditional) {\n              items.push.apply(items, _toConsumableArray(consequent.conditional));\n            } else if (!consequent.code) {\n              items.push(consequent);\n            } else {\n              break;\n            }\n            if (alternate.conditional) {\n              items.push.apply(items, _toConsumableArray(alternate.conditional));\n            } else if (!alternate.code) {\n              items.push(alternate);\n            } else {\n              break;\n            }\n            return {\n              range: undefined,\n              value: \"\",\n              code: true,\n              conditional: items\n            };\n          }\n        case \"Literal\":\n          return {\n            range: expression.range,\n            value: expression.value + \"\",\n            code: false,\n            conditional: false\n          };\n      }\n      return {\n        range: undefined,\n        value: \"\",\n        code: true,\n        conditional: false\n      };\n    }\n\n    /**\n     * @param {string | Buffer | PreparsedAst} source the source to parse\n     * @param {ParserState} state the parser state\n     * @returns {ParserState} the parser state\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(source, state) {\n      var ast;\n      var comments;\n      var semicolons = new Set();\n      if (source === null) {\n        throw new Error(\"source must not be null\");\n      }\n      if (Buffer.isBuffer(source)) {\n        source = source.toString(\"utf-8\");\n      }\n      if (typeof source === \"object\") {\n        ast = /** @type {ProgramNode} */source;\n        comments = source.comments;\n      } else {\n        comments = [];\n        ast = JavascriptParser._parse(source, {\n          sourceType: this.sourceType,\n          onComment: comments,\n          onInsertedSemicolon: function onInsertedSemicolon(pos) {\n            return semicolons.add(pos);\n          }\n        });\n      }\n      var oldScope = this.scope;\n      var oldState = this.state;\n      var oldComments = this.comments;\n      var oldSemicolons = this.semicolons;\n      var oldStatementPath = this.statementPath;\n      var oldPrevStatement = this.prevStatement;\n      this.scope = {\n        topLevelScope: true,\n        inTry: false,\n        inShorthand: false,\n        isStrict: false,\n        isAsmJs: false,\n        definitions: new StackedMap()\n      };\n      /** @type {ParserState} */\n      this.state = state;\n      this.comments = comments;\n      this.semicolons = semicolons;\n      this.statementPath = [];\n      this.prevStatement = undefined;\n      if (this.hooks.program.call(ast, comments) === undefined) {\n        this.detectMode(ast.body);\n        this.preWalkStatements(ast.body);\n        this.prevStatement = undefined;\n        this.blockPreWalkStatements(ast.body);\n        this.prevStatement = undefined;\n        this.walkStatements(ast.body);\n      }\n      this.hooks.finish.call(ast, comments);\n      this.scope = oldScope;\n      /** @type {ParserState} */\n      this.state = oldState;\n      this.comments = oldComments;\n      this.semicolons = oldSemicolons;\n      this.statementPath = oldStatementPath;\n      this.prevStatement = oldPrevStatement;\n      return state;\n    }\n\n    /**\n     * @param {string} source source code\n     * @returns {BasicEvaluatedExpression} evaluation result\n     */\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(source) {\n      var ast = JavascriptParser._parse(\"(\" + source + \")\", {\n        sourceType: this.sourceType,\n        locations: false\n      });\n      if (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n        throw new Error(\"evaluate: Source is not a expression\");\n      }\n      return this.evaluateExpression(ast.body[0].expression);\n    }\n\n    /**\n     * @param {ExpressionNode | DeclarationNode | PrivateIdentifierNode | null | undefined} expr an expression\n     * @param {number} commentsStartPos source position from which annotation comments are checked\n     * @returns {boolean} true, when the expression is pure\n     */\n  }, {\n    key: \"isPure\",\n    value: function isPure(expr, commentsStartPos) {\n      var _this19 = this;\n      if (!expr) return true;\n      var result = this.hooks.isPure.for(expr.type).call(expr, commentsStartPos);\n      if (typeof result === \"boolean\") return result;\n      switch (expr.type) {\n        case \"ClassDeclaration\":\n        case \"ClassExpression\":\n          {\n            if (expr.body.type !== \"ClassBody\") return false;\n            if (expr.superClass && !this.isPure(expr.superClass, expr.range[0])) {\n              return false;\n            }\n            var items = /** @type {(MethodDefinitionNode | PropertyDefinitionNode)[]} */\n            expr.body.body;\n            return items.every(function (item) {\n              return (!item.computed || !item.key || _this19.isPure(item.key, item.range[0])) && (!item.static || !item.value || _this19.isPure(item.value, item.key ? item.key.range[1] : item.range[0]));\n            });\n          }\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"Literal\":\n        case \"PrivateIdentifier\":\n          return true;\n        case \"VariableDeclaration\":\n          return expr.declarations.every(function (decl) {\n            return _this19.isPure(decl.init, decl.range[0]);\n          });\n        case \"ConditionalExpression\":\n          return this.isPure(expr.test, commentsStartPos) && this.isPure(expr.consequent, expr.test.range[1]) && this.isPure(expr.alternate, expr.consequent.range[1]);\n        case \"SequenceExpression\":\n          return expr.expressions.every(function (expr) {\n            var pureFlag = _this19.isPure(expr, commentsStartPos);\n            commentsStartPos = expr.range[1];\n            return pureFlag;\n          });\n        case \"CallExpression\":\n          {\n            var pureFlag = expr.range[0] - commentsStartPos > 12 && this.getComments([commentsStartPos, expr.range[0]]).some(function (comment) {\n              return comment.type === \"Block\" && /^\\s*(#|@)__PURE__\\s*$/.test(comment.value);\n            });\n            if (!pureFlag) return false;\n            commentsStartPos = expr.callee.range[1];\n            return expr.arguments.every(function (arg) {\n              if (arg.type === \"SpreadElement\") return false;\n              var pureFlag = _this19.isPure(arg, commentsStartPos);\n              commentsStartPos = arg.range[1];\n              return pureFlag;\n            });\n          }\n      }\n      var evaluated = this.evaluateExpression(expr);\n      return !evaluated.couldHaveSideEffects();\n    }\n  }, {\n    key: \"getComments\",\n    value: function getComments(range) {\n      var _range = _slicedToArray(range, 2),\n        rangeStart = _range[0],\n        rangeEnd = _range[1];\n      var compare = function compare(comment, needle) {\n        return comment.range[0] - needle;\n      };\n      var idx = binarySearchBounds.ge(this.comments, rangeStart, compare);\n      var commentsInRange = [];\n      while (this.comments[idx] && this.comments[idx].range[1] <= rangeEnd) {\n        commentsInRange.push(this.comments[idx]);\n        idx++;\n      }\n      return commentsInRange;\n    }\n\n    /**\n     * @param {number} pos source code position\n     * @returns {boolean} true when a semicolon has been inserted before this position, false if not\n     */\n  }, {\n    key: \"isAsiPosition\",\n    value: function isAsiPosition(pos) {\n      var currentStatement = this.statementPath[this.statementPath.length - 1];\n      if (currentStatement === undefined) throw new Error(\"Not in statement\");\n      return (\n        // Either asking directly for the end position of the current statement\n        currentStatement.range[1] === pos && this.semicolons.has(pos) ||\n        // Or asking for the start position of the current statement,\n        // here we have to check multiple things\n        currentStatement.range[0] === pos &&\n        // is there a previous statement which might be relevant?\n        this.prevStatement !== undefined &&\n        // is the end position of the previous statement an ASI position?\n        this.semicolons.has(this.prevStatement.range[1])\n      );\n    }\n\n    /**\n     * @param {number} pos source code position\n     * @returns {void}\n     */\n  }, {\n    key: \"unsetAsiPosition\",\n    value: function unsetAsiPosition(pos) {\n      this.semicolons.delete(pos);\n    }\n  }, {\n    key: \"isStatementLevelExpression\",\n    value: function isStatementLevelExpression(expr) {\n      var currentStatement = this.statementPath[this.statementPath.length - 1];\n      return expr === currentStatement || currentStatement.type === \"ExpressionStatement\" && currentStatement.expression === expr;\n    }\n  }, {\n    key: \"getTagData\",\n    value: function getTagData(name, tag) {\n      var info = this.scope.definitions.get(name);\n      if (info instanceof VariableInfo) {\n        var tagInfo = info.tagInfo;\n        while (tagInfo !== undefined) {\n          if (tagInfo.tag === tag) return tagInfo.data;\n          tagInfo = tagInfo.next;\n        }\n      }\n    }\n  }, {\n    key: \"tagVariable\",\n    value: function tagVariable(name, tag, data) {\n      var oldInfo = this.scope.definitions.get(name);\n      /** @type {VariableInfo} */\n      var newInfo;\n      if (oldInfo === undefined) {\n        newInfo = new VariableInfo(this.scope, name, {\n          tag: tag,\n          data: data,\n          next: undefined\n        });\n      } else if (oldInfo instanceof VariableInfo) {\n        newInfo = new VariableInfo(oldInfo.declaredScope, oldInfo.freeName, {\n          tag: tag,\n          data: data,\n          next: oldInfo.tagInfo\n        });\n      } else {\n        newInfo = new VariableInfo(oldInfo, true, {\n          tag: tag,\n          data: data,\n          next: undefined\n        });\n      }\n      this.scope.definitions.set(name, newInfo);\n    }\n  }, {\n    key: \"defineVariable\",\n    value: function defineVariable(name) {\n      var oldInfo = this.scope.definitions.get(name);\n      // Don't redefine variable in same scope to keep existing tags\n      if (oldInfo instanceof VariableInfo && oldInfo.declaredScope === this.scope) return;\n      this.scope.definitions.set(name, this.scope);\n    }\n  }, {\n    key: \"undefineVariable\",\n    value: function undefineVariable(name) {\n      this.scope.definitions.delete(name);\n    }\n  }, {\n    key: \"isVariableDefined\",\n    value: function isVariableDefined(name) {\n      var info = this.scope.definitions.get(name);\n      if (info === undefined) return false;\n      if (info instanceof VariableInfo) {\n        return info.freeName === true;\n      }\n      return true;\n    }\n\n    /**\n     * @param {string} name variable name\n     * @returns {ExportedVariableInfo} info for this variable\n     */\n  }, {\n    key: \"getVariableInfo\",\n    value: function getVariableInfo(name) {\n      var value = this.scope.definitions.get(name);\n      if (value === undefined) {\n        return name;\n      } else {\n        return value;\n      }\n    }\n\n    /**\n     * @param {string} name variable name\n     * @param {ExportedVariableInfo} variableInfo new info for this variable\n     * @returns {void}\n     */\n  }, {\n    key: \"setVariable\",\n    value: function setVariable(name, variableInfo) {\n      if (typeof variableInfo === \"string\") {\n        if (variableInfo === name) {\n          this.scope.definitions.delete(name);\n        } else {\n          this.scope.definitions.set(name, new VariableInfo(this.scope, variableInfo, undefined));\n        }\n      } else {\n        this.scope.definitions.set(name, variableInfo);\n      }\n    }\n  }, {\n    key: \"evaluatedVariable\",\n    value: function evaluatedVariable(tagInfo) {\n      return new VariableInfo(this.scope, undefined, tagInfo);\n    }\n  }, {\n    key: \"parseCommentOptions\",\n    value: function parseCommentOptions(range) {\n      var comments = this.getComments(range);\n      if (comments.length === 0) {\n        return EMPTY_COMMENT_OPTIONS;\n      }\n      var options = {};\n      var errors = [];\n      var _iterator13 = _createForOfIteratorHelper(comments),\n        _step13;\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var comment = _step13.value;\n          var value = comment.value;\n          if (value && webpackCommentRegExp.test(value)) {\n            // try compile only if webpack options comment is present\n            try {\n              var val = vm.runInNewContext(\"(function(){return {\".concat(value, \"};})()\"));\n              Object.assign(options, val);\n            } catch (e) {\n              e.comment = comment;\n              errors.push(e);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n      return {\n        options: options,\n        errors: errors\n      };\n    }\n\n    /**\n     * @param {MemberExpressionNode} expression a member expression\n     * @returns {{ members: string[], object: ExpressionNode | SuperNode, membersOptionals: boolean[] }} member names (reverse order) and remaining object\n     */\n  }, {\n    key: \"extractMemberExpressionChain\",\n    value: function extractMemberExpressionChain(expression) {\n      /** @type {AnyNode} */\n      var expr = expression;\n      var members = [];\n      var membersOptionals = [];\n      while (expr.type === \"MemberExpression\") {\n        if (expr.computed) {\n          if (expr.property.type !== \"Literal\") break;\n          members.push(\"\".concat(expr.property.value));\n        } else {\n          if (expr.property.type !== \"Identifier\") break;\n          members.push(expr.property.name);\n        }\n        membersOptionals.push(expr.optional);\n        expr = expr.object;\n      }\n      return {\n        members: members,\n        membersOptionals: membersOptionals,\n        object: expr\n      };\n    }\n\n    /**\n     * @param {string} varName variable name\n     * @returns {{name: string, info: VariableInfo | string}} name of the free variable and variable info for that\n     */\n  }, {\n    key: \"getFreeInfoFromVariable\",\n    value: function getFreeInfoFromVariable(varName) {\n      var info = this.getVariableInfo(varName);\n      var name;\n      if (info instanceof VariableInfo) {\n        name = info.freeName;\n        if (typeof name !== \"string\") return undefined;\n      } else if (typeof info !== \"string\") {\n        return undefined;\n      } else {\n        name = info;\n      }\n      return {\n        info: info,\n        name: name\n      };\n    }\n\n    /** @typedef {{ type: \"call\", call: CallExpressionNode, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () => string[], name: string, getMembers: () => string[], getMembersOptionals: () => boolean[]}} CallExpressionInfo */\n    /** @typedef {{ type: \"expression\", rootInfo: string | VariableInfo, name: string, getMembers: () => string[], getMembersOptionals: () => boolean[]}} ExpressionExpressionInfo */\n\n    /**\n     * @param {MemberExpressionNode} expression a member expression\n     * @param {number} allowedTypes which types should be returned, presented in bit mask\n     * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info\n     */\n  }, {\n    key: \"getMemberExpressionInfo\",\n    value: function getMemberExpressionInfo(expression, allowedTypes) {\n      var _this$extractMemberEx = this.extractMemberExpressionChain(expression),\n        object = _this$extractMemberEx.object,\n        members = _this$extractMemberEx.members,\n        membersOptionals = _this$extractMemberEx.membersOptionals;\n      switch (object.type) {\n        case \"CallExpression\":\n          {\n            if ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0) return undefined;\n            var callee = object.callee;\n            var rootMembers = EMPTY_ARRAY;\n            if (callee.type === \"MemberExpression\") {\n              var _this$extractMemberEx2 = this.extractMemberExpressionChain(callee);\n              callee = _this$extractMemberEx2.object;\n              rootMembers = _this$extractMemberEx2.members;\n            }\n            var rootName = getRootName(callee);\n            if (!rootName) return undefined;\n            var result = this.getFreeInfoFromVariable(rootName);\n            if (!result) return undefined;\n            var rootInfo = result.info,\n              resolvedRoot = result.name;\n            var calleeName = objectAndMembersToName(resolvedRoot, rootMembers);\n            return {\n              type: \"call\",\n              call: object,\n              calleeName: calleeName,\n              rootInfo: rootInfo,\n              getCalleeMembers: memoize(function () {\n                return rootMembers.reverse();\n              }),\n              name: objectAndMembersToName(\"\".concat(calleeName, \"()\"), members),\n              getMembers: memoize(function () {\n                return members.reverse();\n              }),\n              getMembersOptionals: memoize(function () {\n                return membersOptionals.reverse();\n              })\n            };\n          }\n        case \"Identifier\":\n        case \"MetaProperty\":\n        case \"ThisExpression\":\n          {\n            if ((allowedTypes & ALLOWED_MEMBER_TYPES_EXPRESSION) === 0) return undefined;\n            var _rootName = getRootName(object);\n            if (!_rootName) return undefined;\n            var _result3 = this.getFreeInfoFromVariable(_rootName);\n            if (!_result3) return undefined;\n            var _rootInfo = _result3.info,\n              _resolvedRoot = _result3.name;\n            return {\n              type: \"expression\",\n              name: objectAndMembersToName(_resolvedRoot, members),\n              rootInfo: _rootInfo,\n              getMembers: memoize(function () {\n                return members.reverse();\n              }),\n              getMembersOptionals: memoize(function () {\n                return membersOptionals.reverse();\n              })\n            };\n          }\n      }\n    }\n\n    /**\n     * @param {MemberExpressionNode} expression an expression\n     * @returns {{ name: string, rootInfo: ExportedVariableInfo, getMembers: () => string[]}} name info\n     */\n  }, {\n    key: \"getNameForExpression\",\n    value: function getNameForExpression(expression) {\n      return this.getMemberExpressionInfo(expression, ALLOWED_MEMBER_TYPES_EXPRESSION);\n    }\n\n    /**\n     * @param {string} code source code\n     * @param {ParseOptions} options parsing options\n     * @returns {ProgramNode} parsed ast\n     */\n  }], [{\n    key: \"_parse\",\n    value: function _parse(code, options) {\n      var type = options ? options.sourceType : \"module\";\n      /** @type {AcornOptions} */\n      var parserOptions = _objectSpread(_objectSpread(_objectSpread({}, defaultParserOptions), {}, {\n        allowReturnOutsideFunction: type === \"script\"\n      }, options), {}, {\n        sourceType: type === \"auto\" ? \"module\" : type\n      });\n\n      /** @type {AnyNode} */\n      var ast;\n      var error;\n      var threw = false;\n      try {\n        ast = /** @type {AnyNode} */parser.parse(code, parserOptions);\n      } catch (e) {\n        error = e;\n        threw = true;\n      }\n      if (threw && type === \"auto\") {\n        parserOptions.sourceType = \"script\";\n        if (!(\"allowReturnOutsideFunction\" in options)) {\n          parserOptions.allowReturnOutsideFunction = true;\n        }\n        if (Array.isArray(parserOptions.onComment)) {\n          parserOptions.onComment.length = 0;\n        }\n        try {\n          ast = /** @type {AnyNode} */parser.parse(code, parserOptions);\n          threw = false;\n        } catch (e) {\n          // we use the error from first parse try\n          // so nothing to do here\n        }\n      }\n      if (threw) {\n        throw error;\n      }\n      return (/** @type {ProgramNode} */ast\n      );\n    }\n  }]);\n  return JavascriptParser;\n}(Parser);\nmodule.exports = JavascriptParser;\nmodule.exports.ALLOWED_MEMBER_TYPES_ALL = ALLOWED_MEMBER_TYPES_ALL;\nmodule.exports.ALLOWED_MEMBER_TYPES_EXPRESSION = ALLOWED_MEMBER_TYPES_EXPRESSION;\nmodule.exports.ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = ALLOWED_MEMBER_TYPES_CALL_EXPRESSION;","map":{"version":3,"names":["require","AcornParser","Parser","importAssertions","SyncBailHook","HookMap","vm","StackedMap","binarySearchBounds","memoize","BasicEvaluatedExpression","EMPTY_ARRAY","ALLOWED_MEMBER_TYPES_CALL_EXPRESSION","ALLOWED_MEMBER_TYPES_EXPRESSION","ALLOWED_MEMBER_TYPES_ALL","parser","extend","VariableInfo","declaredScope","freeName","tagInfo","joinRanges","startRange","endRange","objectAndMembersToName","object","membersReversed","name","i","length","getRootName","expression","type","meta","property","undefined","defaultParserOptions","ranges","locations","ecmaVersion","sourceType","allowHashBang","onComment","webpackCommentRegExp","RegExp","EMPTY_COMMENT_OPTIONS","options","errors","JavascriptParser","hooks","Object","freeze","evaluateTypeof","evaluate","evaluateIdentifier","evaluateDefinedIdentifier","evaluateNewExpression","evaluateCallExpression","evaluateCallExpressionMember","isPure","preStatement","blockPreStatement","statement","statementIf","classExtendsExpression","classBodyElement","classBodyValue","label","import","importSpecifier","export","exportImport","exportDeclaration","exportExpression","exportSpecifier","exportImportSpecifier","preDeclarator","declarator","varDeclaration","varDeclarationLet","varDeclarationConst","varDeclarationVar","pattern","canRename","rename","assign","assignMemberChain","typeof","importCall","topLevelAwait","call","callMemberChain","memberChainOfCallMemberChain","callMemberChainOfCallMemberChain","optionalChaining","new","binaryExpression","expressionMemberChain","unhandledExpressionMemberChain","expressionConditionalOperator","expressionLogicalOperator","program","finish","scope","state","comments","semicolons","statementPath","prevStatement","currentTagData","_initializeEvaluating","for","tap","_expr","expr","value","setNumber","setRange","range","setBigInt","setString","setBoolean","setNull","setRegExp","callee","callHooksForName","arguments","getVariableInfo","regExp","flags","arg1","evaluatedRegExp","evaluateExpression","asString","arg2","evaluatedFlags","isUndefined","isValidRegExpFlags","left","returnRight","allowedRight","operator","leftAsBool","asBool","leftAsNullish","asNullish","right","couldHaveSideEffects","setSideEffects","setTruthy","setFalsy","valueAsExpression","sideEffects","handleConstOperation","fn","isCompileTimeValue","result","asCompileTimeValue","isAlwaysDifferent","a","b","handleTemplateStringCompare","res","eql","getPrefix","parts","p","v","getSuffix","leftPrefix","rightPrefix","leftSuffix","rightSuffix","lenPrefix","Math","min","lenSuffix","slice","handleStrictEqualityComparison","leftConst","rightConst","isArray","isTemplateString","leftPrimitive","isPrimitiveType","rightPrimitive","handleAbstractEqualityComparison","isString","string","isNumber","number","isWrapped","prefix","setWrapped","postfix","wrappedInnerExpressions","isBigInt","bigint","concat","l","r","argument","callHooksForExpression","arg","isUnknown","isBoolean","isConstArray","isRegExp","isNull","bool","setUndefined","tapEvaluateWithVariableInfo","exprType","getInfo","cachedExpression","cachedInfo","info","callHooksForInfoWithFallback","hook","get","stage","setIdentifier","rootInfo","getMembers","getMembersOptionals","metaProperty","getMemberExpressionInfo","computed","param","arg1Eval","arg1Value","arg2Eval","indexOf","arg2Value","replace","forEach","str","getSimplifiedTemplateResult","kind","templateLiteralExpr","quasis","quasiExpr","quasi","prevExpr","expressions","exprAsString","setExpression","push","part","_node","node","setTemplateString","tag","isIdentifier","identifier","stringSuffix","hasUnknownParams","innerExpressions","argExpr","newString","newRange","inner","reverse","split","setArray","condition","test","conditionValue","consequent","alternate","isConditional","setOptions","addOptions","items","elements","map","element","every","Boolean","setItems","optionalExpressionsStack","next","optional","pop","evaluated","classy","superClass","walkExpression","body","classElement","key","wasTopLevel","topLevelScope","walkBlockStatement","statements","index","len","preWalkStatement","blockPreWalkStatement","walkStatement","preWalkBlockStatement","preWalkDoWhileStatement","preWalkForInStatement","preWalkForOfStatement","preWalkForStatement","preWalkFunctionDeclaration","preWalkIfStatement","preWalkLabeledStatement","preWalkSwitchStatement","preWalkTryStatement","preWalkVariableDeclaration","preWalkWhileStatement","preWalkWithStatement","blockPreWalkImportDeclaration","blockPreWalkExportAllDeclaration","blockPreWalkExportDefaultDeclaration","blockPreWalkExportNamedDeclaration","blockPreWalkVariableDeclaration","blockPreWalkClassDeclaration","walkClassDeclaration","walkDoWhileStatement","walkExportDefaultDeclaration","walkExportNamedDeclaration","walkExpressionStatement","walkForInStatement","walkForOfStatement","walkForStatement","walkFunctionDeclaration","walkIfStatement","walkLabeledStatement","walkReturnStatement","walkSwitchStatement","walkThrowStatement","walkTryStatement","walkVariableDeclaration","walkWhileStatement","walkWithStatement","preWalkStatements","inBlockScope","prev","blockPreWalkStatements","walkStatements","walkNestedStatement","preWalkSwitchCases","cases","discriminant","walkSwitchCases","walkTerminatingStatement","block","handler","preWalkCatchClause","finializer","inTry","walkCatchClause","finalizer","init","update","walkPattern","await","id","defineVariable","inFunctionScope","params","detectMode","source","specifiers","specifier","local","imported","declaration","onIdent","declarations","enterPattern","enterDeclaration","def","specifierIndex","exported","_preWalkVariableDeclaration","hookMap","decl","renameIdentifier","getRenameIdentifier","setVariable","walkClass","switchCases","switchCase","catchClause","ident","walkArrayPattern","walkAssignmentPattern","walkMemberExpression","walkObjectPattern","walkRestElement","properties","prop","walkArrayExpression","walkArrowFunctionExpression","walkAssignmentExpression","walkAwaitExpression","walkBinaryExpression","walkCallExpression","walkChainExpression","walkClassExpression","walkConditionalExpression","walkFunctionExpression","walkIdentifier","walkImportExpression","walkLogicalExpression","walkMetaProperty","walkNewExpression","walkObjectExpression","walkSequenceExpression","walkSpreadElement","walkTaggedTemplateExpression","walkTemplateLiteral","walkThisExpression","walkUnaryExpression","walkUpdateExpression","walkYieldExpression","walkExpressions","propIndex","walkProperty","shorthand","inShorthand","scopeParams","currentStatement","old","walkLeftRightExpression","callHooksForInfo","endsWith","exprName","functionExpression","currentThis","getVarInfo","argOrThis","arrow","renameThis","varInfoForArgs","filter","idx","varInfo","isSimpleFunction","_walkIIFE","exprInfo","getCalleeMembers","result1","result2","members","membersOptionals","walkMemberExpressionWithExpressionName","onUnhandled","args","callHooksForExpressionWithFallback","fallback","defined","callHooksForNameWithFallback","data","oldScope","isStrict","isAsmJs","definitions","createChild","undefineVariable","enterPatterns","hasThis","isLiteral","patterns","enterArrayPattern","enterAssignmentPattern","enterIdentifier","enterObjectPattern","enterRestElement","elementIndex","e","console","warn","parseString","Error","parseCalculatedString","code","conditional","ast","Set","Buffer","isBuffer","toString","_parse","onInsertedSemicolon","pos","add","oldState","oldComments","oldSemicolons","oldStatementPath","oldPrevStatement","commentsStartPos","item","static","pureFlag","getComments","some","comment","rangeStart","rangeEnd","compare","needle","ge","commentsInRange","has","delete","oldInfo","newInfo","set","variableInfo","val","runInNewContext","varName","allowedTypes","extractMemberExpressionChain","rootMembers","rootName","getFreeInfoFromVariable","resolvedRoot","calleeName","parserOptions","allowReturnOutsideFunction","error","threw","parse","Array","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/javascript/JavascriptParser.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { Parser: AcornParser } = require(\"acorn\");\nconst { importAssertions } = require(\"acorn-import-assertions\");\nconst { SyncBailHook, HookMap } = require(\"tapable\");\nconst vm = require(\"vm\");\nconst Parser = require(\"../Parser\");\nconst StackedMap = require(\"../util/StackedMap\");\nconst binarySearchBounds = require(\"../util/binarySearchBounds\");\nconst memoize = require(\"../util/memoize\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n\n/** @typedef {import(\"acorn\").Options} AcornOptions */\n/** @typedef {import(\"estree\").ArrayExpression} ArrayExpressionNode */\n/** @typedef {import(\"estree\").BinaryExpression} BinaryExpressionNode */\n/** @typedef {import(\"estree\").BlockStatement} BlockStatementNode */\n/** @typedef {import(\"estree\").SequenceExpression} SequenceExpressionNode */\n/** @typedef {import(\"estree\").CallExpression} CallExpressionNode */\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclarationNode */\n/** @typedef {import(\"estree\").ClassExpression} ClassExpressionNode */\n/** @typedef {import(\"estree\").Comment} CommentNode */\n/** @typedef {import(\"estree\").ConditionalExpression} ConditionalExpressionNode */\n/** @typedef {import(\"estree\").Declaration} DeclarationNode */\n/** @typedef {import(\"estree\").PrivateIdentifier} PrivateIdentifierNode */\n/** @typedef {import(\"estree\").PropertyDefinition} PropertyDefinitionNode */\n/** @typedef {import(\"estree\").Expression} ExpressionNode */\n/** @typedef {import(\"estree\").Identifier} IdentifierNode */\n/** @typedef {import(\"estree\").IfStatement} IfStatementNode */\n/** @typedef {import(\"estree\").LabeledStatement} LabeledStatementNode */\n/** @typedef {import(\"estree\").Literal} LiteralNode */\n/** @typedef {import(\"estree\").LogicalExpression} LogicalExpressionNode */\n/** @typedef {import(\"estree\").ChainExpression} ChainExpressionNode */\n/** @typedef {import(\"estree\").MemberExpression} MemberExpressionNode */\n/** @typedef {import(\"estree\").MetaProperty} MetaPropertyNode */\n/** @typedef {import(\"estree\").MethodDefinition} MethodDefinitionNode */\n/** @typedef {import(\"estree\").ModuleDeclaration} ModuleDeclarationNode */\n/** @typedef {import(\"estree\").NewExpression} NewExpressionNode */\n/** @typedef {import(\"estree\").Node} AnyNode */\n/** @typedef {import(\"estree\").Program} ProgramNode */\n/** @typedef {import(\"estree\").Statement} StatementNode */\n/** @typedef {import(\"estree\").ImportDeclaration} ImportDeclarationNode */\n/** @typedef {import(\"estree\").ExportNamedDeclaration} ExportNamedDeclarationNode */\n/** @typedef {import(\"estree\").ExportDefaultDeclaration} ExportDefaultDeclarationNode */\n/** @typedef {import(\"estree\").ExportAllDeclaration} ExportAllDeclarationNode */\n/** @typedef {import(\"estree\").Super} SuperNode */\n/** @typedef {import(\"estree\").TaggedTemplateExpression} TaggedTemplateExpressionNode */\n/** @typedef {import(\"estree\").TemplateLiteral} TemplateLiteralNode */\n/** @typedef {import(\"estree\").ThisExpression} ThisExpressionNode */\n/** @typedef {import(\"estree\").UnaryExpression} UnaryExpressionNode */\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclaratorNode */\n/** @template T @typedef {import(\"tapable\").AsArray<T>} AsArray<T> */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../Parser\").PreparsedAst} PreparsedAst */\n/** @typedef {{declaredScope: ScopeInfo, freeName: string | true, tagInfo: TagInfo | undefined}} VariableInfoInterface */\n/** @typedef {{ name: string | VariableInfo, rootInfo: string | VariableInfo, getMembers: () => string[], getMembersOptionals: () => boolean[] }} GetInfoResult */\n\nconst EMPTY_ARRAY = [];\nconst ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = 0b01;\nconst ALLOWED_MEMBER_TYPES_EXPRESSION = 0b10;\nconst ALLOWED_MEMBER_TYPES_ALL = 0b11;\n\n// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\n\nconst parser = AcornParser.extend(importAssertions);\n\nclass VariableInfo {\n\t/**\n\t * @param {ScopeInfo} declaredScope scope in which the variable is declared\n\t * @param {string | true} freeName which free name the variable aliases, or true when none\n\t * @param {TagInfo | undefined} tagInfo info about tags\n\t */\n\tconstructor(declaredScope, freeName, tagInfo) {\n\t\tthis.declaredScope = declaredScope;\n\t\tthis.freeName = freeName;\n\t\tthis.tagInfo = tagInfo;\n\t}\n}\n\n/** @typedef {string | ScopeInfo | VariableInfo} ExportedVariableInfo */\n/** @typedef {LiteralNode | string | null | undefined} ImportSource */\n/** @typedef {Omit<AcornOptions, \"sourceType\" | \"ecmaVersion\"> & { sourceType: \"module\" | \"script\" | \"auto\", ecmaVersion?: AcornOptions[\"ecmaVersion\"] }} ParseOptions */\n\n/**\n * @typedef {Object} TagInfo\n * @property {any} tag\n * @property {any} data\n * @property {TagInfo | undefined} next\n */\n\n/**\n * @typedef {Object} ScopeInfo\n * @property {StackedMap<string, VariableInfo | ScopeInfo>} definitions\n * @property {boolean | \"arrow\"} topLevelScope\n * @property {boolean} inShorthand\n * @property {boolean} isStrict\n * @property {boolean} isAsmJs\n * @property {boolean} inTry\n */\n\nconst joinRanges = (startRange, endRange) => {\n\tif (!endRange) return startRange;\n\tif (!startRange) return endRange;\n\treturn [startRange[0], endRange[1]];\n};\n\nconst objectAndMembersToName = (object, membersReversed) => {\n\tlet name = object;\n\tfor (let i = membersReversed.length - 1; i >= 0; i--) {\n\t\tname = name + \".\" + membersReversed[i];\n\t}\n\treturn name;\n};\n\nconst getRootName = expression => {\n\tswitch (expression.type) {\n\t\tcase \"Identifier\":\n\t\t\treturn expression.name;\n\t\tcase \"ThisExpression\":\n\t\t\treturn \"this\";\n\t\tcase \"MetaProperty\":\n\t\t\treturn `${expression.meta.name}.${expression.property.name}`;\n\t\tdefault:\n\t\t\treturn undefined;\n\t}\n};\n\n/** @type {AcornOptions} */\nconst defaultParserOptions = {\n\tranges: true,\n\tlocations: true,\n\tecmaVersion: \"latest\",\n\tsourceType: \"module\",\n\t// https://github.com/tc39/proposal-hashbang\n\tallowHashBang: true,\n\tonComment: null\n};\n\n// regexp to match at least one \"magic comment\"\nconst webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\n\nconst EMPTY_COMMENT_OPTIONS = {\n\toptions: null,\n\terrors: null\n};\n\nclass JavascriptParser extends Parser {\n\t/**\n\t * @param {\"module\" | \"script\" | \"auto\"} sourceType default source type\n\t */\n\tconstructor(sourceType = \"auto\") {\n\t\tsuper();\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {HookMap<SyncBailHook<[UnaryExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateTypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluate: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode | MetaPropertyNode], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateDefinedIdentifier: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[NewExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateNewExpression: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[CallExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateCallExpression: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[CallExpressionNode, BasicEvaluatedExpression | undefined], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateCallExpressionMember: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"param\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode | DeclarationNode | PrivateIdentifierNode, number], boolean | void>>} */\n\t\t\tisPure: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"commentsStartPosition\"])\n\t\t\t),\n\t\t\t/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */\n\t\t\tpreStatement: new SyncBailHook([\"statement\"]),\n\n\t\t\t/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */\n\t\t\tblockPreStatement: new SyncBailHook([\"declaration\"]),\n\t\t\t/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */\n\t\t\tstatement: new SyncBailHook([\"statement\"]),\n\t\t\t/** @type {SyncBailHook<[IfStatementNode], boolean | void>} */\n\t\t\tstatementIf: new SyncBailHook([\"statement\"]),\n\t\t\t/** @type {SyncBailHook<[ExpressionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */\n\t\t\tclassExtendsExpression: new SyncBailHook([\n\t\t\t\t\"expression\",\n\t\t\t\t\"classDefinition\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */\n\t\t\tclassBodyElement: new SyncBailHook([\"element\", \"classDefinition\"]),\n\t\t\t/** @type {SyncBailHook<[ExpressionNode, MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */\n\t\t\tclassBodyValue: new SyncBailHook([\n\t\t\t\t\"expression\",\n\t\t\t\t\"element\",\n\t\t\t\t\"classDefinition\"\n\t\t\t]),\n\t\t\t/** @type {HookMap<SyncBailHook<[LabeledStatementNode], boolean | void>>} */\n\t\t\tlabel: new HookMap(() => new SyncBailHook([\"statement\"])),\n\t\t\t/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource], boolean | void>} */\n\t\t\timport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\t/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource, string, string], boolean | void>} */\n\t\t\timportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"identifierName\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode], boolean | void>} */\n\t\t\texport: new SyncBailHook([\"statement\"]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource], boolean | void>} */\n\t\t\texportImport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, DeclarationNode], boolean | void>} */\n\t\t\texportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\t/** @type {SyncBailHook<[ExportDefaultDeclarationNode, DeclarationNode], boolean | void>} */\n\t\t\texportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, string, string, number | undefined], boolean | void>} */\n\t\t\texportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource, string, string, number | undefined], boolean | void>} */\n\t\t\texportImportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */\n\t\t\tpreDeclarator: new SyncBailHook([\"declarator\", \"statement\"]),\n\t\t\t/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */\n\t\t\tdeclarator: new SyncBailHook([\"declarator\", \"statement\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n\t\t\tvarDeclaration: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n\t\t\tvarDeclarationLet: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n\t\t\tvarDeclarationConst: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n\t\t\tvarDeclarationVar: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[IdentifierNode], boolean | void>>} */\n\t\t\tpattern: new HookMap(() => new SyncBailHook([\"pattern\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n\t\t\tcanRename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n\t\t\trename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[import(\"estree\").AssignmentExpression], boolean | void>>} */\n\t\t\tassign: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[import(\"estree\").AssignmentExpression, string[]], boolean | void>>} */\n\t\t\tassignMemberChain: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"members\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n\t\t\ttypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n\t\t\timportCall: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n\t\t\ttopLevelAwait: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n\t\t\tcall: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** Something like \"a.b()\" */\n\t\t\t/** @type {HookMap<SyncBailHook<[CallExpressionNode, string[], boolean[]], boolean | void>>} */\n\t\t\tcallMemberChain: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"members\", \"membersOptionals\"])\n\t\t\t),\n\t\t\t/** Something like \"a.b().c.d\" */\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */\n\t\t\tmemberChainOfCallMemberChain: new HookMap(\n\t\t\t\t() =>\n\t\t\t\t\tnew SyncBailHook([\n\t\t\t\t\t\t\"expression\",\n\t\t\t\t\t\t\"calleeMembers\",\n\t\t\t\t\t\t\"callExpression\",\n\t\t\t\t\t\t\"members\"\n\t\t\t\t\t])\n\t\t\t),\n\t\t\t/** Something like \"a.b().c.d()\"\" */\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */\n\t\t\tcallMemberChainOfCallMemberChain: new HookMap(\n\t\t\t\t() =>\n\t\t\t\t\tnew SyncBailHook([\n\t\t\t\t\t\t\"expression\",\n\t\t\t\t\t\t\"calleeMembers\",\n\t\t\t\t\t\t\"innerCallExpression\",\n\t\t\t\t\t\t\"members\"\n\t\t\t\t\t])\n\t\t\t),\n\t\t\t/** @type {SyncBailHook<[ChainExpressionNode], boolean | void>} */\n\t\t\toptionalChaining: new SyncBailHook([\"optionalChaining\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[NewExpressionNode], boolean | void>>} */\n\t\t\tnew: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {SyncBailHook<[BinaryExpressionNode], boolean | void>} */\n\t\t\tbinaryExpression: new SyncBailHook([\"binaryExpression\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n\t\t\texpression: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], boolean[]], boolean | void>>} */\n\t\t\texpressionMemberChain: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"members\", \"membersOptionals\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode, string[]], boolean | void>>} */\n\t\t\tunhandledExpressionMemberChain: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"members\"])\n\t\t\t),\n\t\t\t/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n\t\t\texpressionConditionalOperator: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n\t\t\texpressionLogicalOperator: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {SyncBailHook<[ProgramNode, CommentNode[]], boolean | void>} */\n\t\t\tprogram: new SyncBailHook([\"ast\", \"comments\"]),\n\t\t\t/** @type {SyncBailHook<[ProgramNode, CommentNode[]], boolean | void>} */\n\t\t\tfinish: new SyncBailHook([\"ast\", \"comments\"])\n\t\t});\n\t\tthis.sourceType = sourceType;\n\t\t/** @type {ScopeInfo} */\n\t\tthis.scope = undefined;\n\t\t/** @type {ParserState} */\n\t\tthis.state = undefined;\n\t\tthis.comments = undefined;\n\t\tthis.semicolons = undefined;\n\t\t/** @type {(StatementNode|ExpressionNode)[]} */\n\t\tthis.statementPath = undefined;\n\t\tthis.prevStatement = undefined;\n\t\tthis.currentTagData = undefined;\n\t\tthis._initializeEvaluating();\n\t}\n\n\t_initializeEvaluating() {\n\t\tthis.hooks.evaluate.for(\"Literal\").tap(\"JavascriptParser\", _expr => {\n\t\t\tconst expr = /** @type {LiteralNode} */ (_expr);\n\n\t\t\tswitch (typeof expr.value) {\n\t\t\t\tcase \"number\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setNumber(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"bigint\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBigInt(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t\tif (expr.value === null) {\n\t\t\t\treturn new BasicEvaluatedExpression().setNull().setRange(expr.range);\n\t\t\t}\n\t\t\tif (expr.value instanceof RegExp) {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setRegExp(expr.value)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"NewExpression\").tap(\"JavascriptParser\", _expr => {\n\t\t\tconst expr = /** @type {NewExpressionNode} */ (_expr);\n\t\t\tconst callee = expr.callee;\n\t\t\tif (callee.type !== \"Identifier\") return;\n\t\t\tif (callee.name !== \"RegExp\") {\n\t\t\t\treturn this.callHooksForName(\n\t\t\t\t\tthis.hooks.evaluateNewExpression,\n\t\t\t\t\tcallee.name,\n\t\t\t\t\texpr\n\t\t\t\t);\n\t\t\t} else if (\n\t\t\t\texpr.arguments.length > 2 ||\n\t\t\t\tthis.getVariableInfo(\"RegExp\") !== \"RegExp\"\n\t\t\t)\n\t\t\t\treturn;\n\n\t\t\tlet regExp, flags;\n\t\t\tconst arg1 = expr.arguments[0];\n\n\t\t\tif (arg1) {\n\t\t\t\tif (arg1.type === \"SpreadElement\") return;\n\n\t\t\t\tconst evaluatedRegExp = this.evaluateExpression(arg1);\n\n\t\t\t\tif (!evaluatedRegExp) return;\n\n\t\t\t\tregExp = evaluatedRegExp.asString();\n\n\t\t\t\tif (!regExp) return;\n\t\t\t} else {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setRegExp(new RegExp(\"\"))\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\n\t\t\tconst arg2 = expr.arguments[1];\n\n\t\t\tif (arg2) {\n\t\t\t\tif (arg2.type === \"SpreadElement\") return;\n\n\t\t\t\tconst evaluatedFlags = this.evaluateExpression(arg2);\n\n\t\t\t\tif (!evaluatedFlags) return;\n\n\t\t\t\tif (!evaluatedFlags.isUndefined()) {\n\t\t\t\t\tflags = evaluatedFlags.asString();\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tflags === undefined ||\n\t\t\t\t\t\t!BasicEvaluatedExpression.isValidRegExpFlags(flags)\n\t\t\t\t\t)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))\n\t\t\t\t.setRange(expr.range);\n\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"LogicalExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {LogicalExpressionNode} */ (_expr);\n\n\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\tlet returnRight = false;\n\t\t\t\t/** @type {boolean|undefined} */\n\t\t\t\tlet allowedRight;\n\t\t\t\tif (expr.operator === \"&&\") {\n\t\t\t\t\tconst leftAsBool = left.asBool();\n\t\t\t\t\tif (leftAsBool === false) return left.setRange(expr.range);\n\t\t\t\t\treturnRight = leftAsBool === true;\n\t\t\t\t\tallowedRight = false;\n\t\t\t\t} else if (expr.operator === \"||\") {\n\t\t\t\t\tconst leftAsBool = left.asBool();\n\t\t\t\t\tif (leftAsBool === true) return left.setRange(expr.range);\n\t\t\t\t\treturnRight = leftAsBool === false;\n\t\t\t\t\tallowedRight = true;\n\t\t\t\t} else if (expr.operator === \"??\") {\n\t\t\t\t\tconst leftAsNullish = left.asNullish();\n\t\t\t\t\tif (leftAsNullish === false) return left.setRange(expr.range);\n\t\t\t\t\tif (leftAsNullish !== true) return;\n\t\t\t\t\treturnRight = true;\n\t\t\t\t} else return;\n\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\tif (returnRight) {\n\t\t\t\t\tif (left.couldHaveSideEffects()) right.setSideEffects();\n\t\t\t\t\treturn right.setRange(expr.range);\n\t\t\t\t}\n\n\t\t\t\tconst asBool = right.asBool();\n\n\t\t\t\tif (allowedRight === true && asBool === true) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setRange(expr.range)\n\t\t\t\t\t\t.setTruthy();\n\t\t\t\t} else if (allowedRight === false && asBool === false) {\n\t\t\t\t\treturn new BasicEvaluatedExpression().setRange(expr.range).setFalsy();\n\t\t\t\t}\n\t\t\t});\n\n\t\tconst valueAsExpression = (value, expr, sideEffects) => {\n\t\t\tswitch (typeof value) {\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"number\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setNumber(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"bigint\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBigInt(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t};\n\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"BinaryExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {BinaryExpressionNode} */ (_expr);\n\n\t\t\t\tconst handleConstOperation = fn => {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tif (!left.isCompileTimeValue()) return;\n\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tif (!right.isCompileTimeValue()) return;\n\n\t\t\t\t\tconst result = fn(\n\t\t\t\t\t\tleft.asCompileTimeValue(),\n\t\t\t\t\t\tright.asCompileTimeValue()\n\t\t\t\t\t);\n\t\t\t\t\treturn valueAsExpression(\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\texpr,\n\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\tconst isAlwaysDifferent = (a, b) =>\n\t\t\t\t\t(a === true && b === false) || (a === false && b === true);\n\n\t\t\t\tconst handleTemplateStringCompare = (left, right, res, eql) => {\n\t\t\t\t\tconst getPrefix = parts => {\n\t\t\t\t\t\tlet value = \"\";\n\t\t\t\t\t\tfor (const p of parts) {\n\t\t\t\t\t\t\tconst v = p.asString();\n\t\t\t\t\t\t\tif (v !== undefined) value += v;\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t};\n\t\t\t\t\tconst getSuffix = parts => {\n\t\t\t\t\t\tlet value = \"\";\n\t\t\t\t\t\tfor (let i = parts.length - 1; i >= 0; i--) {\n\t\t\t\t\t\t\tconst v = parts[i].asString();\n\t\t\t\t\t\t\tif (v !== undefined) value = v + value;\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t};\n\t\t\t\t\tconst leftPrefix = getPrefix(left.parts);\n\t\t\t\t\tconst rightPrefix = getPrefix(right.parts);\n\t\t\t\t\tconst leftSuffix = getSuffix(left.parts);\n\t\t\t\t\tconst rightSuffix = getSuffix(right.parts);\n\t\t\t\t\tconst lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);\n\t\t\t\t\tconst lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);\n\t\t\t\t\tif (\n\t\t\t\t\t\tleftPrefix.slice(0, lenPrefix) !==\n\t\t\t\t\t\t\trightPrefix.slice(0, lenPrefix) ||\n\t\t\t\t\t\tleftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tconst handleStrictEqualityComparison = eql => {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\t\tres.setRange(expr.range);\n\n\t\t\t\t\tconst leftConst = left.isCompileTimeValue();\n\t\t\t\t\tconst rightConst = right.isCompileTimeValue();\n\n\t\t\t\t\tif (leftConst && rightConst) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(\n\t\t\t\t\t\t\t\teql ===\n\t\t\t\t\t\t\t\t\t(left.asCompileTimeValue() === right.asCompileTimeValue())\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (left.isArray() && right.isArray()) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (left.isTemplateString() && right.isTemplateString()) {\n\t\t\t\t\t\treturn handleTemplateStringCompare(left, right, res, eql);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst leftPrimitive = left.isPrimitiveType();\n\t\t\t\t\tconst rightPrimitive = right.isPrimitiveType();\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t// Primitive !== Object or\n\t\t\t\t\t\t// compile-time object types are never equal to something at runtime\n\t\t\t\t\t\t(leftPrimitive === false &&\n\t\t\t\t\t\t\t(leftConst || rightPrimitive === true)) ||\n\t\t\t\t\t\t(rightPrimitive === false &&\n\t\t\t\t\t\t\t(rightConst || leftPrimitive === true)) ||\n\t\t\t\t\t\t// Different nullish or boolish status also means not equal\n\t\t\t\t\t\tisAlwaysDifferent(left.asBool(), right.asBool()) ||\n\t\t\t\t\t\tisAlwaysDifferent(left.asNullish(), right.asNullish())\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tconst handleAbstractEqualityComparison = eql => {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\t\tres.setRange(expr.range);\n\n\t\t\t\t\tconst leftConst = left.isCompileTimeValue();\n\t\t\t\t\tconst rightConst = right.isCompileTimeValue();\n\n\t\t\t\t\tif (leftConst && rightConst) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(\n\t\t\t\t\t\t\t\teql ===\n\t\t\t\t\t\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\t\t\t\t\t\t(left.asCompileTimeValue() == right.asCompileTimeValue())\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (left.isArray() && right.isArray()) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (left.isTemplateString() && right.isTemplateString()) {\n\t\t\t\t\t\treturn handleTemplateStringCompare(left, right, res, eql);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tif (expr.operator === \"+\") {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\t\tif (left.isString()) {\n\t\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t\tres.setString(left.string + right.string);\n\t\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t\tres.setString(left.string + right.number);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tright.isWrapped() &&\n\t\t\t\t\t\t\tright.prefix &&\n\t\t\t\t\t\t\tright.prefix.isString()\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// \"left\" + (\"prefix\" + inner + \"postfix\")\n\t\t\t\t\t\t\t// => (\"leftPrefix\" + inner + \"postfix\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(left.string + right.prefix.string)\n\t\t\t\t\t\t\t\t\t.setRange(joinRanges(left.range, right.prefix.range)),\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t\t// \"left\" + ([null] + inner + \"postfix\")\n\t\t\t\t\t\t\t// => (\"left\" + inner + \"postfix\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// \"left\" + expr\n\t\t\t\t\t\t\t// => (\"left\" + expr + \"\")\n\t\t\t\t\t\t\tres.setWrapped(left, null, [right]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (left.isNumber()) {\n\t\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t\tres.setString(left.number + right.string);\n\t\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t\tres.setNumber(left.number + right.number);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (left.isBigInt()) {\n\t\t\t\t\t\tif (right.isBigInt()) {\n\t\t\t\t\t\t\tres.setBigInt(left.bigint + right.bigint);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (left.isWrapped()) {\n\t\t\t\t\t\tif (left.postfix && left.postfix.isString() && right.isString()) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + \"right\"\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfixRight\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(left.postfix.string + right.string)\n\t\t\t\t\t\t\t\t\t.setRange(joinRanges(left.postfix.range, right.range)),\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tleft.postfix &&\n\t\t\t\t\t\t\tleft.postfix.isString() &&\n\t\t\t\t\t\t\tright.isNumber()\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + 123\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfix123\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(left.postfix.string + right.number)\n\t\t\t\t\t\t\t\t\t.setRange(joinRanges(left.postfix.range, right.range)),\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (right.isString()) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + \"right\"\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"right\")\n\t\t\t\t\t\t\tres.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n\t\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + 123\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"123\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(right.number + \"\")\n\t\t\t\t\t\t\t\t\t.setRange(right.range),\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t\t\t.concat(left.postfix ? [left.postfix] : [])\n\t\t\t\t\t\t\t\t\t\t.concat(right.prefix ? [right.prefix] : [])\n\t\t\t\t\t\t\t\t\t\t.concat(right.wrappedInnerExpressions)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + postfix) + expr\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + postfix + expr + [null])\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions.concat(\n\t\t\t\t\t\t\t\t\t\tleft.postfix ? [left.postfix, right] : [right]\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t\t// left + \"right\"\n\t\t\t\t\t\t\t// => ([null] + left + \"right\")\n\t\t\t\t\t\t\tres.setWrapped(null, right, [left]);\n\t\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t\t// left + (prefix + inner + \"postfix\")\n\t\t\t\t\t\t\t// => ([null] + left + prefix + inner + \"postfix\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\t(right.prefix ? [left, right.prefix] : [left]).concat(\n\t\t\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (left.couldHaveSideEffects() || right.couldHaveSideEffects())\n\t\t\t\t\t\tres.setSideEffects();\n\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\treturn res;\n\t\t\t\t} else if (expr.operator === \"-\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l - r);\n\t\t\t\t} else if (expr.operator === \"*\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l * r);\n\t\t\t\t} else if (expr.operator === \"/\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l / r);\n\t\t\t\t} else if (expr.operator === \"**\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l ** r);\n\t\t\t\t} else if (expr.operator === \"===\") {\n\t\t\t\t\treturn handleStrictEqualityComparison(true);\n\t\t\t\t} else if (expr.operator === \"==\") {\n\t\t\t\t\treturn handleAbstractEqualityComparison(true);\n\t\t\t\t} else if (expr.operator === \"!==\") {\n\t\t\t\t\treturn handleStrictEqualityComparison(false);\n\t\t\t\t} else if (expr.operator === \"!=\") {\n\t\t\t\t\treturn handleAbstractEqualityComparison(false);\n\t\t\t\t} else if (expr.operator === \"&\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l & r);\n\t\t\t\t} else if (expr.operator === \"|\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l | r);\n\t\t\t\t} else if (expr.operator === \"^\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l ^ r);\n\t\t\t\t} else if (expr.operator === \">>>\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l >>> r);\n\t\t\t\t} else if (expr.operator === \">>\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l >> r);\n\t\t\t\t} else if (expr.operator === \"<<\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l << r);\n\t\t\t\t} else if (expr.operator === \"<\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l < r);\n\t\t\t\t} else if (expr.operator === \">\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l > r);\n\t\t\t\t} else if (expr.operator === \"<=\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l <= r);\n\t\t\t\t} else if (expr.operator === \">=\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l >= r);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"UnaryExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {UnaryExpressionNode} */ (_expr);\n\n\t\t\t\tconst handleConstOperation = fn => {\n\t\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\t\tif (!argument.isCompileTimeValue()) return;\n\t\t\t\t\tconst result = fn(argument.asCompileTimeValue());\n\t\t\t\t\treturn valueAsExpression(\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\texpr,\n\t\t\t\t\t\targument.couldHaveSideEffects()\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\tif (expr.operator === \"typeof\") {\n\t\t\t\t\tswitch (expr.argument.type) {\n\t\t\t\t\t\tcase \"Identifier\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForName(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\texpr.argument.name,\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"MetaProperty\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForName(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\tgetRootName(expr.argument),\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"MemberExpression\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForExpression(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\texpr.argument,\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"ChainExpression\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForExpression(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\texpr.argument.expression,\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"FunctionExpression\": {\n\t\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(\"function\")\n\t\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst arg = this.evaluateExpression(expr.argument);\n\t\t\t\t\tif (arg.isUnknown()) return;\n\t\t\t\t\tif (arg.isString()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"string\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isWrapped()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"string\")\n\t\t\t\t\t\t\t.setSideEffects()\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isUndefined()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"undefined\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isNumber()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"number\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isBigInt()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"bigint\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isBoolean()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"boolean\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"object\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isArray()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"object\")\n\t\t\t\t\t\t\t.setSideEffects(arg.couldHaveSideEffects())\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t} else if (expr.operator === \"!\") {\n\t\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\t\tconst bool = argument.asBool();\n\t\t\t\t\tif (typeof bool !== \"boolean\") return;\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!bool)\n\t\t\t\t\t\t.setSideEffects(argument.couldHaveSideEffects())\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else if (expr.operator === \"~\") {\n\t\t\t\t\treturn handleConstOperation(v => ~v);\n\t\t\t\t} else if (expr.operator === \"+\") {\n\t\t\t\t\treturn handleConstOperation(v => +v);\n\t\t\t\t} else if (expr.operator === \"-\") {\n\t\t\t\t\treturn handleConstOperation(v => -v);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluateTypeof.for(\"undefined\").tap(\"JavascriptParser\", expr => {\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setString(\"undefined\")\n\t\t\t\t.setRange(expr.range);\n\t\t});\n\t\tthis.hooks.evaluate.for(\"Identifier\").tap(\"JavascriptParser\", expr => {\n\t\t\tif (/** @type {IdentifierNode} */ (expr).name === \"undefined\") {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setUndefined()\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\t/**\n\t\t * @param {string} exprType expression type name\n\t\t * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info\n\t\t * @returns {void}\n\t\t */\n\t\tconst tapEvaluateWithVariableInfo = (exprType, getInfo) => {\n\t\t\t/** @type {ExpressionNode | undefined} */\n\t\t\tlet cachedExpression = undefined;\n\t\t\t/** @type {GetInfoResult | undefined} */\n\t\t\tlet cachedInfo = undefined;\n\t\t\tthis.hooks.evaluate.for(exprType).tap(\"JavascriptParser\", expr => {\n\t\t\t\tconst expression = /** @type {MemberExpressionNode} */ (expr);\n\n\t\t\t\tconst info = getInfo(expr);\n\t\t\t\tif (info !== undefined) {\n\t\t\t\t\treturn this.callHooksForInfoWithFallback(\n\t\t\t\t\t\tthis.hooks.evaluateIdentifier,\n\t\t\t\t\t\tinfo.name,\n\t\t\t\t\t\tname => {\n\t\t\t\t\t\t\tcachedExpression = expression;\n\t\t\t\t\t\t\tcachedInfo = info;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tname => {\n\t\t\t\t\t\t\tconst hook = this.hooks.evaluateDefinedIdentifier.get(name);\n\t\t\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\t\t\treturn hook.call(expression);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\texpression\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.hooks.evaluate\n\t\t\t\t.for(exprType)\n\t\t\t\t.tap({ name: \"JavascriptParser\", stage: 100 }, expr => {\n\t\t\t\t\tconst info = cachedExpression === expr ? cachedInfo : getInfo(expr);\n\t\t\t\t\tif (info !== undefined) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setIdentifier(\n\t\t\t\t\t\t\t\tinfo.name,\n\t\t\t\t\t\t\t\tinfo.rootInfo,\n\t\t\t\t\t\t\t\tinfo.getMembers,\n\t\t\t\t\t\t\t\tinfo.getMembersOptionals\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tthis.hooks.finish.tap(\"JavascriptParser\", () => {\n\t\t\t\t// Cleanup for GC\n\t\t\t\tcachedExpression = cachedInfo = undefined;\n\t\t\t});\n\t\t};\n\t\ttapEvaluateWithVariableInfo(\"Identifier\", expr => {\n\t\t\tconst info = this.getVariableInfo(\n\t\t\t\t/** @type {IdentifierNode} */ (expr).name\n\t\t\t);\n\t\t\tif (\n\t\t\t\ttypeof info === \"string\" ||\n\t\t\t\t(info instanceof VariableInfo && typeof info.freeName === \"string\")\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\tname: info,\n\t\t\t\t\trootInfo: info,\n\t\t\t\t\tgetMembers: () => [],\n\t\t\t\t\tgetMembersOptionals: () => []\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\ttapEvaluateWithVariableInfo(\"ThisExpression\", expr => {\n\t\t\tconst info = this.getVariableInfo(\"this\");\n\t\t\tif (\n\t\t\t\ttypeof info === \"string\" ||\n\t\t\t\t(info instanceof VariableInfo && typeof info.freeName === \"string\")\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\tname: info,\n\t\t\t\t\trootInfo: info,\n\t\t\t\t\tgetMembers: () => [],\n\t\t\t\t\tgetMembersOptionals: () => []\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"MetaProperty\").tap(\"JavascriptParser\", expr => {\n\t\t\tconst metaProperty = /** @type {MetaPropertyNode} */ (expr);\n\n\t\t\treturn this.callHooksForName(\n\t\t\t\tthis.hooks.evaluateIdentifier,\n\t\t\t\tgetRootName(expr),\n\t\t\t\tmetaProperty\n\t\t\t);\n\t\t});\n\t\ttapEvaluateWithVariableInfo(\"MemberExpression\", expr =>\n\t\t\tthis.getMemberExpressionInfo(\n\t\t\t\t/** @type {MemberExpressionNode} */ (expr),\n\t\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t\t)\n\t\t);\n\n\t\tthis.hooks.evaluate.for(\"CallExpression\").tap(\"JavascriptParser\", _expr => {\n\t\t\tconst expr = /** @type {CallExpressionNode} */ (_expr);\n\t\t\tif (\n\t\t\t\texpr.callee.type === \"MemberExpression\" &&\n\t\t\t\texpr.callee.property.type ===\n\t\t\t\t\t(expr.callee.computed ? \"Literal\" : \"Identifier\")\n\t\t\t) {\n\t\t\t\t// type Super also possible here\n\t\t\t\tconst param = this.evaluateExpression(\n\t\t\t\t\t/** @type {ExpressionNode} */ (expr.callee.object)\n\t\t\t\t);\n\t\t\t\tconst property =\n\t\t\t\t\texpr.callee.property.type === \"Literal\"\n\t\t\t\t\t\t? `${expr.callee.property.value}`\n\t\t\t\t\t\t: expr.callee.property.name;\n\t\t\t\tconst hook = this.hooks.evaluateCallExpressionMember.get(property);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\treturn hook.call(expr, param);\n\t\t\t\t}\n\t\t\t} else if (expr.callee.type === \"Identifier\") {\n\t\t\t\treturn this.callHooksForName(\n\t\t\t\t\tthis.hooks.evaluateCallExpression,\n\t\t\t\t\texpr.callee.name,\n\t\t\t\t\texpr\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"indexOf\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length === 0) return;\n\t\t\t\tconst [arg1, arg2] = expr.arguments;\n\t\t\t\tif (arg1.type === \"SpreadElement\") return;\n\t\t\t\tconst arg1Eval = this.evaluateExpression(arg1);\n\t\t\t\tif (!arg1Eval.isString()) return;\n\t\t\t\tconst arg1Value = arg1Eval.string;\n\n\t\t\t\tlet result;\n\t\t\t\tif (arg2) {\n\t\t\t\t\tif (arg2.type === \"SpreadElement\") return;\n\t\t\t\t\tconst arg2Eval = this.evaluateExpression(arg2);\n\t\t\t\t\tif (!arg2Eval.isNumber()) return;\n\t\t\t\t\tresult = param.string.indexOf(arg1Value, arg2Eval.number);\n\t\t\t\t} else {\n\t\t\t\t\tresult = param.string.indexOf(arg1Value);\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setNumber(result)\n\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"replace\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 2) return;\n\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\tif (expr.arguments[1].type === \"SpreadElement\") return;\n\t\t\t\tlet arg1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tlet arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\tif (!arg1.isString() && !arg1.isRegExp()) return;\n\t\t\t\tconst arg1Value = arg1.regExp || arg1.string;\n\t\t\t\tif (!arg2.isString()) return;\n\t\t\t\tconst arg2Value = arg2.string;\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(param.string.replace(arg1Value, arg2Value))\n\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\t[\"substr\", \"substring\", \"slice\"].forEach(fn => {\n\t\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t\t.for(fn)\n\t\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\t\tif (!param.isString()) return;\n\t\t\t\t\tlet arg1;\n\t\t\t\t\tlet result,\n\t\t\t\t\t\tstr = param.string;\n\t\t\t\t\tswitch (expr.arguments.length) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[fn](arg1.number);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\t\t\t\tif (expr.arguments[1].type === \"SpreadElement\") return;\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tconst arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tif (!arg2.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[fn](arg1.number, arg2.number);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(result)\n\t\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t});\n\t\t});\n\n\t\t/**\n\t\t * @param {\"cooked\" | \"raw\"} kind kind of values to get\n\t\t * @param {TemplateLiteralNode} templateLiteralExpr TemplateLiteral expr\n\t\t * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n\t\t */\n\t\tconst getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {\n\t\t\t/** @type {BasicEvaluatedExpression[]} */\n\t\t\tconst quasis = [];\n\t\t\t/** @type {BasicEvaluatedExpression[]} */\n\t\t\tconst parts = [];\n\n\t\t\tfor (let i = 0; i < templateLiteralExpr.quasis.length; i++) {\n\t\t\t\tconst quasiExpr = templateLiteralExpr.quasis[i];\n\t\t\t\tconst quasi = quasiExpr.value[kind];\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tconst prevExpr = parts[parts.length - 1];\n\t\t\t\t\tconst expr = this.evaluateExpression(\n\t\t\t\t\t\ttemplateLiteralExpr.expressions[i - 1]\n\t\t\t\t\t);\n\t\t\t\t\tconst exprAsString = expr.asString();\n\t\t\t\t\tif (\n\t\t\t\t\t\ttypeof exprAsString === \"string\" &&\n\t\t\t\t\t\t!expr.couldHaveSideEffects()\n\t\t\t\t\t) {\n\t\t\t\t\t\t// We can merge quasi + expr + quasi when expr\n\t\t\t\t\t\t// is a const string\n\n\t\t\t\t\t\tprevExpr.setString(prevExpr.string + exprAsString + quasi);\n\t\t\t\t\t\tprevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);\n\t\t\t\t\t\t// We unset the expression as it doesn't match to a single expression\n\t\t\t\t\t\tprevExpr.setExpression(undefined);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tparts.push(expr);\n\t\t\t\t}\n\n\t\t\t\tconst part = new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(quasi)\n\t\t\t\t\t.setRange(quasiExpr.range)\n\t\t\t\t\t.setExpression(quasiExpr);\n\t\t\t\tquasis.push(part);\n\t\t\t\tparts.push(part);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tquasis,\n\t\t\t\tparts\n\t\t\t};\n\t\t};\n\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"TemplateLiteral\")\n\t\t\t.tap(\"JavascriptParser\", _node => {\n\t\t\t\tconst node = /** @type {TemplateLiteralNode} */ (_node);\n\n\t\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\"cooked\", node);\n\t\t\t\tif (parts.length === 1) {\n\t\t\t\t\treturn parts[0].setRange(node.range);\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setTemplateString(quasis, parts, \"cooked\")\n\t\t\t\t\t.setRange(node.range);\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"TaggedTemplateExpression\")\n\t\t\t.tap(\"JavascriptParser\", _node => {\n\t\t\t\tconst node = /** @type {TaggedTemplateExpressionNode} */ (_node);\n\t\t\t\tconst tag = this.evaluateExpression(node.tag);\n\n\t\t\t\tif (tag.isIdentifier() && tag.identifier === \"String.raw\") {\n\t\t\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\n\t\t\t\t\t\t\"raw\",\n\t\t\t\t\t\tnode.quasi\n\t\t\t\t\t);\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setTemplateString(quasis, parts, \"raw\")\n\t\t\t\t\t\t.setRange(node.range);\n\t\t\t\t}\n\t\t\t});\n\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"concat\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString() && !param.isWrapped()) return;\n\n\t\t\t\tlet stringSuffix = null;\n\t\t\t\tlet hasUnknownParams = false;\n\t\t\t\tconst innerExpressions = [];\n\t\t\t\tfor (let i = expr.arguments.length - 1; i >= 0; i--) {\n\t\t\t\t\tconst arg = expr.arguments[i];\n\t\t\t\t\tif (arg.type === \"SpreadElement\") return;\n\t\t\t\t\tconst argExpr = this.evaluateExpression(arg);\n\t\t\t\t\tif (\n\t\t\t\t\t\thasUnknownParams ||\n\t\t\t\t\t\t(!argExpr.isString() && !argExpr.isNumber())\n\t\t\t\t\t) {\n\t\t\t\t\t\thasUnknownParams = true;\n\t\t\t\t\t\tinnerExpressions.push(argExpr);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = argExpr.isString()\n\t\t\t\t\t\t? argExpr.string\n\t\t\t\t\t\t: \"\" + argExpr.number;\n\n\t\t\t\t\tconst newString = value + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\tconst newRange = [\n\t\t\t\t\t\targExpr.range[0],\n\t\t\t\t\t\t(stringSuffix || argExpr).range[1]\n\t\t\t\t\t];\n\t\t\t\t\tstringSuffix = new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t(stringSuffix && stringSuffix.couldHaveSideEffects()) ||\n\t\t\t\t\t\t\t\targExpr.couldHaveSideEffects()\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.setRange(newRange);\n\t\t\t\t}\n\n\t\t\t\tif (hasUnknownParams) {\n\t\t\t\t\tconst prefix = param.isString() ? param : param.prefix;\n\t\t\t\t\tconst inner =\n\t\t\t\t\t\tparam.isWrapped() && param.wrappedInnerExpressions\n\t\t\t\t\t\t\t? param.wrappedInnerExpressions.concat(innerExpressions.reverse())\n\t\t\t\t\t\t\t: innerExpressions.reverse();\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(prefix, stringSuffix, inner)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else if (param.isWrapped()) {\n\t\t\t\t\tconst postfix = stringSuffix || param.postfix;\n\t\t\t\t\tconst inner = param.wrappedInnerExpressions\n\t\t\t\t\t\t? param.wrappedInnerExpressions.concat(innerExpressions.reverse())\n\t\t\t\t\t\t: innerExpressions.reverse();\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(param.prefix, postfix, inner)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else {\n\t\t\t\t\tconst newString =\n\t\t\t\t\t\tparam.string + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t(stringSuffix && stringSuffix.couldHaveSideEffects()) ||\n\t\t\t\t\t\t\t\tparam.couldHaveSideEffects()\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"split\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 1) return;\n\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\tlet result;\n\t\t\t\tconst arg = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tif (arg.isString()) {\n\t\t\t\t\tresult = param.string.split(arg.string);\n\t\t\t\t} else if (arg.isRegExp()) {\n\t\t\t\t\tresult = param.string.split(arg.regExp);\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setArray(result)\n\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"ConditionalExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {ConditionalExpressionNode} */ (_expr);\n\n\t\t\t\tconst condition = this.evaluateExpression(expr.test);\n\t\t\t\tconst conditionValue = condition.asBool();\n\t\t\t\tlet res;\n\t\t\t\tif (conditionValue === undefined) {\n\t\t\t\t\tconst consequent = this.evaluateExpression(expr.consequent);\n\t\t\t\t\tconst alternate = this.evaluateExpression(expr.alternate);\n\t\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\t\tif (consequent.isConditional()) {\n\t\t\t\t\t\tres.setOptions(consequent.options);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres.setOptions([consequent]);\n\t\t\t\t\t}\n\t\t\t\t\tif (alternate.isConditional()) {\n\t\t\t\t\t\tres.addOptions(alternate.options);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres.addOptions([alternate]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tres = this.evaluateExpression(\n\t\t\t\t\t\tconditionValue ? expr.consequent : expr.alternate\n\t\t\t\t\t);\n\t\t\t\t\tif (condition.couldHaveSideEffects()) res.setSideEffects();\n\t\t\t\t}\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"ArrayExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {ArrayExpressionNode} */ (_expr);\n\n\t\t\t\tconst items = expr.elements.map(element => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\telement !== null &&\n\t\t\t\t\t\telement.type !== \"SpreadElement\" &&\n\t\t\t\t\t\tthis.evaluateExpression(element)\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t\tif (!items.every(Boolean)) return;\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setItems(items)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"ChainExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {ChainExpressionNode} */ (_expr);\n\t\t\t\t/** @type {ExpressionNode[]} */\n\t\t\t\tconst optionalExpressionsStack = [];\n\t\t\t\t/** @type {ExpressionNode|SuperNode} */\n\t\t\t\tlet next = expr.expression;\n\n\t\t\t\twhile (\n\t\t\t\t\tnext.type === \"MemberExpression\" ||\n\t\t\t\t\tnext.type === \"CallExpression\"\n\t\t\t\t) {\n\t\t\t\t\tif (next.type === \"MemberExpression\") {\n\t\t\t\t\t\tif (next.optional) {\n\t\t\t\t\t\t\t// SuperNode can not be optional\n\t\t\t\t\t\t\toptionalExpressionsStack.push(\n\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (next.object)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext = next.object;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (next.optional) {\n\t\t\t\t\t\t\t// SuperNode can not be optional\n\t\t\t\t\t\t\toptionalExpressionsStack.push(\n\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (next.callee)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext = next.callee;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (optionalExpressionsStack.length > 0) {\n\t\t\t\t\tconst expression = optionalExpressionsStack.pop();\n\t\t\t\t\tconst evaluated = this.evaluateExpression(expression);\n\n\t\t\t\t\tif (evaluated.asNullish()) {\n\t\t\t\t\t\treturn evaluated.setRange(_expr.range);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this.evaluateExpression(expr.expression);\n\t\t\t});\n\t}\n\n\tgetRenameIdentifier(expr) {\n\t\tconst result = this.evaluateExpression(expr);\n\t\tif (result.isIdentifier()) {\n\t\t\treturn result.identifier;\n\t\t}\n\t}\n\n\t/**\n\t * @param {ClassExpressionNode | ClassDeclarationNode} classy a class node\n\t * @returns {void}\n\t */\n\twalkClass(classy) {\n\t\tif (classy.superClass) {\n\t\t\tif (!this.hooks.classExtendsExpression.call(classy.superClass, classy)) {\n\t\t\t\tthis.walkExpression(classy.superClass);\n\t\t\t}\n\t\t}\n\t\tif (classy.body && classy.body.type === \"ClassBody\") {\n\t\t\tfor (const classElement of /** @type {TODO} */ (classy.body.body)) {\n\t\t\t\tif (!this.hooks.classBodyElement.call(classElement, classy)) {\n\t\t\t\t\tif (classElement.computed && classElement.key) {\n\t\t\t\t\t\tthis.walkExpression(classElement.key);\n\t\t\t\t\t}\n\t\t\t\t\tif (classElement.value) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!this.hooks.classBodyValue.call(\n\t\t\t\t\t\t\t\tclassElement.value,\n\t\t\t\t\t\t\t\tclassElement,\n\t\t\t\t\t\t\t\tclassy\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\t\t\t\t\t\tthis.scope.topLevelScope = false;\n\t\t\t\t\t\t\tthis.walkExpression(classElement.value);\n\t\t\t\t\t\t\tthis.scope.topLevelScope = wasTopLevel;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (classElement.type === \"StaticBlock\") {\n\t\t\t\t\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\t\t\t\t\tthis.scope.topLevelScope = false;\n\t\t\t\t\t\tthis.walkBlockStatement(classElement);\n\t\t\t\t\t\tthis.scope.topLevelScope = wasTopLevel;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Pre walking iterates the scope for variable declarations\n\tpreWalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.preWalkStatement(statement);\n\t\t}\n\t}\n\n\t// Block pre walking iterates the scope for block variable declarations\n\tblockPreWalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.blockPreWalkStatement(statement);\n\t\t}\n\t}\n\n\t// Walking iterates the statements and expressions and processes them\n\twalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.walkStatement(statement);\n\t\t}\n\t}\n\n\tpreWalkStatement(statement) {\n\t\tthis.statementPath.push(statement);\n\t\tif (this.hooks.preStatement.call(statement)) {\n\t\t\tthis.prevStatement = this.statementPath.pop();\n\t\t\treturn;\n\t\t}\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.preWalkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.preWalkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.preWalkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.preWalkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.preWalkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.preWalkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.preWalkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.preWalkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.preWalkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.preWalkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.preWalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.preWalkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.preWalkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.prevStatement = this.statementPath.pop();\n\t}\n\n\tblockPreWalkStatement(statement) {\n\t\tthis.statementPath.push(statement);\n\t\tif (this.hooks.blockPreStatement.call(statement)) {\n\t\t\tthis.prevStatement = this.statementPath.pop();\n\t\t\treturn;\n\t\t}\n\t\tswitch (statement.type) {\n\t\t\tcase \"ImportDeclaration\":\n\t\t\t\tthis.blockPreWalkImportDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportAllDeclaration\":\n\t\t\t\tthis.blockPreWalkExportAllDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.blockPreWalkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.blockPreWalkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.blockPreWalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.blockPreWalkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.prevStatement = this.statementPath.pop();\n\t}\n\n\twalkStatement(statement) {\n\t\tthis.statementPath.push(statement);\n\t\tif (this.hooks.statement.call(statement) !== undefined) {\n\t\t\tthis.prevStatement = this.statementPath.pop();\n\t\t\treturn;\n\t\t}\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.walkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.walkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.walkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.walkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.walkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExpressionStatement\":\n\t\t\t\tthis.walkExpressionStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.walkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.walkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.walkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.walkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.walkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.walkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ReturnStatement\":\n\t\t\t\tthis.walkReturnStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.walkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ThrowStatement\":\n\t\t\t\tthis.walkThrowStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.walkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.walkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.walkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.walkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.prevStatement = this.statementPath.pop();\n\t}\n\n\t/**\n\t * Walks a statements that is nested within a parent statement\n\t * and can potentially be a non-block statement.\n\t * This enforces the nested statement to never be in ASI position.\n\t * @param {StatementNode} statement the nested statement\n\t * @returns {void}\n\t */\n\twalkNestedStatement(statement) {\n\t\tthis.prevStatement = undefined;\n\t\tthis.walkStatement(statement);\n\t}\n\n\t// Real Statements\n\tpreWalkBlockStatement(statement) {\n\t\tthis.preWalkStatements(statement.body);\n\t}\n\n\twalkBlockStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tconst body = statement.body;\n\t\t\tconst prev = this.prevStatement;\n\t\t\tthis.blockPreWalkStatements(body);\n\t\t\tthis.prevStatement = prev;\n\t\t\tthis.walkStatements(body);\n\t\t});\n\t}\n\n\twalkExpressionStatement(statement) {\n\t\tthis.walkExpression(statement.expression);\n\t}\n\n\tpreWalkIfStatement(statement) {\n\t\tthis.preWalkStatement(statement.consequent);\n\t\tif (statement.alternate) {\n\t\t\tthis.preWalkStatement(statement.alternate);\n\t\t}\n\t}\n\n\twalkIfStatement(statement) {\n\t\tconst result = this.hooks.statementIf.call(statement);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(statement.test);\n\t\t\tthis.walkNestedStatement(statement.consequent);\n\t\t\tif (statement.alternate) {\n\t\t\t\tthis.walkNestedStatement(statement.alternate);\n\t\t\t}\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkNestedStatement(statement.consequent);\n\t\t\t} else if (statement.alternate) {\n\t\t\t\tthis.walkNestedStatement(statement.alternate);\n\t\t\t}\n\t\t}\n\t}\n\n\tpreWalkLabeledStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkLabeledStatement(statement) {\n\t\tconst hook = this.hooks.label.get(statement.label.name);\n\t\tif (hook !== undefined) {\n\t\t\tconst result = hook.call(statement);\n\t\t\tif (result === true) return;\n\t\t}\n\t\tthis.walkNestedStatement(statement.body);\n\t}\n\n\tpreWalkWithStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkWithStatement(statement) {\n\t\tthis.walkExpression(statement.object);\n\t\tthis.walkNestedStatement(statement.body);\n\t}\n\n\tpreWalkSwitchStatement(statement) {\n\t\tthis.preWalkSwitchCases(statement.cases);\n\t}\n\n\twalkSwitchStatement(statement) {\n\t\tthis.walkExpression(statement.discriminant);\n\t\tthis.walkSwitchCases(statement.cases);\n\t}\n\n\twalkTerminatingStatement(statement) {\n\t\tif (statement.argument) this.walkExpression(statement.argument);\n\t}\n\n\twalkReturnStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\twalkThrowStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\tpreWalkTryStatement(statement) {\n\t\tthis.preWalkStatement(statement.block);\n\t\tif (statement.handler) this.preWalkCatchClause(statement.handler);\n\t\tif (statement.finializer) this.preWalkStatement(statement.finializer);\n\t}\n\n\twalkTryStatement(statement) {\n\t\tif (this.scope.inTry) {\n\t\t\tthis.walkStatement(statement.block);\n\t\t} else {\n\t\t\tthis.scope.inTry = true;\n\t\t\tthis.walkStatement(statement.block);\n\t\t\tthis.scope.inTry = false;\n\t\t}\n\t\tif (statement.handler) this.walkCatchClause(statement.handler);\n\t\tif (statement.finalizer) this.walkStatement(statement.finalizer);\n\t}\n\n\tpreWalkWhileStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkWhileStatement(statement) {\n\t\tthis.walkExpression(statement.test);\n\t\tthis.walkNestedStatement(statement.body);\n\t}\n\n\tpreWalkDoWhileStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkDoWhileStatement(statement) {\n\t\tthis.walkNestedStatement(statement.body);\n\t\tthis.walkExpression(statement.test);\n\t}\n\n\tpreWalkForStatement(statement) {\n\t\tif (statement.init) {\n\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\tthis.preWalkStatement(statement.init);\n\t\t\t}\n\t\t}\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkForStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.init) {\n\t\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\t\tthis.blockPreWalkVariableDeclaration(statement.init);\n\t\t\t\t\tthis.prevStatement = undefined;\n\t\t\t\t\tthis.walkStatement(statement.init);\n\t\t\t\t} else {\n\t\t\t\t\tthis.walkExpression(statement.init);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (statement.test) {\n\t\t\t\tthis.walkExpression(statement.test);\n\t\t\t}\n\t\t\tif (statement.update) {\n\t\t\t\tthis.walkExpression(statement.update);\n\t\t\t}\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.blockPreWalkStatements(body.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkNestedStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\tpreWalkForInStatement(statement) {\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.preWalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkForInStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPreWalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.blockPreWalkStatements(body.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkNestedStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\tpreWalkForOfStatement(statement) {\n\t\tif (statement.await && this.scope.topLevelScope === true) {\n\t\t\tthis.hooks.topLevelAwait.call(statement);\n\t\t}\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.preWalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkForOfStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPreWalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.blockPreWalkStatements(body.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkNestedStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Declarations\n\tpreWalkFunctionDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.defineVariable(statement.id.name);\n\t\t}\n\t}\n\n\twalkFunctionDeclaration(statement) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tthis.inFunctionScope(true, statement.params, () => {\n\t\t\tfor (const param of statement.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (statement.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(statement.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(statement.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(statement.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\tblockPreWalkImportDeclaration(statement) {\n\t\tconst source = statement.source.value;\n\t\tthis.hooks.import.call(statement, source);\n\t\tfor (const specifier of statement.specifiers) {\n\t\t\tconst name = specifier.local.name;\n\t\t\tswitch (specifier.type) {\n\t\t\t\tcase \"ImportDefaultSpecifier\":\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.hooks.importSpecifier.call(statement, source, \"default\", name)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportSpecifier\":\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.hooks.importSpecifier.call(\n\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\tspecifier.imported.name || specifier.imported.value,\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportNamespaceSpecifier\":\n\t\t\t\t\tif (!this.hooks.importSpecifier.call(statement, source, null, name)) {\n\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.defineVariable(name);\n\t\t\t}\n\t\t}\n\t}\n\n\tenterDeclaration(declaration, onIdent) {\n\t\tswitch (declaration.type) {\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tfor (const declarator of declaration.declarations) {\n\t\t\t\t\tswitch (declarator.type) {\n\t\t\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\t\t\tthis.enterPattern(declarator.id, onIdent);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tblockPreWalkExportNamedDeclaration(statement) {\n\t\tlet source;\n\t\tif (statement.source) {\n\t\t\tsource = statement.source.value;\n\t\t\tthis.hooks.exportImport.call(statement, source);\n\t\t} else {\n\t\t\tthis.hooks.export.call(statement);\n\t\t}\n\t\tif (statement.declaration) {\n\t\t\tif (\n\t\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t\t) {\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(statement.declaration);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.blockPreWalkStatement(statement.declaration);\n\t\t\t\tlet index = 0;\n\t\t\t\tthis.enterDeclaration(statement.declaration, def => {\n\t\t\t\t\tthis.hooks.exportSpecifier.call(statement, def, def, index++);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (statement.specifiers) {\n\t\t\tfor (\n\t\t\t\tlet specifierIndex = 0;\n\t\t\t\tspecifierIndex < statement.specifiers.length;\n\t\t\t\tspecifierIndex++\n\t\t\t) {\n\t\t\t\tconst specifier = statement.specifiers[specifierIndex];\n\t\t\t\tswitch (specifier.type) {\n\t\t\t\t\tcase \"ExportSpecifier\": {\n\t\t\t\t\t\tconst name = specifier.exported.name || specifier.exported.value;\n\t\t\t\t\t\tif (source) {\n\t\t\t\t\t\t\tthis.hooks.exportImportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\tspecifier.local.name,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tspecifier.local.name,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twalkExportNamedDeclaration(statement) {\n\t\tif (statement.declaration) {\n\t\t\tthis.walkStatement(statement.declaration);\n\t\t}\n\t}\n\n\tblockPreWalkExportDefaultDeclaration(statement) {\n\t\tconst prev = this.prevStatement;\n\t\tthis.preWalkStatement(statement.declaration);\n\t\tthis.prevStatement = prev;\n\t\tthis.blockPreWalkStatement(statement.declaration);\n\t\tif (\n\t\t\tstatement.declaration.id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\tstatement,\n\t\t\t\tstatement.declaration.id.name,\n\t\t\t\t\"default\",\n\t\t\t\tundefined\n\t\t\t);\n\t\t}\n\t}\n\n\twalkExportDefaultDeclaration(statement) {\n\t\tthis.hooks.export.call(statement);\n\t\tif (\n\t\t\tstatement.declaration.id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tif (\n\t\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t\t) {\n\t\t\t\tthis.walkStatement(statement.declaration);\n\t\t\t}\n\t\t} else {\n\t\t\t// Acorn parses `export default function() {}` as `FunctionDeclaration` and\n\t\t\t// `export default class {}` as `ClassDeclaration`, both with `id = null`.\n\t\t\t// These nodes must be treated as expressions.\n\t\t\tif (\n\t\t\t\tstatement.declaration.type === \"FunctionDeclaration\" ||\n\t\t\t\tstatement.declaration.type === \"ClassDeclaration\"\n\t\t\t) {\n\t\t\t\tthis.walkStatement(statement.declaration);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.declaration);\n\t\t\t}\n\t\t\tif (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\tstatement,\n\t\t\t\t\tstatement.declaration,\n\t\t\t\t\t\"default\",\n\t\t\t\t\tundefined\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tblockPreWalkExportAllDeclaration(statement) {\n\t\tconst source = statement.source.value;\n\t\tconst name = statement.exported ? statement.exported.name : null;\n\t\tthis.hooks.exportImport.call(statement, source);\n\t\tthis.hooks.exportImportSpecifier.call(statement, source, null, name, 0);\n\t}\n\n\tpreWalkVariableDeclaration(statement) {\n\t\tif (statement.kind !== \"var\") return;\n\t\tthis._preWalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n\t}\n\n\tblockPreWalkVariableDeclaration(statement) {\n\t\tif (statement.kind === \"var\") return;\n\t\tconst hookMap =\n\t\t\tstatement.kind === \"const\"\n\t\t\t\t? this.hooks.varDeclarationConst\n\t\t\t\t: this.hooks.varDeclarationLet;\n\t\tthis._preWalkVariableDeclaration(statement, hookMap);\n\t}\n\n\t_preWalkVariableDeclaration(statement, hookMap) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tif (!this.hooks.preDeclarator.call(declarator, statement)) {\n\t\t\t\t\t\tthis.enterPattern(declarator.id, (name, decl) => {\n\t\t\t\t\t\t\tlet hook = hookMap.get(name);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\t\thook = this.hooks.varDeclaration.get(name);\n\t\t\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twalkVariableDeclaration(statement) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tconst renameIdentifier =\n\t\t\t\t\t\tdeclarator.init && this.getRenameIdentifier(declarator.init);\n\t\t\t\t\tif (renameIdentifier && declarator.id.type === \"Identifier\") {\n\t\t\t\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\t\t\t\tif (hook !== undefined && hook.call(declarator.init)) {\n\t\t\t\t\t\t\t// renaming with \"var a = b;\"\n\t\t\t\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(declarator.init)) {\n\t\t\t\t\t\t\t\tthis.setVariable(declarator.id.name, renameIdentifier);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!this.hooks.declarator.call(declarator, statement)) {\n\t\t\t\t\t\tthis.walkPattern(declarator.id);\n\t\t\t\t\t\tif (declarator.init) this.walkExpression(declarator.init);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tblockPreWalkClassDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.defineVariable(statement.id.name);\n\t\t}\n\t}\n\n\twalkClassDeclaration(statement) {\n\t\tthis.walkClass(statement);\n\t}\n\n\tpreWalkSwitchCases(switchCases) {\n\t\tfor (let index = 0, len = switchCases.length; index < len; index++) {\n\t\t\tconst switchCase = switchCases[index];\n\t\t\tthis.preWalkStatements(switchCase.consequent);\n\t\t}\n\t}\n\n\twalkSwitchCases(switchCases) {\n\t\tthis.inBlockScope(() => {\n\t\t\tconst len = switchCases.length;\n\n\t\t\t// we need to pre walk all statements first since we can have invalid code\n\t\t\t// import A from \"module\";\n\t\t\t// switch(1) {\n\t\t\t//    case 1:\n\t\t\t//      console.log(A); // should fail at runtime\n\t\t\t//    case 2:\n\t\t\t//      const A = 1;\n\t\t\t// }\n\t\t\tfor (let index = 0; index < len; index++) {\n\t\t\t\tconst switchCase = switchCases[index];\n\n\t\t\t\tif (switchCase.consequent.length > 0) {\n\t\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\t\tthis.blockPreWalkStatements(switchCase.consequent);\n\t\t\t\t\tthis.prevStatement = prev;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let index = 0; index < len; index++) {\n\t\t\t\tconst switchCase = switchCases[index];\n\n\t\t\t\tif (switchCase.test) {\n\t\t\t\t\tthis.walkExpression(switchCase.test);\n\t\t\t\t}\n\t\t\t\tif (switchCase.consequent.length > 0) {\n\t\t\t\t\tthis.walkStatements(switchCase.consequent);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpreWalkCatchClause(catchClause) {\n\t\tthis.preWalkStatement(catchClause.body);\n\t}\n\n\twalkCatchClause(catchClause) {\n\t\tthis.inBlockScope(() => {\n\t\t\t// Error binding is optional in catch clause since ECMAScript 2019\n\t\t\tif (catchClause.param !== null) {\n\t\t\t\tthis.enterPattern(catchClause.param, ident => {\n\t\t\t\t\tthis.defineVariable(ident);\n\t\t\t\t});\n\t\t\t\tthis.walkPattern(catchClause.param);\n\t\t\t}\n\t\t\tconst prev = this.prevStatement;\n\t\t\tthis.blockPreWalkStatement(catchClause.body);\n\t\t\tthis.prevStatement = prev;\n\t\t\tthis.walkStatement(catchClause.body);\n\t\t});\n\t}\n\n\twalkPattern(pattern) {\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.walkArrayPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.walkAssignmentPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.walkObjectPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.walkRestElement(pattern);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkAssignmentPattern(pattern) {\n\t\tthis.walkExpression(pattern.right);\n\t\tthis.walkPattern(pattern.left);\n\t}\n\n\twalkObjectPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.properties.length; i < len; i++) {\n\t\t\tconst prop = pattern.properties[i];\n\t\t\tif (prop) {\n\t\t\t\tif (prop.computed) this.walkExpression(prop.key);\n\t\t\t\tif (prop.value) this.walkPattern(prop.value);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkArrayPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.elements.length; i < len; i++) {\n\t\t\tconst element = pattern.elements[i];\n\t\t\tif (element) this.walkPattern(element);\n\t\t}\n\t}\n\n\twalkRestElement(pattern) {\n\t\tthis.walkPattern(pattern.argument);\n\t}\n\n\twalkExpressions(expressions) {\n\t\tfor (const expression of expressions) {\n\t\t\tif (expression) {\n\t\t\t\tthis.walkExpression(expression);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkExpression(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"ArrayExpression\":\n\t\t\t\tthis.walkArrayExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ArrowFunctionExpression\":\n\t\t\t\tthis.walkArrowFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentExpression\":\n\t\t\t\tthis.walkAssignmentExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AwaitExpression\":\n\t\t\t\tthis.walkAwaitExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tthis.walkBinaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"CallExpression\":\n\t\t\t\tthis.walkCallExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ChainExpression\":\n\t\t\t\tthis.walkChainExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassExpression\":\n\t\t\t\tthis.walkClassExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\":\n\t\t\t\tthis.walkConditionalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionExpression\":\n\t\t\t\tthis.walkFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.walkIdentifier(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ImportExpression\":\n\t\t\t\tthis.walkImportExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"LogicalExpression\":\n\t\t\t\tthis.walkLogicalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"MetaProperty\":\n\t\t\t\tthis.walkMetaProperty(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"NewExpression\":\n\t\t\t\tthis.walkNewExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectExpression\":\n\t\t\t\tthis.walkObjectExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SequenceExpression\":\n\t\t\t\tthis.walkSequenceExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SpreadElement\":\n\t\t\t\tthis.walkSpreadElement(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TaggedTemplateExpression\":\n\t\t\t\tthis.walkTaggedTemplateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TemplateLiteral\":\n\t\t\t\tthis.walkTemplateLiteral(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ThisExpression\":\n\t\t\t\tthis.walkThisExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UnaryExpression\":\n\t\t\t\tthis.walkUnaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UpdateExpression\":\n\t\t\t\tthis.walkUpdateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"YieldExpression\":\n\t\t\t\tthis.walkYieldExpression(expression);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkAwaitExpression(expression) {\n\t\tif (this.scope.topLevelScope === true)\n\t\t\tthis.hooks.topLevelAwait.call(expression);\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkArrayExpression(expression) {\n\t\tif (expression.elements) {\n\t\t\tthis.walkExpressions(expression.elements);\n\t\t}\n\t}\n\n\twalkSpreadElement(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\twalkObjectExpression(expression) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = expression.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = expression.properties[propIndex];\n\t\t\tthis.walkProperty(prop);\n\t\t}\n\t}\n\n\twalkProperty(prop) {\n\t\tif (prop.type === \"SpreadElement\") {\n\t\t\tthis.walkExpression(prop.argument);\n\t\t\treturn;\n\t\t}\n\t\tif (prop.computed) {\n\t\t\tthis.walkExpression(prop.key);\n\t\t}\n\t\tif (prop.shorthand && prop.value && prop.value.type === \"Identifier\") {\n\t\t\tthis.scope.inShorthand = prop.value.name;\n\t\t\tthis.walkIdentifier(prop.value);\n\t\t\tthis.scope.inShorthand = false;\n\t\t} else {\n\t\t\tthis.walkExpression(prop.value);\n\t\t}\n\t}\n\n\twalkFunctionExpression(expression) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tconst scopeParams = expression.params;\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (expression.id) {\n\t\t\tscopeParams.push(expression.id.name);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(expression.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\twalkArrowFunctionExpression(expression) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = wasTopLevel ? \"arrow\" : false;\n\t\tthis.inFunctionScope(false, expression.params, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(expression.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\t/**\n\t * @param {SequenceExpressionNode} expression the sequence\n\t */\n\twalkSequenceExpression(expression) {\n\t\tif (!expression.expressions) return;\n\t\t// We treat sequence expressions like statements when they are one statement level\n\t\t// This has some benefits for optimizations that only work on statement level\n\t\tconst currentStatement = this.statementPath[this.statementPath.length - 1];\n\t\tif (\n\t\t\tcurrentStatement === expression ||\n\t\t\t(currentStatement.type === \"ExpressionStatement\" &&\n\t\t\t\tcurrentStatement.expression === expression)\n\t\t) {\n\t\t\tconst old = this.statementPath.pop();\n\t\t\tfor (const expr of expression.expressions) {\n\t\t\t\tthis.statementPath.push(expr);\n\t\t\t\tthis.walkExpression(expr);\n\t\t\t\tthis.statementPath.pop();\n\t\t\t}\n\t\t\tthis.statementPath.push(old);\n\t\t} else {\n\t\t\tthis.walkExpressions(expression.expressions);\n\t\t}\n\t}\n\n\twalkUpdateExpression(expression) {\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkUnaryExpression(expression) {\n\t\tif (expression.operator === \"typeof\") {\n\t\t\tconst result = this.callHooksForExpression(\n\t\t\t\tthis.hooks.typeof,\n\t\t\t\texpression.argument,\n\t\t\t\texpression\n\t\t\t);\n\t\t\tif (result === true) return;\n\t\t\tif (expression.argument.type === \"ChainExpression\") {\n\t\t\t\tconst result = this.callHooksForExpression(\n\t\t\t\t\tthis.hooks.typeof,\n\t\t\t\t\texpression.argument.expression,\n\t\t\t\t\texpression\n\t\t\t\t);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkLeftRightExpression(expression) {\n\t\tthis.walkExpression(expression.left);\n\t\tthis.walkExpression(expression.right);\n\t}\n\n\twalkBinaryExpression(expression) {\n\t\tif (this.hooks.binaryExpression.call(expression) === undefined) {\n\t\t\tthis.walkLeftRightExpression(expression);\n\t\t}\n\t}\n\n\twalkLogicalExpression(expression) {\n\t\tconst result = this.hooks.expressionLogicalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkLeftRightExpression(expression);\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkExpression(expression.right);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkAssignmentExpression(expression) {\n\t\tif (expression.left.type === \"Identifier\") {\n\t\t\tconst renameIdentifier = this.getRenameIdentifier(expression.right);\n\t\t\tif (renameIdentifier) {\n\t\t\t\tif (\n\t\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.canRename,\n\t\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t\texpression.right\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\t// renaming \"a = b;\"\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.callHooksForInfo(\n\t\t\t\t\t\t\tthis.hooks.rename,\n\t\t\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t\t\texpression.right\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.setVariable(\n\t\t\t\t\t\t\texpression.left.name,\n\t\t\t\t\t\t\ttypeof renameIdentifier === \"string\"\n\t\t\t\t\t\t\t\t? this.getVariableInfo(renameIdentifier)\n\t\t\t\t\t\t\t\t: renameIdentifier\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.enterPattern(expression.left, (name, decl) => {\n\t\t\t\tif (!this.callHooksForName(this.hooks.assign, name, expression)) {\n\t\t\t\t\tthis.walkExpression(expression.left);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tif (expression.left.type.endsWith(\"Pattern\")) {\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.enterPattern(expression.left, (name, decl) => {\n\t\t\t\tif (!this.callHooksForName(this.hooks.assign, name, expression)) {\n\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.walkPattern(expression.left);\n\t\t} else if (expression.left.type === \"MemberExpression\") {\n\t\t\tconst exprName = this.getMemberExpressionInfo(\n\t\t\t\texpression.left,\n\t\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t\t);\n\t\t\tif (exprName) {\n\t\t\t\tif (\n\t\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.assignMemberChain,\n\t\t\t\t\t\texprName.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprName.getMembers()\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.walkExpression(expression.left);\n\t\t} else {\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.walkExpression(expression.left);\n\t\t}\n\t}\n\n\twalkConditionalExpression(expression) {\n\t\tconst result = this.hooks.expressionConditionalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(expression.test);\n\t\t\tthis.walkExpression(expression.consequent);\n\t\t\tif (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkExpression(expression.consequent);\n\t\t\t} else if (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkNewExpression(expression) {\n\t\tconst result = this.callHooksForExpression(\n\t\t\tthis.hooks.new,\n\t\t\texpression.callee,\n\t\t\texpression\n\t\t);\n\t\tif (result === true) return;\n\t\tthis.walkExpression(expression.callee);\n\t\tif (expression.arguments) {\n\t\t\tthis.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\twalkYieldExpression(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\twalkTemplateLiteral(expression) {\n\t\tif (expression.expressions) {\n\t\t\tthis.walkExpressions(expression.expressions);\n\t\t}\n\t}\n\n\twalkTaggedTemplateExpression(expression) {\n\t\tif (expression.tag) {\n\t\t\tthis.walkExpression(expression.tag);\n\t\t}\n\t\tif (expression.quasi && expression.quasi.expressions) {\n\t\t\tthis.walkExpressions(expression.quasi.expressions);\n\t\t}\n\t}\n\n\twalkClassExpression(expression) {\n\t\tthis.walkClass(expression);\n\t}\n\n\t/**\n\t * @param {ChainExpressionNode} expression expression\n\t */\n\twalkChainExpression(expression) {\n\t\tconst result = this.hooks.optionalChaining.call(expression);\n\n\t\tif (result === undefined) {\n\t\t\tif (expression.expression.type === \"CallExpression\") {\n\t\t\t\tthis.walkCallExpression(expression.expression);\n\t\t\t} else {\n\t\t\t\tthis.walkMemberExpression(expression.expression);\n\t\t\t}\n\t\t}\n\t}\n\n\t_walkIIFE(functionExpression, options, currentThis) {\n\t\tconst getVarInfo = argOrThis => {\n\t\t\tconst renameIdentifier = this.getRenameIdentifier(argOrThis);\n\t\t\tif (renameIdentifier) {\n\t\t\t\tif (\n\t\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.canRename,\n\t\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t\targOrThis\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.callHooksForInfo(\n\t\t\t\t\t\t\tthis.hooks.rename,\n\t\t\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t\t\targOrThis\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn typeof renameIdentifier === \"string\"\n\t\t\t\t\t\t\t? this.getVariableInfo(renameIdentifier)\n\t\t\t\t\t\t\t: renameIdentifier;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.walkExpression(argOrThis);\n\t\t};\n\t\tconst { params, type } = functionExpression;\n\t\tconst arrow = type === \"ArrowFunctionExpression\";\n\t\tconst renameThis = currentThis ? getVarInfo(currentThis) : null;\n\t\tconst varInfoForArgs = options.map(getVarInfo);\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = wasTopLevel && arrow ? \"arrow\" : false;\n\t\tconst scopeParams = params.filter(\n\t\t\t(identifier, idx) => !varInfoForArgs[idx]\n\t\t);\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (functionExpression.id) {\n\t\t\tscopeParams.push(functionExpression.id.name);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tif (renameThis && !arrow) {\n\t\t\t\tthis.setVariable(\"this\", renameThis);\n\t\t\t}\n\t\t\tfor (let i = 0; i < varInfoForArgs.length; i++) {\n\t\t\t\tconst varInfo = varInfoForArgs[i];\n\t\t\t\tif (!varInfo) continue;\n\t\t\t\tif (!params[i] || params[i].type !== \"Identifier\") continue;\n\t\t\t\tthis.setVariable(params[i].name, varInfo);\n\t\t\t}\n\t\t\tif (functionExpression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(functionExpression.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(functionExpression.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(functionExpression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(functionExpression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\twalkImportExpression(expression) {\n\t\tlet result = this.hooks.importCall.call(expression);\n\t\tif (result === true) return;\n\n\t\tthis.walkExpression(expression.source);\n\t}\n\n\twalkCallExpression(expression) {\n\t\tconst isSimpleFunction = fn => {\n\t\t\treturn fn.params.every(p => p.type === \"Identifier\");\n\t\t};\n\t\tif (\n\t\t\texpression.callee.type === \"MemberExpression\" &&\n\t\t\texpression.callee.object.type.endsWith(\"FunctionExpression\") &&\n\t\t\t!expression.callee.computed &&\n\t\t\t(expression.callee.property.name === \"call\" ||\n\t\t\t\texpression.callee.property.name === \"bind\") &&\n\t\t\texpression.arguments.length > 0 &&\n\t\t\tisSimpleFunction(expression.callee.object)\n\t\t) {\n\t\t\t// (function(…) { }.call/bind(?, …))\n\t\t\tthis._walkIIFE(\n\t\t\t\texpression.callee.object,\n\t\t\t\texpression.arguments.slice(1),\n\t\t\t\texpression.arguments[0]\n\t\t\t);\n\t\t} else if (\n\t\t\texpression.callee.type.endsWith(\"FunctionExpression\") &&\n\t\t\tisSimpleFunction(expression.callee)\n\t\t) {\n\t\t\t// (function(…) { }(…))\n\t\t\tthis._walkIIFE(expression.callee, expression.arguments, null);\n\t\t} else {\n\t\t\tif (expression.callee.type === \"MemberExpression\") {\n\t\t\t\tconst exprInfo = this.getMemberExpressionInfo(\n\t\t\t\t\texpression.callee,\n\t\t\t\t\tALLOWED_MEMBER_TYPES_CALL_EXPRESSION\n\t\t\t\t);\n\t\t\t\tif (exprInfo && exprInfo.type === \"call\") {\n\t\t\t\t\tconst result = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.callMemberChainOfCallMemberChain,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprInfo.getCalleeMembers(),\n\t\t\t\t\t\texprInfo.call,\n\t\t\t\t\t\texprInfo.getMembers()\n\t\t\t\t\t);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst callee = this.evaluateExpression(expression.callee);\n\t\t\tif (callee.isIdentifier()) {\n\t\t\t\tconst result1 = this.callHooksForInfo(\n\t\t\t\t\tthis.hooks.callMemberChain,\n\t\t\t\t\tcallee.rootInfo,\n\t\t\t\t\texpression,\n\t\t\t\t\tcallee.getMembers(),\n\t\t\t\t\tcallee.getMembersOptionals\n\t\t\t\t\t\t? callee.getMembersOptionals()\n\t\t\t\t\t\t: callee.getMembers().map(() => false)\n\t\t\t\t);\n\t\t\t\tif (result1 === true) return;\n\t\t\t\tconst result2 = this.callHooksForInfo(\n\t\t\t\t\tthis.hooks.call,\n\t\t\t\t\tcallee.identifier,\n\t\t\t\t\texpression\n\t\t\t\t);\n\t\t\t\tif (result2 === true) return;\n\t\t\t}\n\n\t\t\tif (expression.callee) {\n\t\t\t\tif (expression.callee.type === \"MemberExpression\") {\n\t\t\t\t\t// because of call context we need to walk the call context as expression\n\t\t\t\t\tthis.walkExpression(expression.callee.object);\n\t\t\t\t\tif (expression.callee.computed === true)\n\t\t\t\t\t\tthis.walkExpression(expression.callee.property);\n\t\t\t\t} else {\n\t\t\t\t\tthis.walkExpression(expression.callee);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (expression.arguments) this.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\twalkMemberExpression(expression) {\n\t\tconst exprInfo = this.getMemberExpressionInfo(\n\t\t\texpression,\n\t\t\tALLOWED_MEMBER_TYPES_ALL\n\t\t);\n\t\tif (exprInfo) {\n\t\t\tswitch (exprInfo.type) {\n\t\t\t\tcase \"expression\": {\n\t\t\t\t\tconst result1 = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.expression,\n\t\t\t\t\t\texprInfo.name,\n\t\t\t\t\t\texpression\n\t\t\t\t\t);\n\t\t\t\t\tif (result1 === true) return;\n\t\t\t\t\tconst members = exprInfo.getMembers();\n\t\t\t\t\tconst membersOptionals = exprInfo.getMembersOptionals();\n\t\t\t\t\tconst result2 = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.expressionMemberChain,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\tmembers,\n\t\t\t\t\t\tmembersOptionals\n\t\t\t\t\t);\n\t\t\t\t\tif (result2 === true) return;\n\t\t\t\t\tthis.walkMemberExpressionWithExpressionName(\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprInfo.name,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\tmembers.slice(),\n\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\t\t\t\tthis.hooks.unhandledExpressionMemberChain,\n\t\t\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\t\t\texpression,\n\t\t\t\t\t\t\t\tmembers\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcase \"call\": {\n\t\t\t\t\tconst result = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.memberChainOfCallMemberChain,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprInfo.getCalleeMembers(),\n\t\t\t\t\t\texprInfo.call,\n\t\t\t\t\t\texprInfo.getMembers()\n\t\t\t\t\t);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t\t// Fast skip over the member chain as we already called memberChainOfCallMemberChain\n\t\t\t\t\t// and call computed property are literals anyway\n\t\t\t\t\tthis.walkExpression(exprInfo.call);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.object);\n\t\tif (expression.computed === true) this.walkExpression(expression.property);\n\t}\n\n\twalkMemberExpressionWithExpressionName(\n\t\texpression,\n\t\tname,\n\t\trootInfo,\n\t\tmembers,\n\t\tonUnhandled\n\t) {\n\t\tif (expression.object.type === \"MemberExpression\") {\n\t\t\t// optimize the case where expression.object is a MemberExpression too.\n\t\t\t// we can keep info here when calling walkMemberExpression directly\n\t\t\tconst property =\n\t\t\t\texpression.property.name || `${expression.property.value}`;\n\t\t\tname = name.slice(0, -property.length - 1);\n\t\t\tmembers.pop();\n\t\t\tconst result = this.callHooksForInfo(\n\t\t\t\tthis.hooks.expression,\n\t\t\t\tname,\n\t\t\t\texpression.object\n\t\t\t);\n\t\t\tif (result === true) return;\n\t\t\tthis.walkMemberExpressionWithExpressionName(\n\t\t\t\texpression.object,\n\t\t\t\tname,\n\t\t\t\trootInfo,\n\t\t\t\tmembers,\n\t\t\t\tonUnhandled\n\t\t\t);\n\t\t} else if (!onUnhandled || !onUnhandled()) {\n\t\t\tthis.walkExpression(expression.object);\n\t\t}\n\t\tif (expression.computed === true) this.walkExpression(expression.property);\n\t}\n\n\twalkThisExpression(expression) {\n\t\tthis.callHooksForName(this.hooks.expression, \"this\", expression);\n\t}\n\n\twalkIdentifier(expression) {\n\t\tthis.callHooksForName(this.hooks.expression, expression.name, expression);\n\t}\n\n\t/**\n\t * @param {MetaPropertyNode} metaProperty meta property\n\t */\n\twalkMetaProperty(metaProperty) {\n\t\tthis.hooks.expression.for(getRootName(metaProperty)).call(metaProperty);\n\t}\n\n\tcallHooksForExpression(hookMap, expr, ...args) {\n\t\treturn this.callHooksForExpressionWithFallback(\n\t\t\thookMap,\n\t\t\texpr,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {MemberExpressionNode} expr expression info\n\t * @param {function(string, string | ScopeInfo | VariableInfo, function(): string[]): any} fallback callback when variable in not handled by hooks\n\t * @param {function(string): any} defined callback when variable is defined\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R} result of hook\n\t */\n\tcallHooksForExpressionWithFallback(\n\t\thookMap,\n\t\texpr,\n\t\tfallback,\n\t\tdefined,\n\t\t...args\n\t) {\n\t\tconst exprName = this.getMemberExpressionInfo(\n\t\t\texpr,\n\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t);\n\t\tif (exprName !== undefined) {\n\t\t\tconst members = exprName.getMembers();\n\t\t\treturn this.callHooksForInfoWithFallback(\n\t\t\t\thookMap,\n\t\t\t\tmembers.length === 0 ? exprName.rootInfo : exprName.name,\n\t\t\t\tfallback &&\n\t\t\t\t\t(name => fallback(name, exprName.rootInfo, exprName.getMembers)),\n\t\t\t\tdefined && (() => defined(exprName.name)),\n\t\t\t\t...args\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {string} name key in map\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R} result of hook\n\t */\n\tcallHooksForName(hookMap, name, ...args) {\n\t\treturn this.callHooksForNameWithFallback(\n\t\t\thookMap,\n\t\t\tname,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks that should be called\n\t * @param {ExportedVariableInfo} info variable info\n\t * @param  {AsArray<T>} args args for the hook\n\t * @returns {R} result of hook\n\t */\n\tcallHooksForInfo(hookMap, info, ...args) {\n\t\treturn this.callHooksForInfoWithFallback(\n\t\t\thookMap,\n\t\t\tinfo,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {ExportedVariableInfo} info variable info\n\t * @param {function(string): any} fallback callback when variable in not handled by hooks\n\t * @param {function(): any} defined callback when variable is defined\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R} result of hook\n\t */\n\tcallHooksForInfoWithFallback(hookMap, info, fallback, defined, ...args) {\n\t\tlet name;\n\t\tif (typeof info === \"string\") {\n\t\t\tname = info;\n\t\t} else {\n\t\t\tif (!(info instanceof VariableInfo)) {\n\t\t\t\tif (defined !== undefined) {\n\t\t\t\t\treturn defined();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet tagInfo = info.tagInfo;\n\t\t\twhile (tagInfo !== undefined) {\n\t\t\t\tconst hook = hookMap.get(tagInfo.tag);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tthis.currentTagData = tagInfo.data;\n\t\t\t\t\tconst result = hook.call(...args);\n\t\t\t\t\tthis.currentTagData = undefined;\n\t\t\t\t\tif (result !== undefined) return result;\n\t\t\t\t}\n\t\t\t\ttagInfo = tagInfo.next;\n\t\t\t}\n\t\t\tif (info.freeName === true) {\n\t\t\t\tif (defined !== undefined) {\n\t\t\t\t\treturn defined();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tname = info.freeName;\n\t\t}\n\t\tconst hook = hookMap.get(name);\n\t\tif (hook !== undefined) {\n\t\t\tconst result = hook.call(...args);\n\t\t\tif (result !== undefined) return result;\n\t\t}\n\t\tif (fallback !== undefined) {\n\t\t\treturn fallback(name);\n\t\t}\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {string} name key in map\n\t * @param {function(string): any} fallback callback when variable in not handled by hooks\n\t * @param {function(): any} defined callback when variable is defined\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R} result of hook\n\t */\n\tcallHooksForNameWithFallback(hookMap, name, fallback, defined, ...args) {\n\t\treturn this.callHooksForInfoWithFallback(\n\t\t\thookMap,\n\t\t\tthis.getVariableInfo(name),\n\t\t\tfallback,\n\t\t\tdefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated\n\t * @param {any} params scope params\n\t * @param {function(): void} fn inner function\n\t * @returns {void}\n\t */\n\tinScope(params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild()\n\t\t};\n\n\t\tthis.undefineVariable(\"this\");\n\n\t\tthis.enterPatterns(params, (ident, pattern) => {\n\t\t\tthis.defineVariable(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tinFunctionScope(hasThis, params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild()\n\t\t};\n\n\t\tif (hasThis) {\n\t\t\tthis.undefineVariable(\"this\");\n\t\t}\n\n\t\tthis.enterPatterns(params, (ident, pattern) => {\n\t\t\tthis.defineVariable(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tinBlockScope(fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: oldScope.inTry,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild()\n\t\t};\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tdetectMode(statements) {\n\t\tconst isLiteral =\n\t\t\tstatements.length >= 1 &&\n\t\t\tstatements[0].type === \"ExpressionStatement\" &&\n\t\t\tstatements[0].expression.type === \"Literal\";\n\t\tif (isLiteral && statements[0].expression.value === \"use strict\") {\n\t\t\tthis.scope.isStrict = true;\n\t\t}\n\t\tif (isLiteral && statements[0].expression.value === \"use asm\") {\n\t\t\tthis.scope.isAsmJs = true;\n\t\t}\n\t}\n\n\tenterPatterns(patterns, onIdent) {\n\t\tfor (const pattern of patterns) {\n\t\t\tif (typeof pattern !== \"string\") {\n\t\t\t\tthis.enterPattern(pattern, onIdent);\n\t\t\t} else if (pattern) {\n\t\t\t\tonIdent(pattern);\n\t\t\t}\n\t\t}\n\t}\n\n\tenterPattern(pattern, onIdent) {\n\t\tif (!pattern) return;\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.enterArrayPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.enterAssignmentPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.enterIdentifier(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.enterObjectPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.enterRestElement(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Property\":\n\t\t\t\tif (pattern.shorthand && pattern.value.type === \"Identifier\") {\n\t\t\t\t\tthis.scope.inShorthand = pattern.value.name;\n\t\t\t\t\tthis.enterIdentifier(pattern.value, onIdent);\n\t\t\t\t\tthis.scope.inShorthand = false;\n\t\t\t\t} else {\n\t\t\t\t\tthis.enterPattern(pattern.value, onIdent);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tenterIdentifier(pattern, onIdent) {\n\t\tif (!this.callHooksForName(this.hooks.pattern, pattern.name, pattern)) {\n\t\t\tonIdent(pattern.name, pattern);\n\t\t}\n\t}\n\n\tenterObjectPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = pattern.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = pattern.properties[propIndex];\n\t\t\tthis.enterPattern(prop, onIdent);\n\t\t}\n\t}\n\n\tenterArrayPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet elementIndex = 0, len = pattern.elements.length;\n\t\t\telementIndex < len;\n\t\t\telementIndex++\n\t\t) {\n\t\t\tconst element = pattern.elements[elementIndex];\n\t\t\tthis.enterPattern(element, onIdent);\n\t\t}\n\t}\n\n\tenterRestElement(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.argument, onIdent);\n\t}\n\n\tenterAssignmentPattern(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.left, onIdent);\n\t}\n\n\t/**\n\t * @param {ExpressionNode} expression expression node\n\t * @returns {BasicEvaluatedExpression} evaluation result\n\t */\n\tevaluateExpression(expression) {\n\t\ttry {\n\t\t\tconst hook = this.hooks.evaluate.get(expression.type);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result !== undefined && result !== null) {\n\t\t\t\t\tresult.setExpression(expression);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.warn(e);\n\t\t\t// ignore error\n\t\t}\n\t\treturn new BasicEvaluatedExpression()\n\t\t\t.setRange(expression.range)\n\t\t\t.setExpression(expression);\n\t}\n\n\tparseString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tthis.parseString(expression.left) +\n\t\t\t\t\t\tthis.parseString(expression.right)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"Literal\":\n\t\t\t\treturn expression.value + \"\";\n\t\t}\n\t\tthrow new Error(\n\t\t\texpression.type + \" is not supported as parameter for require\"\n\t\t);\n\t}\n\n\tparseCalculatedString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\tconst left = this.parseCalculatedString(expression.left);\n\t\t\t\t\tconst right = this.parseCalculatedString(expression.right);\n\t\t\t\t\tif (left.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: left.range,\n\t\t\t\t\t\t\tvalue: left.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (right.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [\n\t\t\t\t\t\t\t\tleft.range[0],\n\t\t\t\t\t\t\t\tright.range ? right.range[1] : left.range[1]\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [left.range[0], right.range[1]],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: false,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\": {\n\t\t\t\tconst consequent = this.parseCalculatedString(expression.consequent);\n\t\t\t\tconst alternate = this.parseCalculatedString(expression.alternate);\n\t\t\t\tconst items = [];\n\t\t\t\tif (consequent.conditional) {\n\t\t\t\t\titems.push(...consequent.conditional);\n\t\t\t\t} else if (!consequent.code) {\n\t\t\t\t\titems.push(consequent);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (alternate.conditional) {\n\t\t\t\t\titems.push(...alternate.conditional);\n\t\t\t\t} else if (!alternate.code) {\n\t\t\t\t\titems.push(alternate);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\trange: undefined,\n\t\t\t\t\tvalue: \"\",\n\t\t\t\t\tcode: true,\n\t\t\t\t\tconditional: items\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase \"Literal\":\n\t\t\t\treturn {\n\t\t\t\t\trange: expression.range,\n\t\t\t\t\tvalue: expression.value + \"\",\n\t\t\t\t\tcode: false,\n\t\t\t\t\tconditional: false\n\t\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\trange: undefined,\n\t\t\tvalue: \"\",\n\t\t\tcode: true,\n\t\t\tconditional: false\n\t\t};\n\t}\n\n\t/**\n\t * @param {string | Buffer | PreparsedAst} source the source to parse\n\t * @param {ParserState} state the parser state\n\t * @returns {ParserState} the parser state\n\t */\n\tparse(source, state) {\n\t\tlet ast;\n\t\tlet comments;\n\t\tconst semicolons = new Set();\n\t\tif (source === null) {\n\t\t\tthrow new Error(\"source must not be null\");\n\t\t}\n\t\tif (Buffer.isBuffer(source)) {\n\t\t\tsource = source.toString(\"utf-8\");\n\t\t}\n\t\tif (typeof source === \"object\") {\n\t\t\tast = /** @type {ProgramNode} */ (source);\n\t\t\tcomments = source.comments;\n\t\t} else {\n\t\t\tcomments = [];\n\t\t\tast = JavascriptParser._parse(source, {\n\t\t\t\tsourceType: this.sourceType,\n\t\t\t\tonComment: comments,\n\t\t\t\tonInsertedSemicolon: pos => semicolons.add(pos)\n\t\t\t});\n\t\t}\n\n\t\tconst oldScope = this.scope;\n\t\tconst oldState = this.state;\n\t\tconst oldComments = this.comments;\n\t\tconst oldSemicolons = this.semicolons;\n\t\tconst oldStatementPath = this.statementPath;\n\t\tconst oldPrevStatement = this.prevStatement;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: true,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: false,\n\t\t\tisAsmJs: false,\n\t\t\tdefinitions: new StackedMap()\n\t\t};\n\t\t/** @type {ParserState} */\n\t\tthis.state = state;\n\t\tthis.comments = comments;\n\t\tthis.semicolons = semicolons;\n\t\tthis.statementPath = [];\n\t\tthis.prevStatement = undefined;\n\t\tif (this.hooks.program.call(ast, comments) === undefined) {\n\t\t\tthis.detectMode(ast.body);\n\t\t\tthis.preWalkStatements(ast.body);\n\t\t\tthis.prevStatement = undefined;\n\t\t\tthis.blockPreWalkStatements(ast.body);\n\t\t\tthis.prevStatement = undefined;\n\t\t\tthis.walkStatements(ast.body);\n\t\t}\n\t\tthis.hooks.finish.call(ast, comments);\n\t\tthis.scope = oldScope;\n\t\t/** @type {ParserState} */\n\t\tthis.state = oldState;\n\t\tthis.comments = oldComments;\n\t\tthis.semicolons = oldSemicolons;\n\t\tthis.statementPath = oldStatementPath;\n\t\tthis.prevStatement = oldPrevStatement;\n\t\treturn state;\n\t}\n\n\t/**\n\t * @param {string} source source code\n\t * @returns {BasicEvaluatedExpression} evaluation result\n\t */\n\tevaluate(source) {\n\t\tconst ast = JavascriptParser._parse(\"(\" + source + \")\", {\n\t\t\tsourceType: this.sourceType,\n\t\t\tlocations: false\n\t\t});\n\t\tif (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n\t\t\tthrow new Error(\"evaluate: Source is not a expression\");\n\t\t}\n\t\treturn this.evaluateExpression(ast.body[0].expression);\n\t}\n\n\t/**\n\t * @param {ExpressionNode | DeclarationNode | PrivateIdentifierNode | null | undefined} expr an expression\n\t * @param {number} commentsStartPos source position from which annotation comments are checked\n\t * @returns {boolean} true, when the expression is pure\n\t */\n\tisPure(expr, commentsStartPos) {\n\t\tif (!expr) return true;\n\t\tconst result = this.hooks.isPure\n\t\t\t.for(expr.type)\n\t\t\t.call(expr, commentsStartPos);\n\t\tif (typeof result === \"boolean\") return result;\n\t\tswitch (expr.type) {\n\t\t\tcase \"ClassDeclaration\":\n\t\t\tcase \"ClassExpression\": {\n\t\t\t\tif (expr.body.type !== \"ClassBody\") return false;\n\t\t\t\tif (expr.superClass && !this.isPure(expr.superClass, expr.range[0])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tconst items =\n\t\t\t\t\t/** @type {(MethodDefinitionNode | PropertyDefinitionNode)[]} */ (\n\t\t\t\t\t\texpr.body.body\n\t\t\t\t\t);\n\t\t\t\treturn items.every(\n\t\t\t\t\titem =>\n\t\t\t\t\t\t(!item.computed ||\n\t\t\t\t\t\t\t!item.key ||\n\t\t\t\t\t\t\tthis.isPure(item.key, item.range[0])) &&\n\t\t\t\t\t\t(!item.static ||\n\t\t\t\t\t\t\t!item.value ||\n\t\t\t\t\t\t\tthis.isPure(\n\t\t\t\t\t\t\t\titem.value,\n\t\t\t\t\t\t\t\titem.key ? item.key.range[1] : item.range[0]\n\t\t\t\t\t\t\t))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\tcase \"FunctionExpression\":\n\t\t\tcase \"ArrowFunctionExpression\":\n\t\t\tcase \"Literal\":\n\t\t\tcase \"PrivateIdentifier\":\n\t\t\t\treturn true;\n\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\treturn expr.declarations.every(decl =>\n\t\t\t\t\tthis.isPure(decl.init, decl.range[0])\n\t\t\t\t);\n\n\t\t\tcase \"ConditionalExpression\":\n\t\t\t\treturn (\n\t\t\t\t\tthis.isPure(expr.test, commentsStartPos) &&\n\t\t\t\t\tthis.isPure(expr.consequent, expr.test.range[1]) &&\n\t\t\t\t\tthis.isPure(expr.alternate, expr.consequent.range[1])\n\t\t\t\t);\n\n\t\t\tcase \"SequenceExpression\":\n\t\t\t\treturn expr.expressions.every(expr => {\n\t\t\t\t\tconst pureFlag = this.isPure(expr, commentsStartPos);\n\t\t\t\t\tcommentsStartPos = expr.range[1];\n\t\t\t\t\treturn pureFlag;\n\t\t\t\t});\n\n\t\t\tcase \"CallExpression\": {\n\t\t\t\tconst pureFlag =\n\t\t\t\t\texpr.range[0] - commentsStartPos > 12 &&\n\t\t\t\t\tthis.getComments([commentsStartPos, expr.range[0]]).some(\n\t\t\t\t\t\tcomment =>\n\t\t\t\t\t\t\tcomment.type === \"Block\" &&\n\t\t\t\t\t\t\t/^\\s*(#|@)__PURE__\\s*$/.test(comment.value)\n\t\t\t\t\t);\n\t\t\t\tif (!pureFlag) return false;\n\t\t\t\tcommentsStartPos = expr.callee.range[1];\n\t\t\t\treturn expr.arguments.every(arg => {\n\t\t\t\t\tif (arg.type === \"SpreadElement\") return false;\n\t\t\t\t\tconst pureFlag = this.isPure(arg, commentsStartPos);\n\t\t\t\t\tcommentsStartPos = arg.range[1];\n\t\t\t\t\treturn pureFlag;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tconst evaluated = this.evaluateExpression(expr);\n\t\treturn !evaluated.couldHaveSideEffects();\n\t}\n\n\tgetComments(range) {\n\t\tconst [rangeStart, rangeEnd] = range;\n\t\tconst compare = (comment, needle) => comment.range[0] - needle;\n\t\tlet idx = binarySearchBounds.ge(this.comments, rangeStart, compare);\n\t\tlet commentsInRange = [];\n\t\twhile (this.comments[idx] && this.comments[idx].range[1] <= rangeEnd) {\n\t\t\tcommentsInRange.push(this.comments[idx]);\n\t\t\tidx++;\n\t\t}\n\n\t\treturn commentsInRange;\n\t}\n\n\t/**\n\t * @param {number} pos source code position\n\t * @returns {boolean} true when a semicolon has been inserted before this position, false if not\n\t */\n\tisAsiPosition(pos) {\n\t\tconst currentStatement = this.statementPath[this.statementPath.length - 1];\n\t\tif (currentStatement === undefined) throw new Error(\"Not in statement\");\n\t\treturn (\n\t\t\t// Either asking directly for the end position of the current statement\n\t\t\t(currentStatement.range[1] === pos && this.semicolons.has(pos)) ||\n\t\t\t// Or asking for the start position of the current statement,\n\t\t\t// here we have to check multiple things\n\t\t\t(currentStatement.range[0] === pos &&\n\t\t\t\t// is there a previous statement which might be relevant?\n\t\t\t\tthis.prevStatement !== undefined &&\n\t\t\t\t// is the end position of the previous statement an ASI position?\n\t\t\t\tthis.semicolons.has(this.prevStatement.range[1]))\n\t\t);\n\t}\n\n\t/**\n\t * @param {number} pos source code position\n\t * @returns {void}\n\t */\n\tunsetAsiPosition(pos) {\n\t\tthis.semicolons.delete(pos);\n\t}\n\n\tisStatementLevelExpression(expr) {\n\t\tconst currentStatement = this.statementPath[this.statementPath.length - 1];\n\t\treturn (\n\t\t\texpr === currentStatement ||\n\t\t\t(currentStatement.type === \"ExpressionStatement\" &&\n\t\t\t\tcurrentStatement.expression === expr)\n\t\t);\n\t}\n\n\tgetTagData(name, tag) {\n\t\tconst info = this.scope.definitions.get(name);\n\t\tif (info instanceof VariableInfo) {\n\t\t\tlet tagInfo = info.tagInfo;\n\t\t\twhile (tagInfo !== undefined) {\n\t\t\t\tif (tagInfo.tag === tag) return tagInfo.data;\n\t\t\t\ttagInfo = tagInfo.next;\n\t\t\t}\n\t\t}\n\t}\n\n\ttagVariable(name, tag, data) {\n\t\tconst oldInfo = this.scope.definitions.get(name);\n\t\t/** @type {VariableInfo} */\n\t\tlet newInfo;\n\t\tif (oldInfo === undefined) {\n\t\t\tnewInfo = new VariableInfo(this.scope, name, {\n\t\t\t\ttag,\n\t\t\t\tdata,\n\t\t\t\tnext: undefined\n\t\t\t});\n\t\t} else if (oldInfo instanceof VariableInfo) {\n\t\t\tnewInfo = new VariableInfo(oldInfo.declaredScope, oldInfo.freeName, {\n\t\t\t\ttag,\n\t\t\t\tdata,\n\t\t\t\tnext: oldInfo.tagInfo\n\t\t\t});\n\t\t} else {\n\t\t\tnewInfo = new VariableInfo(oldInfo, true, {\n\t\t\t\ttag,\n\t\t\t\tdata,\n\t\t\t\tnext: undefined\n\t\t\t});\n\t\t}\n\t\tthis.scope.definitions.set(name, newInfo);\n\t}\n\n\tdefineVariable(name) {\n\t\tconst oldInfo = this.scope.definitions.get(name);\n\t\t// Don't redefine variable in same scope to keep existing tags\n\t\tif (oldInfo instanceof VariableInfo && oldInfo.declaredScope === this.scope)\n\t\t\treturn;\n\t\tthis.scope.definitions.set(name, this.scope);\n\t}\n\n\tundefineVariable(name) {\n\t\tthis.scope.definitions.delete(name);\n\t}\n\n\tisVariableDefined(name) {\n\t\tconst info = this.scope.definitions.get(name);\n\t\tif (info === undefined) return false;\n\t\tif (info instanceof VariableInfo) {\n\t\t\treturn info.freeName === true;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {string} name variable name\n\t * @returns {ExportedVariableInfo} info for this variable\n\t */\n\tgetVariableInfo(name) {\n\t\tconst value = this.scope.definitions.get(name);\n\t\tif (value === undefined) {\n\t\t\treturn name;\n\t\t} else {\n\t\t\treturn value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} name variable name\n\t * @param {ExportedVariableInfo} variableInfo new info for this variable\n\t * @returns {void}\n\t */\n\tsetVariable(name, variableInfo) {\n\t\tif (typeof variableInfo === \"string\") {\n\t\t\tif (variableInfo === name) {\n\t\t\t\tthis.scope.definitions.delete(name);\n\t\t\t} else {\n\t\t\t\tthis.scope.definitions.set(\n\t\t\t\t\tname,\n\t\t\t\t\tnew VariableInfo(this.scope, variableInfo, undefined)\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.scope.definitions.set(name, variableInfo);\n\t\t}\n\t}\n\n\tevaluatedVariable(tagInfo) {\n\t\treturn new VariableInfo(this.scope, undefined, tagInfo);\n\t}\n\n\tparseCommentOptions(range) {\n\t\tconst comments = this.getComments(range);\n\t\tif (comments.length === 0) {\n\t\t\treturn EMPTY_COMMENT_OPTIONS;\n\t\t}\n\t\tlet options = {};\n\t\tlet errors = [];\n\t\tfor (const comment of comments) {\n\t\t\tconst { value } = comment;\n\t\t\tif (value && webpackCommentRegExp.test(value)) {\n\t\t\t\t// try compile only if webpack options comment is present\n\t\t\t\ttry {\n\t\t\t\t\tconst val = vm.runInNewContext(`(function(){return {${value}};})()`);\n\t\t\t\t\tObject.assign(options, val);\n\t\t\t\t} catch (e) {\n\t\t\t\t\te.comment = comment;\n\t\t\t\t\terrors.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { options, errors };\n\t}\n\n\t/**\n\t * @param {MemberExpressionNode} expression a member expression\n\t * @returns {{ members: string[], object: ExpressionNode | SuperNode, membersOptionals: boolean[] }} member names (reverse order) and remaining object\n\t */\n\textractMemberExpressionChain(expression) {\n\t\t/** @type {AnyNode} */\n\t\tlet expr = expression;\n\t\tconst members = [];\n\t\tconst membersOptionals = [];\n\t\twhile (expr.type === \"MemberExpression\") {\n\t\t\tif (expr.computed) {\n\t\t\t\tif (expr.property.type !== \"Literal\") break;\n\t\t\t\tmembers.push(`${expr.property.value}`);\n\t\t\t} else {\n\t\t\t\tif (expr.property.type !== \"Identifier\") break;\n\t\t\t\tmembers.push(expr.property.name);\n\t\t\t}\n\t\t\tmembersOptionals.push(expr.optional);\n\t\t\texpr = expr.object;\n\t\t}\n\n\t\treturn {\n\t\t\tmembers,\n\t\t\tmembersOptionals,\n\t\t\tobject: expr\n\t\t};\n\t}\n\n\t/**\n\t * @param {string} varName variable name\n\t * @returns {{name: string, info: VariableInfo | string}} name of the free variable and variable info for that\n\t */\n\tgetFreeInfoFromVariable(varName) {\n\t\tconst info = this.getVariableInfo(varName);\n\t\tlet name;\n\t\tif (info instanceof VariableInfo) {\n\t\t\tname = info.freeName;\n\t\t\tif (typeof name !== \"string\") return undefined;\n\t\t} else if (typeof info !== \"string\") {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tname = info;\n\t\t}\n\t\treturn { info, name };\n\t}\n\n\t/** @typedef {{ type: \"call\", call: CallExpressionNode, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () => string[], name: string, getMembers: () => string[], getMembersOptionals: () => boolean[]}} CallExpressionInfo */\n\t/** @typedef {{ type: \"expression\", rootInfo: string | VariableInfo, name: string, getMembers: () => string[], getMembersOptionals: () => boolean[]}} ExpressionExpressionInfo */\n\n\t/**\n\t * @param {MemberExpressionNode} expression a member expression\n\t * @param {number} allowedTypes which types should be returned, presented in bit mask\n\t * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info\n\t */\n\tgetMemberExpressionInfo(expression, allowedTypes) {\n\t\tconst { object, members, membersOptionals } =\n\t\t\tthis.extractMemberExpressionChain(expression);\n\t\tswitch (object.type) {\n\t\t\tcase \"CallExpression\": {\n\t\t\t\tif ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0)\n\t\t\t\t\treturn undefined;\n\t\t\t\tlet callee = object.callee;\n\t\t\t\tlet rootMembers = EMPTY_ARRAY;\n\t\t\t\tif (callee.type === \"MemberExpression\") {\n\t\t\t\t\t({ object: callee, members: rootMembers } =\n\t\t\t\t\t\tthis.extractMemberExpressionChain(callee));\n\t\t\t\t}\n\t\t\t\tconst rootName = getRootName(callee);\n\t\t\t\tif (!rootName) return undefined;\n\t\t\t\tconst result = this.getFreeInfoFromVariable(rootName);\n\t\t\t\tif (!result) return undefined;\n\t\t\t\tconst { info: rootInfo, name: resolvedRoot } = result;\n\t\t\t\tconst calleeName = objectAndMembersToName(resolvedRoot, rootMembers);\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"call\",\n\t\t\t\t\tcall: object,\n\t\t\t\t\tcalleeName,\n\t\t\t\t\trootInfo,\n\t\t\t\t\tgetCalleeMembers: memoize(() => rootMembers.reverse()),\n\t\t\t\t\tname: objectAndMembersToName(`${calleeName}()`, members),\n\t\t\t\t\tgetMembers: memoize(() => members.reverse()),\n\t\t\t\t\tgetMembersOptionals: memoize(() => membersOptionals.reverse())\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase \"Identifier\":\n\t\t\tcase \"MetaProperty\":\n\t\t\tcase \"ThisExpression\": {\n\t\t\t\tif ((allowedTypes & ALLOWED_MEMBER_TYPES_EXPRESSION) === 0)\n\t\t\t\t\treturn undefined;\n\t\t\t\tconst rootName = getRootName(object);\n\t\t\t\tif (!rootName) return undefined;\n\n\t\t\t\tconst result = this.getFreeInfoFromVariable(rootName);\n\t\t\t\tif (!result) return undefined;\n\t\t\t\tconst { info: rootInfo, name: resolvedRoot } = result;\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"expression\",\n\t\t\t\t\tname: objectAndMembersToName(resolvedRoot, members),\n\t\t\t\t\trootInfo,\n\t\t\t\t\tgetMembers: memoize(() => members.reverse()),\n\t\t\t\t\tgetMembersOptionals: memoize(() => membersOptionals.reverse())\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {MemberExpressionNode} expression an expression\n\t * @returns {{ name: string, rootInfo: ExportedVariableInfo, getMembers: () => string[]}} name info\n\t */\n\tgetNameForExpression(expression) {\n\t\treturn this.getMemberExpressionInfo(\n\t\t\texpression,\n\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} code source code\n\t * @param {ParseOptions} options parsing options\n\t * @returns {ProgramNode} parsed ast\n\t */\n\tstatic _parse(code, options) {\n\t\tconst type = options ? options.sourceType : \"module\";\n\t\t/** @type {AcornOptions} */\n\t\tconst parserOptions = {\n\t\t\t...defaultParserOptions,\n\t\t\tallowReturnOutsideFunction: type === \"script\",\n\t\t\t...options,\n\t\t\tsourceType: type === \"auto\" ? \"module\" : type\n\t\t};\n\n\t\t/** @type {AnyNode} */\n\t\tlet ast;\n\t\tlet error;\n\t\tlet threw = false;\n\t\ttry {\n\t\t\tast = /** @type {AnyNode} */ (parser.parse(code, parserOptions));\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t\tthrew = true;\n\t\t}\n\n\t\tif (threw && type === \"auto\") {\n\t\t\tparserOptions.sourceType = \"script\";\n\t\t\tif (!(\"allowReturnOutsideFunction\" in options)) {\n\t\t\t\tparserOptions.allowReturnOutsideFunction = true;\n\t\t\t}\n\t\t\tif (Array.isArray(parserOptions.onComment)) {\n\t\t\t\tparserOptions.onComment.length = 0;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tast = /** @type {AnyNode} */ (parser.parse(code, parserOptions));\n\t\t\t\tthrew = false;\n\t\t\t} catch (e) {\n\t\t\t\t// we use the error from first parse try\n\t\t\t\t// so nothing to do here\n\t\t\t}\n\t\t}\n\n\t\tif (threw) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn /** @type {ProgramNode} */ (ast);\n\t}\n}\n\nmodule.exports = JavascriptParser;\nmodule.exports.ALLOWED_MEMBER_TYPES_ALL = ALLOWED_MEMBER_TYPES_ALL;\nmodule.exports.ALLOWED_MEMBER_TYPES_EXPRESSION =\n\tALLOWED_MEMBER_TYPES_EXPRESSION;\nmodule.exports.ALLOWED_MEMBER_TYPES_CALL_EXPRESSION =\n\tALLOWED_MEMBER_TYPES_CALL_EXPRESSION;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}