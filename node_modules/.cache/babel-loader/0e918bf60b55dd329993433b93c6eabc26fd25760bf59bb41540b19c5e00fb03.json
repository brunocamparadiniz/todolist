{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar NO_MARKER = 0;\nvar IN_PROGRESS_MARKER = 1;\nvar DONE_MARKER = 2;\nvar DONE_MAYBE_ROOT_CYCLE_MARKER = 3;\nvar DONE_AND_ROOT_MARKER = 4;\n\n/**\n * @template T\n */\nvar Node = /*#__PURE__*/_createClass(\n/**\n * @param {T} item the value of the node\n */\nfunction Node(item) {\n  _classCallCheck(this, Node);\n  this.item = item;\n  /** @type {Set<Node<T>>} */\n  this.dependencies = new Set();\n  this.marker = NO_MARKER;\n  /** @type {Cycle<T> | undefined} */\n  this.cycle = undefined;\n  this.incoming = 0;\n});\n/**\n * @template T\n */\nvar Cycle = /*#__PURE__*/_createClass(function Cycle() {\n  _classCallCheck(this, Cycle);\n  /** @type {Set<Node<T>>} */\n  this.nodes = new Set();\n});\n/**\n * @template T\n * @typedef {Object} StackEntry\n * @property {Node<T>} node\n * @property {Node<T>[]} openEdges\n */\n/**\n * @template T\n * @param {Iterable<T>} items list of items\n * @param {function(T): Iterable<T>} getDependencies function to get dependencies of an item (items that are not in list are ignored)\n * @returns {Iterable<T>} graph roots of the items\n */\nmodule.exports = function (items, getDependencies) {\n  /** @type {Map<T, Node<T>>} */\n  var itemToNode = new Map();\n  var _iterator = _createForOfIteratorHelper(items),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      var node = new Node(item);\n      itemToNode.set(item, node);\n    }\n\n    // early exit when there is only a single item\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  if (itemToNode.size <= 1) return items;\n\n  // grab all the dependencies\n  var _iterator2 = _createForOfIteratorHelper(itemToNode.values()),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _node = _step2.value;\n      var _iterator5 = _createForOfIteratorHelper(getDependencies(_node.item)),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var dep = _step5.value;\n          var depNode = itemToNode.get(dep);\n          if (depNode !== undefined) {\n            _node.dependencies.add(depNode);\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n\n    // Set of current root modules\n    // items will be removed if a new reference to it has been found\n    /** @type {Set<Node<T>>} */\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  var roots = new Set();\n\n  // Set of current cycles without references to it\n  // cycles will be removed if a new reference to it has been found\n  // that is not part of the cycle\n  /** @type {Set<Cycle<T>>} */\n  var rootCycles = new Set();\n\n  // For all non-marked nodes\n  var _iterator3 = _createForOfIteratorHelper(itemToNode.values()),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var selectedNode = _step3.value;\n      if (selectedNode.marker === NO_MARKER) {\n        // deep-walk all referenced modules\n        // in a non-recursive way\n\n        // start by entering the selected node\n        selectedNode.marker = IN_PROGRESS_MARKER;\n\n        // keep a stack to avoid recursive walk\n        /** @type {StackEntry<T>[]} */\n        var stack = [{\n          node: selectedNode,\n          openEdges: Array.from(selectedNode.dependencies)\n        }];\n\n        // process the top item until stack is empty\n        while (stack.length > 0) {\n          var topOfStack = stack[stack.length - 1];\n\n          // Are there still edges unprocessed in the current node?\n          if (topOfStack.openEdges.length > 0) {\n            // Process one dependency\n            var dependency = topOfStack.openEdges.pop();\n            switch (dependency.marker) {\n              case NO_MARKER:\n                // dependency has not be visited yet\n                // mark it as in-progress and recurse\n                stack.push({\n                  node: dependency,\n                  openEdges: Array.from(dependency.dependencies)\n                });\n                dependency.marker = IN_PROGRESS_MARKER;\n                break;\n              case IN_PROGRESS_MARKER:\n                {\n                  // It's a in-progress cycle\n                  var _cycle = dependency.cycle;\n                  if (!_cycle) {\n                    _cycle = new Cycle();\n                    _cycle.nodes.add(dependency);\n                    dependency.cycle = _cycle;\n                  }\n                  // set cycle property for each node in the cycle\n                  // if nodes are already part of a cycle\n                  // we merge the cycles to a shared cycle\n                  for (var i = stack.length - 1; stack[i].node !== dependency; i--) {\n                    var _node2 = stack[i].node;\n                    if (_node2.cycle) {\n                      if (_node2.cycle !== _cycle) {\n                        // merge cycles\n                        var _iterator6 = _createForOfIteratorHelper(_node2.cycle.nodes),\n                          _step6;\n                        try {\n                          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                            var cycleNode = _step6.value;\n                            cycleNode.cycle = _cycle;\n                            _cycle.nodes.add(cycleNode);\n                          }\n                        } catch (err) {\n                          _iterator6.e(err);\n                        } finally {\n                          _iterator6.f();\n                        }\n                      }\n                    } else {\n                      _node2.cycle = _cycle;\n                      _cycle.nodes.add(_node2);\n                    }\n                  }\n                  // don't recurse into dependencies\n                  // these are already on the stack\n                  break;\n                }\n              case DONE_AND_ROOT_MARKER:\n                // This node has be visited yet and is currently a root node\n                // But as this is a new reference to the node\n                // it's not really a root\n                // so we have to convert it to a normal node\n                dependency.marker = DONE_MARKER;\n                roots.delete(dependency);\n                break;\n              case DONE_MAYBE_ROOT_CYCLE_MARKER:\n                // This node has be visited yet and\n                // is maybe currently part of a completed root cycle\n                // we found a new reference to the cycle\n                // so it's not really a root cycle\n                // remove the cycle from the root cycles\n                // and convert it to a normal node\n                rootCycles.delete(dependency.cycle);\n                dependency.marker = DONE_MARKER;\n                break;\n              // DONE_MARKER: nothing to do, don't recurse into dependencies\n            }\n          } else {\n            // All dependencies of the current node has been visited\n            // we leave the node\n            stack.pop();\n            topOfStack.node.marker = DONE_MARKER;\n          }\n        }\n        var cycle = selectedNode.cycle;\n        if (cycle) {\n          var _iterator7 = _createForOfIteratorHelper(cycle.nodes),\n            _step7;\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var _node3 = _step7.value;\n              _node3.marker = DONE_MAYBE_ROOT_CYCLE_MARKER;\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n          rootCycles.add(cycle);\n        } else {\n          selectedNode.marker = DONE_AND_ROOT_MARKER;\n          roots.add(selectedNode);\n        }\n      }\n    }\n\n    // Extract roots from root cycles\n    // We take the nodes with most incoming edges\n    // inside of the cycle\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  var _iterator4 = _createForOfIteratorHelper(rootCycles),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _cycle2 = _step4.value;\n      var max = 0;\n      /** @type {Set<Node<T>>} */\n      var cycleRoots = new Set();\n      var nodes = _cycle2.nodes;\n      var _iterator8 = _createForOfIteratorHelper(nodes),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _node4 = _step8.value;\n          var _iterator10 = _createForOfIteratorHelper(_node4.dependencies),\n            _step10;\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var _dep = _step10.value;\n              if (nodes.has(_dep)) {\n                _dep.incoming++;\n                if (_dep.incoming < max) continue;\n                if (_dep.incoming > max) {\n                  cycleRoots.clear();\n                  max = _dep.incoming;\n                }\n                cycleRoots.add(_dep);\n              }\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      var _iterator9 = _createForOfIteratorHelper(cycleRoots),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var cycleRoot = _step9.value;\n          roots.add(cycleRoot);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n\n    // When roots were found, return them\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  if (roots.size > 0) {\n    return Array.from(roots, function (r) {\n      return r.item;\n    });\n  } else {\n    throw new Error(\"Implementation of findGraphRoots is broken\");\n  }\n};","map":{"version":3,"names":["NO_MARKER","IN_PROGRESS_MARKER","DONE_MARKER","DONE_MAYBE_ROOT_CYCLE_MARKER","DONE_AND_ROOT_MARKER","Node","item","dependencies","Set","marker","cycle","undefined","incoming","Cycle","nodes","module","exports","items","getDependencies","itemToNode","Map","node","set","size","values","dep","depNode","get","add","roots","rootCycles","selectedNode","stack","openEdges","Array","from","length","topOfStack","dependency","pop","push","i","cycleNode","delete","max","cycleRoots","has","clear","cycleRoot","r","Error"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/util/findGraphRoots.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst NO_MARKER = 0;\nconst IN_PROGRESS_MARKER = 1;\nconst DONE_MARKER = 2;\nconst DONE_MAYBE_ROOT_CYCLE_MARKER = 3;\nconst DONE_AND_ROOT_MARKER = 4;\n\n/**\n * @template T\n */\nclass Node {\n\t/**\n\t * @param {T} item the value of the node\n\t */\n\tconstructor(item) {\n\t\tthis.item = item;\n\t\t/** @type {Set<Node<T>>} */\n\t\tthis.dependencies = new Set();\n\t\tthis.marker = NO_MARKER;\n\t\t/** @type {Cycle<T> | undefined} */\n\t\tthis.cycle = undefined;\n\t\tthis.incoming = 0;\n\t}\n}\n\n/**\n * @template T\n */\nclass Cycle {\n\tconstructor() {\n\t\t/** @type {Set<Node<T>>} */\n\t\tthis.nodes = new Set();\n\t}\n}\n\n/**\n * @template T\n * @typedef {Object} StackEntry\n * @property {Node<T>} node\n * @property {Node<T>[]} openEdges\n */\n\n/**\n * @template T\n * @param {Iterable<T>} items list of items\n * @param {function(T): Iterable<T>} getDependencies function to get dependencies of an item (items that are not in list are ignored)\n * @returns {Iterable<T>} graph roots of the items\n */\nmodule.exports = (items, getDependencies) => {\n\t/** @type {Map<T, Node<T>>} */\n\tconst itemToNode = new Map();\n\tfor (const item of items) {\n\t\tconst node = new Node(item);\n\t\titemToNode.set(item, node);\n\t}\n\n\t// early exit when there is only a single item\n\tif (itemToNode.size <= 1) return items;\n\n\t// grab all the dependencies\n\tfor (const node of itemToNode.values()) {\n\t\tfor (const dep of getDependencies(node.item)) {\n\t\t\tconst depNode = itemToNode.get(dep);\n\t\t\tif (depNode !== undefined) {\n\t\t\t\tnode.dependencies.add(depNode);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set of current root modules\n\t// items will be removed if a new reference to it has been found\n\t/** @type {Set<Node<T>>} */\n\tconst roots = new Set();\n\n\t// Set of current cycles without references to it\n\t// cycles will be removed if a new reference to it has been found\n\t// that is not part of the cycle\n\t/** @type {Set<Cycle<T>>} */\n\tconst rootCycles = new Set();\n\n\t// For all non-marked nodes\n\tfor (const selectedNode of itemToNode.values()) {\n\t\tif (selectedNode.marker === NO_MARKER) {\n\t\t\t// deep-walk all referenced modules\n\t\t\t// in a non-recursive way\n\n\t\t\t// start by entering the selected node\n\t\t\tselectedNode.marker = IN_PROGRESS_MARKER;\n\n\t\t\t// keep a stack to avoid recursive walk\n\t\t\t/** @type {StackEntry<T>[]} */\n\t\t\tconst stack = [\n\t\t\t\t{\n\t\t\t\t\tnode: selectedNode,\n\t\t\t\t\topenEdges: Array.from(selectedNode.dependencies)\n\t\t\t\t}\n\t\t\t];\n\n\t\t\t// process the top item until stack is empty\n\t\t\twhile (stack.length > 0) {\n\t\t\t\tconst topOfStack = stack[stack.length - 1];\n\n\t\t\t\t// Are there still edges unprocessed in the current node?\n\t\t\t\tif (topOfStack.openEdges.length > 0) {\n\t\t\t\t\t// Process one dependency\n\t\t\t\t\tconst dependency = topOfStack.openEdges.pop();\n\t\t\t\t\tswitch (dependency.marker) {\n\t\t\t\t\t\tcase NO_MARKER:\n\t\t\t\t\t\t\t// dependency has not be visited yet\n\t\t\t\t\t\t\t// mark it as in-progress and recurse\n\t\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\t\tnode: dependency,\n\t\t\t\t\t\t\t\topenEdges: Array.from(dependency.dependencies)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdependency.marker = IN_PROGRESS_MARKER;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_PROGRESS_MARKER: {\n\t\t\t\t\t\t\t// It's a in-progress cycle\n\t\t\t\t\t\t\tlet cycle = dependency.cycle;\n\t\t\t\t\t\t\tif (!cycle) {\n\t\t\t\t\t\t\t\tcycle = new Cycle();\n\t\t\t\t\t\t\t\tcycle.nodes.add(dependency);\n\t\t\t\t\t\t\t\tdependency.cycle = cycle;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// set cycle property for each node in the cycle\n\t\t\t\t\t\t\t// if nodes are already part of a cycle\n\t\t\t\t\t\t\t// we merge the cycles to a shared cycle\n\t\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\t\tlet i = stack.length - 1;\n\t\t\t\t\t\t\t\tstack[i].node !== dependency;\n\t\t\t\t\t\t\t\ti--\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst node = stack[i].node;\n\t\t\t\t\t\t\t\tif (node.cycle) {\n\t\t\t\t\t\t\t\t\tif (node.cycle !== cycle) {\n\t\t\t\t\t\t\t\t\t\t// merge cycles\n\t\t\t\t\t\t\t\t\t\tfor (const cycleNode of node.cycle.nodes) {\n\t\t\t\t\t\t\t\t\t\t\tcycleNode.cycle = cycle;\n\t\t\t\t\t\t\t\t\t\t\tcycle.nodes.add(cycleNode);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnode.cycle = cycle;\n\t\t\t\t\t\t\t\t\tcycle.nodes.add(node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// don't recurse into dependencies\n\t\t\t\t\t\t\t// these are already on the stack\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase DONE_AND_ROOT_MARKER:\n\t\t\t\t\t\t\t// This node has be visited yet and is currently a root node\n\t\t\t\t\t\t\t// But as this is a new reference to the node\n\t\t\t\t\t\t\t// it's not really a root\n\t\t\t\t\t\t\t// so we have to convert it to a normal node\n\t\t\t\t\t\t\tdependency.marker = DONE_MARKER;\n\t\t\t\t\t\t\troots.delete(dependency);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase DONE_MAYBE_ROOT_CYCLE_MARKER:\n\t\t\t\t\t\t\t// This node has be visited yet and\n\t\t\t\t\t\t\t// is maybe currently part of a completed root cycle\n\t\t\t\t\t\t\t// we found a new reference to the cycle\n\t\t\t\t\t\t\t// so it's not really a root cycle\n\t\t\t\t\t\t\t// remove the cycle from the root cycles\n\t\t\t\t\t\t\t// and convert it to a normal node\n\t\t\t\t\t\t\trootCycles.delete(dependency.cycle);\n\t\t\t\t\t\t\tdependency.marker = DONE_MARKER;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// DONE_MARKER: nothing to do, don't recurse into dependencies\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// All dependencies of the current node has been visited\n\t\t\t\t\t// we leave the node\n\t\t\t\t\tstack.pop();\n\t\t\t\t\ttopOfStack.node.marker = DONE_MARKER;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst cycle = selectedNode.cycle;\n\t\t\tif (cycle) {\n\t\t\t\tfor (const node of cycle.nodes) {\n\t\t\t\t\tnode.marker = DONE_MAYBE_ROOT_CYCLE_MARKER;\n\t\t\t\t}\n\t\t\t\trootCycles.add(cycle);\n\t\t\t} else {\n\t\t\t\tselectedNode.marker = DONE_AND_ROOT_MARKER;\n\t\t\t\troots.add(selectedNode);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Extract roots from root cycles\n\t// We take the nodes with most incoming edges\n\t// inside of the cycle\n\tfor (const cycle of rootCycles) {\n\t\tlet max = 0;\n\t\t/** @type {Set<Node<T>>} */\n\t\tconst cycleRoots = new Set();\n\t\tconst nodes = cycle.nodes;\n\t\tfor (const node of nodes) {\n\t\t\tfor (const dep of node.dependencies) {\n\t\t\t\tif (nodes.has(dep)) {\n\t\t\t\t\tdep.incoming++;\n\t\t\t\t\tif (dep.incoming < max) continue;\n\t\t\t\t\tif (dep.incoming > max) {\n\t\t\t\t\t\tcycleRoots.clear();\n\t\t\t\t\t\tmax = dep.incoming;\n\t\t\t\t\t}\n\t\t\t\t\tcycleRoots.add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const cycleRoot of cycleRoots) {\n\t\t\troots.add(cycleRoot);\n\t\t}\n\t}\n\n\t// When roots were found, return them\n\tif (roots.size > 0) {\n\t\treturn Array.from(roots, r => r.item);\n\t} else {\n\t\tthrow new Error(\"Implementation of findGraphRoots is broken\");\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}