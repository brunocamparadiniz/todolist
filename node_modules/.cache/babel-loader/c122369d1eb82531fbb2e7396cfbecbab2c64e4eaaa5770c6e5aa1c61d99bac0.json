{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar PureExpressionDependency = require(\"../dependencies/PureExpressionDependency\");\nvar InnerGraph = require(\"./InnerGraph\");\n\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclarationNode */\n/** @typedef {import(\"estree\").ClassExpression} ClassExpressionNode */\n/** @typedef {import(\"estree\").Node} Node */\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclaratorNode */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../dependencies/HarmonyImportSpecifierDependency\")} HarmonyImportSpecifierDependency */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"./InnerGraph\").InnerGraph} InnerGraph */\n/** @typedef {import(\"./InnerGraph\").TopLevelSymbol} TopLevelSymbol */\n\nvar topLevelSymbolTag = InnerGraph.topLevelSymbolTag;\nvar InnerGraphPlugin = /*#__PURE__*/function () {\n  function InnerGraphPlugin() {\n    _classCallCheck(this, InnerGraphPlugin);\n  }\n  _createClass(InnerGraphPlugin, [{\n    key: \"apply\",\n    value:\n    /**\n     * Apply the plugin\n     * @param {Compiler} compiler the compiler instance\n     * @returns {void}\n     */\n    function apply(compiler) {\n      compiler.hooks.compilation.tap(\"InnerGraphPlugin\", function (compilation, _ref) {\n        var normalModuleFactory = _ref.normalModuleFactory;\n        var logger = compilation.getLogger(\"webpack.InnerGraphPlugin\");\n        compilation.dependencyTemplates.set(PureExpressionDependency, new PureExpressionDependency.Template());\n\n        /**\n         * @param {JavascriptParser} parser the parser\n         * @param {Object} parserOptions options\n         * @returns {void}\n         */\n        var handler = function handler(parser, parserOptions) {\n          var onUsageSuper = function onUsageSuper(sup) {\n            InnerGraph.onUsage(parser.state, function (usedByExports) {\n              switch (usedByExports) {\n                case undefined:\n                case true:\n                  return;\n                default:\n                  {\n                    var dep = new PureExpressionDependency(sup.range);\n                    dep.loc = sup.loc;\n                    dep.usedByExports = usedByExports;\n                    parser.state.module.addDependency(dep);\n                    break;\n                  }\n              }\n            });\n          };\n          parser.hooks.program.tap(\"InnerGraphPlugin\", function () {\n            InnerGraph.enable(parser.state);\n          });\n          parser.hooks.finish.tap(\"InnerGraphPlugin\", function () {\n            if (!InnerGraph.isEnabled(parser.state)) return;\n            logger.time(\"infer dependency usage\");\n            InnerGraph.inferDependencyUsage(parser.state);\n            logger.timeAggregate(\"infer dependency usage\");\n          });\n\n          // During prewalking the following datastructures are filled with\n          // nodes that have a TopLevelSymbol assigned and\n          // variables are tagged with the assigned TopLevelSymbol\n\n          // We differ 3 types of nodes:\n          // 1. full statements (export default, function declaration)\n          // 2. classes (class declaration, class expression)\n          // 3. variable declarators (const x = ...)\n\n          /** @type {WeakMap<Node, TopLevelSymbol>} */\n          var statementWithTopLevelSymbol = new WeakMap();\n          /** @type {WeakMap<Node, Node>} */\n          var statementPurePart = new WeakMap();\n\n          /** @type {WeakMap<ClassExpressionNode | ClassDeclarationNode, TopLevelSymbol>} */\n          var classWithTopLevelSymbol = new WeakMap();\n\n          /** @type {WeakMap<VariableDeclaratorNode, TopLevelSymbol>} */\n          var declWithTopLevelSymbol = new WeakMap();\n          /** @type {WeakSet<VariableDeclaratorNode>} */\n          var pureDeclarators = new WeakSet();\n\n          // The following hooks are used during prewalking:\n\n          parser.hooks.preStatement.tap(\"InnerGraphPlugin\", function (statement) {\n            if (!InnerGraph.isEnabled(parser.state)) return;\n            if (parser.scope.topLevelScope === true) {\n              if (statement.type === \"FunctionDeclaration\") {\n                var name = statement.id ? statement.id.name : \"*default*\";\n                var fn = InnerGraph.tagTopLevelSymbol(parser, name);\n                statementWithTopLevelSymbol.set(statement, fn);\n                return true;\n              }\n            }\n          });\n          parser.hooks.blockPreStatement.tap(\"InnerGraphPlugin\", function (statement) {\n            if (!InnerGraph.isEnabled(parser.state)) return;\n            if (parser.scope.topLevelScope === true) {\n              if (statement.type === \"ClassDeclaration\") {\n                var name = statement.id ? statement.id.name : \"*default*\";\n                var fn = InnerGraph.tagTopLevelSymbol(parser, name);\n                classWithTopLevelSymbol.set(statement, fn);\n                return true;\n              }\n              if (statement.type === \"ExportDefaultDeclaration\") {\n                var _name = \"*default*\";\n                var _fn = InnerGraph.tagTopLevelSymbol(parser, _name);\n                var decl = statement.declaration;\n                if (decl.type === \"ClassExpression\" || decl.type === \"ClassDeclaration\") {\n                  classWithTopLevelSymbol.set(decl, _fn);\n                } else if (parser.isPure(decl, statement.range[0])) {\n                  statementWithTopLevelSymbol.set(statement, _fn);\n                  if (!decl.type.endsWith(\"FunctionExpression\") && !decl.type.endsWith(\"Declaration\") && decl.type !== \"Literal\") {\n                    statementPurePart.set(statement, decl);\n                  }\n                }\n              }\n            }\n          });\n          parser.hooks.preDeclarator.tap(\"InnerGraphPlugin\", function (decl, statement) {\n            if (!InnerGraph.isEnabled(parser.state)) return;\n            if (parser.scope.topLevelScope === true && decl.init && decl.id.type === \"Identifier\") {\n              var name = decl.id.name;\n              if (decl.init.type === \"ClassExpression\") {\n                var fn = InnerGraph.tagTopLevelSymbol(parser, name);\n                classWithTopLevelSymbol.set(decl.init, fn);\n              } else if (parser.isPure(decl.init, decl.id.range[1])) {\n                var _fn2 = InnerGraph.tagTopLevelSymbol(parser, name);\n                declWithTopLevelSymbol.set(decl, _fn2);\n                if (!decl.init.type.endsWith(\"FunctionExpression\") && decl.init.type !== \"Literal\") {\n                  pureDeclarators.add(decl);\n                }\n                return true;\n              }\n            }\n          });\n\n          // During real walking we set the TopLevelSymbol state to the assigned\n          // TopLevelSymbol by using the fill datastructures.\n\n          // In addition to tracking TopLevelSymbols, we sometimes need to\n          // add a PureExpressionDependency. This is needed to skip execution\n          // of pure expressions, even when they are not dropped due to\n          // minimizing. Otherwise symbols used there might not exist anymore\n          // as they are removed as unused by this optimization\n\n          // When we find a reference to a TopLevelSymbol, we register a\n          // TopLevelSymbol dependency from TopLevelSymbol in state to the\n          // referenced TopLevelSymbol. This way we get a graph of all\n          // TopLevelSymbols.\n\n          // The following hooks are called during walking:\n\n          parser.hooks.statement.tap(\"InnerGraphPlugin\", function (statement) {\n            if (!InnerGraph.isEnabled(parser.state)) return;\n            if (parser.scope.topLevelScope === true) {\n              InnerGraph.setTopLevelSymbol(parser.state, undefined);\n              var fn = statementWithTopLevelSymbol.get(statement);\n              if (fn) {\n                InnerGraph.setTopLevelSymbol(parser.state, fn);\n                var purePart = statementPurePart.get(statement);\n                if (purePart) {\n                  InnerGraph.onUsage(parser.state, function (usedByExports) {\n                    switch (usedByExports) {\n                      case undefined:\n                      case true:\n                        return;\n                      default:\n                        {\n                          var dep = new PureExpressionDependency(purePart.range);\n                          dep.loc = statement.loc;\n                          dep.usedByExports = usedByExports;\n                          parser.state.module.addDependency(dep);\n                          break;\n                        }\n                    }\n                  });\n                }\n              }\n            }\n          });\n          parser.hooks.classExtendsExpression.tap(\"InnerGraphPlugin\", function (expr, statement) {\n            if (!InnerGraph.isEnabled(parser.state)) return;\n            if (parser.scope.topLevelScope === true) {\n              var fn = classWithTopLevelSymbol.get(statement);\n              if (fn && parser.isPure(expr, statement.id ? statement.id.range[1] : statement.range[0])) {\n                InnerGraph.setTopLevelSymbol(parser.state, fn);\n                onUsageSuper(expr);\n              }\n            }\n          });\n          parser.hooks.classBodyElement.tap(\"InnerGraphPlugin\", function (element, classDefinition) {\n            if (!InnerGraph.isEnabled(parser.state)) return;\n            if (parser.scope.topLevelScope === true) {\n              var fn = classWithTopLevelSymbol.get(classDefinition);\n              if (fn) {\n                InnerGraph.setTopLevelSymbol(parser.state, undefined);\n              }\n            }\n          });\n          parser.hooks.classBodyValue.tap(\"InnerGraphPlugin\", function (expression, element, classDefinition) {\n            if (!InnerGraph.isEnabled(parser.state)) return;\n            if (parser.scope.topLevelScope === true) {\n              var fn = classWithTopLevelSymbol.get(classDefinition);\n              if (fn) {\n                if (!element.static || parser.isPure(expression, element.key ? element.key.range[1] : element.range[0])) {\n                  InnerGraph.setTopLevelSymbol(parser.state, fn);\n                  if (element.type !== \"MethodDefinition\" && element.static) {\n                    InnerGraph.onUsage(parser.state, function (usedByExports) {\n                      switch (usedByExports) {\n                        case undefined:\n                        case true:\n                          return;\n                        default:\n                          {\n                            var dep = new PureExpressionDependency(expression.range);\n                            dep.loc = expression.loc;\n                            dep.usedByExports = usedByExports;\n                            parser.state.module.addDependency(dep);\n                            break;\n                          }\n                      }\n                    });\n                  }\n                } else {\n                  InnerGraph.setTopLevelSymbol(parser.state, undefined);\n                }\n              }\n            }\n          });\n          parser.hooks.declarator.tap(\"InnerGraphPlugin\", function (decl, statement) {\n            if (!InnerGraph.isEnabled(parser.state)) return;\n            var fn = declWithTopLevelSymbol.get(decl);\n            if (fn) {\n              InnerGraph.setTopLevelSymbol(parser.state, fn);\n              if (pureDeclarators.has(decl)) {\n                if (decl.init.type === \"ClassExpression\") {\n                  if (decl.init.superClass) {\n                    onUsageSuper(decl.init.superClass);\n                  }\n                } else {\n                  InnerGraph.onUsage(parser.state, function (usedByExports) {\n                    switch (usedByExports) {\n                      case undefined:\n                      case true:\n                        return;\n                      default:\n                        {\n                          var dep = new PureExpressionDependency(decl.init.range);\n                          dep.loc = decl.loc;\n                          dep.usedByExports = usedByExports;\n                          parser.state.module.addDependency(dep);\n                          break;\n                        }\n                    }\n                  });\n                }\n              }\n              parser.walkExpression(decl.init);\n              InnerGraph.setTopLevelSymbol(parser.state, undefined);\n              return true;\n            }\n          });\n          parser.hooks.expression.for(topLevelSymbolTag).tap(\"InnerGraphPlugin\", function () {\n            var topLevelSymbol = /** @type {TopLevelSymbol} */\n            parser.currentTagData;\n            var currentTopLevelSymbol = InnerGraph.getTopLevelSymbol(parser.state);\n            InnerGraph.addUsage(parser.state, topLevelSymbol, currentTopLevelSymbol || true);\n          });\n          parser.hooks.assign.for(topLevelSymbolTag).tap(\"InnerGraphPlugin\", function (expr) {\n            if (!InnerGraph.isEnabled(parser.state)) return;\n            if (expr.operator === \"=\") return true;\n          });\n        };\n        normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"InnerGraphPlugin\", handler);\n        normalModuleFactory.hooks.parser.for(\"javascript/esm\").tap(\"InnerGraphPlugin\", handler);\n        compilation.hooks.finishModules.tap(\"InnerGraphPlugin\", function () {\n          logger.timeAggregateEnd(\"infer dependency usage\");\n        });\n      });\n    }\n  }]);\n  return InnerGraphPlugin;\n}();\nmodule.exports = InnerGraphPlugin;","map":{"version":3,"names":["PureExpressionDependency","require","InnerGraph","topLevelSymbolTag","InnerGraphPlugin","compiler","hooks","compilation","tap","normalModuleFactory","logger","getLogger","dependencyTemplates","set","Template","handler","parser","parserOptions","onUsageSuper","sup","onUsage","state","usedByExports","undefined","dep","range","loc","module","addDependency","program","enable","finish","isEnabled","time","inferDependencyUsage","timeAggregate","statementWithTopLevelSymbol","WeakMap","statementPurePart","classWithTopLevelSymbol","declWithTopLevelSymbol","pureDeclarators","WeakSet","preStatement","statement","scope","topLevelScope","type","name","id","fn","tagTopLevelSymbol","blockPreStatement","decl","declaration","isPure","endsWith","preDeclarator","init","add","setTopLevelSymbol","get","purePart","classExtendsExpression","expr","classBodyElement","element","classDefinition","classBodyValue","expression","static","key","declarator","has","superClass","walkExpression","for","topLevelSymbol","currentTagData","currentTopLevelSymbol","getTopLevelSymbol","addUsage","assign","operator","finishModules","timeAggregateEnd","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/optimize/InnerGraphPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst PureExpressionDependency = require(\"../dependencies/PureExpressionDependency\");\nconst InnerGraph = require(\"./InnerGraph\");\n\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclarationNode */\n/** @typedef {import(\"estree\").ClassExpression} ClassExpressionNode */\n/** @typedef {import(\"estree\").Node} Node */\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclaratorNode */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../dependencies/HarmonyImportSpecifierDependency\")} HarmonyImportSpecifierDependency */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"./InnerGraph\").InnerGraph} InnerGraph */\n/** @typedef {import(\"./InnerGraph\").TopLevelSymbol} TopLevelSymbol */\n\nconst { topLevelSymbolTag } = InnerGraph;\n\nclass InnerGraphPlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"InnerGraphPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tconst logger = compilation.getLogger(\"webpack.InnerGraphPlugin\");\n\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tPureExpressionDependency,\n\t\t\t\t\tnew PureExpressionDependency.Template()\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * @param {JavascriptParser} parser the parser\n\t\t\t\t * @param {Object} parserOptions options\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst handler = (parser, parserOptions) => {\n\t\t\t\t\tconst onUsageSuper = sup => {\n\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(sup.range);\n\t\t\t\t\t\t\t\t\tdep.loc = sup.loc;\n\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\tparser.hooks.program.tap(\"InnerGraphPlugin\", () => {\n\t\t\t\t\t\tInnerGraph.enable(parser.state);\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.finish.tap(\"InnerGraphPlugin\", () => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\n\t\t\t\t\t\tlogger.time(\"infer dependency usage\");\n\t\t\t\t\t\tInnerGraph.inferDependencyUsage(parser.state);\n\t\t\t\t\t\tlogger.timeAggregate(\"infer dependency usage\");\n\t\t\t\t\t});\n\n\t\t\t\t\t// During prewalking the following datastructures are filled with\n\t\t\t\t\t// nodes that have a TopLevelSymbol assigned and\n\t\t\t\t\t// variables are tagged with the assigned TopLevelSymbol\n\n\t\t\t\t\t// We differ 3 types of nodes:\n\t\t\t\t\t// 1. full statements (export default, function declaration)\n\t\t\t\t\t// 2. classes (class declaration, class expression)\n\t\t\t\t\t// 3. variable declarators (const x = ...)\n\n\t\t\t\t\t/** @type {WeakMap<Node, TopLevelSymbol>} */\n\t\t\t\t\tconst statementWithTopLevelSymbol = new WeakMap();\n\t\t\t\t\t/** @type {WeakMap<Node, Node>} */\n\t\t\t\t\tconst statementPurePart = new WeakMap();\n\n\t\t\t\t\t/** @type {WeakMap<ClassExpressionNode | ClassDeclarationNode, TopLevelSymbol>} */\n\t\t\t\t\tconst classWithTopLevelSymbol = new WeakMap();\n\n\t\t\t\t\t/** @type {WeakMap<VariableDeclaratorNode, TopLevelSymbol>} */\n\t\t\t\t\tconst declWithTopLevelSymbol = new WeakMap();\n\t\t\t\t\t/** @type {WeakSet<VariableDeclaratorNode>} */\n\t\t\t\t\tconst pureDeclarators = new WeakSet();\n\n\t\t\t\t\t// The following hooks are used during prewalking:\n\n\t\t\t\t\tparser.hooks.preStatement.tap(\"InnerGraphPlugin\", statement => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\n\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\tif (statement.type === \"FunctionDeclaration\") {\n\t\t\t\t\t\t\t\tconst name = statement.id ? statement.id.name : \"*default*\";\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tstatementWithTopLevelSymbol.set(statement, fn);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.blockPreStatement.tap(\"InnerGraphPlugin\", statement => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\n\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\tif (statement.type === \"ClassDeclaration\") {\n\t\t\t\t\t\t\t\tconst name = statement.id ? statement.id.name : \"*default*\";\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tclassWithTopLevelSymbol.set(statement, fn);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (statement.type === \"ExportDefaultDeclaration\") {\n\t\t\t\t\t\t\t\tconst name = \"*default*\";\n\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\tconst decl = statement.declaration;\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tdecl.type === \"ClassExpression\" ||\n\t\t\t\t\t\t\t\t\tdecl.type === \"ClassDeclaration\"\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tclassWithTopLevelSymbol.set(decl, fn);\n\t\t\t\t\t\t\t\t} else if (parser.isPure(decl, statement.range[0])) {\n\t\t\t\t\t\t\t\t\tstatementWithTopLevelSymbol.set(statement, fn);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!decl.type.endsWith(\"FunctionExpression\") &&\n\t\t\t\t\t\t\t\t\t\t!decl.type.endsWith(\"Declaration\") &&\n\t\t\t\t\t\t\t\t\t\tdecl.type !== \"Literal\"\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tstatementPurePart.set(statement, decl);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.preDeclarator.tap(\n\t\t\t\t\t\t\"InnerGraphPlugin\",\n\t\t\t\t\t\t(decl, statement) => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tparser.scope.topLevelScope === true &&\n\t\t\t\t\t\t\t\tdecl.init &&\n\t\t\t\t\t\t\t\tdecl.id.type === \"Identifier\"\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst name = decl.id.name;\n\t\t\t\t\t\t\t\tif (decl.init.type === \"ClassExpression\") {\n\t\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\t\tclassWithTopLevelSymbol.set(decl.init, fn);\n\t\t\t\t\t\t\t\t} else if (parser.isPure(decl.init, decl.id.range[1])) {\n\t\t\t\t\t\t\t\t\tconst fn = InnerGraph.tagTopLevelSymbol(parser, name);\n\t\t\t\t\t\t\t\t\tdeclWithTopLevelSymbol.set(decl, fn);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!decl.init.type.endsWith(\"FunctionExpression\") &&\n\t\t\t\t\t\t\t\t\t\tdecl.init.type !== \"Literal\"\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tpureDeclarators.add(decl);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\t// During real walking we set the TopLevelSymbol state to the assigned\n\t\t\t\t\t// TopLevelSymbol by using the fill datastructures.\n\n\t\t\t\t\t// In addition to tracking TopLevelSymbols, we sometimes need to\n\t\t\t\t\t// add a PureExpressionDependency. This is needed to skip execution\n\t\t\t\t\t// of pure expressions, even when they are not dropped due to\n\t\t\t\t\t// minimizing. Otherwise symbols used there might not exist anymore\n\t\t\t\t\t// as they are removed as unused by this optimization\n\n\t\t\t\t\t// When we find a reference to a TopLevelSymbol, we register a\n\t\t\t\t\t// TopLevelSymbol dependency from TopLevelSymbol in state to the\n\t\t\t\t\t// referenced TopLevelSymbol. This way we get a graph of all\n\t\t\t\t\t// TopLevelSymbols.\n\n\t\t\t\t\t// The following hooks are called during walking:\n\n\t\t\t\t\tparser.hooks.statement.tap(\"InnerGraphPlugin\", statement => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\n\t\t\t\t\t\t\tconst fn = statementWithTopLevelSymbol.get(statement);\n\t\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\t\tconst purePart = statementPurePart.get(statement);\n\t\t\t\t\t\t\t\tif (purePart) {\n\t\t\t\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\tpurePart.range\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tdep.loc = statement.loc;\n\t\t\t\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.classExtendsExpression.tap(\n\t\t\t\t\t\t\"InnerGraphPlugin\",\n\t\t\t\t\t\t(expr, statement) => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\t\tconst fn = classWithTopLevelSymbol.get(statement);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tfn &&\n\t\t\t\t\t\t\t\t\tparser.isPure(\n\t\t\t\t\t\t\t\t\t\texpr,\n\t\t\t\t\t\t\t\t\t\tstatement.id ? statement.id.range[1] : statement.range[0]\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\t\t\tonUsageSuper(expr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tparser.hooks.classBodyElement.tap(\n\t\t\t\t\t\t\"InnerGraphPlugin\",\n\t\t\t\t\t\t(element, classDefinition) => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\t\tconst fn = classWithTopLevelSymbol.get(classDefinition);\n\t\t\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tparser.hooks.classBodyValue.tap(\n\t\t\t\t\t\t\"InnerGraphPlugin\",\n\t\t\t\t\t\t(expression, element, classDefinition) => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (parser.scope.topLevelScope === true) {\n\t\t\t\t\t\t\t\tconst fn = classWithTopLevelSymbol.get(classDefinition);\n\t\t\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!element.static ||\n\t\t\t\t\t\t\t\t\t\tparser.isPure(\n\t\t\t\t\t\t\t\t\t\t\texpression,\n\t\t\t\t\t\t\t\t\t\t\telement.key ? element.key.range[1] : element.range[0]\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\t\t\t\tif (element.type !== \"MethodDefinition\" && element.static) {\n\t\t\t\t\t\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texpression.range\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep.loc = expression.loc;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\tparser.hooks.declarator.tap(\"InnerGraphPlugin\", (decl, statement) => {\n\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\tconst fn = declWithTopLevelSymbol.get(decl);\n\n\t\t\t\t\t\tif (fn) {\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, fn);\n\t\t\t\t\t\t\tif (pureDeclarators.has(decl)) {\n\t\t\t\t\t\t\t\tif (decl.init.type === \"ClassExpression\") {\n\t\t\t\t\t\t\t\t\tif (decl.init.superClass) {\n\t\t\t\t\t\t\t\t\t\tonUsageSuper(decl.init.superClass);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tInnerGraph.onUsage(parser.state, usedByExports => {\n\t\t\t\t\t\t\t\t\t\tswitch (usedByExports) {\n\t\t\t\t\t\t\t\t\t\t\tcase undefined:\n\t\t\t\t\t\t\t\t\t\t\tcase true:\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new PureExpressionDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\tdecl.init.range\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tdep.loc = decl.loc;\n\t\t\t\t\t\t\t\t\t\t\t\tdep.usedByExports = usedByExports;\n\t\t\t\t\t\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparser.walkExpression(decl.init);\n\t\t\t\t\t\t\tInnerGraph.setTopLevelSymbol(parser.state, undefined);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tparser.hooks.expression\n\t\t\t\t\t\t.for(topLevelSymbolTag)\n\t\t\t\t\t\t.tap(\"InnerGraphPlugin\", () => {\n\t\t\t\t\t\t\tconst topLevelSymbol = /** @type {TopLevelSymbol} */ (\n\t\t\t\t\t\t\t\tparser.currentTagData\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst currentTopLevelSymbol = InnerGraph.getTopLevelSymbol(\n\t\t\t\t\t\t\t\tparser.state\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tInnerGraph.addUsage(\n\t\t\t\t\t\t\t\tparser.state,\n\t\t\t\t\t\t\t\ttopLevelSymbol,\n\t\t\t\t\t\t\t\tcurrentTopLevelSymbol || true\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.assign\n\t\t\t\t\t\t.for(topLevelSymbolTag)\n\t\t\t\t\t\t.tap(\"InnerGraphPlugin\", expr => {\n\t\t\t\t\t\t\tif (!InnerGraph.isEnabled(parser.state)) return;\n\t\t\t\t\t\t\tif (expr.operator === \"=\") return true;\n\t\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/auto\")\n\t\t\t\t\t.tap(\"InnerGraphPlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/esm\")\n\t\t\t\t\t.tap(\"InnerGraphPlugin\", handler);\n\n\t\t\t\tcompilation.hooks.finishModules.tap(\"InnerGraphPlugin\", () => {\n\t\t\t\t\tlogger.timeAggregateEnd(\"infer dependency usage\");\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = InnerGraphPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}