{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/**\n * @typedef {Object} GroupOptions\n * @property {boolean=} groupChildren\n * @property {boolean=} force\n * @property {number=} targetGroupCount\n */\n\n/**\n * @template T\n * @template R\n * @typedef {Object} GroupConfig\n * @property {function(T): string[]} getKeys\n * @property {function(string, (R | T)[], T[]): R} createGroup\n * @property {function(string, T[]): GroupOptions=} getOptions\n */\n\n/**\n * @template T\n * @template R\n * @typedef {Object} ItemWithGroups\n * @property {T} item\n * @property {Set<Group<T, R>>} groups\n */\n\n/**\n * @template T\n * @template R\n * @typedef {{ config: GroupConfig<T, R>, name: string, alreadyGrouped: boolean, items: Set<ItemWithGroups<T, R>> | undefined }} Group\n */\n\n/**\n * @template T\n * @template R\n * @param {T[]} items the list of items\n * @param {GroupConfig<T, R>[]} groupConfigs configuration\n * @returns {(R | T)[]} grouped items\n */\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar smartGrouping = function smartGrouping(items, groupConfigs) {\n  /** @type {Set<ItemWithGroups<T, R>>} */\n  var itemsWithGroups = new Set();\n  /** @type {Map<string, Group<T, R>>} */\n  var allGroups = new Map();\n  var _iterator = _createForOfIteratorHelper(items),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      /** @type {Set<Group<T, R>>} */\n      var groups = new Set();\n      for (var i = 0; i < groupConfigs.length; i++) {\n        var groupConfig = groupConfigs[i];\n        var keys = groupConfig.getKeys(item);\n        if (keys) {\n          var _iterator9 = _createForOfIteratorHelper(keys),\n            _step9;\n          try {\n            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n              var name = _step9.value;\n              var key = \"\".concat(i, \":\").concat(name);\n              var group = allGroups.get(key);\n              if (group === undefined) {\n                allGroups.set(key, group = {\n                  config: groupConfig,\n                  name: name,\n                  alreadyGrouped: false,\n                  items: undefined\n                });\n              }\n              groups.add(group);\n            }\n          } catch (err) {\n            _iterator9.e(err);\n          } finally {\n            _iterator9.f();\n          }\n        }\n      }\n      itemsWithGroups.add({\n        item: item,\n        groups: groups\n      });\n    }\n    /**\n     * @param {Set<ItemWithGroups<T, R>>} itemsWithGroups input items with groups\n     * @returns {(T | R)[]} groups items\n     */\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var runGrouping = function runGrouping(itemsWithGroups) {\n    var totalSize = itemsWithGroups.size;\n    var _iterator2 = _createForOfIteratorHelper(itemsWithGroups),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var entry = _step2.value;\n        var _iterator8 = _createForOfIteratorHelper(entry.groups),\n          _step8;\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var _group2 = _step8.value;\n            if (_group2.alreadyGrouped) continue;\n            var _items3 = _group2.items;\n            if (_items3 === undefined) {\n              _group2.items = new Set([entry]);\n            } else {\n              _items3.add(entry);\n            }\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n      }\n      /** @type {Map<Group<T, R>, { items: Set<ItemWithGroups<T, R>>, options: GroupOptions | false | undefined, used: boolean }>} */\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    var groupMap = new Map();\n    var _iterator3 = _createForOfIteratorHelper(allGroups.values()),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _group3 = _step3.value;\n        if (_group3.items) {\n          var _items4 = _group3.items;\n          _group3.items = undefined;\n          groupMap.set(_group3, {\n            items: _items4,\n            options: undefined,\n            used: false\n          });\n        }\n      }\n      /** @type {(T | R)[]} */\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    var results = [];\n    for (;;) {\n      /** @type {Group<T, R>} */\n      var bestGroup = undefined;\n      var bestGroupSize = -1;\n      var bestGroupItems = undefined;\n      var bestGroupOptions = undefined;\n      var _iterator4 = _createForOfIteratorHelper(groupMap),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n            group = _step4$value[0],\n            state = _step4$value[1];\n          var _items2 = state.items,\n            used = state.used;\n          var _options = state.options;\n          if (_options === undefined) {\n            var _groupConfig = group.config;\n            state.options = _options = _groupConfig.getOptions && _groupConfig.getOptions(group.name, Array.from(_items2, function (_ref2) {\n              var item = _ref2.item;\n              return item;\n            })) || false;\n          }\n          var force = _options && _options.force;\n          if (!force) {\n            if (bestGroupOptions && bestGroupOptions.force) continue;\n            if (used) continue;\n            if (_items2.size <= 1 || totalSize - _items2.size <= 1) {\n              continue;\n            }\n          }\n          var targetGroupCount = _options && _options.targetGroupCount || 4;\n          var sizeValue = force ? _items2.size : Math.min(_items2.size, totalSize * 2 / targetGroupCount + itemsWithGroups.size - _items2.size);\n          if (sizeValue > bestGroupSize || force && (!bestGroupOptions || !bestGroupOptions.force)) {\n            bestGroup = group;\n            bestGroupSize = sizeValue;\n            bestGroupItems = _items2;\n            bestGroupOptions = _options;\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      if (bestGroup === undefined) {\n        break;\n      }\n      var _items = new Set(bestGroupItems);\n      var options = bestGroupOptions;\n      var groupChildren = !options || options.groupChildren !== false;\n      var _iterator5 = _createForOfIteratorHelper(_items),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var item = _step5.value;\n          itemsWithGroups.delete(item);\n          // Remove all groups that items have from the map to not select them again\n          var _iterator6 = _createForOfIteratorHelper(item.groups),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var _group = _step6.value;\n              var _state = groupMap.get(_group);\n              if (_state !== undefined) {\n                _state.items.delete(item);\n                if (_state.items.size === 0) {\n                  groupMap.delete(_group);\n                } else {\n                  _state.options = undefined;\n                  if (groupChildren) {\n                    _state.used = true;\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      groupMap.delete(bestGroup);\n      var key = bestGroup.name;\n      var groupConfig = bestGroup.config;\n      var allItems = Array.from(_items, function (_ref) {\n        var item = _ref.item;\n        return item;\n      });\n      bestGroup.alreadyGrouped = true;\n      var children = groupChildren ? runGrouping(_items) : allItems;\n      bestGroup.alreadyGrouped = false;\n      results.push(groupConfig.createGroup(key, children, allItems));\n    }\n    var _iterator7 = _createForOfIteratorHelper(itemsWithGroups),\n      _step7;\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var _item = _step7.value.item;\n        results.push(_item);\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n    return results;\n  };\n  return runGrouping(itemsWithGroups);\n};\nmodule.exports = smartGrouping;","map":{"version":3,"names":["smartGrouping","items","groupConfigs","itemsWithGroups","Set","allGroups","Map","item","groups","i","length","groupConfig","keys","getKeys","name","key","group","get","undefined","set","config","alreadyGrouped","add","runGrouping","totalSize","size","entry","groupMap","values","options","used","results","bestGroup","bestGroupSize","bestGroupItems","bestGroupOptions","state","getOptions","Array","from","force","targetGroupCount","sizeValue","Math","min","groupChildren","delete","allItems","children","push","createGroup","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/util/smartGrouping.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/**\n * @typedef {Object} GroupOptions\n * @property {boolean=} groupChildren\n * @property {boolean=} force\n * @property {number=} targetGroupCount\n */\n\n/**\n * @template T\n * @template R\n * @typedef {Object} GroupConfig\n * @property {function(T): string[]} getKeys\n * @property {function(string, (R | T)[], T[]): R} createGroup\n * @property {function(string, T[]): GroupOptions=} getOptions\n */\n\n/**\n * @template T\n * @template R\n * @typedef {Object} ItemWithGroups\n * @property {T} item\n * @property {Set<Group<T, R>>} groups\n */\n\n/**\n * @template T\n * @template R\n * @typedef {{ config: GroupConfig<T, R>, name: string, alreadyGrouped: boolean, items: Set<ItemWithGroups<T, R>> | undefined }} Group\n */\n\n/**\n * @template T\n * @template R\n * @param {T[]} items the list of items\n * @param {GroupConfig<T, R>[]} groupConfigs configuration\n * @returns {(R | T)[]} grouped items\n */\nconst smartGrouping = (items, groupConfigs) => {\n\t/** @type {Set<ItemWithGroups<T, R>>} */\n\tconst itemsWithGroups = new Set();\n\t/** @type {Map<string, Group<T, R>>} */\n\tconst allGroups = new Map();\n\tfor (const item of items) {\n\t\t/** @type {Set<Group<T, R>>} */\n\t\tconst groups = new Set();\n\t\tfor (let i = 0; i < groupConfigs.length; i++) {\n\t\t\tconst groupConfig = groupConfigs[i];\n\t\t\tconst keys = groupConfig.getKeys(item);\n\t\t\tif (keys) {\n\t\t\t\tfor (const name of keys) {\n\t\t\t\t\tconst key = `${i}:${name}`;\n\t\t\t\t\tlet group = allGroups.get(key);\n\t\t\t\t\tif (group === undefined) {\n\t\t\t\t\t\tallGroups.set(\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t(group = {\n\t\t\t\t\t\t\t\tconfig: groupConfig,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\talreadyGrouped: false,\n\t\t\t\t\t\t\t\titems: undefined\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tgroups.add(group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\titemsWithGroups.add({\n\t\t\titem,\n\t\t\tgroups\n\t\t});\n\t}\n\t/**\n\t * @param {Set<ItemWithGroups<T, R>>} itemsWithGroups input items with groups\n\t * @returns {(T | R)[]} groups items\n\t */\n\tconst runGrouping = itemsWithGroups => {\n\t\tconst totalSize = itemsWithGroups.size;\n\t\tfor (const entry of itemsWithGroups) {\n\t\t\tfor (const group of entry.groups) {\n\t\t\t\tif (group.alreadyGrouped) continue;\n\t\t\t\tconst items = group.items;\n\t\t\t\tif (items === undefined) {\n\t\t\t\t\tgroup.items = new Set([entry]);\n\t\t\t\t} else {\n\t\t\t\t\titems.add(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/** @type {Map<Group<T, R>, { items: Set<ItemWithGroups<T, R>>, options: GroupOptions | false | undefined, used: boolean }>} */\n\t\tconst groupMap = new Map();\n\t\tfor (const group of allGroups.values()) {\n\t\t\tif (group.items) {\n\t\t\t\tconst items = group.items;\n\t\t\t\tgroup.items = undefined;\n\t\t\t\tgroupMap.set(group, {\n\t\t\t\t\titems,\n\t\t\t\t\toptions: undefined,\n\t\t\t\t\tused: false\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t/** @type {(T | R)[]} */\n\t\tconst results = [];\n\t\tfor (;;) {\n\t\t\t/** @type {Group<T, R>} */\n\t\t\tlet bestGroup = undefined;\n\t\t\tlet bestGroupSize = -1;\n\t\t\tlet bestGroupItems = undefined;\n\t\t\tlet bestGroupOptions = undefined;\n\t\t\tfor (const [group, state] of groupMap) {\n\t\t\t\tconst { items, used } = state;\n\t\t\t\tlet options = state.options;\n\t\t\t\tif (options === undefined) {\n\t\t\t\t\tconst groupConfig = group.config;\n\t\t\t\t\tstate.options = options =\n\t\t\t\t\t\t(groupConfig.getOptions &&\n\t\t\t\t\t\t\tgroupConfig.getOptions(\n\t\t\t\t\t\t\t\tgroup.name,\n\t\t\t\t\t\t\t\tArray.from(items, ({ item }) => item)\n\t\t\t\t\t\t\t)) ||\n\t\t\t\t\t\tfalse;\n\t\t\t\t}\n\n\t\t\t\tconst force = options && options.force;\n\t\t\t\tif (!force) {\n\t\t\t\t\tif (bestGroupOptions && bestGroupOptions.force) continue;\n\t\t\t\t\tif (used) continue;\n\t\t\t\t\tif (items.size <= 1 || totalSize - items.size <= 1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst targetGroupCount = (options && options.targetGroupCount) || 4;\n\t\t\t\tlet sizeValue = force\n\t\t\t\t\t? items.size\n\t\t\t\t\t: Math.min(\n\t\t\t\t\t\t\titems.size,\n\t\t\t\t\t\t\t(totalSize * 2) / targetGroupCount +\n\t\t\t\t\t\t\t\titemsWithGroups.size -\n\t\t\t\t\t\t\t\titems.size\n\t\t\t\t\t  );\n\t\t\t\tif (\n\t\t\t\t\tsizeValue > bestGroupSize ||\n\t\t\t\t\t(force && (!bestGroupOptions || !bestGroupOptions.force))\n\t\t\t\t) {\n\t\t\t\t\tbestGroup = group;\n\t\t\t\t\tbestGroupSize = sizeValue;\n\t\t\t\t\tbestGroupItems = items;\n\t\t\t\t\tbestGroupOptions = options;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bestGroup === undefined) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst items = new Set(bestGroupItems);\n\t\t\tconst options = bestGroupOptions;\n\n\t\t\tconst groupChildren = !options || options.groupChildren !== false;\n\n\t\t\tfor (const item of items) {\n\t\t\t\titemsWithGroups.delete(item);\n\t\t\t\t// Remove all groups that items have from the map to not select them again\n\t\t\t\tfor (const group of item.groups) {\n\t\t\t\t\tconst state = groupMap.get(group);\n\t\t\t\t\tif (state !== undefined) {\n\t\t\t\t\t\tstate.items.delete(item);\n\t\t\t\t\t\tif (state.items.size === 0) {\n\t\t\t\t\t\t\tgroupMap.delete(group);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstate.options = undefined;\n\t\t\t\t\t\t\tif (groupChildren) {\n\t\t\t\t\t\t\t\tstate.used = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgroupMap.delete(bestGroup);\n\n\t\t\tconst key = bestGroup.name;\n\t\t\tconst groupConfig = bestGroup.config;\n\n\t\t\tconst allItems = Array.from(items, ({ item }) => item);\n\n\t\t\tbestGroup.alreadyGrouped = true;\n\t\t\tconst children = groupChildren ? runGrouping(items) : allItems;\n\t\t\tbestGroup.alreadyGrouped = false;\n\n\t\t\tresults.push(groupConfig.createGroup(key, children, allItems));\n\t\t}\n\t\tfor (const { item } of itemsWithGroups) {\n\t\t\tresults.push(item);\n\t\t}\n\t\treturn results;\n\t};\n\treturn runGrouping(itemsWithGroups);\n};\n\nmodule.exports = smartGrouping;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}