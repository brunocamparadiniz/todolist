{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nvar _objectSpread = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar createHash = require(\"../util/createHash\");\nvar ArraySerializer = require(\"./ArraySerializer\");\nvar DateObjectSerializer = require(\"./DateObjectSerializer\");\nvar ErrorObjectSerializer = require(\"./ErrorObjectSerializer\");\nvar MapObjectSerializer = require(\"./MapObjectSerializer\");\nvar NullPrototypeObjectSerializer = require(\"./NullPrototypeObjectSerializer\");\nvar PlainObjectSerializer = require(\"./PlainObjectSerializer\");\nvar RegExpObjectSerializer = require(\"./RegExpObjectSerializer\");\nvar SerializerMiddleware = require(\"./SerializerMiddleware\");\nvar SetObjectSerializer = require(\"./SetObjectSerializer\");\n\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n/** @typedef {import(\"./types\").ComplexSerializableType} ComplexSerializableType */\n/** @typedef {import(\"./types\").PrimitiveSerializableType} PrimitiveSerializableType */\n\n/** @typedef {new (...params: any[]) => any} Constructor */\n\n/*\n\nFormat:\n\nFile -> Section*\nSection -> ObjectSection | ReferenceSection | EscapeSection | OtherSection\n\nObjectSection -> ESCAPE (\n\tnumber:relativeOffset (number > 0) |\n\tstring:request (string|null):export\n) Section:value* ESCAPE ESCAPE_END_OBJECT\nReferenceSection -> ESCAPE number:relativeOffset (number < 0)\nEscapeSection -> ESCAPE ESCAPE_ESCAPE_VALUE (escaped value ESCAPE)\nEscapeSection -> ESCAPE ESCAPE_UNDEFINED (escaped value ESCAPE)\nOtherSection -> any (except ESCAPE)\n\nWhy using null as escape value?\nMultiple null values can merged by the BinaryMiddleware, which makes it very efficient\nTechnically any value can be used.\n\n*/\n\n/**\n * @typedef {Object} ObjectSerializerContext\n * @property {function(any): void} write\n */\n\n/**\n * @typedef {Object} ObjectDeserializerContext\n * @property {function(): any} read\n */\n\n/**\n * @typedef {Object} ObjectSerializer\n * @property {function(any, ObjectSerializerContext): void} serialize\n * @property {function(ObjectDeserializerContext): any} deserialize\n */\n\nvar setSetSize = function setSetSize(set, size) {\n  var i = 0;\n  var _iterator = _createForOfIteratorHelper(set),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      if (i++ >= size) {\n        set.delete(item);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\nvar setMapSize = function setMapSize(map, size) {\n  var i = 0;\n  var _iterator2 = _createForOfIteratorHelper(map.keys()),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var item = _step2.value;\n      if (i++ >= size) {\n        map.delete(item);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n};\n\n/**\n * @param {Buffer} buffer buffer\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\nvar toHash = function toHash(buffer, hashFunction) {\n  var hash = createHash(hashFunction);\n  hash.update(buffer);\n  return (/** @type {string} */hash.digest(\"latin1\")\n  );\n};\nvar ESCAPE = null;\nvar ESCAPE_ESCAPE_VALUE = null;\nvar ESCAPE_END_OBJECT = true;\nvar ESCAPE_UNDEFINED = false;\nvar CURRENT_VERSION = 2;\nvar serializers = new Map();\nvar serializerInversed = new Map();\nvar loadedRequests = new Set();\nvar NOT_SERIALIZABLE = {};\nvar jsTypes = new Map();\njsTypes.set(Object, new PlainObjectSerializer());\njsTypes.set(Array, new ArraySerializer());\njsTypes.set(null, new NullPrototypeObjectSerializer());\njsTypes.set(Map, new MapObjectSerializer());\njsTypes.set(Set, new SetObjectSerializer());\njsTypes.set(Date, new DateObjectSerializer());\njsTypes.set(RegExp, new RegExpObjectSerializer());\njsTypes.set(Error, new ErrorObjectSerializer(Error));\njsTypes.set(EvalError, new ErrorObjectSerializer(EvalError));\njsTypes.set(RangeError, new ErrorObjectSerializer(RangeError));\njsTypes.set(ReferenceError, new ErrorObjectSerializer(ReferenceError));\njsTypes.set(SyntaxError, new ErrorObjectSerializer(SyntaxError));\njsTypes.set(TypeError, new ErrorObjectSerializer(TypeError));\n\n// If in a sandboxed environment (e. g. jest), this escapes the sandbox and registers\n// real Object and Array types to. These types may occur in the wild too, e. g. when\n// using Structured Clone in postMessage.\nif (exports.constructor !== Object) {\n  var Obj = /** @type {typeof Object} */exports.constructor;\n  var Fn = /** @type {typeof Function} */Obj.constructor;\n  for (var _i = 0, _Array$from = Array.from(jsTypes); _i < _Array$from.length; _i++) {\n    var _Array$from$_i = _slicedToArray(_Array$from[_i], 2),\n      type = _Array$from$_i[0],\n      config = _Array$from$_i[1];\n    if (type) {\n      var Type = new Fn(\"return \".concat(type.name, \";\"))();\n      jsTypes.set(Type, config);\n    }\n  }\n}\n{\n  var i = 1;\n  var _iterator3 = _createForOfIteratorHelper(jsTypes),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _step3$value = _slicedToArray(_step3.value, 2),\n        _type = _step3$value[0],\n        serializer = _step3$value[1];\n      serializers.set(_type, {\n        request: \"\",\n        name: i++,\n        serializer: serializer\n      });\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n}\nvar _iterator4 = _createForOfIteratorHelper(serializers.values()),\n  _step4;\ntry {\n  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n    var _step4$value = _step4.value,\n      request = _step4$value.request,\n      name = _step4$value.name,\n      _serializer3 = _step4$value.serializer;\n    serializerInversed.set(\"\".concat(request, \"/\").concat(name), _serializer3);\n  }\n\n  /** @type {Map<RegExp, (request: string) => boolean>} */\n} catch (err) {\n  _iterator4.e(err);\n} finally {\n  _iterator4.f();\n}\nvar loaders = new Map();\n\n/**\n * @typedef {ComplexSerializableType[]} DeserializedType\n * @typedef {PrimitiveSerializableType[]} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\nvar ObjectMiddleware = /*#__PURE__*/function (_SerializerMiddleware) {\n  _inherits(ObjectMiddleware, _SerializerMiddleware);\n  var _super = _createSuper(ObjectMiddleware);\n  /**\n   * @param {function(any): void} extendContext context extensions\n   * @param {string | Hash} hashFunction hash function to use\n   */\n  function ObjectMiddleware(extendContext) {\n    var _this;\n    var hashFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"md4\";\n    _classCallCheck(this, ObjectMiddleware);\n    _this = _super.call(this);\n    _this.extendContext = extendContext;\n    _this._hashFunction = hashFunction;\n    return _this;\n  }\n  /**\n   * @param {RegExp} regExp RegExp for which the request is tested\n   * @param {function(string): boolean} loader loader to load the request, returns true when successful\n   * @returns {void}\n   */\n  _createClass(ObjectMiddleware, [{\n    key: \"serialize\",\n    value:\n    /**\n     * @param {DeserializedType} data data\n     * @param {Object} context context object\n     * @returns {SerializedType|Promise<SerializedType>} serialized data\n     */\n    function serialize(data, context) {\n      var _this2 = this;\n      /** @type {any[]} */\n      var result = [CURRENT_VERSION];\n      var currentPos = 0;\n      var referenceable = new Map();\n      var addReferenceable = function addReferenceable(item) {\n        referenceable.set(item, currentPos++);\n      };\n      var bufferDedupeMap = new Map();\n      var dedupeBuffer = function dedupeBuffer(buf) {\n        var len = buf.length;\n        var entry = bufferDedupeMap.get(len);\n        if (entry === undefined) {\n          bufferDedupeMap.set(len, buf);\n          return buf;\n        }\n        if (Buffer.isBuffer(entry)) {\n          if (len < 32) {\n            if (buf.equals(entry)) {\n              return entry;\n            }\n            bufferDedupeMap.set(len, [entry, buf]);\n            return buf;\n          } else {\n            var hash = toHash(entry, _this2._hashFunction);\n            var newMap = new Map();\n            newMap.set(hash, entry);\n            bufferDedupeMap.set(len, newMap);\n            var hashBuf = toHash(buf, _this2._hashFunction);\n            if (hash === hashBuf) {\n              return entry;\n            }\n            return buf;\n          }\n        } else if (Array.isArray(entry)) {\n          if (entry.length < 16) {\n            var _iterator5 = _createForOfIteratorHelper(entry),\n              _step5;\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                var item = _step5.value;\n                if (buf.equals(item)) {\n                  return item;\n                }\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n            entry.push(buf);\n            return buf;\n          } else {\n            var _newMap = new Map();\n            var _hash = toHash(buf, _this2._hashFunction);\n            var found;\n            var _iterator6 = _createForOfIteratorHelper(entry),\n              _step6;\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var _item = _step6.value;\n                var itemHash = toHash(_item, _this2._hashFunction);\n                _newMap.set(itemHash, _item);\n                if (found === undefined && itemHash === _hash) found = _item;\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n            bufferDedupeMap.set(len, _newMap);\n            if (found === undefined) {\n              _newMap.set(_hash, buf);\n              return buf;\n            } else {\n              return found;\n            }\n          }\n        } else {\n          var _hash2 = toHash(buf, _this2._hashFunction);\n          var _item2 = entry.get(_hash2);\n          if (_item2 !== undefined) {\n            return _item2;\n          }\n          entry.set(_hash2, buf);\n          return buf;\n        }\n      };\n      var currentPosTypeLookup = 0;\n      var objectTypeLookup = new Map();\n      var cycleStack = new Set();\n      var stackToString = function stackToString(item) {\n        var arr = Array.from(cycleStack);\n        arr.push(item);\n        return arr.map(function (item) {\n          if (typeof item === \"string\") {\n            if (item.length > 100) {\n              return \"String \".concat(JSON.stringify(item.slice(0, 100)).slice(0, -1), \"...\\\"\");\n            }\n            return \"String \".concat(JSON.stringify(item));\n          }\n          try {\n            var _ObjectMiddleware$get = ObjectMiddleware.getSerializerFor(item),\n              request = _ObjectMiddleware$get.request,\n              name = _ObjectMiddleware$get.name;\n            if (request) {\n              return \"\".concat(request).concat(name ? \".\".concat(name) : \"\");\n            }\n          } catch (e) {\n            // ignore -> fallback\n          }\n          if (typeof item === \"object\" && item !== null) {\n            if (item.constructor) {\n              if (item.constructor === Object) return \"Object { \".concat(Object.keys(item).join(\", \"), \" }\");\n              if (item.constructor === Map) return \"Map { \".concat(item.size, \" items }\");\n              if (item.constructor === Array) return \"Array { \".concat(item.length, \" items }\");\n              if (item.constructor === Set) return \"Set { \".concat(item.size, \" items }\");\n              if (item.constructor === RegExp) return item.toString();\n              return \"\".concat(item.constructor.name);\n            }\n            return \"Object [null prototype] { \".concat(Object.keys(item).join(\", \"), \" }\");\n          }\n          try {\n            return \"\".concat(item);\n          } catch (e) {\n            return \"(\".concat(e.message, \")\");\n          }\n        }).join(\" -> \");\n      };\n      var hasDebugInfoAttached;\n      var ctx = _objectSpread({\n        write: function write(value, key) {\n          try {\n            process(value);\n          } catch (e) {\n            if (e !== NOT_SERIALIZABLE) {\n              if (hasDebugInfoAttached === undefined) hasDebugInfoAttached = new WeakSet();\n              if (!hasDebugInfoAttached.has(e)) {\n                e.message += \"\\nwhile serializing \".concat(stackToString(value));\n                hasDebugInfoAttached.add(e);\n              }\n            }\n            throw e;\n          }\n        },\n        setCircularReference: function setCircularReference(ref) {\n          addReferenceable(ref);\n        },\n        snapshot: function snapshot() {\n          return {\n            length: result.length,\n            cycleStackSize: cycleStack.size,\n            referenceableSize: referenceable.size,\n            currentPos: currentPos,\n            objectTypeLookupSize: objectTypeLookup.size,\n            currentPosTypeLookup: currentPosTypeLookup\n          };\n        },\n        rollback: function rollback(snapshot) {\n          result.length = snapshot.length;\n          setSetSize(cycleStack, snapshot.cycleStackSize);\n          setMapSize(referenceable, snapshot.referenceableSize);\n          currentPos = snapshot.currentPos;\n          setMapSize(objectTypeLookup, snapshot.objectTypeLookupSize);\n          currentPosTypeLookup = snapshot.currentPosTypeLookup;\n        }\n      }, context);\n      this.extendContext(ctx);\n      var process = function process(item) {\n        if (Buffer.isBuffer(item)) {\n          // check if we can emit a reference\n          var ref = referenceable.get(item);\n          if (ref !== undefined) {\n            result.push(ESCAPE, ref - currentPos);\n            return;\n          }\n          var alreadyUsedBuffer = dedupeBuffer(item);\n          if (alreadyUsedBuffer !== item) {\n            var _ref = referenceable.get(alreadyUsedBuffer);\n            if (_ref !== undefined) {\n              referenceable.set(item, _ref);\n              result.push(ESCAPE, _ref - currentPos);\n              return;\n            }\n            item = alreadyUsedBuffer;\n          }\n          addReferenceable(item);\n          result.push(item);\n        } else if (item === ESCAPE) {\n          result.push(ESCAPE, ESCAPE_ESCAPE_VALUE);\n        } else if (typeof item === \"object\"\n        // We don't have to check for null as ESCAPE is null and this has been checked before\n        ) {\n          // check if we can emit a reference\n          var _ref2 = referenceable.get(item);\n          if (_ref2 !== undefined) {\n            result.push(ESCAPE, _ref2 - currentPos);\n            return;\n          }\n          if (cycleStack.has(item)) {\n            throw new Error(\"This is a circular references. To serialize circular references use 'setCircularReference' somewhere in the circle during serialize and deserialize.\");\n          }\n          var _ObjectMiddleware$get2 = ObjectMiddleware.getSerializerFor(item),\n            request = _ObjectMiddleware$get2.request,\n            name = _ObjectMiddleware$get2.name,\n            _serializer = _ObjectMiddleware$get2.serializer;\n          var key = \"\".concat(request, \"/\").concat(name);\n          var lastIndex = objectTypeLookup.get(key);\n          if (lastIndex === undefined) {\n            objectTypeLookup.set(key, currentPosTypeLookup++);\n            result.push(ESCAPE, request, name);\n          } else {\n            result.push(ESCAPE, currentPosTypeLookup - lastIndex);\n          }\n          cycleStack.add(item);\n          try {\n            _serializer.serialize(item, ctx);\n          } finally {\n            cycleStack.delete(item);\n          }\n          result.push(ESCAPE, ESCAPE_END_OBJECT);\n          addReferenceable(item);\n        } else if (typeof item === \"string\") {\n          if (item.length > 1) {\n            // short strings are shorter when not emitting a reference (this saves 1 byte per empty string)\n            // check if we can emit a reference\n            var _ref3 = referenceable.get(item);\n            if (_ref3 !== undefined) {\n              result.push(ESCAPE, _ref3 - currentPos);\n              return;\n            }\n            addReferenceable(item);\n          }\n          if (item.length > 102400 && context.logger) {\n            context.logger.warn(\"Serializing big strings (\".concat(Math.round(item.length / 1024), \"kiB) impacts deserialization performance (consider using Buffer instead and decode when needed)\"));\n          }\n          result.push(item);\n        } else if (typeof item === \"function\") {\n          if (!SerializerMiddleware.isLazy(item)) throw new Error(\"Unexpected function \" + item);\n          /** @type {SerializedType} */\n          var serializedData = SerializerMiddleware.getLazySerializedValue(item);\n          if (serializedData !== undefined) {\n            if (typeof serializedData === \"function\") {\n              result.push(serializedData);\n            } else {\n              throw new Error(\"Not implemented\");\n            }\n          } else if (SerializerMiddleware.isLazy(item, _this2)) {\n            throw new Error(\"Not implemented\");\n          } else {\n            var _data = SerializerMiddleware.serializeLazy(item, function (data) {\n              return _this2.serialize([data], context);\n            });\n            SerializerMiddleware.setLazySerializedValue(item, _data);\n            result.push(_data);\n          }\n        } else if (item === undefined) {\n          result.push(ESCAPE, ESCAPE_UNDEFINED);\n        } else {\n          result.push(item);\n        }\n      };\n      try {\n        var _iterator7 = _createForOfIteratorHelper(data),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var item = _step7.value;\n            process(item);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n        return result;\n      } catch (e) {\n        if (e === NOT_SERIALIZABLE) return null;\n        throw e;\n      } finally {\n        // Get rid of these references to avoid leaking memory\n        // This happens because the optimized code v8 generates\n        // is optimized for our \"ctx.write\" method so it will reference\n        // it from e. g. Dependency.prototype.serialize -(IC)-> ctx.write\n        data = result = referenceable = bufferDedupeMap = objectTypeLookup = ctx = undefined;\n      }\n    }\n\n    /**\n     * @param {SerializedType} data data\n     * @param {Object} context context object\n     * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n     */\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data, context) {\n      var _this3 = this;\n      var currentDataPos = 0;\n      var read = function read() {\n        if (currentDataPos >= data.length) throw new Error(\"Unexpected end of stream\");\n        return data[currentDataPos++];\n      };\n      if (read() !== CURRENT_VERSION) throw new Error(\"Version mismatch, serializer changed\");\n      var currentPos = 0;\n      var referenceable = [];\n      var addReferenceable = function addReferenceable(item) {\n        referenceable.push(item);\n        currentPos++;\n      };\n      var currentPosTypeLookup = 0;\n      var objectTypeLookup = [];\n      var result = [];\n      var ctx = _objectSpread({\n        read: function read() {\n          return decodeValue();\n        },\n        setCircularReference: function setCircularReference(ref) {\n          addReferenceable(ref);\n        }\n      }, context);\n      this.extendContext(ctx);\n      var decodeValue = function decodeValue() {\n        var item = read();\n        if (item === ESCAPE) {\n          var nextItem = read();\n          if (nextItem === ESCAPE_ESCAPE_VALUE) {\n            return ESCAPE;\n          } else if (nextItem === ESCAPE_UNDEFINED) {\n            return undefined;\n          } else if (nextItem === ESCAPE_END_OBJECT) {\n            throw new Error(\"Unexpected end of object at position \".concat(currentDataPos - 1));\n          } else {\n            var request = nextItem;\n            var _serializer2;\n            if (typeof request === \"number\") {\n              if (request < 0) {\n                // relative reference\n                return referenceable[currentPos + request];\n              }\n              _serializer2 = objectTypeLookup[currentPosTypeLookup - request];\n            } else {\n              if (typeof request !== \"string\") {\n                throw new Error(\"Unexpected type (\".concat(typeof request, \") of request \") + \"at position \".concat(currentDataPos - 1));\n              }\n              var name = read();\n              _serializer2 = ObjectMiddleware._getDeserializerForWithoutError(request, name);\n              if (_serializer2 === undefined) {\n                if (request && !loadedRequests.has(request)) {\n                  var loaded = false;\n                  var _iterator8 = _createForOfIteratorHelper(loaders),\n                    _step8;\n                  try {\n                    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                      var _step8$value = _slicedToArray(_step8.value, 2),\n                        regExp = _step8$value[0],\n                        loader = _step8$value[1];\n                      if (regExp.test(request)) {\n                        if (loader(request)) {\n                          loaded = true;\n                          break;\n                        }\n                      }\n                    }\n                  } catch (err) {\n                    _iterator8.e(err);\n                  } finally {\n                    _iterator8.f();\n                  }\n                  if (!loaded) {\n                    require(request);\n                  }\n                  loadedRequests.add(request);\n                }\n                _serializer2 = ObjectMiddleware.getDeserializerFor(request, name);\n              }\n              objectTypeLookup.push(_serializer2);\n              currentPosTypeLookup++;\n            }\n            try {\n              var _item3 = _serializer2.deserialize(ctx);\n              var end1 = read();\n              if (end1 !== ESCAPE) {\n                throw new Error(\"Expected end of object\");\n              }\n              var end2 = read();\n              if (end2 !== ESCAPE_END_OBJECT) {\n                throw new Error(\"Expected end of object\");\n              }\n              addReferenceable(_item3);\n              return _item3;\n            } catch (err) {\n              // As this is only for error handling, we omit creating a Map for\n              // faster access to this information, as this would affect performance\n              // in the good case\n              var serializerEntry;\n              var _iterator9 = _createForOfIteratorHelper(serializers),\n                _step9;\n              try {\n                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                  var entry = _step9.value;\n                  if (entry[1].serializer === _serializer2) {\n                    serializerEntry = entry;\n                    break;\n                  }\n                }\n              } catch (err) {\n                _iterator9.e(err);\n              } finally {\n                _iterator9.f();\n              }\n              var _name = !serializerEntry ? \"unknown\" : !serializerEntry[1].request ? serializerEntry[0].name : serializerEntry[1].name ? \"\".concat(serializerEntry[1].request, \" \").concat(serializerEntry[1].name) : serializerEntry[1].request;\n              err.message += \"\\n(during deserialization of \".concat(_name, \")\");\n              throw err;\n            }\n          }\n        } else if (typeof item === \"string\") {\n          if (item.length > 1) {\n            addReferenceable(item);\n          }\n          return item;\n        } else if (Buffer.isBuffer(item)) {\n          addReferenceable(item);\n          return item;\n        } else if (typeof item === \"function\") {\n          return SerializerMiddleware.deserializeLazy(item, function (data) {\n            return _this3.deserialize(data, context)[0];\n          });\n        } else {\n          return item;\n        }\n      };\n      try {\n        while (currentDataPos < data.length) {\n          result.push(decodeValue());\n        }\n        return result;\n      } finally {\n        // Get rid of these references to avoid leaking memory\n        // This happens because the optimized code v8 generates\n        // is optimized for our \"ctx.read\" method so it will reference\n        // it from e. g. Dependency.prototype.deserialize -(IC)-> ctx.read\n        result = referenceable = data = objectTypeLookup = ctx = undefined;\n      }\n    }\n  }], [{\n    key: \"registerLoader\",\n    value: function registerLoader(regExp, loader) {\n      loaders.set(regExp, loader);\n    }\n\n    /**\n     * @param {Constructor} Constructor the constructor\n     * @param {string} request the request which will be required when deserializing\n     * @param {string} name the name to make multiple serializer unique when sharing a request\n     * @param {ObjectSerializer} serializer the serializer\n     * @returns {void}\n     */\n  }, {\n    key: \"register\",\n    value: function register(Constructor, request, name, serializer) {\n      var key = request + \"/\" + name;\n      if (serializers.has(Constructor)) {\n        throw new Error(\"ObjectMiddleware.register: serializer for \".concat(Constructor.name, \" is already registered\"));\n      }\n      if (serializerInversed.has(key)) {\n        throw new Error(\"ObjectMiddleware.register: serializer for \".concat(key, \" is already registered\"));\n      }\n      serializers.set(Constructor, {\n        request: request,\n        name: name,\n        serializer: serializer\n      });\n      serializerInversed.set(key, serializer);\n    }\n\n    /**\n     * @param {Constructor} Constructor the constructor\n     * @returns {void}\n     */\n  }, {\n    key: \"registerNotSerializable\",\n    value: function registerNotSerializable(Constructor) {\n      if (serializers.has(Constructor)) {\n        throw new Error(\"ObjectMiddleware.registerNotSerializable: serializer for \".concat(Constructor.name, \" is already registered\"));\n      }\n      serializers.set(Constructor, NOT_SERIALIZABLE);\n    }\n  }, {\n    key: \"getSerializerFor\",\n    value: function getSerializerFor(object) {\n      var proto = Object.getPrototypeOf(object);\n      var c;\n      if (proto === null) {\n        // Object created with Object.create(null)\n        c = null;\n      } else {\n        c = proto.constructor;\n        if (!c) {\n          throw new Error(\"Serialization of objects with prototype without valid constructor property not possible\");\n        }\n      }\n      var config = serializers.get(c);\n      if (!config) throw new Error(\"No serializer registered for \".concat(c.name));\n      if (config === NOT_SERIALIZABLE) throw NOT_SERIALIZABLE;\n      return config;\n    }\n  }, {\n    key: \"getDeserializerFor\",\n    value: function getDeserializerFor(request, name) {\n      var key = request + \"/\" + name;\n      var serializer = serializerInversed.get(key);\n      if (serializer === undefined) {\n        throw new Error(\"No deserializer registered for \".concat(key));\n      }\n      return serializer;\n    }\n  }, {\n    key: \"_getDeserializerForWithoutError\",\n    value: function _getDeserializerForWithoutError(request, name) {\n      var key = request + \"/\" + name;\n      var serializer = serializerInversed.get(key);\n      return serializer;\n    }\n  }]);\n  return ObjectMiddleware;\n}(SerializerMiddleware);\nmodule.exports = ObjectMiddleware;\nmodule.exports.NOT_SERIALIZABLE = NOT_SERIALIZABLE;","map":{"version":3,"names":["createHash","require","ArraySerializer","DateObjectSerializer","ErrorObjectSerializer","MapObjectSerializer","NullPrototypeObjectSerializer","PlainObjectSerializer","RegExpObjectSerializer","SerializerMiddleware","SetObjectSerializer","setSetSize","set","size","i","item","delete","setMapSize","map","keys","toHash","buffer","hashFunction","hash","update","digest","ESCAPE","ESCAPE_ESCAPE_VALUE","ESCAPE_END_OBJECT","ESCAPE_UNDEFINED","CURRENT_VERSION","serializers","Map","serializerInversed","loadedRequests","Set","NOT_SERIALIZABLE","jsTypes","Object","Array","Date","RegExp","Error","EvalError","RangeError","ReferenceError","SyntaxError","TypeError","exports","constructor","Obj","Fn","from","type","config","Type","name","serializer","request","values","loaders","ObjectMiddleware","extendContext","_hashFunction","data","context","result","currentPos","referenceable","addReferenceable","bufferDedupeMap","dedupeBuffer","buf","len","length","entry","get","undefined","Buffer","isBuffer","equals","newMap","hashBuf","isArray","push","found","itemHash","currentPosTypeLookup","objectTypeLookup","cycleStack","stackToString","arr","JSON","stringify","slice","getSerializerFor","e","join","toString","message","hasDebugInfoAttached","ctx","write","value","key","process","WeakSet","has","add","setCircularReference","ref","snapshot","cycleStackSize","referenceableSize","objectTypeLookupSize","rollback","alreadyUsedBuffer","lastIndex","serialize","logger","warn","Math","round","isLazy","serializedData","getLazySerializedValue","serializeLazy","setLazySerializedValue","currentDataPos","read","decodeValue","nextItem","_getDeserializerForWithoutError","loaded","regExp","loader","test","getDeserializerFor","deserialize","end1","end2","err","serializerEntry","deserializeLazy","Constructor","object","proto","getPrototypeOf","c","module"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/serialization/ObjectMiddleware.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst createHash = require(\"../util/createHash\");\nconst ArraySerializer = require(\"./ArraySerializer\");\nconst DateObjectSerializer = require(\"./DateObjectSerializer\");\nconst ErrorObjectSerializer = require(\"./ErrorObjectSerializer\");\nconst MapObjectSerializer = require(\"./MapObjectSerializer\");\nconst NullPrototypeObjectSerializer = require(\"./NullPrototypeObjectSerializer\");\nconst PlainObjectSerializer = require(\"./PlainObjectSerializer\");\nconst RegExpObjectSerializer = require(\"./RegExpObjectSerializer\");\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\nconst SetObjectSerializer = require(\"./SetObjectSerializer\");\n\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n/** @typedef {import(\"./types\").ComplexSerializableType} ComplexSerializableType */\n/** @typedef {import(\"./types\").PrimitiveSerializableType} PrimitiveSerializableType */\n\n/** @typedef {new (...params: any[]) => any} Constructor */\n\n/*\n\nFormat:\n\nFile -> Section*\nSection -> ObjectSection | ReferenceSection | EscapeSection | OtherSection\n\nObjectSection -> ESCAPE (\n\tnumber:relativeOffset (number > 0) |\n\tstring:request (string|null):export\n) Section:value* ESCAPE ESCAPE_END_OBJECT\nReferenceSection -> ESCAPE number:relativeOffset (number < 0)\nEscapeSection -> ESCAPE ESCAPE_ESCAPE_VALUE (escaped value ESCAPE)\nEscapeSection -> ESCAPE ESCAPE_UNDEFINED (escaped value ESCAPE)\nOtherSection -> any (except ESCAPE)\n\nWhy using null as escape value?\nMultiple null values can merged by the BinaryMiddleware, which makes it very efficient\nTechnically any value can be used.\n\n*/\n\n/**\n * @typedef {Object} ObjectSerializerContext\n * @property {function(any): void} write\n */\n\n/**\n * @typedef {Object} ObjectDeserializerContext\n * @property {function(): any} read\n */\n\n/**\n * @typedef {Object} ObjectSerializer\n * @property {function(any, ObjectSerializerContext): void} serialize\n * @property {function(ObjectDeserializerContext): any} deserialize\n */\n\nconst setSetSize = (set, size) => {\n\tlet i = 0;\n\tfor (const item of set) {\n\t\tif (i++ >= size) {\n\t\t\tset.delete(item);\n\t\t}\n\t}\n};\n\nconst setMapSize = (map, size) => {\n\tlet i = 0;\n\tfor (const item of map.keys()) {\n\t\tif (i++ >= size) {\n\t\t\tmap.delete(item);\n\t\t}\n\t}\n};\n\n/**\n * @param {Buffer} buffer buffer\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\nconst toHash = (buffer, hashFunction) => {\n\tconst hash = createHash(hashFunction);\n\thash.update(buffer);\n\treturn /** @type {string} */ (hash.digest(\"latin1\"));\n};\n\nconst ESCAPE = null;\nconst ESCAPE_ESCAPE_VALUE = null;\nconst ESCAPE_END_OBJECT = true;\nconst ESCAPE_UNDEFINED = false;\n\nconst CURRENT_VERSION = 2;\n\nconst serializers = new Map();\nconst serializerInversed = new Map();\n\nconst loadedRequests = new Set();\n\nconst NOT_SERIALIZABLE = {};\n\nconst jsTypes = new Map();\njsTypes.set(Object, new PlainObjectSerializer());\njsTypes.set(Array, new ArraySerializer());\njsTypes.set(null, new NullPrototypeObjectSerializer());\njsTypes.set(Map, new MapObjectSerializer());\njsTypes.set(Set, new SetObjectSerializer());\njsTypes.set(Date, new DateObjectSerializer());\njsTypes.set(RegExp, new RegExpObjectSerializer());\njsTypes.set(Error, new ErrorObjectSerializer(Error));\njsTypes.set(EvalError, new ErrorObjectSerializer(EvalError));\njsTypes.set(RangeError, new ErrorObjectSerializer(RangeError));\njsTypes.set(ReferenceError, new ErrorObjectSerializer(ReferenceError));\njsTypes.set(SyntaxError, new ErrorObjectSerializer(SyntaxError));\njsTypes.set(TypeError, new ErrorObjectSerializer(TypeError));\n\n// If in a sandboxed environment (e. g. jest), this escapes the sandbox and registers\n// real Object and Array types to. These types may occur in the wild too, e. g. when\n// using Structured Clone in postMessage.\nif (exports.constructor !== Object) {\n\tconst Obj = /** @type {typeof Object} */ (exports.constructor);\n\tconst Fn = /** @type {typeof Function} */ (Obj.constructor);\n\tfor (const [type, config] of Array.from(jsTypes)) {\n\t\tif (type) {\n\t\t\tconst Type = new Fn(`return ${type.name};`)();\n\t\t\tjsTypes.set(Type, config);\n\t\t}\n\t}\n}\n\n{\n\tlet i = 1;\n\tfor (const [type, serializer] of jsTypes) {\n\t\tserializers.set(type, {\n\t\t\trequest: \"\",\n\t\t\tname: i++,\n\t\t\tserializer\n\t\t});\n\t}\n}\n\nfor (const { request, name, serializer } of serializers.values()) {\n\tserializerInversed.set(`${request}/${name}`, serializer);\n}\n\n/** @type {Map<RegExp, (request: string) => boolean>} */\nconst loaders = new Map();\n\n/**\n * @typedef {ComplexSerializableType[]} DeserializedType\n * @typedef {PrimitiveSerializableType[]} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\nclass ObjectMiddleware extends SerializerMiddleware {\n\t/**\n\t * @param {function(any): void} extendContext context extensions\n\t * @param {string | Hash} hashFunction hash function to use\n\t */\n\tconstructor(extendContext, hashFunction = \"md4\") {\n\t\tsuper();\n\t\tthis.extendContext = extendContext;\n\t\tthis._hashFunction = hashFunction;\n\t}\n\t/**\n\t * @param {RegExp} regExp RegExp for which the request is tested\n\t * @param {function(string): boolean} loader loader to load the request, returns true when successful\n\t * @returns {void}\n\t */\n\tstatic registerLoader(regExp, loader) {\n\t\tloaders.set(regExp, loader);\n\t}\n\n\t/**\n\t * @param {Constructor} Constructor the constructor\n\t * @param {string} request the request which will be required when deserializing\n\t * @param {string} name the name to make multiple serializer unique when sharing a request\n\t * @param {ObjectSerializer} serializer the serializer\n\t * @returns {void}\n\t */\n\tstatic register(Constructor, request, name, serializer) {\n\t\tconst key = request + \"/\" + name;\n\n\t\tif (serializers.has(Constructor)) {\n\t\t\tthrow new Error(\n\t\t\t\t`ObjectMiddleware.register: serializer for ${Constructor.name} is already registered`\n\t\t\t);\n\t\t}\n\n\t\tif (serializerInversed.has(key)) {\n\t\t\tthrow new Error(\n\t\t\t\t`ObjectMiddleware.register: serializer for ${key} is already registered`\n\t\t\t);\n\t\t}\n\n\t\tserializers.set(Constructor, {\n\t\t\trequest,\n\t\t\tname,\n\t\t\tserializer\n\t\t});\n\n\t\tserializerInversed.set(key, serializer);\n\t}\n\n\t/**\n\t * @param {Constructor} Constructor the constructor\n\t * @returns {void}\n\t */\n\tstatic registerNotSerializable(Constructor) {\n\t\tif (serializers.has(Constructor)) {\n\t\t\tthrow new Error(\n\t\t\t\t`ObjectMiddleware.registerNotSerializable: serializer for ${Constructor.name} is already registered`\n\t\t\t);\n\t\t}\n\n\t\tserializers.set(Constructor, NOT_SERIALIZABLE);\n\t}\n\n\tstatic getSerializerFor(object) {\n\t\tconst proto = Object.getPrototypeOf(object);\n\t\tlet c;\n\t\tif (proto === null) {\n\t\t\t// Object created with Object.create(null)\n\t\t\tc = null;\n\t\t} else {\n\t\t\tc = proto.constructor;\n\t\t\tif (!c) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Serialization of objects with prototype without valid constructor property not possible\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tconst config = serializers.get(c);\n\n\t\tif (!config) throw new Error(`No serializer registered for ${c.name}`);\n\t\tif (config === NOT_SERIALIZABLE) throw NOT_SERIALIZABLE;\n\n\t\treturn config;\n\t}\n\n\tstatic getDeserializerFor(request, name) {\n\t\tconst key = request + \"/\" + name;\n\t\tconst serializer = serializerInversed.get(key);\n\n\t\tif (serializer === undefined) {\n\t\t\tthrow new Error(`No deserializer registered for ${key}`);\n\t\t}\n\n\t\treturn serializer;\n\t}\n\n\tstatic _getDeserializerForWithoutError(request, name) {\n\t\tconst key = request + \"/\" + name;\n\t\tconst serializer = serializerInversed.get(key);\n\t\treturn serializer;\n\t}\n\n\t/**\n\t * @param {DeserializedType} data data\n\t * @param {Object} context context object\n\t * @returns {SerializedType|Promise<SerializedType>} serialized data\n\t */\n\tserialize(data, context) {\n\t\t/** @type {any[]} */\n\t\tlet result = [CURRENT_VERSION];\n\t\tlet currentPos = 0;\n\t\tlet referenceable = new Map();\n\t\tconst addReferenceable = item => {\n\t\t\treferenceable.set(item, currentPos++);\n\t\t};\n\t\tlet bufferDedupeMap = new Map();\n\t\tconst dedupeBuffer = buf => {\n\t\t\tconst len = buf.length;\n\t\t\tconst entry = bufferDedupeMap.get(len);\n\t\t\tif (entry === undefined) {\n\t\t\t\tbufferDedupeMap.set(len, buf);\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t\tif (Buffer.isBuffer(entry)) {\n\t\t\t\tif (len < 32) {\n\t\t\t\t\tif (buf.equals(entry)) {\n\t\t\t\t\t\treturn entry;\n\t\t\t\t\t}\n\t\t\t\t\tbufferDedupeMap.set(len, [entry, buf]);\n\t\t\t\t\treturn buf;\n\t\t\t\t} else {\n\t\t\t\t\tconst hash = toHash(entry, this._hashFunction);\n\t\t\t\t\tconst newMap = new Map();\n\t\t\t\t\tnewMap.set(hash, entry);\n\t\t\t\t\tbufferDedupeMap.set(len, newMap);\n\t\t\t\t\tconst hashBuf = toHash(buf, this._hashFunction);\n\t\t\t\t\tif (hash === hashBuf) {\n\t\t\t\t\t\treturn entry;\n\t\t\t\t\t}\n\t\t\t\t\treturn buf;\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(entry)) {\n\t\t\t\tif (entry.length < 16) {\n\t\t\t\t\tfor (const item of entry) {\n\t\t\t\t\t\tif (buf.equals(item)) {\n\t\t\t\t\t\t\treturn item;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tentry.push(buf);\n\t\t\t\t\treturn buf;\n\t\t\t\t} else {\n\t\t\t\t\tconst newMap = new Map();\n\t\t\t\t\tconst hash = toHash(buf, this._hashFunction);\n\t\t\t\t\tlet found;\n\t\t\t\t\tfor (const item of entry) {\n\t\t\t\t\t\tconst itemHash = toHash(item, this._hashFunction);\n\t\t\t\t\t\tnewMap.set(itemHash, item);\n\t\t\t\t\t\tif (found === undefined && itemHash === hash) found = item;\n\t\t\t\t\t}\n\t\t\t\t\tbufferDedupeMap.set(len, newMap);\n\t\t\t\t\tif (found === undefined) {\n\t\t\t\t\t\tnewMap.set(hash, buf);\n\t\t\t\t\t\treturn buf;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn found;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst hash = toHash(buf, this._hashFunction);\n\t\t\t\tconst item = entry.get(hash);\n\t\t\t\tif (item !== undefined) {\n\t\t\t\t\treturn item;\n\t\t\t\t}\n\t\t\t\tentry.set(hash, buf);\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t};\n\t\tlet currentPosTypeLookup = 0;\n\t\tlet objectTypeLookup = new Map();\n\t\tconst cycleStack = new Set();\n\t\tconst stackToString = item => {\n\t\t\tconst arr = Array.from(cycleStack);\n\t\t\tarr.push(item);\n\t\t\treturn arr\n\t\t\t\t.map(item => {\n\t\t\t\t\tif (typeof item === \"string\") {\n\t\t\t\t\t\tif (item.length > 100) {\n\t\t\t\t\t\t\treturn `String ${JSON.stringify(item.slice(0, 100)).slice(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t-1\n\t\t\t\t\t\t\t)}...\"`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn `String ${JSON.stringify(item)}`;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst { request, name } = ObjectMiddleware.getSerializerFor(item);\n\t\t\t\t\t\tif (request) {\n\t\t\t\t\t\t\treturn `${request}${name ? `.${name}` : \"\"}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// ignore -> fallback\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof item === \"object\" && item !== null) {\n\t\t\t\t\t\tif (item.constructor) {\n\t\t\t\t\t\t\tif (item.constructor === Object)\n\t\t\t\t\t\t\t\treturn `Object { ${Object.keys(item).join(\", \")} }`;\n\t\t\t\t\t\t\tif (item.constructor === Map) return `Map { ${item.size} items }`;\n\t\t\t\t\t\t\tif (item.constructor === Array)\n\t\t\t\t\t\t\t\treturn `Array { ${item.length} items }`;\n\t\t\t\t\t\t\tif (item.constructor === Set) return `Set { ${item.size} items }`;\n\t\t\t\t\t\t\tif (item.constructor === RegExp) return item.toString();\n\t\t\t\t\t\t\treturn `${item.constructor.name}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn `Object [null prototype] { ${Object.keys(item).join(\n\t\t\t\t\t\t\t\", \"\n\t\t\t\t\t\t)} }`;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn `${item}`;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn `(${e.message})`;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.join(\" -> \");\n\t\t};\n\t\tlet hasDebugInfoAttached;\n\t\tlet ctx = {\n\t\t\twrite(value, key) {\n\t\t\t\ttry {\n\t\t\t\t\tprocess(value);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e !== NOT_SERIALIZABLE) {\n\t\t\t\t\t\tif (hasDebugInfoAttached === undefined)\n\t\t\t\t\t\t\thasDebugInfoAttached = new WeakSet();\n\t\t\t\t\t\tif (!hasDebugInfoAttached.has(e)) {\n\t\t\t\t\t\t\te.message += `\\nwhile serializing ${stackToString(value)}`;\n\t\t\t\t\t\t\thasDebugInfoAttached.add(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t},\n\t\t\tsetCircularReference(ref) {\n\t\t\t\taddReferenceable(ref);\n\t\t\t},\n\t\t\tsnapshot() {\n\t\t\t\treturn {\n\t\t\t\t\tlength: result.length,\n\t\t\t\t\tcycleStackSize: cycleStack.size,\n\t\t\t\t\treferenceableSize: referenceable.size,\n\t\t\t\t\tcurrentPos,\n\t\t\t\t\tobjectTypeLookupSize: objectTypeLookup.size,\n\t\t\t\t\tcurrentPosTypeLookup\n\t\t\t\t};\n\t\t\t},\n\t\t\trollback(snapshot) {\n\t\t\t\tresult.length = snapshot.length;\n\t\t\t\tsetSetSize(cycleStack, snapshot.cycleStackSize);\n\t\t\t\tsetMapSize(referenceable, snapshot.referenceableSize);\n\t\t\t\tcurrentPos = snapshot.currentPos;\n\t\t\t\tsetMapSize(objectTypeLookup, snapshot.objectTypeLookupSize);\n\t\t\t\tcurrentPosTypeLookup = snapshot.currentPosTypeLookup;\n\t\t\t},\n\t\t\t...context\n\t\t};\n\t\tthis.extendContext(ctx);\n\t\tconst process = item => {\n\t\t\tif (Buffer.isBuffer(item)) {\n\t\t\t\t// check if we can emit a reference\n\t\t\t\tconst ref = referenceable.get(item);\n\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst alreadyUsedBuffer = dedupeBuffer(item);\n\t\t\t\tif (alreadyUsedBuffer !== item) {\n\t\t\t\t\tconst ref = referenceable.get(alreadyUsedBuffer);\n\t\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\t\treferenceable.set(item, ref);\n\t\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\titem = alreadyUsedBuffer;\n\t\t\t\t}\n\t\t\t\taddReferenceable(item);\n\n\t\t\t\tresult.push(item);\n\t\t\t} else if (item === ESCAPE) {\n\t\t\t\tresult.push(ESCAPE, ESCAPE_ESCAPE_VALUE);\n\t\t\t} else if (\n\t\t\t\ttypeof item === \"object\"\n\t\t\t\t// We don't have to check for null as ESCAPE is null and this has been checked before\n\t\t\t) {\n\t\t\t\t// check if we can emit a reference\n\t\t\t\tconst ref = referenceable.get(item);\n\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (cycleStack.has(item)) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`This is a circular references. To serialize circular references use 'setCircularReference' somewhere in the circle during serialize and deserialize.`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst { request, name, serializer } =\n\t\t\t\t\tObjectMiddleware.getSerializerFor(item);\n\t\t\t\tconst key = `${request}/${name}`;\n\t\t\t\tconst lastIndex = objectTypeLookup.get(key);\n\n\t\t\t\tif (lastIndex === undefined) {\n\t\t\t\t\tobjectTypeLookup.set(key, currentPosTypeLookup++);\n\n\t\t\t\t\tresult.push(ESCAPE, request, name);\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(ESCAPE, currentPosTypeLookup - lastIndex);\n\t\t\t\t}\n\n\t\t\t\tcycleStack.add(item);\n\n\t\t\t\ttry {\n\t\t\t\t\tserializer.serialize(item, ctx);\n\t\t\t\t} finally {\n\t\t\t\t\tcycleStack.delete(item);\n\t\t\t\t}\n\n\t\t\t\tresult.push(ESCAPE, ESCAPE_END_OBJECT);\n\n\t\t\t\taddReferenceable(item);\n\t\t\t} else if (typeof item === \"string\") {\n\t\t\t\tif (item.length > 1) {\n\t\t\t\t\t// short strings are shorter when not emitting a reference (this saves 1 byte per empty string)\n\t\t\t\t\t// check if we can emit a reference\n\t\t\t\t\tconst ref = referenceable.get(item);\n\t\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\taddReferenceable(item);\n\t\t\t\t}\n\n\t\t\t\tif (item.length > 102400 && context.logger) {\n\t\t\t\t\tcontext.logger.warn(\n\t\t\t\t\t\t`Serializing big strings (${Math.round(\n\t\t\t\t\t\t\titem.length / 1024\n\t\t\t\t\t\t)}kiB) impacts deserialization performance (consider using Buffer instead and decode when needed)`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tresult.push(item);\n\t\t\t} else if (typeof item === \"function\") {\n\t\t\t\tif (!SerializerMiddleware.isLazy(item))\n\t\t\t\t\tthrow new Error(\"Unexpected function \" + item);\n\t\t\t\t/** @type {SerializedType} */\n\t\t\t\tconst serializedData =\n\t\t\t\t\tSerializerMiddleware.getLazySerializedValue(item);\n\t\t\t\tif (serializedData !== undefined) {\n\t\t\t\t\tif (typeof serializedData === \"function\") {\n\t\t\t\t\t\tresult.push(serializedData);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\"Not implemented\");\n\t\t\t\t\t}\n\t\t\t\t} else if (SerializerMiddleware.isLazy(item, this)) {\n\t\t\t\t\tthrow new Error(\"Not implemented\");\n\t\t\t\t} else {\n\t\t\t\t\tconst data = SerializerMiddleware.serializeLazy(item, data =>\n\t\t\t\t\t\tthis.serialize([data], context)\n\t\t\t\t\t);\n\t\t\t\t\tSerializerMiddleware.setLazySerializedValue(item, data);\n\t\t\t\t\tresult.push(data);\n\t\t\t\t}\n\t\t\t} else if (item === undefined) {\n\t\t\t\tresult.push(ESCAPE, ESCAPE_UNDEFINED);\n\t\t\t} else {\n\t\t\t\tresult.push(item);\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\tfor (const item of data) {\n\t\t\t\tprocess(item);\n\t\t\t}\n\t\t\treturn result;\n\t\t} catch (e) {\n\t\t\tif (e === NOT_SERIALIZABLE) return null;\n\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\t// Get rid of these references to avoid leaking memory\n\t\t\t// This happens because the optimized code v8 generates\n\t\t\t// is optimized for our \"ctx.write\" method so it will reference\n\t\t\t// it from e. g. Dependency.prototype.serialize -(IC)-> ctx.write\n\t\t\tdata =\n\t\t\t\tresult =\n\t\t\t\treferenceable =\n\t\t\t\tbufferDedupeMap =\n\t\t\t\tobjectTypeLookup =\n\t\t\t\tctx =\n\t\t\t\t\tundefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {SerializedType} data data\n\t * @param {Object} context context object\n\t * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n\t */\n\tdeserialize(data, context) {\n\t\tlet currentDataPos = 0;\n\t\tconst read = () => {\n\t\t\tif (currentDataPos >= data.length)\n\t\t\t\tthrow new Error(\"Unexpected end of stream\");\n\n\t\t\treturn data[currentDataPos++];\n\t\t};\n\n\t\tif (read() !== CURRENT_VERSION)\n\t\t\tthrow new Error(\"Version mismatch, serializer changed\");\n\n\t\tlet currentPos = 0;\n\t\tlet referenceable = [];\n\t\tconst addReferenceable = item => {\n\t\t\treferenceable.push(item);\n\t\t\tcurrentPos++;\n\t\t};\n\t\tlet currentPosTypeLookup = 0;\n\t\tlet objectTypeLookup = [];\n\t\tlet result = [];\n\t\tlet ctx = {\n\t\t\tread() {\n\t\t\t\treturn decodeValue();\n\t\t\t},\n\t\t\tsetCircularReference(ref) {\n\t\t\t\taddReferenceable(ref);\n\t\t\t},\n\t\t\t...context\n\t\t};\n\t\tthis.extendContext(ctx);\n\t\tconst decodeValue = () => {\n\t\t\tconst item = read();\n\n\t\t\tif (item === ESCAPE) {\n\t\t\t\tconst nextItem = read();\n\n\t\t\t\tif (nextItem === ESCAPE_ESCAPE_VALUE) {\n\t\t\t\t\treturn ESCAPE;\n\t\t\t\t} else if (nextItem === ESCAPE_UNDEFINED) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else if (nextItem === ESCAPE_END_OBJECT) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Unexpected end of object at position ${currentDataPos - 1}`\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tconst request = nextItem;\n\t\t\t\t\tlet serializer;\n\n\t\t\t\t\tif (typeof request === \"number\") {\n\t\t\t\t\t\tif (request < 0) {\n\t\t\t\t\t\t\t// relative reference\n\t\t\t\t\t\t\treturn referenceable[currentPos + request];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tserializer = objectTypeLookup[currentPosTypeLookup - request];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (typeof request !== \"string\") {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unexpected type (${typeof request}) of request ` +\n\t\t\t\t\t\t\t\t\t`at position ${currentDataPos - 1}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst name = read();\n\n\t\t\t\t\t\tserializer = ObjectMiddleware._getDeserializerForWithoutError(\n\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (serializer === undefined) {\n\t\t\t\t\t\t\tif (request && !loadedRequests.has(request)) {\n\t\t\t\t\t\t\t\tlet loaded = false;\n\t\t\t\t\t\t\t\tfor (const [regExp, loader] of loaders) {\n\t\t\t\t\t\t\t\t\tif (regExp.test(request)) {\n\t\t\t\t\t\t\t\t\t\tif (loader(request)) {\n\t\t\t\t\t\t\t\t\t\t\tloaded = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!loaded) {\n\t\t\t\t\t\t\t\t\trequire(request);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tloadedRequests.add(request);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tserializer = ObjectMiddleware.getDeserializerFor(request, name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobjectTypeLookup.push(serializer);\n\t\t\t\t\t\tcurrentPosTypeLookup++;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst item = serializer.deserialize(ctx);\n\t\t\t\t\t\tconst end1 = read();\n\n\t\t\t\t\t\tif (end1 !== ESCAPE) {\n\t\t\t\t\t\t\tthrow new Error(\"Expected end of object\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst end2 = read();\n\n\t\t\t\t\t\tif (end2 !== ESCAPE_END_OBJECT) {\n\t\t\t\t\t\t\tthrow new Error(\"Expected end of object\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\taddReferenceable(item);\n\n\t\t\t\t\t\treturn item;\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t// As this is only for error handling, we omit creating a Map for\n\t\t\t\t\t\t// faster access to this information, as this would affect performance\n\t\t\t\t\t\t// in the good case\n\t\t\t\t\t\tlet serializerEntry;\n\t\t\t\t\t\tfor (const entry of serializers) {\n\t\t\t\t\t\t\tif (entry[1].serializer === serializer) {\n\t\t\t\t\t\t\t\tserializerEntry = entry;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst name = !serializerEntry\n\t\t\t\t\t\t\t? \"unknown\"\n\t\t\t\t\t\t\t: !serializerEntry[1].request\n\t\t\t\t\t\t\t? serializerEntry[0].name\n\t\t\t\t\t\t\t: serializerEntry[1].name\n\t\t\t\t\t\t\t? `${serializerEntry[1].request} ${serializerEntry[1].name}`\n\t\t\t\t\t\t\t: serializerEntry[1].request;\n\t\t\t\t\t\terr.message += `\\n(during deserialization of ${name})`;\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (typeof item === \"string\") {\n\t\t\t\tif (item.length > 1) {\n\t\t\t\t\taddReferenceable(item);\n\t\t\t\t}\n\n\t\t\t\treturn item;\n\t\t\t} else if (Buffer.isBuffer(item)) {\n\t\t\t\taddReferenceable(item);\n\n\t\t\t\treturn item;\n\t\t\t} else if (typeof item === \"function\") {\n\t\t\t\treturn SerializerMiddleware.deserializeLazy(\n\t\t\t\t\titem,\n\t\t\t\t\tdata => this.deserialize(data, context)[0]\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\twhile (currentDataPos < data.length) {\n\t\t\t\tresult.push(decodeValue());\n\t\t\t}\n\t\t\treturn result;\n\t\t} finally {\n\t\t\t// Get rid of these references to avoid leaking memory\n\t\t\t// This happens because the optimized code v8 generates\n\t\t\t// is optimized for our \"ctx.read\" method so it will reference\n\t\t\t// it from e. g. Dependency.prototype.deserialize -(IC)-> ctx.read\n\t\t\tresult = referenceable = data = objectTypeLookup = ctx = undefined;\n\t\t}\n\t}\n}\n\nmodule.exports = ObjectMiddleware;\nmodule.exports.NOT_SERIALIZABLE = NOT_SERIALIZABLE;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}