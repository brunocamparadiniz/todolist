{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar memoize = require(\"../util/memoize\");\nvar SerializerMiddleware = require(\"./SerializerMiddleware\");\n\n/** @typedef {import(\"./types\").BufferSerializableType} BufferSerializableType */\n/** @typedef {import(\"./types\").PrimitiveSerializableType} PrimitiveSerializableType */\n\n/*\nFormat:\n\nFile -> Section*\n\nSection -> NullsSection |\n\t\t\t\t\t BooleansSection |\n\t\t\t\t\t F64NumbersSection |\n\t\t\t\t\t I32NumbersSection |\n\t\t\t\t\t I8NumbersSection |\n\t\t\t\t\t ShortStringSection |\n\t\t\t\t\t StringSection |\n\t\t\t\t\t BufferSection |\n\t\t\t\t\t NopSection\n\n\n\nNullsSection ->\n\tNullHeaderByte | Null2HeaderByte | Null3HeaderByte |\n\tNulls8HeaderByte 0xnn (n:count - 4) |\n\tNulls32HeaderByte n:ui32 (n:count - 260) |\nBooleansSection -> TrueHeaderByte | FalseHeaderByte | BooleansSectionHeaderByte BooleansCountAndBitsByte\nF64NumbersSection -> F64NumbersSectionHeaderByte f64*\nI32NumbersSection -> I32NumbersSectionHeaderByte i32*\nI8NumbersSection -> I8NumbersSectionHeaderByte i8*\nShortStringSection -> ShortStringSectionHeaderByte ascii-byte*\nStringSection -> StringSectionHeaderByte i32:length utf8-byte*\nBufferSection -> BufferSectionHeaderByte i32:length byte*\nNopSection --> NopSectionHeaderByte\n\nShortStringSectionHeaderByte -> 0b1nnn_nnnn (n:length)\n\nF64NumbersSectionHeaderByte -> 0b001n_nnnn (n:count - 1)\nI32NumbersSectionHeaderByte -> 0b010n_nnnn (n:count - 1)\nI8NumbersSectionHeaderByte -> 0b011n_nnnn (n:count - 1)\n\nNullsSectionHeaderByte -> 0b0001_nnnn (n:count - 1)\nBooleansCountAndBitsByte ->\n\t0b0000_1xxx (count = 3) |\n\t0b0001_xxxx (count = 4) |\n\t0b001x_xxxx (count = 5) |\n\t0b01xx_xxxx (count = 6) |\n\t0b1nnn_nnnn (n:count - 7, 7 <= count <= 133)\n\t0xff n:ui32 (n:count, 134 <= count < 2^32)\n\nStringSectionHeaderByte -> 0b0000_1110\nBufferSectionHeaderByte -> 0b0000_1111\nNopSectionHeaderByte -> 0b0000_1011\nFalseHeaderByte -> 0b0000_1100\nTrueHeaderByte -> 0b0000_1101\n\nRawNumber -> n (n <= 10)\n\n*/\n\nvar LAZY_HEADER = 0x0b;\nvar TRUE_HEADER = 0x0c;\nvar FALSE_HEADER = 0x0d;\nvar BOOLEANS_HEADER = 0x0e;\nvar NULL_HEADER = 0x10;\nvar NULL2_HEADER = 0x11;\nvar NULL3_HEADER = 0x12;\nvar NULLS8_HEADER = 0x13;\nvar NULLS32_HEADER = 0x14;\nvar NULL_AND_I8_HEADER = 0x15;\nvar NULL_AND_I32_HEADER = 0x16;\nvar NULL_AND_TRUE_HEADER = 0x17;\nvar NULL_AND_FALSE_HEADER = 0x18;\nvar STRING_HEADER = 0x1e;\nvar BUFFER_HEADER = 0x1f;\nvar I8_HEADER = 0x60;\nvar I32_HEADER = 0x40;\nvar F64_HEADER = 0x20;\nvar SHORT_STRING_HEADER = 0x80;\n\n/** Uplift high-order bits */\nvar NUMBERS_HEADER_MASK = 0xe0;\nvar NUMBERS_COUNT_MASK = 0x1f; // 0b0001_1111\nvar SHORT_STRING_LENGTH_MASK = 0x7f; // 0b0111_1111\n\nvar HEADER_SIZE = 1;\nvar I8_SIZE = 1;\nvar I32_SIZE = 4;\nvar F64_SIZE = 8;\nvar MEASURE_START_OPERATION = Symbol(\"MEASURE_START_OPERATION\");\nvar MEASURE_END_OPERATION = Symbol(\"MEASURE_END_OPERATION\");\n\n/** @typedef {typeof MEASURE_START_OPERATION} MEASURE_START_OPERATION_TYPE */\n/** @typedef {typeof MEASURE_END_OPERATION} MEASURE_END_OPERATION_TYPE */\n\nvar identifyNumber = function identifyNumber(n) {\n  if (n === (n | 0)) {\n    if (n <= 127 && n >= -128) return 0;\n    if (n <= 2147483647 && n >= -2147483648) return 1;\n  }\n  return 2;\n};\n\n/**\n * @typedef {PrimitiveSerializableType[]} DeserializedType\n * @typedef {BufferSerializableType[]} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\nvar BinaryMiddleware = /*#__PURE__*/function (_SerializerMiddleware) {\n  _inherits(BinaryMiddleware, _SerializerMiddleware);\n  var _super = _createSuper(BinaryMiddleware);\n  function BinaryMiddleware() {\n    _classCallCheck(this, BinaryMiddleware);\n    return _super.apply(this, arguments);\n  }\n  _createClass(BinaryMiddleware, [{\n    key: \"serialize\",\n    value:\n    /**\n     * @param {DeserializedType} data data\n     * @param {Object} context context object\n     * @returns {SerializedType|Promise<SerializedType>} serialized data\n     */\n    function serialize(data, context) {\n      return this._serialize(data, context);\n    }\n  }, {\n    key: \"_serializeLazy\",\n    value: function _serializeLazy(fn, context) {\n      var _this = this;\n      return SerializerMiddleware.serializeLazy(fn, function (data) {\n        return _this._serialize(data, context);\n      });\n    }\n\n    /**\n     * @param {DeserializedType} data data\n     * @param {Object} context context object\n     * @param {{ leftOverBuffer: Buffer | null, allocationSize: number, increaseCounter: number }} allocationScope allocation scope\n     * @returns {SerializedType} serialized data\n     */\n  }, {\n    key: \"_serialize\",\n    value: function _serialize(data, context) {\n      var allocationScope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n        allocationSize: 1024,\n        increaseCounter: 0,\n        leftOverBuffer: null\n      };\n      /** @type {Buffer} */\n      var leftOverBuffer = null;\n      /** @type {BufferSerializableType[]} */\n      var buffers = [];\n      /** @type {Buffer} */\n      var currentBuffer = allocationScope ? allocationScope.leftOverBuffer : null;\n      allocationScope.leftOverBuffer = null;\n      var currentPosition = 0;\n      if (currentBuffer === null) {\n        currentBuffer = Buffer.allocUnsafe(allocationScope.allocationSize);\n      }\n      var allocate = function allocate(bytesNeeded) {\n        if (currentBuffer !== null) {\n          if (currentBuffer.length - currentPosition >= bytesNeeded) return;\n          flush();\n        }\n        if (leftOverBuffer && leftOverBuffer.length >= bytesNeeded) {\n          currentBuffer = leftOverBuffer;\n          leftOverBuffer = null;\n        } else {\n          currentBuffer = Buffer.allocUnsafe(Math.max(bytesNeeded, allocationScope.allocationSize));\n          if (!(allocationScope.increaseCounter = (allocationScope.increaseCounter + 1) % 4) && allocationScope.allocationSize < 16777216) {\n            allocationScope.allocationSize = allocationScope.allocationSize << 1;\n          }\n        }\n      };\n      var flush = function flush() {\n        if (currentBuffer !== null) {\n          if (currentPosition > 0) {\n            buffers.push(Buffer.from(currentBuffer.buffer, currentBuffer.byteOffset, currentPosition));\n          }\n          if (!leftOverBuffer || leftOverBuffer.length < currentBuffer.length - currentPosition) {\n            leftOverBuffer = Buffer.from(currentBuffer.buffer, currentBuffer.byteOffset + currentPosition, currentBuffer.byteLength - currentPosition);\n          }\n          currentBuffer = null;\n          currentPosition = 0;\n        }\n      };\n      var writeU8 = function writeU8(byte) {\n        currentBuffer.writeUInt8(byte, currentPosition++);\n      };\n      var writeU32 = function writeU32(ui32) {\n        currentBuffer.writeUInt32LE(ui32, currentPosition);\n        currentPosition += 4;\n      };\n      var measureStack = [];\n      var measureStart = function measureStart() {\n        measureStack.push(buffers.length, currentPosition);\n      };\n      var measureEnd = function measureEnd() {\n        var oldPos = measureStack.pop();\n        var buffersIndex = measureStack.pop();\n        var size = currentPosition - oldPos;\n        for (var i = buffersIndex; i < buffers.length; i++) {\n          size += buffers[i].length;\n        }\n        return size;\n      };\n      for (var i = 0; i < data.length; i++) {\n        var thing = data[i];\n        switch (typeof thing) {\n          case \"function\":\n            {\n              if (!SerializerMiddleware.isLazy(thing)) throw new Error(\"Unexpected function \" + thing);\n              /** @type {SerializedType | (() => SerializedType)} */\n              var serializedData = SerializerMiddleware.getLazySerializedValue(thing);\n              if (serializedData === undefined) {\n                if (SerializerMiddleware.isLazy(thing, this)) {\n                  flush();\n                  allocationScope.leftOverBuffer = leftOverBuffer;\n                  var result = /** @type {(Exclude<PrimitiveSerializableType, Promise<PrimitiveSerializableType>>)[]} */\n                  thing();\n                  var _data = this._serialize(result, context, allocationScope);\n                  leftOverBuffer = allocationScope.leftOverBuffer;\n                  allocationScope.leftOverBuffer = null;\n                  SerializerMiddleware.setLazySerializedValue(thing, _data);\n                  serializedData = _data;\n                } else {\n                  serializedData = this._serializeLazy(thing, context);\n                  flush();\n                  buffers.push(serializedData);\n                  break;\n                }\n              } else {\n                if (typeof serializedData === \"function\") {\n                  flush();\n                  buffers.push(serializedData);\n                  break;\n                }\n              }\n              var lengths = [];\n              var _iterator = _createForOfIteratorHelper(serializedData),\n                _step;\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var item = _step.value;\n                  var last = void 0;\n                  if (typeof item === \"function\") {\n                    lengths.push(0);\n                  } else if (item.length === 0) {\n                    // ignore\n                  } else if (lengths.length > 0 && (last = lengths[lengths.length - 1]) !== 0) {\n                    var remaining = 0xffffffff - last;\n                    if (remaining >= item.length) {\n                      lengths[lengths.length - 1] += item.length;\n                    } else {\n                      lengths.push(item.length - remaining);\n                      lengths[lengths.length - 2] = 0xffffffff;\n                    }\n                  } else {\n                    lengths.push(item.length);\n                  }\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              allocate(5 + lengths.length * 4);\n              writeU8(LAZY_HEADER);\n              writeU32(lengths.length);\n              for (var _i = 0, _lengths = lengths; _i < _lengths.length; _i++) {\n                var l = _lengths[_i];\n                writeU32(l);\n              }\n              flush();\n              var _iterator2 = _createForOfIteratorHelper(serializedData),\n                _step2;\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var _item = _step2.value;\n                  buffers.push(_item);\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n              break;\n            }\n          case \"string\":\n            {\n              var len = Buffer.byteLength(thing);\n              if (len >= 128 || len !== thing.length) {\n                allocate(len + HEADER_SIZE + I32_SIZE);\n                writeU8(STRING_HEADER);\n                writeU32(len);\n                currentBuffer.write(thing, currentPosition);\n                currentPosition += len;\n              } else if (len >= 70) {\n                allocate(len + HEADER_SIZE);\n                writeU8(SHORT_STRING_HEADER | len);\n                currentBuffer.write(thing, currentPosition, \"latin1\");\n                currentPosition += len;\n              } else {\n                allocate(len + HEADER_SIZE);\n                writeU8(SHORT_STRING_HEADER | len);\n                for (var _i2 = 0; _i2 < len; _i2++) {\n                  currentBuffer[currentPosition++] = thing.charCodeAt(_i2);\n                }\n              }\n              break;\n            }\n          case \"number\":\n            {\n              var type = identifyNumber(thing);\n              if (type === 0 && thing >= 0 && thing <= 10) {\n                // shortcut for very small numbers\n                allocate(I8_SIZE);\n                writeU8(thing);\n                break;\n              }\n              /**\n               * amount of numbers to write\n               * @type {number}\n               */\n              var n = 1;\n              for (; n < 32 && i + n < data.length; n++) {\n                var _item2 = data[i + n];\n                if (typeof _item2 !== \"number\") break;\n                if (identifyNumber(_item2) !== type) break;\n              }\n              switch (type) {\n                case 0:\n                  allocate(HEADER_SIZE + I8_SIZE * n);\n                  writeU8(I8_HEADER | n - 1);\n                  while (n > 0) {\n                    currentBuffer.writeInt8( /** @type {number} */data[i], currentPosition);\n                    currentPosition += I8_SIZE;\n                    n--;\n                    i++;\n                  }\n                  break;\n                case 1:\n                  allocate(HEADER_SIZE + I32_SIZE * n);\n                  writeU8(I32_HEADER | n - 1);\n                  while (n > 0) {\n                    currentBuffer.writeInt32LE( /** @type {number} */data[i], currentPosition);\n                    currentPosition += I32_SIZE;\n                    n--;\n                    i++;\n                  }\n                  break;\n                case 2:\n                  allocate(HEADER_SIZE + F64_SIZE * n);\n                  writeU8(F64_HEADER | n - 1);\n                  while (n > 0) {\n                    currentBuffer.writeDoubleLE( /** @type {number} */data[i], currentPosition);\n                    currentPosition += F64_SIZE;\n                    n--;\n                    i++;\n                  }\n                  break;\n              }\n              i--;\n              break;\n            }\n          case \"boolean\":\n            {\n              var lastByte = thing === true ? 1 : 0;\n              var bytes = [];\n              var count = 1;\n              var _n = void 0;\n              for (_n = 1; _n < 0xffffffff && i + _n < data.length; _n++) {\n                var _item3 = data[i + _n];\n                if (typeof _item3 !== \"boolean\") break;\n                var pos = count & 0x7;\n                if (pos === 0) {\n                  bytes.push(lastByte);\n                  lastByte = _item3 === true ? 1 : 0;\n                } else if (_item3 === true) {\n                  lastByte |= 1 << pos;\n                }\n                count++;\n              }\n              i += count - 1;\n              if (count === 1) {\n                allocate(HEADER_SIZE);\n                writeU8(lastByte === 1 ? TRUE_HEADER : FALSE_HEADER);\n              } else if (count === 2) {\n                allocate(HEADER_SIZE * 2);\n                writeU8(lastByte & 1 ? TRUE_HEADER : FALSE_HEADER);\n                writeU8(lastByte & 2 ? TRUE_HEADER : FALSE_HEADER);\n              } else if (count <= 6) {\n                allocate(HEADER_SIZE + I8_SIZE);\n                writeU8(BOOLEANS_HEADER);\n                writeU8(1 << count | lastByte);\n              } else if (count <= 133) {\n                allocate(HEADER_SIZE + I8_SIZE + I8_SIZE * bytes.length + I8_SIZE);\n                writeU8(BOOLEANS_HEADER);\n                writeU8(0x80 | count - 7);\n                var _iterator3 = _createForOfIteratorHelper(bytes),\n                  _step3;\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    var byte = _step3.value;\n                    writeU8(byte);\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n                writeU8(lastByte);\n              } else {\n                allocate(HEADER_SIZE + I8_SIZE + I32_SIZE + I8_SIZE * bytes.length + I8_SIZE);\n                writeU8(BOOLEANS_HEADER);\n                writeU8(0xff);\n                writeU32(count);\n                var _iterator4 = _createForOfIteratorHelper(bytes),\n                  _step4;\n                try {\n                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                    var _byte = _step4.value;\n                    writeU8(_byte);\n                  }\n                } catch (err) {\n                  _iterator4.e(err);\n                } finally {\n                  _iterator4.f();\n                }\n                writeU8(lastByte);\n              }\n              break;\n            }\n          case \"object\":\n            {\n              if (thing === null) {\n                var _n2 = void 0;\n                for (_n2 = 1; _n2 < 0x100000104 && i + _n2 < data.length; _n2++) {\n                  var _item4 = data[i + _n2];\n                  if (_item4 !== null) break;\n                }\n                i += _n2 - 1;\n                if (_n2 === 1) {\n                  if (i + 1 < data.length) {\n                    var next = data[i + 1];\n                    if (next === true) {\n                      allocate(HEADER_SIZE);\n                      writeU8(NULL_AND_TRUE_HEADER);\n                      i++;\n                    } else if (next === false) {\n                      allocate(HEADER_SIZE);\n                      writeU8(NULL_AND_FALSE_HEADER);\n                      i++;\n                    } else if (typeof next === \"number\") {\n                      var _type = identifyNumber(next);\n                      if (_type === 0) {\n                        allocate(HEADER_SIZE + I8_SIZE);\n                        writeU8(NULL_AND_I8_HEADER);\n                        currentBuffer.writeInt8(next, currentPosition);\n                        currentPosition += I8_SIZE;\n                        i++;\n                      } else if (_type === 1) {\n                        allocate(HEADER_SIZE + I32_SIZE);\n                        writeU8(NULL_AND_I32_HEADER);\n                        currentBuffer.writeInt32LE(next, currentPosition);\n                        currentPosition += I32_SIZE;\n                        i++;\n                      } else {\n                        allocate(HEADER_SIZE);\n                        writeU8(NULL_HEADER);\n                      }\n                    } else {\n                      allocate(HEADER_SIZE);\n                      writeU8(NULL_HEADER);\n                    }\n                  } else {\n                    allocate(HEADER_SIZE);\n                    writeU8(NULL_HEADER);\n                  }\n                } else if (_n2 === 2) {\n                  allocate(HEADER_SIZE);\n                  writeU8(NULL2_HEADER);\n                } else if (_n2 === 3) {\n                  allocate(HEADER_SIZE);\n                  writeU8(NULL3_HEADER);\n                } else if (_n2 < 260) {\n                  allocate(HEADER_SIZE + I8_SIZE);\n                  writeU8(NULLS8_HEADER);\n                  writeU8(_n2 - 4);\n                } else {\n                  allocate(HEADER_SIZE + I32_SIZE);\n                  writeU8(NULLS32_HEADER);\n                  writeU32(_n2 - 260);\n                }\n              } else if (Buffer.isBuffer(thing)) {\n                if (thing.length < 8192) {\n                  allocate(HEADER_SIZE + I32_SIZE + thing.length);\n                  writeU8(BUFFER_HEADER);\n                  writeU32(thing.length);\n                  thing.copy(currentBuffer, currentPosition);\n                  currentPosition += thing.length;\n                } else {\n                  allocate(HEADER_SIZE + I32_SIZE);\n                  writeU8(BUFFER_HEADER);\n                  writeU32(thing.length);\n                  flush();\n                  buffers.push(thing);\n                }\n              }\n              break;\n            }\n          case \"symbol\":\n            {\n              if (thing === MEASURE_START_OPERATION) {\n                measureStart();\n              } else if (thing === MEASURE_END_OPERATION) {\n                var size = measureEnd();\n                allocate(HEADER_SIZE + I32_SIZE);\n                writeU8(I32_HEADER);\n                currentBuffer.writeInt32LE(size, currentPosition);\n                currentPosition += I32_SIZE;\n              }\n              break;\n            }\n        }\n      }\n      flush();\n      allocationScope.leftOverBuffer = leftOverBuffer;\n\n      // avoid leaking memory\n      currentBuffer = null;\n      leftOverBuffer = null;\n      allocationScope = undefined;\n      var _buffers = buffers;\n      buffers = undefined;\n      return _buffers;\n    }\n\n    /**\n     * @param {SerializedType} data data\n     * @param {Object} context context object\n     * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n     */\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data, context) {\n      return this._deserialize(data, context);\n    }\n  }, {\n    key: \"_createLazyDeserialized\",\n    value: function _createLazyDeserialized(content, context) {\n      var _this2 = this;\n      return SerializerMiddleware.createLazy(memoize(function () {\n        return _this2._deserialize(content, context);\n      }), this, undefined, content);\n    }\n  }, {\n    key: \"_deserializeLazy\",\n    value: function _deserializeLazy(fn, context) {\n      var _this3 = this;\n      return SerializerMiddleware.deserializeLazy(fn, function (data) {\n        return _this3._deserialize(data, context);\n      });\n    }\n\n    /**\n     * @param {SerializedType} data data\n     * @param {Object} context context object\n     * @returns {DeserializedType} deserialized data\n     */\n  }, {\n    key: \"_deserialize\",\n    value: function _deserialize(data, context) {\n      var _this4 = this;\n      var currentDataItem = 0;\n      var currentBuffer = data[0];\n      var currentIsBuffer = Buffer.isBuffer(currentBuffer);\n      var currentPosition = 0;\n      var retainedBuffer = context.retainedBuffer || function (x) {\n        return x;\n      };\n      var checkOverflow = function checkOverflow() {\n        if (currentPosition >= currentBuffer.length) {\n          currentPosition = 0;\n          currentDataItem++;\n          currentBuffer = currentDataItem < data.length ? data[currentDataItem] : null;\n          currentIsBuffer = Buffer.isBuffer(currentBuffer);\n        }\n      };\n      var isInCurrentBuffer = function isInCurrentBuffer(n) {\n        return currentIsBuffer && n + currentPosition <= currentBuffer.length;\n      };\n      var ensureBuffer = function ensureBuffer() {\n        if (!currentIsBuffer) {\n          throw new Error(currentBuffer === null ? \"Unexpected end of stream\" : \"Unexpected lazy element in stream\");\n        }\n      };\n      /**\n       * Reads n bytes\n       * @param {number} n amount of bytes to read\n       * @returns {Buffer} buffer with bytes\n       */\n      var read = function read(n) {\n        ensureBuffer();\n        var rem = currentBuffer.length - currentPosition;\n        if (rem < n) {\n          var buffers = [read(rem)];\n          n -= rem;\n          ensureBuffer();\n          while (currentBuffer.length < n) {\n            var _b = /** @type {Buffer} */currentBuffer;\n            buffers.push(_b);\n            n -= _b.length;\n            currentDataItem++;\n            currentBuffer = currentDataItem < data.length ? data[currentDataItem] : null;\n            currentIsBuffer = Buffer.isBuffer(currentBuffer);\n            ensureBuffer();\n          }\n          buffers.push(read(n));\n          return Buffer.concat(buffers);\n        }\n        var b = /** @type {Buffer} */currentBuffer;\n        var res = Buffer.from(b.buffer, b.byteOffset + currentPosition, n);\n        currentPosition += n;\n        checkOverflow();\n        return res;\n      };\n      /**\n       * Reads up to n bytes\n       * @param {number} n amount of bytes to read\n       * @returns {Buffer} buffer with bytes\n       */\n      var readUpTo = function readUpTo(n) {\n        ensureBuffer();\n        var rem = currentBuffer.length - currentPosition;\n        if (rem < n) {\n          n = rem;\n        }\n        var b = /** @type {Buffer} */currentBuffer;\n        var res = Buffer.from(b.buffer, b.byteOffset + currentPosition, n);\n        currentPosition += n;\n        checkOverflow();\n        return res;\n      };\n      var readU8 = function readU8() {\n        ensureBuffer();\n        /**\n         * There is no need to check remaining buffer size here\n         * since {@link checkOverflow} guarantees at least one byte remaining\n         */\n        var byte = /** @type {Buffer} */currentBuffer.readUInt8(currentPosition);\n        currentPosition += I8_SIZE;\n        checkOverflow();\n        return byte;\n      };\n      var readU32 = function readU32() {\n        return read(I32_SIZE).readUInt32LE(0);\n      };\n      var readBits = function readBits(data, n) {\n        var mask = 1;\n        while (n !== 0) {\n          result.push((data & mask) !== 0);\n          mask = mask << 1;\n          n--;\n        }\n      };\n      var dispatchTable = Array.from({\n        length: 256\n      }).map(function (_, header) {\n        switch (header) {\n          case LAZY_HEADER:\n            return function () {\n              var count = readU32();\n              var lengths = Array.from({\n                length: count\n              }).map(function () {\n                return readU32();\n              });\n              var content = [];\n              var _iterator5 = _createForOfIteratorHelper(lengths),\n                _step5;\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  var l = _step5.value;\n                  if (l === 0) {\n                    if (typeof currentBuffer !== \"function\") {\n                      throw new Error(\"Unexpected non-lazy element in stream\");\n                    }\n                    content.push(currentBuffer);\n                    currentDataItem++;\n                    currentBuffer = currentDataItem < data.length ? data[currentDataItem] : null;\n                    currentIsBuffer = Buffer.isBuffer(currentBuffer);\n                  } else {\n                    do {\n                      var buf = readUpTo(l);\n                      l -= buf.length;\n                      content.push(retainedBuffer(buf));\n                    } while (l > 0);\n                  }\n                }\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n              result.push(_this4._createLazyDeserialized(content, context));\n            };\n          case BUFFER_HEADER:\n            return function () {\n              var len = readU32();\n              result.push(retainedBuffer(read(len)));\n            };\n          case TRUE_HEADER:\n            return function () {\n              return result.push(true);\n            };\n          case FALSE_HEADER:\n            return function () {\n              return result.push(false);\n            };\n          case NULL3_HEADER:\n            return function () {\n              return result.push(null, null, null);\n            };\n          case NULL2_HEADER:\n            return function () {\n              return result.push(null, null);\n            };\n          case NULL_HEADER:\n            return function () {\n              return result.push(null);\n            };\n          case NULL_AND_TRUE_HEADER:\n            return function () {\n              return result.push(null, true);\n            };\n          case NULL_AND_FALSE_HEADER:\n            return function () {\n              return result.push(null, false);\n            };\n          case NULL_AND_I8_HEADER:\n            return function () {\n              if (currentIsBuffer) {\n                result.push(null, /** @type {Buffer} */currentBuffer.readInt8(currentPosition));\n                currentPosition += I8_SIZE;\n                checkOverflow();\n              } else {\n                result.push(null, read(I8_SIZE).readInt8(0));\n              }\n            };\n          case NULL_AND_I32_HEADER:\n            return function () {\n              result.push(null);\n              if (isInCurrentBuffer(I32_SIZE)) {\n                result.push( /** @type {Buffer} */currentBuffer.readInt32LE(currentPosition));\n                currentPosition += I32_SIZE;\n                checkOverflow();\n              } else {\n                result.push(read(I32_SIZE).readInt32LE(0));\n              }\n            };\n          case NULLS8_HEADER:\n            return function () {\n              var len = readU8() + 4;\n              for (var i = 0; i < len; i++) {\n                result.push(null);\n              }\n            };\n          case NULLS32_HEADER:\n            return function () {\n              var len = readU32() + 260;\n              for (var i = 0; i < len; i++) {\n                result.push(null);\n              }\n            };\n          case BOOLEANS_HEADER:\n            return function () {\n              var innerHeader = readU8();\n              if ((innerHeader & 0xf0) === 0) {\n                readBits(innerHeader, 3);\n              } else if ((innerHeader & 0xe0) === 0) {\n                readBits(innerHeader, 4);\n              } else if ((innerHeader & 0xc0) === 0) {\n                readBits(innerHeader, 5);\n              } else if ((innerHeader & 0x80) === 0) {\n                readBits(innerHeader, 6);\n              } else if (innerHeader !== 0xff) {\n                var count = (innerHeader & 0x7f) + 7;\n                while (count > 8) {\n                  readBits(readU8(), 8);\n                  count -= 8;\n                }\n                readBits(readU8(), count);\n              } else {\n                var _count = readU32();\n                while (_count > 8) {\n                  readBits(readU8(), 8);\n                  _count -= 8;\n                }\n                readBits(readU8(), _count);\n              }\n            };\n          case STRING_HEADER:\n            return function () {\n              var len = readU32();\n              if (isInCurrentBuffer(len) && currentPosition + len < 0x7fffffff) {\n                result.push(currentBuffer.toString(undefined, currentPosition, currentPosition + len));\n                currentPosition += len;\n                checkOverflow();\n              } else {\n                result.push(read(len).toString());\n              }\n            };\n          case SHORT_STRING_HEADER:\n            return function () {\n              return result.push(\"\");\n            };\n          case SHORT_STRING_HEADER | 1:\n            return function () {\n              if (currentIsBuffer && currentPosition < 0x7ffffffe) {\n                result.push(currentBuffer.toString(\"latin1\", currentPosition, currentPosition + 1));\n                currentPosition++;\n                checkOverflow();\n              } else {\n                result.push(read(1).toString(\"latin1\"));\n              }\n            };\n          case I8_HEADER:\n            return function () {\n              if (currentIsBuffer) {\n                result.push( /** @type {Buffer} */currentBuffer.readInt8(currentPosition));\n                currentPosition++;\n                checkOverflow();\n              } else {\n                result.push(read(1).readInt8(0));\n              }\n            };\n          default:\n            if (header <= 10) {\n              return function () {\n                return result.push(header);\n              };\n            } else if ((header & SHORT_STRING_HEADER) === SHORT_STRING_HEADER) {\n              var len = header & SHORT_STRING_LENGTH_MASK;\n              return function () {\n                if (isInCurrentBuffer(len) && currentPosition + len < 0x7fffffff) {\n                  result.push(currentBuffer.toString(\"latin1\", currentPosition, currentPosition + len));\n                  currentPosition += len;\n                  checkOverflow();\n                } else {\n                  result.push(read(len).toString(\"latin1\"));\n                }\n              };\n            } else if ((header & NUMBERS_HEADER_MASK) === F64_HEADER) {\n              var _len = (header & NUMBERS_COUNT_MASK) + 1;\n              return function () {\n                var need = F64_SIZE * _len;\n                if (isInCurrentBuffer(need)) {\n                  for (var i = 0; i < _len; i++) {\n                    result.push( /** @type {Buffer} */currentBuffer.readDoubleLE(currentPosition));\n                    currentPosition += F64_SIZE;\n                  }\n                  checkOverflow();\n                } else {\n                  var buf = read(need);\n                  for (var _i3 = 0; _i3 < _len; _i3++) {\n                    result.push(buf.readDoubleLE(_i3 * F64_SIZE));\n                  }\n                }\n              };\n            } else if ((header & NUMBERS_HEADER_MASK) === I32_HEADER) {\n              var _len2 = (header & NUMBERS_COUNT_MASK) + 1;\n              return function () {\n                var need = I32_SIZE * _len2;\n                if (isInCurrentBuffer(need)) {\n                  for (var i = 0; i < _len2; i++) {\n                    result.push( /** @type {Buffer} */currentBuffer.readInt32LE(currentPosition));\n                    currentPosition += I32_SIZE;\n                  }\n                  checkOverflow();\n                } else {\n                  var buf = read(need);\n                  for (var _i4 = 0; _i4 < _len2; _i4++) {\n                    result.push(buf.readInt32LE(_i4 * I32_SIZE));\n                  }\n                }\n              };\n            } else if ((header & NUMBERS_HEADER_MASK) === I8_HEADER) {\n              var _len3 = (header & NUMBERS_COUNT_MASK) + 1;\n              return function () {\n                var need = I8_SIZE * _len3;\n                if (isInCurrentBuffer(need)) {\n                  for (var i = 0; i < _len3; i++) {\n                    result.push( /** @type {Buffer} */currentBuffer.readInt8(currentPosition));\n                    currentPosition += I8_SIZE;\n                  }\n                  checkOverflow();\n                } else {\n                  var buf = read(need);\n                  for (var _i5 = 0; _i5 < _len3; _i5++) {\n                    result.push(buf.readInt8(_i5 * I8_SIZE));\n                  }\n                }\n              };\n            } else {\n              return function () {\n                throw new Error(\"Unexpected header byte 0x\".concat(header.toString(16)));\n              };\n            }\n        }\n      });\n\n      /** @type {DeserializedType} */\n      var result = [];\n      while (currentBuffer !== null) {\n        if (typeof currentBuffer === \"function\") {\n          result.push(this._deserializeLazy(currentBuffer, context));\n          currentDataItem++;\n          currentBuffer = currentDataItem < data.length ? data[currentDataItem] : null;\n          currentIsBuffer = Buffer.isBuffer(currentBuffer);\n        } else {\n          var header = readU8();\n          dispatchTable[header]();\n        }\n      }\n\n      // avoid leaking memory in context\n      var _result = result;\n      result = undefined;\n      return _result;\n    }\n  }]);\n  return BinaryMiddleware;\n}(SerializerMiddleware);\nmodule.exports = BinaryMiddleware;\nmodule.exports.MEASURE_START_OPERATION = MEASURE_START_OPERATION;\nmodule.exports.MEASURE_END_OPERATION = MEASURE_END_OPERATION;","map":{"version":3,"names":["memoize","require","SerializerMiddleware","LAZY_HEADER","TRUE_HEADER","FALSE_HEADER","BOOLEANS_HEADER","NULL_HEADER","NULL2_HEADER","NULL3_HEADER","NULLS8_HEADER","NULLS32_HEADER","NULL_AND_I8_HEADER","NULL_AND_I32_HEADER","NULL_AND_TRUE_HEADER","NULL_AND_FALSE_HEADER","STRING_HEADER","BUFFER_HEADER","I8_HEADER","I32_HEADER","F64_HEADER","SHORT_STRING_HEADER","NUMBERS_HEADER_MASK","NUMBERS_COUNT_MASK","SHORT_STRING_LENGTH_MASK","HEADER_SIZE","I8_SIZE","I32_SIZE","F64_SIZE","MEASURE_START_OPERATION","Symbol","MEASURE_END_OPERATION","identifyNumber","n","BinaryMiddleware","data","context","_serialize","fn","serializeLazy","allocationScope","allocationSize","increaseCounter","leftOverBuffer","buffers","currentBuffer","currentPosition","Buffer","allocUnsafe","allocate","bytesNeeded","length","flush","Math","max","push","from","buffer","byteOffset","byteLength","writeU8","byte","writeUInt8","writeU32","ui32","writeUInt32LE","measureStack","measureStart","measureEnd","oldPos","pop","buffersIndex","size","i","thing","isLazy","Error","serializedData","getLazySerializedValue","undefined","result","setLazySerializedValue","_serializeLazy","lengths","item","last","remaining","l","len","write","charCodeAt","type","writeInt8","writeInt32LE","writeDoubleLE","lastByte","bytes","count","pos","next","isBuffer","copy","_buffers","_deserialize","content","createLazy","deserializeLazy","currentDataItem","currentIsBuffer","retainedBuffer","x","checkOverflow","isInCurrentBuffer","ensureBuffer","read","rem","b","concat","res","readUpTo","readU8","readUInt8","readU32","readUInt32LE","readBits","mask","dispatchTable","Array","map","_","header","buf","_createLazyDeserialized","readInt8","readInt32LE","innerHeader","toString","need","readDoubleLE","_deserializeLazy","_result","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/serialization/BinaryMiddleware.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst memoize = require(\"../util/memoize\");\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\n\n/** @typedef {import(\"./types\").BufferSerializableType} BufferSerializableType */\n/** @typedef {import(\"./types\").PrimitiveSerializableType} PrimitiveSerializableType */\n\n/*\nFormat:\n\nFile -> Section*\n\nSection -> NullsSection |\n\t\t\t\t\t BooleansSection |\n\t\t\t\t\t F64NumbersSection |\n\t\t\t\t\t I32NumbersSection |\n\t\t\t\t\t I8NumbersSection |\n\t\t\t\t\t ShortStringSection |\n\t\t\t\t\t StringSection |\n\t\t\t\t\t BufferSection |\n\t\t\t\t\t NopSection\n\n\n\nNullsSection ->\n\tNullHeaderByte | Null2HeaderByte | Null3HeaderByte |\n\tNulls8HeaderByte 0xnn (n:count - 4) |\n\tNulls32HeaderByte n:ui32 (n:count - 260) |\nBooleansSection -> TrueHeaderByte | FalseHeaderByte | BooleansSectionHeaderByte BooleansCountAndBitsByte\nF64NumbersSection -> F64NumbersSectionHeaderByte f64*\nI32NumbersSection -> I32NumbersSectionHeaderByte i32*\nI8NumbersSection -> I8NumbersSectionHeaderByte i8*\nShortStringSection -> ShortStringSectionHeaderByte ascii-byte*\nStringSection -> StringSectionHeaderByte i32:length utf8-byte*\nBufferSection -> BufferSectionHeaderByte i32:length byte*\nNopSection --> NopSectionHeaderByte\n\nShortStringSectionHeaderByte -> 0b1nnn_nnnn (n:length)\n\nF64NumbersSectionHeaderByte -> 0b001n_nnnn (n:count - 1)\nI32NumbersSectionHeaderByte -> 0b010n_nnnn (n:count - 1)\nI8NumbersSectionHeaderByte -> 0b011n_nnnn (n:count - 1)\n\nNullsSectionHeaderByte -> 0b0001_nnnn (n:count - 1)\nBooleansCountAndBitsByte ->\n\t0b0000_1xxx (count = 3) |\n\t0b0001_xxxx (count = 4) |\n\t0b001x_xxxx (count = 5) |\n\t0b01xx_xxxx (count = 6) |\n\t0b1nnn_nnnn (n:count - 7, 7 <= count <= 133)\n\t0xff n:ui32 (n:count, 134 <= count < 2^32)\n\nStringSectionHeaderByte -> 0b0000_1110\nBufferSectionHeaderByte -> 0b0000_1111\nNopSectionHeaderByte -> 0b0000_1011\nFalseHeaderByte -> 0b0000_1100\nTrueHeaderByte -> 0b0000_1101\n\nRawNumber -> n (n <= 10)\n\n*/\n\nconst LAZY_HEADER = 0x0b;\nconst TRUE_HEADER = 0x0c;\nconst FALSE_HEADER = 0x0d;\nconst BOOLEANS_HEADER = 0x0e;\nconst NULL_HEADER = 0x10;\nconst NULL2_HEADER = 0x11;\nconst NULL3_HEADER = 0x12;\nconst NULLS8_HEADER = 0x13;\nconst NULLS32_HEADER = 0x14;\nconst NULL_AND_I8_HEADER = 0x15;\nconst NULL_AND_I32_HEADER = 0x16;\nconst NULL_AND_TRUE_HEADER = 0x17;\nconst NULL_AND_FALSE_HEADER = 0x18;\nconst STRING_HEADER = 0x1e;\nconst BUFFER_HEADER = 0x1f;\nconst I8_HEADER = 0x60;\nconst I32_HEADER = 0x40;\nconst F64_HEADER = 0x20;\nconst SHORT_STRING_HEADER = 0x80;\n\n/** Uplift high-order bits */\nconst NUMBERS_HEADER_MASK = 0xe0;\nconst NUMBERS_COUNT_MASK = 0x1f; // 0b0001_1111\nconst SHORT_STRING_LENGTH_MASK = 0x7f; // 0b0111_1111\n\nconst HEADER_SIZE = 1;\nconst I8_SIZE = 1;\nconst I32_SIZE = 4;\nconst F64_SIZE = 8;\n\nconst MEASURE_START_OPERATION = Symbol(\"MEASURE_START_OPERATION\");\nconst MEASURE_END_OPERATION = Symbol(\"MEASURE_END_OPERATION\");\n\n/** @typedef {typeof MEASURE_START_OPERATION} MEASURE_START_OPERATION_TYPE */\n/** @typedef {typeof MEASURE_END_OPERATION} MEASURE_END_OPERATION_TYPE */\n\nconst identifyNumber = n => {\n\tif (n === (n | 0)) {\n\t\tif (n <= 127 && n >= -128) return 0;\n\t\tif (n <= 2147483647 && n >= -2147483648) return 1;\n\t}\n\treturn 2;\n};\n\n/**\n * @typedef {PrimitiveSerializableType[]} DeserializedType\n * @typedef {BufferSerializableType[]} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\nclass BinaryMiddleware extends SerializerMiddleware {\n\t/**\n\t * @param {DeserializedType} data data\n\t * @param {Object} context context object\n\t * @returns {SerializedType|Promise<SerializedType>} serialized data\n\t */\n\tserialize(data, context) {\n\t\treturn this._serialize(data, context);\n\t}\n\n\t_serializeLazy(fn, context) {\n\t\treturn SerializerMiddleware.serializeLazy(fn, data =>\n\t\t\tthis._serialize(data, context)\n\t\t);\n\t}\n\n\t/**\n\t * @param {DeserializedType} data data\n\t * @param {Object} context context object\n\t * @param {{ leftOverBuffer: Buffer | null, allocationSize: number, increaseCounter: number }} allocationScope allocation scope\n\t * @returns {SerializedType} serialized data\n\t */\n\t_serialize(\n\t\tdata,\n\t\tcontext,\n\t\tallocationScope = {\n\t\t\tallocationSize: 1024,\n\t\t\tincreaseCounter: 0,\n\t\t\tleftOverBuffer: null\n\t\t}\n\t) {\n\t\t/** @type {Buffer} */\n\t\tlet leftOverBuffer = null;\n\t\t/** @type {BufferSerializableType[]} */\n\t\tlet buffers = [];\n\t\t/** @type {Buffer} */\n\t\tlet currentBuffer = allocationScope ? allocationScope.leftOverBuffer : null;\n\t\tallocationScope.leftOverBuffer = null;\n\t\tlet currentPosition = 0;\n\t\tif (currentBuffer === null) {\n\t\t\tcurrentBuffer = Buffer.allocUnsafe(allocationScope.allocationSize);\n\t\t}\n\t\tconst allocate = bytesNeeded => {\n\t\t\tif (currentBuffer !== null) {\n\t\t\t\tif (currentBuffer.length - currentPosition >= bytesNeeded) return;\n\t\t\t\tflush();\n\t\t\t}\n\t\t\tif (leftOverBuffer && leftOverBuffer.length >= bytesNeeded) {\n\t\t\t\tcurrentBuffer = leftOverBuffer;\n\t\t\t\tleftOverBuffer = null;\n\t\t\t} else {\n\t\t\t\tcurrentBuffer = Buffer.allocUnsafe(\n\t\t\t\t\tMath.max(bytesNeeded, allocationScope.allocationSize)\n\t\t\t\t);\n\t\t\t\tif (\n\t\t\t\t\t!(allocationScope.increaseCounter =\n\t\t\t\t\t\t(allocationScope.increaseCounter + 1) % 4) &&\n\t\t\t\t\tallocationScope.allocationSize < 16777216\n\t\t\t\t) {\n\t\t\t\t\tallocationScope.allocationSize = allocationScope.allocationSize << 1;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tconst flush = () => {\n\t\t\tif (currentBuffer !== null) {\n\t\t\t\tif (currentPosition > 0) {\n\t\t\t\t\tbuffers.push(\n\t\t\t\t\t\tBuffer.from(\n\t\t\t\t\t\t\tcurrentBuffer.buffer,\n\t\t\t\t\t\t\tcurrentBuffer.byteOffset,\n\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\t!leftOverBuffer ||\n\t\t\t\t\tleftOverBuffer.length < currentBuffer.length - currentPosition\n\t\t\t\t) {\n\t\t\t\t\tleftOverBuffer = Buffer.from(\n\t\t\t\t\t\tcurrentBuffer.buffer,\n\t\t\t\t\t\tcurrentBuffer.byteOffset + currentPosition,\n\t\t\t\t\t\tcurrentBuffer.byteLength - currentPosition\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tcurrentBuffer = null;\n\t\t\t\tcurrentPosition = 0;\n\t\t\t}\n\t\t};\n\t\tconst writeU8 = byte => {\n\t\t\tcurrentBuffer.writeUInt8(byte, currentPosition++);\n\t\t};\n\t\tconst writeU32 = ui32 => {\n\t\t\tcurrentBuffer.writeUInt32LE(ui32, currentPosition);\n\t\t\tcurrentPosition += 4;\n\t\t};\n\t\tconst measureStack = [];\n\t\tconst measureStart = () => {\n\t\t\tmeasureStack.push(buffers.length, currentPosition);\n\t\t};\n\t\tconst measureEnd = () => {\n\t\t\tconst oldPos = measureStack.pop();\n\t\t\tconst buffersIndex = measureStack.pop();\n\t\t\tlet size = currentPosition - oldPos;\n\t\t\tfor (let i = buffersIndex; i < buffers.length; i++) {\n\t\t\t\tsize += buffers[i].length;\n\t\t\t}\n\t\t\treturn size;\n\t\t};\n\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\tconst thing = data[i];\n\t\t\tswitch (typeof thing) {\n\t\t\t\tcase \"function\": {\n\t\t\t\t\tif (!SerializerMiddleware.isLazy(thing))\n\t\t\t\t\t\tthrow new Error(\"Unexpected function \" + thing);\n\t\t\t\t\t/** @type {SerializedType | (() => SerializedType)} */\n\t\t\t\t\tlet serializedData =\n\t\t\t\t\t\tSerializerMiddleware.getLazySerializedValue(thing);\n\t\t\t\t\tif (serializedData === undefined) {\n\t\t\t\t\t\tif (SerializerMiddleware.isLazy(thing, this)) {\n\t\t\t\t\t\t\tflush();\n\t\t\t\t\t\t\tallocationScope.leftOverBuffer = leftOverBuffer;\n\t\t\t\t\t\t\tconst result =\n\t\t\t\t\t\t\t\t/** @type {(Exclude<PrimitiveSerializableType, Promise<PrimitiveSerializableType>>)[]} */ (\n\t\t\t\t\t\t\t\t\tthing()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst data = this._serialize(result, context, allocationScope);\n\t\t\t\t\t\t\tleftOverBuffer = allocationScope.leftOverBuffer;\n\t\t\t\t\t\t\tallocationScope.leftOverBuffer = null;\n\t\t\t\t\t\t\tSerializerMiddleware.setLazySerializedValue(thing, data);\n\t\t\t\t\t\t\tserializedData = data;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tserializedData = this._serializeLazy(thing, context);\n\t\t\t\t\t\t\tflush();\n\t\t\t\t\t\t\tbuffers.push(serializedData);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (typeof serializedData === \"function\") {\n\t\t\t\t\t\t\tflush();\n\t\t\t\t\t\t\tbuffers.push(serializedData);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst lengths = [];\n\t\t\t\t\tfor (const item of serializedData) {\n\t\t\t\t\t\tlet last;\n\t\t\t\t\t\tif (typeof item === \"function\") {\n\t\t\t\t\t\t\tlengths.push(0);\n\t\t\t\t\t\t} else if (item.length === 0) {\n\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tlengths.length > 0 &&\n\t\t\t\t\t\t\t(last = lengths[lengths.length - 1]) !== 0\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst remaining = 0xffffffff - last;\n\t\t\t\t\t\t\tif (remaining >= item.length) {\n\t\t\t\t\t\t\t\tlengths[lengths.length - 1] += item.length;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlengths.push(item.length - remaining);\n\t\t\t\t\t\t\t\tlengths[lengths.length - 2] = 0xffffffff;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlengths.push(item.length);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tallocate(5 + lengths.length * 4);\n\t\t\t\t\twriteU8(LAZY_HEADER);\n\t\t\t\t\twriteU32(lengths.length);\n\t\t\t\t\tfor (const l of lengths) {\n\t\t\t\t\t\twriteU32(l);\n\t\t\t\t\t}\n\t\t\t\t\tflush();\n\t\t\t\t\tfor (const item of serializedData) {\n\t\t\t\t\t\tbuffers.push(item);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"string\": {\n\t\t\t\t\tconst len = Buffer.byteLength(thing);\n\t\t\t\t\tif (len >= 128 || len !== thing.length) {\n\t\t\t\t\t\tallocate(len + HEADER_SIZE + I32_SIZE);\n\t\t\t\t\t\twriteU8(STRING_HEADER);\n\t\t\t\t\t\twriteU32(len);\n\t\t\t\t\t\tcurrentBuffer.write(thing, currentPosition);\n\t\t\t\t\t\tcurrentPosition += len;\n\t\t\t\t\t} else if (len >= 70) {\n\t\t\t\t\t\tallocate(len + HEADER_SIZE);\n\t\t\t\t\t\twriteU8(SHORT_STRING_HEADER | len);\n\n\t\t\t\t\t\tcurrentBuffer.write(thing, currentPosition, \"latin1\");\n\t\t\t\t\t\tcurrentPosition += len;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tallocate(len + HEADER_SIZE);\n\t\t\t\t\t\twriteU8(SHORT_STRING_HEADER | len);\n\n\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\tcurrentBuffer[currentPosition++] = thing.charCodeAt(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"number\": {\n\t\t\t\t\tconst type = identifyNumber(thing);\n\t\t\t\t\tif (type === 0 && thing >= 0 && thing <= 10) {\n\t\t\t\t\t\t// shortcut for very small numbers\n\t\t\t\t\t\tallocate(I8_SIZE);\n\t\t\t\t\t\twriteU8(thing);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/**\n\t\t\t\t\t * amount of numbers to write\n\t\t\t\t\t * @type {number}\n\t\t\t\t\t */\n\t\t\t\t\tlet n = 1;\n\t\t\t\t\tfor (; n < 32 && i + n < data.length; n++) {\n\t\t\t\t\t\tconst item = data[i + n];\n\t\t\t\t\t\tif (typeof item !== \"number\") break;\n\t\t\t\t\t\tif (identifyNumber(item) !== type) break;\n\t\t\t\t\t}\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE * n);\n\t\t\t\t\t\t\twriteU8(I8_HEADER | (n - 1));\n\t\t\t\t\t\t\twhile (n > 0) {\n\t\t\t\t\t\t\t\tcurrentBuffer.writeInt8(\n\t\t\t\t\t\t\t\t\t/** @type {number} */ (data[i]),\n\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentPosition += I8_SIZE;\n\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE * n);\n\t\t\t\t\t\t\twriteU8(I32_HEADER | (n - 1));\n\t\t\t\t\t\t\twhile (n > 0) {\n\t\t\t\t\t\t\t\tcurrentBuffer.writeInt32LE(\n\t\t\t\t\t\t\t\t\t/** @type {number} */ (data[i]),\n\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + F64_SIZE * n);\n\t\t\t\t\t\t\twriteU8(F64_HEADER | (n - 1));\n\t\t\t\t\t\t\twhile (n > 0) {\n\t\t\t\t\t\t\t\tcurrentBuffer.writeDoubleLE(\n\t\t\t\t\t\t\t\t\t/** @type {number} */ (data[i]),\n\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentPosition += F64_SIZE;\n\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"boolean\": {\n\t\t\t\t\tlet lastByte = thing === true ? 1 : 0;\n\t\t\t\t\tconst bytes = [];\n\t\t\t\t\tlet count = 1;\n\t\t\t\t\tlet n;\n\t\t\t\t\tfor (n = 1; n < 0xffffffff && i + n < data.length; n++) {\n\t\t\t\t\t\tconst item = data[i + n];\n\t\t\t\t\t\tif (typeof item !== \"boolean\") break;\n\t\t\t\t\t\tconst pos = count & 0x7;\n\t\t\t\t\t\tif (pos === 0) {\n\t\t\t\t\t\t\tbytes.push(lastByte);\n\t\t\t\t\t\t\tlastByte = item === true ? 1 : 0;\n\t\t\t\t\t\t} else if (item === true) {\n\t\t\t\t\t\t\tlastByte |= 1 << pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\ti += count - 1;\n\t\t\t\t\tif (count === 1) {\n\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\twriteU8(lastByte === 1 ? TRUE_HEADER : FALSE_HEADER);\n\t\t\t\t\t} else if (count === 2) {\n\t\t\t\t\t\tallocate(HEADER_SIZE * 2);\n\t\t\t\t\t\twriteU8(lastByte & 1 ? TRUE_HEADER : FALSE_HEADER);\n\t\t\t\t\t\twriteU8(lastByte & 2 ? TRUE_HEADER : FALSE_HEADER);\n\t\t\t\t\t} else if (count <= 6) {\n\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE);\n\t\t\t\t\t\twriteU8(BOOLEANS_HEADER);\n\t\t\t\t\t\twriteU8((1 << count) | lastByte);\n\t\t\t\t\t} else if (count <= 133) {\n\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE + I8_SIZE * bytes.length + I8_SIZE);\n\t\t\t\t\t\twriteU8(BOOLEANS_HEADER);\n\t\t\t\t\t\twriteU8(0x80 | (count - 7));\n\t\t\t\t\t\tfor (const byte of bytes) writeU8(byte);\n\t\t\t\t\t\twriteU8(lastByte);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tallocate(\n\t\t\t\t\t\t\tHEADER_SIZE +\n\t\t\t\t\t\t\t\tI8_SIZE +\n\t\t\t\t\t\t\t\tI32_SIZE +\n\t\t\t\t\t\t\t\tI8_SIZE * bytes.length +\n\t\t\t\t\t\t\t\tI8_SIZE\n\t\t\t\t\t\t);\n\t\t\t\t\t\twriteU8(BOOLEANS_HEADER);\n\t\t\t\t\t\twriteU8(0xff);\n\t\t\t\t\t\twriteU32(count);\n\t\t\t\t\t\tfor (const byte of bytes) writeU8(byte);\n\t\t\t\t\t\twriteU8(lastByte);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"object\": {\n\t\t\t\t\tif (thing === null) {\n\t\t\t\t\t\tlet n;\n\t\t\t\t\t\tfor (n = 1; n < 0x100000104 && i + n < data.length; n++) {\n\t\t\t\t\t\t\tconst item = data[i + n];\n\t\t\t\t\t\t\tif (item !== null) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti += n - 1;\n\t\t\t\t\t\tif (n === 1) {\n\t\t\t\t\t\t\tif (i + 1 < data.length) {\n\t\t\t\t\t\t\t\tconst next = data[i + 1];\n\t\t\t\t\t\t\t\tif (next === true) {\n\t\t\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\t\t\twriteU8(NULL_AND_TRUE_HEADER);\n\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t} else if (next === false) {\n\t\t\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\t\t\twriteU8(NULL_AND_FALSE_HEADER);\n\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t} else if (typeof next === \"number\") {\n\t\t\t\t\t\t\t\t\tconst type = identifyNumber(next);\n\t\t\t\t\t\t\t\t\tif (type === 0) {\n\t\t\t\t\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE);\n\t\t\t\t\t\t\t\t\t\twriteU8(NULL_AND_I8_HEADER);\n\t\t\t\t\t\t\t\t\t\tcurrentBuffer.writeInt8(next, currentPosition);\n\t\t\t\t\t\t\t\t\t\tcurrentPosition += I8_SIZE;\n\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t} else if (type === 1) {\n\t\t\t\t\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE);\n\t\t\t\t\t\t\t\t\t\twriteU8(NULL_AND_I32_HEADER);\n\t\t\t\t\t\t\t\t\t\tcurrentBuffer.writeInt32LE(next, currentPosition);\n\t\t\t\t\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\t\t\t\twriteU8(NULL_HEADER);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\t\t\twriteU8(NULL_HEADER);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\t\twriteU8(NULL_HEADER);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (n === 2) {\n\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\twriteU8(NULL2_HEADER);\n\t\t\t\t\t\t} else if (n === 3) {\n\t\t\t\t\t\t\tallocate(HEADER_SIZE);\n\t\t\t\t\t\t\twriteU8(NULL3_HEADER);\n\t\t\t\t\t\t} else if (n < 260) {\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I8_SIZE);\n\t\t\t\t\t\t\twriteU8(NULLS8_HEADER);\n\t\t\t\t\t\t\twriteU8(n - 4);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE);\n\t\t\t\t\t\t\twriteU8(NULLS32_HEADER);\n\t\t\t\t\t\t\twriteU32(n - 260);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (Buffer.isBuffer(thing)) {\n\t\t\t\t\t\tif (thing.length < 8192) {\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE + thing.length);\n\t\t\t\t\t\t\twriteU8(BUFFER_HEADER);\n\t\t\t\t\t\t\twriteU32(thing.length);\n\t\t\t\t\t\t\tthing.copy(currentBuffer, currentPosition);\n\t\t\t\t\t\t\tcurrentPosition += thing.length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE);\n\t\t\t\t\t\t\twriteU8(BUFFER_HEADER);\n\t\t\t\t\t\t\twriteU32(thing.length);\n\t\t\t\t\t\t\tflush();\n\t\t\t\t\t\t\tbuffers.push(thing);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"symbol\": {\n\t\t\t\t\tif (thing === MEASURE_START_OPERATION) {\n\t\t\t\t\t\tmeasureStart();\n\t\t\t\t\t} else if (thing === MEASURE_END_OPERATION) {\n\t\t\t\t\t\tconst size = measureEnd();\n\t\t\t\t\t\tallocate(HEADER_SIZE + I32_SIZE);\n\t\t\t\t\t\twriteU8(I32_HEADER);\n\t\t\t\t\t\tcurrentBuffer.writeInt32LE(size, currentPosition);\n\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tflush();\n\n\t\tallocationScope.leftOverBuffer = leftOverBuffer;\n\n\t\t// avoid leaking memory\n\t\tcurrentBuffer = null;\n\t\tleftOverBuffer = null;\n\t\tallocationScope = undefined;\n\t\tconst _buffers = buffers;\n\t\tbuffers = undefined;\n\t\treturn _buffers;\n\t}\n\n\t/**\n\t * @param {SerializedType} data data\n\t * @param {Object} context context object\n\t * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n\t */\n\tdeserialize(data, context) {\n\t\treturn this._deserialize(data, context);\n\t}\n\n\t_createLazyDeserialized(content, context) {\n\t\treturn SerializerMiddleware.createLazy(\n\t\t\tmemoize(() => this._deserialize(content, context)),\n\t\t\tthis,\n\t\t\tundefined,\n\t\t\tcontent\n\t\t);\n\t}\n\n\t_deserializeLazy(fn, context) {\n\t\treturn SerializerMiddleware.deserializeLazy(fn, data =>\n\t\t\tthis._deserialize(data, context)\n\t\t);\n\t}\n\n\t/**\n\t * @param {SerializedType} data data\n\t * @param {Object} context context object\n\t * @returns {DeserializedType} deserialized data\n\t */\n\t_deserialize(data, context) {\n\t\tlet currentDataItem = 0;\n\t\tlet currentBuffer = data[0];\n\t\tlet currentIsBuffer = Buffer.isBuffer(currentBuffer);\n\t\tlet currentPosition = 0;\n\n\t\tconst retainedBuffer = context.retainedBuffer || (x => x);\n\n\t\tconst checkOverflow = () => {\n\t\t\tif (currentPosition >= currentBuffer.length) {\n\t\t\t\tcurrentPosition = 0;\n\t\t\t\tcurrentDataItem++;\n\t\t\t\tcurrentBuffer =\n\t\t\t\t\tcurrentDataItem < data.length ? data[currentDataItem] : null;\n\t\t\t\tcurrentIsBuffer = Buffer.isBuffer(currentBuffer);\n\t\t\t}\n\t\t};\n\t\tconst isInCurrentBuffer = n => {\n\t\t\treturn currentIsBuffer && n + currentPosition <= currentBuffer.length;\n\t\t};\n\t\tconst ensureBuffer = () => {\n\t\t\tif (!currentIsBuffer) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\tcurrentBuffer === null\n\t\t\t\t\t\t? \"Unexpected end of stream\"\n\t\t\t\t\t\t: \"Unexpected lazy element in stream\"\n\t\t\t\t);\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * Reads n bytes\n\t\t * @param {number} n amount of bytes to read\n\t\t * @returns {Buffer} buffer with bytes\n\t\t */\n\t\tconst read = n => {\n\t\t\tensureBuffer();\n\t\t\tconst rem = currentBuffer.length - currentPosition;\n\t\t\tif (rem < n) {\n\t\t\t\tconst buffers = [read(rem)];\n\t\t\t\tn -= rem;\n\t\t\t\tensureBuffer();\n\t\t\t\twhile (currentBuffer.length < n) {\n\t\t\t\t\tconst b = /** @type {Buffer} */ (currentBuffer);\n\t\t\t\t\tbuffers.push(b);\n\t\t\t\t\tn -= b.length;\n\t\t\t\t\tcurrentDataItem++;\n\t\t\t\t\tcurrentBuffer =\n\t\t\t\t\t\tcurrentDataItem < data.length ? data[currentDataItem] : null;\n\t\t\t\t\tcurrentIsBuffer = Buffer.isBuffer(currentBuffer);\n\t\t\t\t\tensureBuffer();\n\t\t\t\t}\n\t\t\t\tbuffers.push(read(n));\n\t\t\t\treturn Buffer.concat(buffers);\n\t\t\t}\n\t\t\tconst b = /** @type {Buffer} */ (currentBuffer);\n\t\t\tconst res = Buffer.from(b.buffer, b.byteOffset + currentPosition, n);\n\t\t\tcurrentPosition += n;\n\t\t\tcheckOverflow();\n\t\t\treturn res;\n\t\t};\n\t\t/**\n\t\t * Reads up to n bytes\n\t\t * @param {number} n amount of bytes to read\n\t\t * @returns {Buffer} buffer with bytes\n\t\t */\n\t\tconst readUpTo = n => {\n\t\t\tensureBuffer();\n\t\t\tconst rem = currentBuffer.length - currentPosition;\n\t\t\tif (rem < n) {\n\t\t\t\tn = rem;\n\t\t\t}\n\t\t\tconst b = /** @type {Buffer} */ (currentBuffer);\n\t\t\tconst res = Buffer.from(b.buffer, b.byteOffset + currentPosition, n);\n\t\t\tcurrentPosition += n;\n\t\t\tcheckOverflow();\n\t\t\treturn res;\n\t\t};\n\t\tconst readU8 = () => {\n\t\t\tensureBuffer();\n\t\t\t/**\n\t\t\t * There is no need to check remaining buffer size here\n\t\t\t * since {@link checkOverflow} guarantees at least one byte remaining\n\t\t\t */\n\t\t\tconst byte = /** @type {Buffer} */ (currentBuffer).readUInt8(\n\t\t\t\tcurrentPosition\n\t\t\t);\n\t\t\tcurrentPosition += I8_SIZE;\n\t\t\tcheckOverflow();\n\t\t\treturn byte;\n\t\t};\n\t\tconst readU32 = () => {\n\t\t\treturn read(I32_SIZE).readUInt32LE(0);\n\t\t};\n\t\tconst readBits = (data, n) => {\n\t\t\tlet mask = 1;\n\t\t\twhile (n !== 0) {\n\t\t\t\tresult.push((data & mask) !== 0);\n\t\t\t\tmask = mask << 1;\n\t\t\t\tn--;\n\t\t\t}\n\t\t};\n\t\tconst dispatchTable = Array.from({ length: 256 }).map((_, header) => {\n\t\t\tswitch (header) {\n\t\t\t\tcase LAZY_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst count = readU32();\n\t\t\t\t\t\tconst lengths = Array.from({ length: count }).map(() => readU32());\n\t\t\t\t\t\tconst content = [];\n\t\t\t\t\t\tfor (let l of lengths) {\n\t\t\t\t\t\t\tif (l === 0) {\n\t\t\t\t\t\t\t\tif (typeof currentBuffer !== \"function\") {\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Unexpected non-lazy element in stream\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontent.push(currentBuffer);\n\t\t\t\t\t\t\t\tcurrentDataItem++;\n\t\t\t\t\t\t\t\tcurrentBuffer =\n\t\t\t\t\t\t\t\t\tcurrentDataItem < data.length ? data[currentDataItem] : null;\n\t\t\t\t\t\t\t\tcurrentIsBuffer = Buffer.isBuffer(currentBuffer);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\tconst buf = readUpTo(l);\n\t\t\t\t\t\t\t\t\tl -= buf.length;\n\t\t\t\t\t\t\t\t\tcontent.push(retainedBuffer(buf));\n\t\t\t\t\t\t\t\t} while (l > 0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.push(this._createLazyDeserialized(content, context));\n\t\t\t\t\t};\n\t\t\t\tcase BUFFER_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst len = readU32();\n\t\t\t\t\t\tresult.push(retainedBuffer(read(len)));\n\t\t\t\t\t};\n\t\t\t\tcase TRUE_HEADER:\n\t\t\t\t\treturn () => result.push(true);\n\t\t\t\tcase FALSE_HEADER:\n\t\t\t\t\treturn () => result.push(false);\n\t\t\t\tcase NULL3_HEADER:\n\t\t\t\t\treturn () => result.push(null, null, null);\n\t\t\t\tcase NULL2_HEADER:\n\t\t\t\t\treturn () => result.push(null, null);\n\t\t\t\tcase NULL_HEADER:\n\t\t\t\t\treturn () => result.push(null);\n\t\t\t\tcase NULL_AND_TRUE_HEADER:\n\t\t\t\t\treturn () => result.push(null, true);\n\t\t\t\tcase NULL_AND_FALSE_HEADER:\n\t\t\t\t\treturn () => result.push(null, false);\n\t\t\t\tcase NULL_AND_I8_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tif (currentIsBuffer) {\n\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t/** @type {Buffer} */ (currentBuffer).readInt8(currentPosition)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcurrentPosition += I8_SIZE;\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.push(null, read(I8_SIZE).readInt8(0));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase NULL_AND_I32_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tresult.push(null);\n\t\t\t\t\t\tif (isInCurrentBuffer(I32_SIZE)) {\n\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\t/** @type {Buffer} */ (currentBuffer).readInt32LE(\n\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.push(read(I32_SIZE).readInt32LE(0));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase NULLS8_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst len = readU8() + 4;\n\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\tresult.push(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase NULLS32_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst len = readU32() + 260;\n\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\tresult.push(null);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase BOOLEANS_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst innerHeader = readU8();\n\t\t\t\t\t\tif ((innerHeader & 0xf0) === 0) {\n\t\t\t\t\t\t\treadBits(innerHeader, 3);\n\t\t\t\t\t\t} else if ((innerHeader & 0xe0) === 0) {\n\t\t\t\t\t\t\treadBits(innerHeader, 4);\n\t\t\t\t\t\t} else if ((innerHeader & 0xc0) === 0) {\n\t\t\t\t\t\t\treadBits(innerHeader, 5);\n\t\t\t\t\t\t} else if ((innerHeader & 0x80) === 0) {\n\t\t\t\t\t\t\treadBits(innerHeader, 6);\n\t\t\t\t\t\t} else if (innerHeader !== 0xff) {\n\t\t\t\t\t\t\tlet count = (innerHeader & 0x7f) + 7;\n\t\t\t\t\t\t\twhile (count > 8) {\n\t\t\t\t\t\t\t\treadBits(readU8(), 8);\n\t\t\t\t\t\t\t\tcount -= 8;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treadBits(readU8(), count);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet count = readU32();\n\t\t\t\t\t\t\twhile (count > 8) {\n\t\t\t\t\t\t\t\treadBits(readU8(), 8);\n\t\t\t\t\t\t\t\tcount -= 8;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treadBits(readU8(), count);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase STRING_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tconst len = readU32();\n\t\t\t\t\t\tif (isInCurrentBuffer(len) && currentPosition + len < 0x7fffffff) {\n\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\tcurrentBuffer.toString(\n\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\tcurrentPosition,\n\t\t\t\t\t\t\t\t\tcurrentPosition + len\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcurrentPosition += len;\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.push(read(len).toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase SHORT_STRING_HEADER:\n\t\t\t\t\treturn () => result.push(\"\");\n\t\t\t\tcase SHORT_STRING_HEADER | 1:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tif (currentIsBuffer && currentPosition < 0x7ffffffe) {\n\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\tcurrentBuffer.toString(\n\t\t\t\t\t\t\t\t\t\"latin1\",\n\t\t\t\t\t\t\t\t\tcurrentPosition,\n\t\t\t\t\t\t\t\t\tcurrentPosition + 1\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcurrentPosition++;\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.push(read(1).toString(\"latin1\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tcase I8_HEADER:\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tif (currentIsBuffer) {\n\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\t/** @type {Buffer} */ (currentBuffer).readInt8(currentPosition)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcurrentPosition++;\n\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.push(read(1).readInt8(0));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\tdefault:\n\t\t\t\t\tif (header <= 10) {\n\t\t\t\t\t\treturn () => result.push(header);\n\t\t\t\t\t} else if ((header & SHORT_STRING_HEADER) === SHORT_STRING_HEADER) {\n\t\t\t\t\t\tconst len = header & SHORT_STRING_LENGTH_MASK;\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tisInCurrentBuffer(len) &&\n\t\t\t\t\t\t\t\tcurrentPosition + len < 0x7fffffff\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\t\tcurrentBuffer.toString(\n\t\t\t\t\t\t\t\t\t\t\"latin1\",\n\t\t\t\t\t\t\t\t\t\tcurrentPosition,\n\t\t\t\t\t\t\t\t\t\tcurrentPosition + len\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcurrentPosition += len;\n\t\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult.push(read(len).toString(\"latin1\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if ((header & NUMBERS_HEADER_MASK) === F64_HEADER) {\n\t\t\t\t\t\tconst len = (header & NUMBERS_COUNT_MASK) + 1;\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\tconst need = F64_SIZE * len;\n\t\t\t\t\t\t\tif (isInCurrentBuffer(need)) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\t\t\t/** @type {Buffer} */ (currentBuffer).readDoubleLE(\n\t\t\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tcurrentPosition += F64_SIZE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst buf = read(need);\n\t\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\t\tresult.push(buf.readDoubleLE(i * F64_SIZE));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if ((header & NUMBERS_HEADER_MASK) === I32_HEADER) {\n\t\t\t\t\t\tconst len = (header & NUMBERS_COUNT_MASK) + 1;\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\tconst need = I32_SIZE * len;\n\t\t\t\t\t\t\tif (isInCurrentBuffer(need)) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\t\t\t/** @type {Buffer} */ (currentBuffer).readInt32LE(\n\t\t\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tcurrentPosition += I32_SIZE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst buf = read(need);\n\t\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\t\tresult.push(buf.readInt32LE(i * I32_SIZE));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if ((header & NUMBERS_HEADER_MASK) === I8_HEADER) {\n\t\t\t\t\t\tconst len = (header & NUMBERS_COUNT_MASK) + 1;\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\tconst need = I8_SIZE * len;\n\t\t\t\t\t\t\tif (isInCurrentBuffer(need)) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\t\tresult.push(\n\t\t\t\t\t\t\t\t\t\t/** @type {Buffer} */ (currentBuffer).readInt8(\n\t\t\t\t\t\t\t\t\t\t\tcurrentPosition\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tcurrentPosition += I8_SIZE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcheckOverflow();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst buf = read(need);\n\t\t\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\t\tresult.push(buf.readInt8(i * I8_SIZE));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn () => {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unexpected header byte 0x${header.toString(16)}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t/** @type {DeserializedType} */\n\t\tlet result = [];\n\t\twhile (currentBuffer !== null) {\n\t\t\tif (typeof currentBuffer === \"function\") {\n\t\t\t\tresult.push(this._deserializeLazy(currentBuffer, context));\n\t\t\t\tcurrentDataItem++;\n\t\t\t\tcurrentBuffer =\n\t\t\t\t\tcurrentDataItem < data.length ? data[currentDataItem] : null;\n\t\t\t\tcurrentIsBuffer = Buffer.isBuffer(currentBuffer);\n\t\t\t} else {\n\t\t\t\tconst header = readU8();\n\t\t\t\tdispatchTable[header]();\n\t\t\t}\n\t\t}\n\n\t\t// avoid leaking memory in context\n\t\tlet _result = result;\n\t\tresult = undefined;\n\t\treturn _result;\n\t}\n}\n\nmodule.exports = BinaryMiddleware;\n\nmodule.exports.MEASURE_START_OPERATION = MEASURE_START_OPERATION;\nmodule.exports.MEASURE_END_OPERATION = MEASURE_END_OPERATION;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}