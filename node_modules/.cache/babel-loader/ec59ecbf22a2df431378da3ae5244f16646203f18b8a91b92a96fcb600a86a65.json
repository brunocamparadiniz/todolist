{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n// Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar similarity = function similarity(a, b) {\n  var l = Math.min(a.length, b.length);\n  var dist = 0;\n  for (var i = 0; i < l; i++) {\n    var ca = a.charCodeAt(i);\n    var cb = b.charCodeAt(i);\n    dist += Math.max(0, 10 - Math.abs(ca - cb));\n  }\n  return dist;\n};\n\n/**\n * @param {string} a key\n * @param {string} b key\n * @param {Set<string>} usedNames set of already used names\n * @returns {string} the common part and a single char for the difference\n */\nvar getName = function getName(a, b, usedNames) {\n  var l = Math.min(a.length, b.length);\n  var i = 0;\n  while (i < l) {\n    if (a.charCodeAt(i) !== b.charCodeAt(i)) {\n      i++;\n      break;\n    }\n    i++;\n  }\n  while (i < l) {\n    var name = a.slice(0, i);\n    var lowerName = name.toLowerCase();\n    if (!usedNames.has(lowerName)) {\n      usedNames.add(lowerName);\n      return name;\n    }\n    i++;\n  }\n  // names always contain a hash, so this is always unique\n  // we don't need to check usedNames nor add it\n  return a;\n};\n\n/**\n * @param {Record<string, number>} total total size\n * @param {Record<string, number>} size single size\n * @returns {void}\n */\nvar addSizeTo = function addSizeTo(total, size) {\n  for (var _i = 0, _Object$keys = Object.keys(size); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    total[key] = (total[key] || 0) + size[key];\n  }\n};\n\n/**\n * @param {Record<string, number>} total total size\n * @param {Record<string, number>} size single size\n * @returns {void}\n */\nvar subtractSizeFrom = function subtractSizeFrom(total, size) {\n  for (var _i2 = 0, _Object$keys2 = Object.keys(size); _i2 < _Object$keys2.length; _i2++) {\n    var key = _Object$keys2[_i2];\n    total[key] -= size[key];\n  }\n};\n\n/**\n * @param {Iterable<Node>} nodes some nodes\n * @returns {Record<string, number>} total size\n */\nvar sumSize = function sumSize(nodes) {\n  var sum = Object.create(null);\n  var _iterator = _createForOfIteratorHelper(nodes),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var node = _step.value;\n      addSizeTo(sum, node.size);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return sum;\n};\nvar isTooBig = function isTooBig(size, maxSize) {\n  for (var _i3 = 0, _Object$keys3 = Object.keys(size); _i3 < _Object$keys3.length; _i3++) {\n    var key = _Object$keys3[_i3];\n    var s = size[key];\n    if (s === 0) continue;\n    var maxSizeValue = maxSize[key];\n    if (typeof maxSizeValue === \"number\") {\n      if (s > maxSizeValue) return true;\n    }\n  }\n  return false;\n};\nvar isTooSmall = function isTooSmall(size, minSize) {\n  for (var _i4 = 0, _Object$keys4 = Object.keys(size); _i4 < _Object$keys4.length; _i4++) {\n    var key = _Object$keys4[_i4];\n    var s = size[key];\n    if (s === 0) continue;\n    var minSizeValue = minSize[key];\n    if (typeof minSizeValue === \"number\") {\n      if (s < minSizeValue) return true;\n    }\n  }\n  return false;\n};\nvar getTooSmallTypes = function getTooSmallTypes(size, minSize) {\n  var types = new Set();\n  for (var _i5 = 0, _Object$keys5 = Object.keys(size); _i5 < _Object$keys5.length; _i5++) {\n    var key = _Object$keys5[_i5];\n    var s = size[key];\n    if (s === 0) continue;\n    var minSizeValue = minSize[key];\n    if (typeof minSizeValue === \"number\") {\n      if (s < minSizeValue) types.add(key);\n    }\n  }\n  return types;\n};\nvar getNumberOfMatchingSizeTypes = function getNumberOfMatchingSizeTypes(size, types) {\n  var i = 0;\n  for (var _i6 = 0, _Object$keys6 = Object.keys(size); _i6 < _Object$keys6.length; _i6++) {\n    var key = _Object$keys6[_i6];\n    if (size[key] !== 0 && types.has(key)) i++;\n  }\n  return i;\n};\nvar selectiveSizeSum = function selectiveSizeSum(size, types) {\n  var sum = 0;\n  for (var _i7 = 0, _Object$keys7 = Object.keys(size); _i7 < _Object$keys7.length; _i7++) {\n    var key = _Object$keys7[_i7];\n    if (size[key] !== 0 && types.has(key)) sum += size[key];\n  }\n  return sum;\n};\n\n/**\n * @template T\n */\nvar Node = /*#__PURE__*/_createClass(\n/**\n * @param {T} item item\n * @param {string} key key\n * @param {Record<string, number>} size size\n */\nfunction Node(item, key, size) {\n  _classCallCheck(this, Node);\n  this.item = item;\n  this.key = key;\n  this.size = size;\n});\n/**\n * @template T\n */\nvar Group = /*#__PURE__*/function () {\n  /**\n   * @param {Node<T>[]} nodes nodes\n   * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n   * @param {Record<string, number>=} size size of the group\n   */\n  function Group(nodes, similarities, size) {\n    _classCallCheck(this, Group);\n    this.nodes = nodes;\n    this.similarities = similarities;\n    this.size = size || sumSize(nodes);\n    /** @type {string} */\n    this.key = undefined;\n  }\n\n  /**\n   * @param {function(Node): boolean} filter filter function\n   * @returns {Node[]} removed nodes\n   */\n  _createClass(Group, [{\n    key: \"popNodes\",\n    value: function popNodes(filter) {\n      var newNodes = [];\n      var newSimilarities = [];\n      var resultNodes = [];\n      var lastNode;\n      for (var i = 0; i < this.nodes.length; i++) {\n        var node = this.nodes[i];\n        if (filter(node)) {\n          resultNodes.push(node);\n        } else {\n          if (newNodes.length > 0) {\n            newSimilarities.push(lastNode === this.nodes[i - 1] ? this.similarities[i - 1] : similarity(lastNode.key, node.key));\n          }\n          newNodes.push(node);\n          lastNode = node;\n        }\n      }\n      if (resultNodes.length === this.nodes.length) return undefined;\n      this.nodes = newNodes;\n      this.similarities = newSimilarities;\n      this.size = sumSize(newNodes);\n      return resultNodes;\n    }\n  }]);\n  return Group;\n}();\n/**\n * @param {Iterable<Node>} nodes nodes\n * @returns {number[]} similarities\n */\nvar getSimilarities = function getSimilarities(nodes) {\n  // calculate similarities between lexically adjacent nodes\n  /** @type {number[]} */\n  var similarities = [];\n  var last = undefined;\n  var _iterator2 = _createForOfIteratorHelper(nodes),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var node = _step2.value;\n      if (last !== undefined) {\n        similarities.push(similarity(last.key, node.key));\n      }\n      last = node;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return similarities;\n};\n\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {Record<string, number>} size\n */\n\n/**\n * @template T\n * @typedef {Object} Options\n * @property {Record<string, number>} maxSize maximum size of a group\n * @property {Record<string, number>} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): Record<string, number>} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\nmodule.exports = function (_ref) {\n  var maxSize = _ref.maxSize,\n    minSize = _ref.minSize,\n    items = _ref.items,\n    getSize = _ref.getSize,\n    getKey = _ref.getKey;\n  /** @type {Group<T>[]} */\n  var result = [];\n  var nodes = Array.from(items, function (item) {\n    return new Node(item, getKey(item), getSize(item));\n  });\n\n  /** @type {Node<T>[]} */\n  var initialNodes = [];\n\n  // lexically ordering of keys\n  nodes.sort(function (a, b) {\n    if (a.key < b.key) return -1;\n    if (a.key > b.key) return 1;\n    return 0;\n  });\n\n  // return nodes bigger than maxSize directly as group\n  // But make sure that minSize is not violated\n  for (var _i8 = 0, _nodes = nodes; _i8 < _nodes.length; _i8++) {\n    var node = _nodes[_i8];\n    if (isTooBig(node.size, maxSize) && !isTooSmall(node.size, minSize)) {\n      result.push(new Group([node], []));\n    } else {\n      initialNodes.push(node);\n    }\n  }\n  if (initialNodes.length > 0) {\n    var initialGroup = new Group(initialNodes, getSimilarities(initialNodes));\n    var removeProblematicNodes = function removeProblematicNodes(group) {\n      var consideredSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : group.size;\n      var problemTypes = getTooSmallTypes(consideredSize, minSize);\n      if (problemTypes.size > 0) {\n        // We hit an edge case where the working set is already smaller than minSize\n        // We merge problematic nodes with the smallest result node to keep minSize intact\n        var problemNodes = group.popNodes(function (n) {\n          return getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0;\n        });\n        if (problemNodes === undefined) return false;\n        // Only merge it with result nodes that have the problematic size type\n        var possibleResultGroups = result.filter(function (n) {\n          return getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0;\n        });\n        if (possibleResultGroups.length > 0) {\n          var bestGroup = possibleResultGroups.reduce(function (min, group) {\n            var minMatches = getNumberOfMatchingSizeTypes(min, problemTypes);\n            var groupMatches = getNumberOfMatchingSizeTypes(group, problemTypes);\n            if (minMatches !== groupMatches) return minMatches < groupMatches ? group : min;\n            if (selectiveSizeSum(min.size, problemTypes) > selectiveSizeSum(group.size, problemTypes)) return group;\n            return min;\n          });\n          var _iterator3 = _createForOfIteratorHelper(problemNodes),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _node = _step3.value;\n              bestGroup.nodes.push(_node);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          bestGroup.nodes.sort(function (a, b) {\n            if (a.key < b.key) return -1;\n            if (a.key > b.key) return 1;\n            return 0;\n          });\n        } else {\n          // There are no other nodes with the same size types\n          // We create a new group and have to accept that it's smaller than minSize\n          result.push(new Group(problemNodes, null));\n        }\n        return true;\n      } else {\n        return false;\n      }\n    };\n    if (initialGroup.nodes.length > 0) {\n      var queue = [initialGroup];\n      while (queue.length) {\n        var group = queue.pop();\n        // only groups bigger than maxSize need to be splitted\n        if (!isTooBig(group.size, maxSize)) {\n          result.push(group);\n          continue;\n        }\n        // If the group is already too small\n        // we try to work only with the unproblematic nodes\n        if (removeProblematicNodes(group)) {\n          // This changed something, so we try this group again\n          queue.push(group);\n          continue;\n        }\n\n        // find unsplittable area from left and right\n        // going minSize from left and right\n        // at least one node need to be included otherwise we get stuck\n        var left = 1;\n        var leftSize = Object.create(null);\n        addSizeTo(leftSize, group.nodes[0].size);\n        while (left < group.nodes.length && isTooSmall(leftSize, minSize)) {\n          addSizeTo(leftSize, group.nodes[left].size);\n          left++;\n        }\n        var right = group.nodes.length - 2;\n        var rightSize = Object.create(null);\n        addSizeTo(rightSize, group.nodes[group.nodes.length - 1].size);\n        while (right >= 0 && isTooSmall(rightSize, minSize)) {\n          addSizeTo(rightSize, group.nodes[right].size);\n          right--;\n        }\n\n        //      left v   v right\n        // [ O O O ] O O O [ O O O ]\n        // ^^^^^^^^^ leftSize\n        //       rightSize ^^^^^^^^^\n        // leftSize > minSize\n        // rightSize > minSize\n\n        // Perfect split: [ O O O ] [ O O O ]\n        //                right === left - 1\n\n        if (left - 1 > right) {\n          // We try to remove some problematic nodes to \"fix\" that\n          var prevSize = void 0;\n          if (right < group.nodes.length - left) {\n            subtractSizeFrom(rightSize, group.nodes[right + 1].size);\n            prevSize = rightSize;\n          } else {\n            subtractSizeFrom(leftSize, group.nodes[left - 1].size);\n            prevSize = leftSize;\n          }\n          if (removeProblematicNodes(group, prevSize)) {\n            // This changed something, so we try this group again\n            queue.push(group);\n            continue;\n          }\n          // can't split group while holding minSize\n          // because minSize is preferred of maxSize we return\n          // the problematic nodes as result here even while it's too big\n          // To avoid this make sure maxSize > minSize * 3\n          result.push(group);\n          continue;\n        }\n        if (left <= right) {\n          // when there is a area between left and right\n          // we look for best split point\n          // we split at the minimum similarity\n          // here key space is separated the most\n          // But we also need to make sure to not create too small groups\n          var best = -1;\n          var bestSimilarity = Infinity;\n          var pos = left;\n          var _rightSize = sumSize(group.nodes.slice(pos));\n\n          //       pos v   v right\n          // [ O O O ] O O O [ O O O ]\n          // ^^^^^^^^^ leftSize\n          // rightSize ^^^^^^^^^^^^^^^\n\n          while (pos <= right + 1) {\n            var _similarity = group.similarities[pos - 1];\n            if (_similarity < bestSimilarity && !isTooSmall(leftSize, minSize) && !isTooSmall(_rightSize, minSize)) {\n              best = pos;\n              bestSimilarity = _similarity;\n            }\n            addSizeTo(leftSize, group.nodes[pos].size);\n            subtractSizeFrom(_rightSize, group.nodes[pos].size);\n            pos++;\n          }\n          if (best < 0) {\n            // This can't happen\n            // but if that assumption is wrong\n            // fallback to a big group\n            result.push(group);\n            continue;\n          }\n          left = best;\n          right = best - 1;\n        }\n\n        // create two new groups for left and right area\n        // and queue them up\n        var rightNodes = [group.nodes[right + 1]];\n        /** @type {number[]} */\n        var rightSimilarities = [];\n        for (var i = right + 2; i < group.nodes.length; i++) {\n          rightSimilarities.push(group.similarities[i - 1]);\n          rightNodes.push(group.nodes[i]);\n        }\n        queue.push(new Group(rightNodes, rightSimilarities));\n        var leftNodes = [group.nodes[0]];\n        /** @type {number[]} */\n        var leftSimilarities = [];\n        for (var _i9 = 1; _i9 < left; _i9++) {\n          leftSimilarities.push(group.similarities[_i9 - 1]);\n          leftNodes.push(group.nodes[_i9]);\n        }\n        queue.push(new Group(leftNodes, leftSimilarities));\n      }\n    }\n  }\n\n  // lexically ordering\n  result.sort(function (a, b) {\n    if (a.nodes[0].key < b.nodes[0].key) return -1;\n    if (a.nodes[0].key > b.nodes[0].key) return 1;\n    return 0;\n  });\n\n  // give every group a name\n  var usedNames = new Set();\n  for (var _i10 = 0; _i10 < result.length; _i10++) {\n    var _group = result[_i10];\n    if (_group.nodes.length === 1) {\n      _group.key = _group.nodes[0].key;\n    } else {\n      var first = _group.nodes[0];\n      var last = _group.nodes[_group.nodes.length - 1];\n      var name = getName(first.key, last.key, usedNames);\n      _group.key = name;\n    }\n  }\n\n  // return the results\n  return result.map(function (group) {\n    /** @type {GroupedItems<T>} */\n    return {\n      key: group.key,\n      items: group.nodes.map(function (node) {\n        return node.item;\n      }),\n      size: group.size\n    };\n  });\n};","map":{"version":3,"names":["similarity","a","b","l","Math","min","length","dist","i","ca","charCodeAt","cb","max","abs","getName","usedNames","name","slice","lowerName","toLowerCase","has","add","addSizeTo","total","size","Object","keys","key","subtractSizeFrom","sumSize","nodes","sum","create","node","isTooBig","maxSize","s","maxSizeValue","isTooSmall","minSize","minSizeValue","getTooSmallTypes","types","Set","getNumberOfMatchingSizeTypes","selectiveSizeSum","Node","item","Group","similarities","undefined","filter","newNodes","newSimilarities","resultNodes","lastNode","push","getSimilarities","last","module","exports","items","getSize","getKey","result","Array","from","initialNodes","sort","initialGroup","removeProblematicNodes","group","consideredSize","problemTypes","problemNodes","popNodes","n","possibleResultGroups","bestGroup","reduce","minMatches","groupMatches","queue","pop","left","leftSize","right","rightSize","prevSize","best","bestSimilarity","Infinity","pos","rightNodes","rightSimilarities","leftNodes","leftSimilarities","first","map"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/util/deterministicGrouping.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n// Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\nconst similarity = (a, b) => {\n\tconst l = Math.min(a.length, b.length);\n\tlet dist = 0;\n\tfor (let i = 0; i < l; i++) {\n\t\tconst ca = a.charCodeAt(i);\n\t\tconst cb = b.charCodeAt(i);\n\t\tdist += Math.max(0, 10 - Math.abs(ca - cb));\n\t}\n\treturn dist;\n};\n\n/**\n * @param {string} a key\n * @param {string} b key\n * @param {Set<string>} usedNames set of already used names\n * @returns {string} the common part and a single char for the difference\n */\nconst getName = (a, b, usedNames) => {\n\tconst l = Math.min(a.length, b.length);\n\tlet i = 0;\n\twhile (i < l) {\n\t\tif (a.charCodeAt(i) !== b.charCodeAt(i)) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\twhile (i < l) {\n\t\tconst name = a.slice(0, i);\n\t\tconst lowerName = name.toLowerCase();\n\t\tif (!usedNames.has(lowerName)) {\n\t\t\tusedNames.add(lowerName);\n\t\t\treturn name;\n\t\t}\n\t\ti++;\n\t}\n\t// names always contain a hash, so this is always unique\n\t// we don't need to check usedNames nor add it\n\treturn a;\n};\n\n/**\n * @param {Record<string, number>} total total size\n * @param {Record<string, number>} size single size\n * @returns {void}\n */\nconst addSizeTo = (total, size) => {\n\tfor (const key of Object.keys(size)) {\n\t\ttotal[key] = (total[key] || 0) + size[key];\n\t}\n};\n\n/**\n * @param {Record<string, number>} total total size\n * @param {Record<string, number>} size single size\n * @returns {void}\n */\nconst subtractSizeFrom = (total, size) => {\n\tfor (const key of Object.keys(size)) {\n\t\ttotal[key] -= size[key];\n\t}\n};\n\n/**\n * @param {Iterable<Node>} nodes some nodes\n * @returns {Record<string, number>} total size\n */\nconst sumSize = nodes => {\n\tconst sum = Object.create(null);\n\tfor (const node of nodes) {\n\t\taddSizeTo(sum, node.size);\n\t}\n\treturn sum;\n};\n\nconst isTooBig = (size, maxSize) => {\n\tfor (const key of Object.keys(size)) {\n\t\tconst s = size[key];\n\t\tif (s === 0) continue;\n\t\tconst maxSizeValue = maxSize[key];\n\t\tif (typeof maxSizeValue === \"number\") {\n\t\t\tif (s > maxSizeValue) return true;\n\t\t}\n\t}\n\treturn false;\n};\n\nconst isTooSmall = (size, minSize) => {\n\tfor (const key of Object.keys(size)) {\n\t\tconst s = size[key];\n\t\tif (s === 0) continue;\n\t\tconst minSizeValue = minSize[key];\n\t\tif (typeof minSizeValue === \"number\") {\n\t\t\tif (s < minSizeValue) return true;\n\t\t}\n\t}\n\treturn false;\n};\n\nconst getTooSmallTypes = (size, minSize) => {\n\tconst types = new Set();\n\tfor (const key of Object.keys(size)) {\n\t\tconst s = size[key];\n\t\tif (s === 0) continue;\n\t\tconst minSizeValue = minSize[key];\n\t\tif (typeof minSizeValue === \"number\") {\n\t\t\tif (s < minSizeValue) types.add(key);\n\t\t}\n\t}\n\treturn types;\n};\n\nconst getNumberOfMatchingSizeTypes = (size, types) => {\n\tlet i = 0;\n\tfor (const key of Object.keys(size)) {\n\t\tif (size[key] !== 0 && types.has(key)) i++;\n\t}\n\treturn i;\n};\n\nconst selectiveSizeSum = (size, types) => {\n\tlet sum = 0;\n\tfor (const key of Object.keys(size)) {\n\t\tif (size[key] !== 0 && types.has(key)) sum += size[key];\n\t}\n\treturn sum;\n};\n\n/**\n * @template T\n */\nclass Node {\n\t/**\n\t * @param {T} item item\n\t * @param {string} key key\n\t * @param {Record<string, number>} size size\n\t */\n\tconstructor(item, key, size) {\n\t\tthis.item = item;\n\t\tthis.key = key;\n\t\tthis.size = size;\n\t}\n}\n\n/**\n * @template T\n */\nclass Group {\n\t/**\n\t * @param {Node<T>[]} nodes nodes\n\t * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n\t * @param {Record<string, number>=} size size of the group\n\t */\n\tconstructor(nodes, similarities, size) {\n\t\tthis.nodes = nodes;\n\t\tthis.similarities = similarities;\n\t\tthis.size = size || sumSize(nodes);\n\t\t/** @type {string} */\n\t\tthis.key = undefined;\n\t}\n\n\t/**\n\t * @param {function(Node): boolean} filter filter function\n\t * @returns {Node[]} removed nodes\n\t */\n\tpopNodes(filter) {\n\t\tconst newNodes = [];\n\t\tconst newSimilarities = [];\n\t\tconst resultNodes = [];\n\t\tlet lastNode;\n\t\tfor (let i = 0; i < this.nodes.length; i++) {\n\t\t\tconst node = this.nodes[i];\n\t\t\tif (filter(node)) {\n\t\t\t\tresultNodes.push(node);\n\t\t\t} else {\n\t\t\t\tif (newNodes.length > 0) {\n\t\t\t\t\tnewSimilarities.push(\n\t\t\t\t\t\tlastNode === this.nodes[i - 1]\n\t\t\t\t\t\t\t? this.similarities[i - 1]\n\t\t\t\t\t\t\t: similarity(lastNode.key, node.key)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tnewNodes.push(node);\n\t\t\t\tlastNode = node;\n\t\t\t}\n\t\t}\n\t\tif (resultNodes.length === this.nodes.length) return undefined;\n\t\tthis.nodes = newNodes;\n\t\tthis.similarities = newSimilarities;\n\t\tthis.size = sumSize(newNodes);\n\t\treturn resultNodes;\n\t}\n}\n\n/**\n * @param {Iterable<Node>} nodes nodes\n * @returns {number[]} similarities\n */\nconst getSimilarities = nodes => {\n\t// calculate similarities between lexically adjacent nodes\n\t/** @type {number[]} */\n\tconst similarities = [];\n\tlet last = undefined;\n\tfor (const node of nodes) {\n\t\tif (last !== undefined) {\n\t\t\tsimilarities.push(similarity(last.key, node.key));\n\t\t}\n\t\tlast = node;\n\t}\n\treturn similarities;\n};\n\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {Record<string, number>} size\n */\n\n/**\n * @template T\n * @typedef {Object} Options\n * @property {Record<string, number>} maxSize maximum size of a group\n * @property {Record<string, number>} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): Record<string, number>} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\nmodule.exports = ({ maxSize, minSize, items, getSize, getKey }) => {\n\t/** @type {Group<T>[]} */\n\tconst result = [];\n\n\tconst nodes = Array.from(\n\t\titems,\n\t\titem => new Node(item, getKey(item), getSize(item))\n\t);\n\n\t/** @type {Node<T>[]} */\n\tconst initialNodes = [];\n\n\t// lexically ordering of keys\n\tnodes.sort((a, b) => {\n\t\tif (a.key < b.key) return -1;\n\t\tif (a.key > b.key) return 1;\n\t\treturn 0;\n\t});\n\n\t// return nodes bigger than maxSize directly as group\n\t// But make sure that minSize is not violated\n\tfor (const node of nodes) {\n\t\tif (isTooBig(node.size, maxSize) && !isTooSmall(node.size, minSize)) {\n\t\t\tresult.push(new Group([node], []));\n\t\t} else {\n\t\t\tinitialNodes.push(node);\n\t\t}\n\t}\n\n\tif (initialNodes.length > 0) {\n\t\tconst initialGroup = new Group(initialNodes, getSimilarities(initialNodes));\n\n\t\tconst removeProblematicNodes = (group, consideredSize = group.size) => {\n\t\t\tconst problemTypes = getTooSmallTypes(consideredSize, minSize);\n\t\t\tif (problemTypes.size > 0) {\n\t\t\t\t// We hit an edge case where the working set is already smaller than minSize\n\t\t\t\t// We merge problematic nodes with the smallest result node to keep minSize intact\n\t\t\t\tconst problemNodes = group.popNodes(\n\t\t\t\t\tn => getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0\n\t\t\t\t);\n\t\t\t\tif (problemNodes === undefined) return false;\n\t\t\t\t// Only merge it with result nodes that have the problematic size type\n\t\t\t\tconst possibleResultGroups = result.filter(\n\t\t\t\t\tn => getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0\n\t\t\t\t);\n\t\t\t\tif (possibleResultGroups.length > 0) {\n\t\t\t\t\tconst bestGroup = possibleResultGroups.reduce((min, group) => {\n\t\t\t\t\t\tconst minMatches = getNumberOfMatchingSizeTypes(min, problemTypes);\n\t\t\t\t\t\tconst groupMatches = getNumberOfMatchingSizeTypes(\n\t\t\t\t\t\t\tgroup,\n\t\t\t\t\t\t\tproblemTypes\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (minMatches !== groupMatches)\n\t\t\t\t\t\t\treturn minMatches < groupMatches ? group : min;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tselectiveSizeSum(min.size, problemTypes) >\n\t\t\t\t\t\t\tselectiveSizeSum(group.size, problemTypes)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\treturn group;\n\t\t\t\t\t\treturn min;\n\t\t\t\t\t});\n\t\t\t\t\tfor (const node of problemNodes) bestGroup.nodes.push(node);\n\t\t\t\t\tbestGroup.nodes.sort((a, b) => {\n\t\t\t\t\t\tif (a.key < b.key) return -1;\n\t\t\t\t\t\tif (a.key > b.key) return 1;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// There are no other nodes with the same size types\n\t\t\t\t\t// We create a new group and have to accept that it's smaller than minSize\n\t\t\t\t\tresult.push(new Group(problemNodes, null));\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\n\t\tif (initialGroup.nodes.length > 0) {\n\t\t\tconst queue = [initialGroup];\n\n\t\t\twhile (queue.length) {\n\t\t\t\tconst group = queue.pop();\n\t\t\t\t// only groups bigger than maxSize need to be splitted\n\t\t\t\tif (!isTooBig(group.size, maxSize)) {\n\t\t\t\t\tresult.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// If the group is already too small\n\t\t\t\t// we try to work only with the unproblematic nodes\n\t\t\t\tif (removeProblematicNodes(group)) {\n\t\t\t\t\t// This changed something, so we try this group again\n\t\t\t\t\tqueue.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// find unsplittable area from left and right\n\t\t\t\t// going minSize from left and right\n\t\t\t\t// at least one node need to be included otherwise we get stuck\n\t\t\t\tlet left = 1;\n\t\t\t\tlet leftSize = Object.create(null);\n\t\t\t\taddSizeTo(leftSize, group.nodes[0].size);\n\t\t\t\twhile (left < group.nodes.length && isTooSmall(leftSize, minSize)) {\n\t\t\t\t\taddSizeTo(leftSize, group.nodes[left].size);\n\t\t\t\t\tleft++;\n\t\t\t\t}\n\t\t\t\tlet right = group.nodes.length - 2;\n\t\t\t\tlet rightSize = Object.create(null);\n\t\t\t\taddSizeTo(rightSize, group.nodes[group.nodes.length - 1].size);\n\t\t\t\twhile (right >= 0 && isTooSmall(rightSize, minSize)) {\n\t\t\t\t\taddSizeTo(rightSize, group.nodes[right].size);\n\t\t\t\t\tright--;\n\t\t\t\t}\n\n\t\t\t\t//      left v   v right\n\t\t\t\t// [ O O O ] O O O [ O O O ]\n\t\t\t\t// ^^^^^^^^^ leftSize\n\t\t\t\t//       rightSize ^^^^^^^^^\n\t\t\t\t// leftSize > minSize\n\t\t\t\t// rightSize > minSize\n\n\t\t\t\t// Perfect split: [ O O O ] [ O O O ]\n\t\t\t\t//                right === left - 1\n\n\t\t\t\tif (left - 1 > right) {\n\t\t\t\t\t// We try to remove some problematic nodes to \"fix\" that\n\t\t\t\t\tlet prevSize;\n\t\t\t\t\tif (right < group.nodes.length - left) {\n\t\t\t\t\t\tsubtractSizeFrom(rightSize, group.nodes[right + 1].size);\n\t\t\t\t\t\tprevSize = rightSize;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsubtractSizeFrom(leftSize, group.nodes[left - 1].size);\n\t\t\t\t\t\tprevSize = leftSize;\n\t\t\t\t\t}\n\t\t\t\t\tif (removeProblematicNodes(group, prevSize)) {\n\t\t\t\t\t\t// This changed something, so we try this group again\n\t\t\t\t\t\tqueue.push(group);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// can't split group while holding minSize\n\t\t\t\t\t// because minSize is preferred of maxSize we return\n\t\t\t\t\t// the problematic nodes as result here even while it's too big\n\t\t\t\t\t// To avoid this make sure maxSize > minSize * 3\n\t\t\t\t\tresult.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (left <= right) {\n\t\t\t\t\t// when there is a area between left and right\n\t\t\t\t\t// we look for best split point\n\t\t\t\t\t// we split at the minimum similarity\n\t\t\t\t\t// here key space is separated the most\n\t\t\t\t\t// But we also need to make sure to not create too small groups\n\t\t\t\t\tlet best = -1;\n\t\t\t\t\tlet bestSimilarity = Infinity;\n\t\t\t\t\tlet pos = left;\n\t\t\t\t\tlet rightSize = sumSize(group.nodes.slice(pos));\n\n\t\t\t\t\t//       pos v   v right\n\t\t\t\t\t// [ O O O ] O O O [ O O O ]\n\t\t\t\t\t// ^^^^^^^^^ leftSize\n\t\t\t\t\t// rightSize ^^^^^^^^^^^^^^^\n\n\t\t\t\t\twhile (pos <= right + 1) {\n\t\t\t\t\t\tconst similarity = group.similarities[pos - 1];\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tsimilarity < bestSimilarity &&\n\t\t\t\t\t\t\t!isTooSmall(leftSize, minSize) &&\n\t\t\t\t\t\t\t!isTooSmall(rightSize, minSize)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tbest = pos;\n\t\t\t\t\t\t\tbestSimilarity = similarity;\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddSizeTo(leftSize, group.nodes[pos].size);\n\t\t\t\t\t\tsubtractSizeFrom(rightSize, group.nodes[pos].size);\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\t\t\t\t\tif (best < 0) {\n\t\t\t\t\t\t// This can't happen\n\t\t\t\t\t\t// but if that assumption is wrong\n\t\t\t\t\t\t// fallback to a big group\n\t\t\t\t\t\tresult.push(group);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tleft = best;\n\t\t\t\t\tright = best - 1;\n\t\t\t\t}\n\n\t\t\t\t// create two new groups for left and right area\n\t\t\t\t// and queue them up\n\t\t\t\tconst rightNodes = [group.nodes[right + 1]];\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tconst rightSimilarities = [];\n\t\t\t\tfor (let i = right + 2; i < group.nodes.length; i++) {\n\t\t\t\t\trightSimilarities.push(group.similarities[i - 1]);\n\t\t\t\t\trightNodes.push(group.nodes[i]);\n\t\t\t\t}\n\t\t\t\tqueue.push(new Group(rightNodes, rightSimilarities));\n\n\t\t\t\tconst leftNodes = [group.nodes[0]];\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tconst leftSimilarities = [];\n\t\t\t\tfor (let i = 1; i < left; i++) {\n\t\t\t\t\tleftSimilarities.push(group.similarities[i - 1]);\n\t\t\t\t\tleftNodes.push(group.nodes[i]);\n\t\t\t\t}\n\t\t\t\tqueue.push(new Group(leftNodes, leftSimilarities));\n\t\t\t}\n\t\t}\n\t}\n\n\t// lexically ordering\n\tresult.sort((a, b) => {\n\t\tif (a.nodes[0].key < b.nodes[0].key) return -1;\n\t\tif (a.nodes[0].key > b.nodes[0].key) return 1;\n\t\treturn 0;\n\t});\n\n\t// give every group a name\n\tconst usedNames = new Set();\n\tfor (let i = 0; i < result.length; i++) {\n\t\tconst group = result[i];\n\t\tif (group.nodes.length === 1) {\n\t\t\tgroup.key = group.nodes[0].key;\n\t\t} else {\n\t\t\tconst first = group.nodes[0];\n\t\t\tconst last = group.nodes[group.nodes.length - 1];\n\t\t\tconst name = getName(first.key, last.key, usedNames);\n\t\t\tgroup.key = name;\n\t\t}\n\t}\n\n\t// return the results\n\treturn result.map(group => {\n\t\t/** @type {GroupedItems<T>} */\n\t\treturn {\n\t\t\tkey: group.key,\n\t\t\titems: group.nodes.map(node => node.item),\n\t\t\tsize: group.size\n\t\t};\n\t});\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}