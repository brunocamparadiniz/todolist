{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n// 65536 is the size of a wasm memory page\n// 64 is the maximum chunk size for every possible wasm hash implementation\n// 4 is the maximum number of bytes per char for string encoding (max is utf-8)\n// ~3 makes sure that it's always a block of 4 chars, so avoid partially encoded bytes for base64\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar MAX_SHORT_STRING = Math.floor((65536 - 64) / 4) & ~3;\nvar WasmHash = /*#__PURE__*/function () {\n  /**\n   * @param {WebAssembly.Instance} instance wasm instance\n   * @param {WebAssembly.Instance[]} instancesPool pool of instances\n   * @param {number} chunkSize size of data chunks passed to wasm\n   * @param {number} digestSize size of digest returned by wasm\n   */\n  function WasmHash(instance, instancesPool, chunkSize, digestSize) {\n    _classCallCheck(this, WasmHash);\n    var exports = /** @type {any} */instance.exports;\n    exports.init();\n    this.exports = exports;\n    this.mem = Buffer.from(exports.memory.buffer, 0, 65536);\n    this.buffered = 0;\n    this.instancesPool = instancesPool;\n    this.chunkSize = chunkSize;\n    this.digestSize = digestSize;\n  }\n  _createClass(WasmHash, [{\n    key: \"reset\",\n    value: function reset() {\n      this.buffered = 0;\n      this.exports.init();\n    }\n\n    /**\n     * @param {Buffer | string} data data\n     * @param {BufferEncoding=} encoding encoding\n     * @returns {this} itself\n     */\n  }, {\n    key: \"update\",\n    value: function update(data, encoding) {\n      if (typeof data === \"string\") {\n        while (data.length > MAX_SHORT_STRING) {\n          this._updateWithShortString(data.slice(0, MAX_SHORT_STRING), encoding);\n          data = data.slice(MAX_SHORT_STRING);\n        }\n        this._updateWithShortString(data, encoding);\n        return this;\n      }\n      this._updateWithBuffer(data);\n      return this;\n    }\n\n    /**\n     * @param {string} data data\n     * @param {BufferEncoding=} encoding encoding\n     * @returns {void}\n     */\n  }, {\n    key: \"_updateWithShortString\",\n    value: function _updateWithShortString(data, encoding) {\n      var exports = this.exports,\n        buffered = this.buffered,\n        mem = this.mem,\n        chunkSize = this.chunkSize;\n      var endPos;\n      if (data.length < 70) {\n        if (!encoding || encoding === \"utf-8\" || encoding === \"utf8\") {\n          endPos = buffered;\n          for (var i = 0; i < data.length; i++) {\n            var cc = data.charCodeAt(i);\n            if (cc < 0x80) mem[endPos++] = cc;else if (cc < 0x800) {\n              mem[endPos] = cc >> 6 | 0xc0;\n              mem[endPos + 1] = cc & 0x3f | 0x80;\n              endPos += 2;\n            } else {\n              // bail-out for weird chars\n              endPos += mem.write(data.slice(i), endPos, encoding);\n              break;\n            }\n          }\n        } else if (encoding === \"latin1\") {\n          endPos = buffered;\n          for (var _i = 0; _i < data.length; _i++) {\n            var _cc = data.charCodeAt(_i);\n            mem[endPos++] = _cc;\n          }\n        } else {\n          endPos = buffered + mem.write(data, buffered, encoding);\n        }\n      } else {\n        endPos = buffered + mem.write(data, buffered, encoding);\n      }\n      if (endPos < chunkSize) {\n        this.buffered = endPos;\n      } else {\n        var l = endPos & ~(this.chunkSize - 1);\n        exports.update(l);\n        var newBuffered = endPos - l;\n        this.buffered = newBuffered;\n        if (newBuffered > 0) mem.copyWithin(0, l, endPos);\n      }\n    }\n\n    /**\n     * @param {Buffer} data data\n     * @returns {void}\n     */\n  }, {\n    key: \"_updateWithBuffer\",\n    value: function _updateWithBuffer(data) {\n      var exports = this.exports,\n        buffered = this.buffered,\n        mem = this.mem;\n      var length = data.length;\n      if (buffered + length < this.chunkSize) {\n        data.copy(mem, buffered, 0, length);\n        this.buffered += length;\n      } else {\n        var l = buffered + length & ~(this.chunkSize - 1);\n        if (l > 65536) {\n          var i = 65536 - buffered;\n          data.copy(mem, buffered, 0, i);\n          exports.update(65536);\n          var stop = l - buffered - 65536;\n          while (i < stop) {\n            data.copy(mem, 0, i, i + 65536);\n            exports.update(65536);\n            i += 65536;\n          }\n          data.copy(mem, 0, i, l - buffered);\n          exports.update(l - buffered - i);\n        } else {\n          data.copy(mem, buffered, 0, l - buffered);\n          exports.update(l);\n        }\n        var newBuffered = length + buffered - l;\n        this.buffered = newBuffered;\n        if (newBuffered > 0) data.copy(mem, 0, length - newBuffered, length);\n      }\n    }\n  }, {\n    key: \"digest\",\n    value: function digest(type) {\n      var exports = this.exports,\n        buffered = this.buffered,\n        mem = this.mem,\n        digestSize = this.digestSize;\n      exports.final(buffered);\n      this.instancesPool.push(this);\n      var hex = mem.toString(\"latin1\", 0, digestSize);\n      if (type === \"hex\") return hex;\n      if (type === \"binary\" || !type) return Buffer.from(hex, \"hex\");\n      return Buffer.from(hex, \"hex\").toString(type);\n    }\n  }]);\n  return WasmHash;\n}();\nvar create = function create(wasmModule, instancesPool, chunkSize, digestSize) {\n  if (instancesPool.length > 0) {\n    var old = instancesPool.pop();\n    old.reset();\n    return old;\n  } else {\n    return new WasmHash(new WebAssembly.Instance(wasmModule), instancesPool, chunkSize, digestSize);\n  }\n};\nmodule.exports = create;\nmodule.exports.MAX_SHORT_STRING = MAX_SHORT_STRING;","map":{"version":3,"names":["MAX_SHORT_STRING","Math","floor","WasmHash","instance","instancesPool","chunkSize","digestSize","exports","init","mem","Buffer","from","memory","buffer","buffered","data","encoding","length","_updateWithShortString","slice","_updateWithBuffer","endPos","i","cc","charCodeAt","write","l","update","newBuffered","copyWithin","copy","stop","type","final","push","hex","toString","create","wasmModule","old","pop","reset","WebAssembly","Instance","module"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/util/hash/wasm-hash.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n// 65536 is the size of a wasm memory page\n// 64 is the maximum chunk size for every possible wasm hash implementation\n// 4 is the maximum number of bytes per char for string encoding (max is utf-8)\n// ~3 makes sure that it's always a block of 4 chars, so avoid partially encoded bytes for base64\nconst MAX_SHORT_STRING = Math.floor((65536 - 64) / 4) & ~3;\n\nclass WasmHash {\n\t/**\n\t * @param {WebAssembly.Instance} instance wasm instance\n\t * @param {WebAssembly.Instance[]} instancesPool pool of instances\n\t * @param {number} chunkSize size of data chunks passed to wasm\n\t * @param {number} digestSize size of digest returned by wasm\n\t */\n\tconstructor(instance, instancesPool, chunkSize, digestSize) {\n\t\tconst exports = /** @type {any} */ (instance.exports);\n\t\texports.init();\n\t\tthis.exports = exports;\n\t\tthis.mem = Buffer.from(exports.memory.buffer, 0, 65536);\n\t\tthis.buffered = 0;\n\t\tthis.instancesPool = instancesPool;\n\t\tthis.chunkSize = chunkSize;\n\t\tthis.digestSize = digestSize;\n\t}\n\n\treset() {\n\t\tthis.buffered = 0;\n\t\tthis.exports.init();\n\t}\n\n\t/**\n\t * @param {Buffer | string} data data\n\t * @param {BufferEncoding=} encoding encoding\n\t * @returns {this} itself\n\t */\n\tupdate(data, encoding) {\n\t\tif (typeof data === \"string\") {\n\t\t\twhile (data.length > MAX_SHORT_STRING) {\n\t\t\t\tthis._updateWithShortString(data.slice(0, MAX_SHORT_STRING), encoding);\n\t\t\t\tdata = data.slice(MAX_SHORT_STRING);\n\t\t\t}\n\t\t\tthis._updateWithShortString(data, encoding);\n\t\t\treturn this;\n\t\t}\n\t\tthis._updateWithBuffer(data);\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {string} data data\n\t * @param {BufferEncoding=} encoding encoding\n\t * @returns {void}\n\t */\n\t_updateWithShortString(data, encoding) {\n\t\tconst { exports, buffered, mem, chunkSize } = this;\n\t\tlet endPos;\n\t\tif (data.length < 70) {\n\t\t\tif (!encoding || encoding === \"utf-8\" || encoding === \"utf8\") {\n\t\t\t\tendPos = buffered;\n\t\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\t\tconst cc = data.charCodeAt(i);\n\t\t\t\t\tif (cc < 0x80) mem[endPos++] = cc;\n\t\t\t\t\telse if (cc < 0x800) {\n\t\t\t\t\t\tmem[endPos] = (cc >> 6) | 0xc0;\n\t\t\t\t\t\tmem[endPos + 1] = (cc & 0x3f) | 0x80;\n\t\t\t\t\t\tendPos += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// bail-out for weird chars\n\t\t\t\t\t\tendPos += mem.write(data.slice(i), endPos, encoding);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (encoding === \"latin1\") {\n\t\t\t\tendPos = buffered;\n\t\t\t\tfor (let i = 0; i < data.length; i++) {\n\t\t\t\t\tconst cc = data.charCodeAt(i);\n\t\t\t\t\tmem[endPos++] = cc;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tendPos = buffered + mem.write(data, buffered, encoding);\n\t\t\t}\n\t\t} else {\n\t\t\tendPos = buffered + mem.write(data, buffered, encoding);\n\t\t}\n\t\tif (endPos < chunkSize) {\n\t\t\tthis.buffered = endPos;\n\t\t} else {\n\t\t\tconst l = endPos & ~(this.chunkSize - 1);\n\t\t\texports.update(l);\n\t\t\tconst newBuffered = endPos - l;\n\t\t\tthis.buffered = newBuffered;\n\t\t\tif (newBuffered > 0) mem.copyWithin(0, l, endPos);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Buffer} data data\n\t * @returns {void}\n\t */\n\t_updateWithBuffer(data) {\n\t\tconst { exports, buffered, mem } = this;\n\t\tconst length = data.length;\n\t\tif (buffered + length < this.chunkSize) {\n\t\t\tdata.copy(mem, buffered, 0, length);\n\t\t\tthis.buffered += length;\n\t\t} else {\n\t\t\tconst l = (buffered + length) & ~(this.chunkSize - 1);\n\t\t\tif (l > 65536) {\n\t\t\t\tlet i = 65536 - buffered;\n\t\t\t\tdata.copy(mem, buffered, 0, i);\n\t\t\t\texports.update(65536);\n\t\t\t\tconst stop = l - buffered - 65536;\n\t\t\t\twhile (i < stop) {\n\t\t\t\t\tdata.copy(mem, 0, i, i + 65536);\n\t\t\t\t\texports.update(65536);\n\t\t\t\t\ti += 65536;\n\t\t\t\t}\n\t\t\t\tdata.copy(mem, 0, i, l - buffered);\n\t\t\t\texports.update(l - buffered - i);\n\t\t\t} else {\n\t\t\t\tdata.copy(mem, buffered, 0, l - buffered);\n\t\t\t\texports.update(l);\n\t\t\t}\n\t\t\tconst newBuffered = length + buffered - l;\n\t\t\tthis.buffered = newBuffered;\n\t\t\tif (newBuffered > 0) data.copy(mem, 0, length - newBuffered, length);\n\t\t}\n\t}\n\n\tdigest(type) {\n\t\tconst { exports, buffered, mem, digestSize } = this;\n\t\texports.final(buffered);\n\t\tthis.instancesPool.push(this);\n\t\tconst hex = mem.toString(\"latin1\", 0, digestSize);\n\t\tif (type === \"hex\") return hex;\n\t\tif (type === \"binary\" || !type) return Buffer.from(hex, \"hex\");\n\t\treturn Buffer.from(hex, \"hex\").toString(type);\n\t}\n}\n\nconst create = (wasmModule, instancesPool, chunkSize, digestSize) => {\n\tif (instancesPool.length > 0) {\n\t\tconst old = instancesPool.pop();\n\t\told.reset();\n\t\treturn old;\n\t} else {\n\t\treturn new WasmHash(\n\t\t\tnew WebAssembly.Instance(wasmModule),\n\t\t\tinstancesPool,\n\t\t\tchunkSize,\n\t\t\tdigestSize\n\t\t);\n\t}\n};\n\nmodule.exports = create;\nmodule.exports.MAX_SHORT_STRING = MAX_SHORT_STRING;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}