{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar util = require(\"util\");\nvar SortableSet = require(\"./util/SortableSet\");\nvar _require = require(\"./util/comparators\"),\n  compareLocations = _require.compareLocations,\n  compareChunks = _require.compareChunks,\n  compareIterables = _require.compareIterables;\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"./Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n\n/** @typedef {{id: number}} HasId */\n/** @typedef {{module: Module, loc: DependencyLocation, request: string}} OriginRecord */\n\n/**\n * @typedef {Object} RawChunkGroupOptions\n * @property {number=} preloadOrder\n * @property {number=} prefetchOrder\n */\n\n/** @typedef {RawChunkGroupOptions & { name?: string }} ChunkGroupOptions */\n\nvar debugId = 5000;\n\n/**\n * @template T\n * @param {SortableSet<T>} set set to convert to array.\n * @returns {T[]} the array format of existing set\n */\nvar getArray = function getArray(set) {\n  return Array.from(set);\n};\n\n/**\n * A convenience method used to sort chunks based on their id's\n * @param {ChunkGroup} a first sorting comparator\n * @param {ChunkGroup} b second sorting comparator\n * @returns {1|0|-1} a sorting index to determine order\n */\nvar sortById = function sortById(a, b) {\n  if (a.id < b.id) return -1;\n  if (b.id < a.id) return 1;\n  return 0;\n};\n\n/**\n * @param {OriginRecord} a the first comparator in sort\n * @param {OriginRecord} b the second comparator in sort\n * @returns {1|-1|0} returns sorting order as index\n */\nvar sortOrigin = function sortOrigin(a, b) {\n  var aIdent = a.module ? a.module.identifier() : \"\";\n  var bIdent = b.module ? b.module.identifier() : \"\";\n  if (aIdent < bIdent) return -1;\n  if (aIdent > bIdent) return 1;\n  return compareLocations(a.loc, b.loc);\n};\nvar ChunkGroup = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of ChunkGroup.\n   * @param {string|ChunkGroupOptions=} options chunk group options passed to chunkGroup\n   */\n  function ChunkGroup(options) {\n    _classCallCheck(this, ChunkGroup);\n    if (typeof options === \"string\") {\n      options = {\n        name: options\n      };\n    } else if (!options) {\n      options = {\n        name: undefined\n      };\n    }\n    /** @type {number} */\n    this.groupDebugId = debugId++;\n    this.options = options;\n    /** @type {SortableSet<ChunkGroup>} */\n    this._children = new SortableSet(undefined, sortById);\n    /** @type {SortableSet<ChunkGroup>} */\n    this._parents = new SortableSet(undefined, sortById);\n    /** @type {SortableSet<ChunkGroup>} */\n    this._asyncEntrypoints = new SortableSet(undefined, sortById);\n    this._blocks = new SortableSet();\n    /** @type {Chunk[]} */\n    this.chunks = [];\n    /** @type {OriginRecord[]} */\n    this.origins = [];\n    /** Indices in top-down order */\n    /** @private @type {Map<Module, number>} */\n    this._modulePreOrderIndices = new Map();\n    /** Indices in bottom-up order */\n    /** @private @type {Map<Module, number>} */\n    this._modulePostOrderIndices = new Map();\n    /** @type {number} */\n    this.index = undefined;\n  }\n\n  /**\n   * when a new chunk is added to a chunkGroup, addingOptions will occur.\n   * @param {ChunkGroupOptions} options the chunkGroup options passed to addOptions\n   * @returns {void}\n   */\n  _createClass(ChunkGroup, [{\n    key: \"addOptions\",\n    value: function addOptions(options) {\n      for (var _i = 0, _Object$keys = Object.keys(options); _i < _Object$keys.length; _i++) {\n        var key = _Object$keys[_i];\n        if (this.options[key] === undefined) {\n          this.options[key] = options[key];\n        } else if (this.options[key] !== options[key]) {\n          if (key.endsWith(\"Order\")) {\n            this.options[key] = Math.max(this.options[key], options[key]);\n          } else {\n            throw new Error(\"ChunkGroup.addOptions: No option merge strategy for \".concat(key));\n          }\n        }\n      }\n    }\n\n    /**\n     * returns the name of current ChunkGroup\n     * @returns {string|undefined} returns the ChunkGroup name\n     */\n  }, {\n    key: \"name\",\n    get: function get() {\n      return this.options.name;\n    }\n\n    /**\n     * sets a new name for current ChunkGroup\n     * @param {string} value the new name for ChunkGroup\n     * @returns {void}\n     */,\n    set: function set(value) {\n      this.options.name = value;\n    }\n\n    /* istanbul ignore next */\n    /**\n     * get a uniqueId for ChunkGroup, made up of its member Chunk debugId's\n     * @returns {string} a unique concatenation of chunk debugId's\n     */\n  }, {\n    key: \"debugId\",\n    get: function get() {\n      return Array.from(this.chunks, function (x) {\n        return x.debugId;\n      }).join(\"+\");\n    }\n\n    /**\n     * get a unique id for ChunkGroup, made up of its member Chunk id's\n     * @returns {string} a unique concatenation of chunk ids\n     */\n  }, {\n    key: \"id\",\n    get: function get() {\n      return Array.from(this.chunks, function (x) {\n        return x.id;\n      }).join(\"+\");\n    }\n\n    /**\n     * Performs an unshift of a specific chunk\n     * @param {Chunk} chunk chunk being unshifted\n     * @returns {boolean} returns true if attempted chunk shift is accepted\n     */\n  }, {\n    key: \"unshiftChunk\",\n    value: function unshiftChunk(chunk) {\n      var oldIdx = this.chunks.indexOf(chunk);\n      if (oldIdx > 0) {\n        this.chunks.splice(oldIdx, 1);\n        this.chunks.unshift(chunk);\n      } else if (oldIdx < 0) {\n        this.chunks.unshift(chunk);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * inserts a chunk before another existing chunk in group\n     * @param {Chunk} chunk Chunk being inserted\n     * @param {Chunk} before Placeholder/target chunk marking new chunk insertion point\n     * @returns {boolean} return true if insertion was successful\n     */\n  }, {\n    key: \"insertChunk\",\n    value: function insertChunk(chunk, before) {\n      var oldIdx = this.chunks.indexOf(chunk);\n      var idx = this.chunks.indexOf(before);\n      if (idx < 0) {\n        throw new Error(\"before chunk not found\");\n      }\n      if (oldIdx >= 0 && oldIdx > idx) {\n        this.chunks.splice(oldIdx, 1);\n        this.chunks.splice(idx, 0, chunk);\n      } else if (oldIdx < 0) {\n        this.chunks.splice(idx, 0, chunk);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * add a chunk into ChunkGroup. Is pushed on or prepended\n     * @param {Chunk} chunk chunk being pushed into ChunkGroupS\n     * @returns {boolean} returns true if chunk addition was successful.\n     */\n  }, {\n    key: \"pushChunk\",\n    value: function pushChunk(chunk) {\n      var oldIdx = this.chunks.indexOf(chunk);\n      if (oldIdx >= 0) {\n        return false;\n      }\n      this.chunks.push(chunk);\n      return true;\n    }\n\n    /**\n     * @param {Chunk} oldChunk chunk to be replaced\n     * @param {Chunk} newChunk New chunk that will be replaced with\n     * @returns {boolean} returns true if the replacement was successful\n     */\n  }, {\n    key: \"replaceChunk\",\n    value: function replaceChunk(oldChunk, newChunk) {\n      var oldIdx = this.chunks.indexOf(oldChunk);\n      if (oldIdx < 0) return false;\n      var newIdx = this.chunks.indexOf(newChunk);\n      if (newIdx < 0) {\n        this.chunks[oldIdx] = newChunk;\n        return true;\n      }\n      if (newIdx < oldIdx) {\n        this.chunks.splice(oldIdx, 1);\n        return true;\n      } else if (newIdx !== oldIdx) {\n        this.chunks[oldIdx] = newChunk;\n        this.chunks.splice(newIdx, 1);\n        return true;\n      }\n    }\n\n    /**\n     * @param {Chunk} chunk chunk to remove\n     * @returns {boolean} returns true if chunk was removed\n     */\n  }, {\n    key: \"removeChunk\",\n    value: function removeChunk(chunk) {\n      var idx = this.chunks.indexOf(chunk);\n      if (idx >= 0) {\n        this.chunks.splice(idx, 1);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @returns {boolean} true, when this chunk group will be loaded on initial page load\n     */\n  }, {\n    key: \"isInitial\",\n    value: function isInitial() {\n      return false;\n    }\n\n    /**\n     * @param {ChunkGroup} group chunk group to add\n     * @returns {boolean} returns true if chunk group was added\n     */\n  }, {\n    key: \"addChild\",\n    value: function addChild(group) {\n      var size = this._children.size;\n      this._children.add(group);\n      return size !== this._children.size;\n    }\n\n    /**\n     * @returns {ChunkGroup[]} returns the children of this group\n     */\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      return this._children.getFromCache(getArray);\n    }\n  }, {\n    key: \"getNumberOfChildren\",\n    value: function getNumberOfChildren() {\n      return this._children.size;\n    }\n  }, {\n    key: \"childrenIterable\",\n    get: function get() {\n      return this._children;\n    }\n\n    /**\n     * @param {ChunkGroup} group the chunk group to remove\n     * @returns {boolean} returns true if the chunk group was removed\n     */\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(group) {\n      if (!this._children.has(group)) {\n        return false;\n      }\n      this._children.delete(group);\n      group.removeParent(this);\n      return true;\n    }\n\n    /**\n     * @param {ChunkGroup} parentChunk the parent group to be added into\n     * @returns {boolean} returns true if this chunk group was added to the parent group\n     */\n  }, {\n    key: \"addParent\",\n    value: function addParent(parentChunk) {\n      if (!this._parents.has(parentChunk)) {\n        this._parents.add(parentChunk);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @returns {ChunkGroup[]} returns the parents of this group\n     */\n  }, {\n    key: \"getParents\",\n    value: function getParents() {\n      return this._parents.getFromCache(getArray);\n    }\n  }, {\n    key: \"getNumberOfParents\",\n    value: function getNumberOfParents() {\n      return this._parents.size;\n    }\n\n    /**\n     * @param {ChunkGroup} parent the parent group\n     * @returns {boolean} returns true if the parent group contains this group\n     */\n  }, {\n    key: \"hasParent\",\n    value: function hasParent(parent) {\n      return this._parents.has(parent);\n    }\n  }, {\n    key: \"parentsIterable\",\n    get: function get() {\n      return this._parents;\n    }\n\n    /**\n     * @param {ChunkGroup} chunkGroup the parent group\n     * @returns {boolean} returns true if this group has been removed from the parent\n     */\n  }, {\n    key: \"removeParent\",\n    value: function removeParent(chunkGroup) {\n      if (this._parents.delete(chunkGroup)) {\n        chunkGroup.removeChild(this);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @param {Entrypoint} entrypoint entrypoint to add\n     * @returns {boolean} returns true if entrypoint was added\n     */\n  }, {\n    key: \"addAsyncEntrypoint\",\n    value: function addAsyncEntrypoint(entrypoint) {\n      var size = this._asyncEntrypoints.size;\n      this._asyncEntrypoints.add(entrypoint);\n      return size !== this._asyncEntrypoints.size;\n    }\n  }, {\n    key: \"asyncEntrypointsIterable\",\n    get: function get() {\n      return this._asyncEntrypoints;\n    }\n\n    /**\n     * @returns {Array} an array containing the blocks\n     */\n  }, {\n    key: \"getBlocks\",\n    value: function getBlocks() {\n      return this._blocks.getFromCache(getArray);\n    }\n  }, {\n    key: \"getNumberOfBlocks\",\n    value: function getNumberOfBlocks() {\n      return this._blocks.size;\n    }\n  }, {\n    key: \"hasBlock\",\n    value: function hasBlock(block) {\n      return this._blocks.has(block);\n    }\n\n    /**\n     * @returns {Iterable<AsyncDependenciesBlock>} blocks\n     */\n  }, {\n    key: \"blocksIterable\",\n    get: function get() {\n      return this._blocks;\n    }\n\n    /**\n     * @param {AsyncDependenciesBlock} block a block\n     * @returns {boolean} false, if block was already added\n     */\n  }, {\n    key: \"addBlock\",\n    value: function addBlock(block) {\n      if (!this._blocks.has(block)) {\n        this._blocks.add(block);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @param {Module} module origin module\n     * @param {DependencyLocation} loc location of the reference in the origin module\n     * @param {string} request request name of the reference\n     * @returns {void}\n     */\n  }, {\n    key: \"addOrigin\",\n    value: function addOrigin(module, loc, request) {\n      this.origins.push({\n        module: module,\n        loc: loc,\n        request: request\n      });\n    }\n\n    /**\n     * @returns {string[]} the files contained this chunk group\n     */\n  }, {\n    key: \"getFiles\",\n    value: function getFiles() {\n      var files = new Set();\n      var _iterator = _createForOfIteratorHelper(this.chunks),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var chunk = _step.value;\n          var _iterator2 = _createForOfIteratorHelper(chunk.files),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var file = _step2.value;\n              files.add(file);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return Array.from(files);\n    }\n\n    /**\n     * @returns {void}\n     */\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      // cleanup parents\n      var _iterator3 = _createForOfIteratorHelper(this._parents),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var parentChunkGroup = _step3.value;\n          // remove this chunk from its parents\n          parentChunkGroup._children.delete(this);\n\n          // cleanup \"sub chunks\"\n          var _iterator6 = _createForOfIteratorHelper(this._children),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var chunkGroup = _step6.value;\n              /**\n               * remove this chunk as \"intermediary\" and connect\n               * it \"sub chunks\" and parents directly\n               */\n              // add parent to each \"sub chunk\"\n              chunkGroup.addParent(parentChunkGroup);\n              // add \"sub chunk\" to parent\n              parentChunkGroup.addChild(chunkGroup);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n\n        /**\n         * we need to iterate again over the children\n         * to remove this from the child's parents.\n         * This can not be done in the above loop\n         * as it is not guaranteed that `this._parents` contains anything.\n         */\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      var _iterator4 = _createForOfIteratorHelper(this._children),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _chunkGroup = _step4.value;\n          // remove this as parent of every \"sub chunk\"\n          _chunkGroup._parents.delete(this);\n        }\n\n        // remove chunks\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      var _iterator5 = _createForOfIteratorHelper(this.chunks),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var chunk = _step5.value;\n          chunk.removeGroup(this);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  }, {\n    key: \"sortItems\",\n    value: function sortItems() {\n      this.origins.sort(sortOrigin);\n    }\n\n    /**\n     * Sorting predicate which allows current ChunkGroup to be compared against another.\n     * Sorting values are based off of number of chunks in ChunkGroup.\n     *\n     * @param {ChunkGraph} chunkGraph the chunk graph\n     * @param {ChunkGroup} otherGroup the chunkGroup to compare this against\n     * @returns {-1|0|1} sort position for comparison\n     */\n  }, {\n    key: \"compareTo\",\n    value: function compareTo(chunkGraph, otherGroup) {\n      if (this.chunks.length > otherGroup.chunks.length) return -1;\n      if (this.chunks.length < otherGroup.chunks.length) return 1;\n      return compareIterables(compareChunks(chunkGraph))(this.chunks, otherGroup.chunks);\n    }\n\n    /**\n     * @param {ModuleGraph} moduleGraph the module graph\n     * @param {ChunkGraph} chunkGraph the chunk graph\n     * @returns {Record<string, ChunkGroup[]>} mapping from children type to ordered list of ChunkGroups\n     */\n  }, {\n    key: \"getChildrenByOrders\",\n    value: function getChildrenByOrders(moduleGraph, chunkGraph) {\n      /** @type {Map<string, {order: number, group: ChunkGroup}[]>} */\n      var lists = new Map();\n      var _iterator7 = _createForOfIteratorHelper(this._children),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var childGroup = _step7.value;\n          for (var _i2 = 0, _Object$keys2 = Object.keys(childGroup.options); _i2 < _Object$keys2.length; _i2++) {\n            var key = _Object$keys2[_i2];\n            if (key.endsWith(\"Order\")) {\n              var name = key.slice(0, key.length - \"Order\".length);\n              var list = lists.get(name);\n              if (list === undefined) {\n                lists.set(name, list = []);\n              }\n              list.push({\n                order: childGroup.options[key],\n                group: childGroup\n              });\n            }\n          }\n        }\n        /** @type {Record<string, ChunkGroup[]>} */\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      var result = Object.create(null);\n      var _iterator8 = _createForOfIteratorHelper(lists),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _step8$value = _slicedToArray(_step8.value, 2),\n            _name = _step8$value[0],\n            _list = _step8$value[1];\n          _list.sort(function (a, b) {\n            var cmp = b.order - a.order;\n            if (cmp !== 0) return cmp;\n            return a.group.compareTo(chunkGraph, b.group);\n          });\n          result[_name] = _list.map(function (i) {\n            return i.group;\n          });\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      return result;\n    }\n\n    /**\n     * Sets the top-down index of a module in this ChunkGroup\n     * @param {Module} module module for which the index should be set\n     * @param {number} index the index of the module\n     * @returns {void}\n     */\n  }, {\n    key: \"setModulePreOrderIndex\",\n    value: function setModulePreOrderIndex(module, index) {\n      this._modulePreOrderIndices.set(module, index);\n    }\n\n    /**\n     * Gets the top-down index of a module in this ChunkGroup\n     * @param {Module} module the module\n     * @returns {number} index\n     */\n  }, {\n    key: \"getModulePreOrderIndex\",\n    value: function getModulePreOrderIndex(module) {\n      return this._modulePreOrderIndices.get(module);\n    }\n\n    /**\n     * Sets the bottom-up index of a module in this ChunkGroup\n     * @param {Module} module module for which the index should be set\n     * @param {number} index the index of the module\n     * @returns {void}\n     */\n  }, {\n    key: \"setModulePostOrderIndex\",\n    value: function setModulePostOrderIndex(module, index) {\n      this._modulePostOrderIndices.set(module, index);\n    }\n\n    /**\n     * Gets the bottom-up index of a module in this ChunkGroup\n     * @param {Module} module the module\n     * @returns {number} index\n     */\n  }, {\n    key: \"getModulePostOrderIndex\",\n    value: function getModulePostOrderIndex(module) {\n      return this._modulePostOrderIndices.get(module);\n    }\n\n    /* istanbul ignore next */\n  }, {\n    key: \"checkConstraints\",\n    value: function checkConstraints() {\n      var chunk = this;\n      var _iterator9 = _createForOfIteratorHelper(chunk._children),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var child = _step9.value;\n          if (!child._parents.has(chunk)) {\n            throw new Error(\"checkConstraints: child missing parent \".concat(chunk.debugId, \" -> \").concat(child.debugId));\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n      var _iterator10 = _createForOfIteratorHelper(chunk._parents),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var parentChunk = _step10.value;\n          if (!parentChunk._children.has(chunk)) {\n            throw new Error(\"checkConstraints: parent missing child \".concat(parentChunk.debugId, \" <- \").concat(chunk.debugId));\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  }]);\n  return ChunkGroup;\n}();\nChunkGroup.prototype.getModuleIndex = util.deprecate(ChunkGroup.prototype.getModulePreOrderIndex, \"ChunkGroup.getModuleIndex was renamed to getModulePreOrderIndex\", \"DEP_WEBPACK_CHUNK_GROUP_GET_MODULE_INDEX\");\nChunkGroup.prototype.getModuleIndex2 = util.deprecate(ChunkGroup.prototype.getModulePostOrderIndex, \"ChunkGroup.getModuleIndex2 was renamed to getModulePostOrderIndex\", \"DEP_WEBPACK_CHUNK_GROUP_GET_MODULE_INDEX_2\");\nmodule.exports = ChunkGroup;","map":{"version":3,"names":["util","require","SortableSet","compareLocations","compareChunks","compareIterables","debugId","getArray","set","Array","from","sortById","a","b","id","sortOrigin","aIdent","module","identifier","bIdent","loc","ChunkGroup","options","name","undefined","groupDebugId","_children","_parents","_asyncEntrypoints","_blocks","chunks","origins","_modulePreOrderIndices","Map","_modulePostOrderIndices","index","Object","keys","key","endsWith","Math","max","Error","value","x","join","chunk","oldIdx","indexOf","splice","unshift","before","idx","push","oldChunk","newChunk","newIdx","group","size","add","getFromCache","has","delete","removeParent","parentChunk","parent","chunkGroup","removeChild","entrypoint","block","request","files","Set","file","parentChunkGroup","addParent","addChild","removeGroup","sort","chunkGraph","otherGroup","length","moduleGraph","lists","childGroup","slice","list","get","order","result","create","cmp","compareTo","map","i","child","prototype","getModuleIndex","deprecate","getModulePreOrderIndex","getModuleIndex2","getModulePostOrderIndex","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/ChunkGroup.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst util = require(\"util\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst {\n\tcompareLocations,\n\tcompareChunks,\n\tcompareIterables\n} = require(\"./util/comparators\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"./Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n\n/** @typedef {{id: number}} HasId */\n/** @typedef {{module: Module, loc: DependencyLocation, request: string}} OriginRecord */\n\n/**\n * @typedef {Object} RawChunkGroupOptions\n * @property {number=} preloadOrder\n * @property {number=} prefetchOrder\n */\n\n/** @typedef {RawChunkGroupOptions & { name?: string }} ChunkGroupOptions */\n\nlet debugId = 5000;\n\n/**\n * @template T\n * @param {SortableSet<T>} set set to convert to array.\n * @returns {T[]} the array format of existing set\n */\nconst getArray = set => Array.from(set);\n\n/**\n * A convenience method used to sort chunks based on their id's\n * @param {ChunkGroup} a first sorting comparator\n * @param {ChunkGroup} b second sorting comparator\n * @returns {1|0|-1} a sorting index to determine order\n */\nconst sortById = (a, b) => {\n\tif (a.id < b.id) return -1;\n\tif (b.id < a.id) return 1;\n\treturn 0;\n};\n\n/**\n * @param {OriginRecord} a the first comparator in sort\n * @param {OriginRecord} b the second comparator in sort\n * @returns {1|-1|0} returns sorting order as index\n */\nconst sortOrigin = (a, b) => {\n\tconst aIdent = a.module ? a.module.identifier() : \"\";\n\tconst bIdent = b.module ? b.module.identifier() : \"\";\n\tif (aIdent < bIdent) return -1;\n\tif (aIdent > bIdent) return 1;\n\treturn compareLocations(a.loc, b.loc);\n};\n\nclass ChunkGroup {\n\t/**\n\t * Creates an instance of ChunkGroup.\n\t * @param {string|ChunkGroupOptions=} options chunk group options passed to chunkGroup\n\t */\n\tconstructor(options) {\n\t\tif (typeof options === \"string\") {\n\t\t\toptions = { name: options };\n\t\t} else if (!options) {\n\t\t\toptions = { name: undefined };\n\t\t}\n\t\t/** @type {number} */\n\t\tthis.groupDebugId = debugId++;\n\t\tthis.options = options;\n\t\t/** @type {SortableSet<ChunkGroup>} */\n\t\tthis._children = new SortableSet(undefined, sortById);\n\t\t/** @type {SortableSet<ChunkGroup>} */\n\t\tthis._parents = new SortableSet(undefined, sortById);\n\t\t/** @type {SortableSet<ChunkGroup>} */\n\t\tthis._asyncEntrypoints = new SortableSet(undefined, sortById);\n\t\tthis._blocks = new SortableSet();\n\t\t/** @type {Chunk[]} */\n\t\tthis.chunks = [];\n\t\t/** @type {OriginRecord[]} */\n\t\tthis.origins = [];\n\t\t/** Indices in top-down order */\n\t\t/** @private @type {Map<Module, number>} */\n\t\tthis._modulePreOrderIndices = new Map();\n\t\t/** Indices in bottom-up order */\n\t\t/** @private @type {Map<Module, number>} */\n\t\tthis._modulePostOrderIndices = new Map();\n\t\t/** @type {number} */\n\t\tthis.index = undefined;\n\t}\n\n\t/**\n\t * when a new chunk is added to a chunkGroup, addingOptions will occur.\n\t * @param {ChunkGroupOptions} options the chunkGroup options passed to addOptions\n\t * @returns {void}\n\t */\n\taddOptions(options) {\n\t\tfor (const key of Object.keys(options)) {\n\t\t\tif (this.options[key] === undefined) {\n\t\t\t\tthis.options[key] = options[key];\n\t\t\t} else if (this.options[key] !== options[key]) {\n\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\tthis.options[key] = Math.max(this.options[key], options[key]);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`ChunkGroup.addOptions: No option merge strategy for ${key}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * returns the name of current ChunkGroup\n\t * @returns {string|undefined} returns the ChunkGroup name\n\t */\n\tget name() {\n\t\treturn this.options.name;\n\t}\n\n\t/**\n\t * sets a new name for current ChunkGroup\n\t * @param {string} value the new name for ChunkGroup\n\t * @returns {void}\n\t */\n\tset name(value) {\n\t\tthis.options.name = value;\n\t}\n\n\t/* istanbul ignore next */\n\t/**\n\t * get a uniqueId for ChunkGroup, made up of its member Chunk debugId's\n\t * @returns {string} a unique concatenation of chunk debugId's\n\t */\n\tget debugId() {\n\t\treturn Array.from(this.chunks, x => x.debugId).join(\"+\");\n\t}\n\n\t/**\n\t * get a unique id for ChunkGroup, made up of its member Chunk id's\n\t * @returns {string} a unique concatenation of chunk ids\n\t */\n\tget id() {\n\t\treturn Array.from(this.chunks, x => x.id).join(\"+\");\n\t}\n\n\t/**\n\t * Performs an unshift of a specific chunk\n\t * @param {Chunk} chunk chunk being unshifted\n\t * @returns {boolean} returns true if attempted chunk shift is accepted\n\t */\n\tunshiftChunk(chunk) {\n\t\tconst oldIdx = this.chunks.indexOf(chunk);\n\t\tif (oldIdx > 0) {\n\t\t\tthis.chunks.splice(oldIdx, 1);\n\t\t\tthis.chunks.unshift(chunk);\n\t\t} else if (oldIdx < 0) {\n\t\t\tthis.chunks.unshift(chunk);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * inserts a chunk before another existing chunk in group\n\t * @param {Chunk} chunk Chunk being inserted\n\t * @param {Chunk} before Placeholder/target chunk marking new chunk insertion point\n\t * @returns {boolean} return true if insertion was successful\n\t */\n\tinsertChunk(chunk, before) {\n\t\tconst oldIdx = this.chunks.indexOf(chunk);\n\t\tconst idx = this.chunks.indexOf(before);\n\t\tif (idx < 0) {\n\t\t\tthrow new Error(\"before chunk not found\");\n\t\t}\n\t\tif (oldIdx >= 0 && oldIdx > idx) {\n\t\t\tthis.chunks.splice(oldIdx, 1);\n\t\t\tthis.chunks.splice(idx, 0, chunk);\n\t\t} else if (oldIdx < 0) {\n\t\t\tthis.chunks.splice(idx, 0, chunk);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * add a chunk into ChunkGroup. Is pushed on or prepended\n\t * @param {Chunk} chunk chunk being pushed into ChunkGroupS\n\t * @returns {boolean} returns true if chunk addition was successful.\n\t */\n\tpushChunk(chunk) {\n\t\tconst oldIdx = this.chunks.indexOf(chunk);\n\t\tif (oldIdx >= 0) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.chunks.push(chunk);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Chunk} oldChunk chunk to be replaced\n\t * @param {Chunk} newChunk New chunk that will be replaced with\n\t * @returns {boolean} returns true if the replacement was successful\n\t */\n\treplaceChunk(oldChunk, newChunk) {\n\t\tconst oldIdx = this.chunks.indexOf(oldChunk);\n\t\tif (oldIdx < 0) return false;\n\t\tconst newIdx = this.chunks.indexOf(newChunk);\n\t\tif (newIdx < 0) {\n\t\t\tthis.chunks[oldIdx] = newChunk;\n\t\t\treturn true;\n\t\t}\n\t\tif (newIdx < oldIdx) {\n\t\t\tthis.chunks.splice(oldIdx, 1);\n\t\t\treturn true;\n\t\t} else if (newIdx !== oldIdx) {\n\t\t\tthis.chunks[oldIdx] = newChunk;\n\t\t\tthis.chunks.splice(newIdx, 1);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk chunk to remove\n\t * @returns {boolean} returns true if chunk was removed\n\t */\n\tremoveChunk(chunk) {\n\t\tconst idx = this.chunks.indexOf(chunk);\n\t\tif (idx >= 0) {\n\t\t\tthis.chunks.splice(idx, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} true, when this chunk group will be loaded on initial page load\n\t */\n\tisInitial() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} group chunk group to add\n\t * @returns {boolean} returns true if chunk group was added\n\t */\n\taddChild(group) {\n\t\tconst size = this._children.size;\n\t\tthis._children.add(group);\n\t\treturn size !== this._children.size;\n\t}\n\n\t/**\n\t * @returns {ChunkGroup[]} returns the children of this group\n\t */\n\tgetChildren() {\n\t\treturn this._children.getFromCache(getArray);\n\t}\n\n\tgetNumberOfChildren() {\n\t\treturn this._children.size;\n\t}\n\n\tget childrenIterable() {\n\t\treturn this._children;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} group the chunk group to remove\n\t * @returns {boolean} returns true if the chunk group was removed\n\t */\n\tremoveChild(group) {\n\t\tif (!this._children.has(group)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._children.delete(group);\n\t\tgroup.removeParent(this);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} parentChunk the parent group to be added into\n\t * @returns {boolean} returns true if this chunk group was added to the parent group\n\t */\n\taddParent(parentChunk) {\n\t\tif (!this._parents.has(parentChunk)) {\n\t\t\tthis._parents.add(parentChunk);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {ChunkGroup[]} returns the parents of this group\n\t */\n\tgetParents() {\n\t\treturn this._parents.getFromCache(getArray);\n\t}\n\n\tgetNumberOfParents() {\n\t\treturn this._parents.size;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} parent the parent group\n\t * @returns {boolean} returns true if the parent group contains this group\n\t */\n\thasParent(parent) {\n\t\treturn this._parents.has(parent);\n\t}\n\n\tget parentsIterable() {\n\t\treturn this._parents;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the parent group\n\t * @returns {boolean} returns true if this group has been removed from the parent\n\t */\n\tremoveParent(chunkGroup) {\n\t\tif (this._parents.delete(chunkGroup)) {\n\t\t\tchunkGroup.removeChild(this);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Entrypoint} entrypoint entrypoint to add\n\t * @returns {boolean} returns true if entrypoint was added\n\t */\n\taddAsyncEntrypoint(entrypoint) {\n\t\tconst size = this._asyncEntrypoints.size;\n\t\tthis._asyncEntrypoints.add(entrypoint);\n\t\treturn size !== this._asyncEntrypoints.size;\n\t}\n\n\tget asyncEntrypointsIterable() {\n\t\treturn this._asyncEntrypoints;\n\t}\n\n\t/**\n\t * @returns {Array} an array containing the blocks\n\t */\n\tgetBlocks() {\n\t\treturn this._blocks.getFromCache(getArray);\n\t}\n\n\tgetNumberOfBlocks() {\n\t\treturn this._blocks.size;\n\t}\n\n\thasBlock(block) {\n\t\treturn this._blocks.has(block);\n\t}\n\n\t/**\n\t * @returns {Iterable<AsyncDependenciesBlock>} blocks\n\t */\n\tget blocksIterable() {\n\t\treturn this._blocks;\n\t}\n\n\t/**\n\t * @param {AsyncDependenciesBlock} block a block\n\t * @returns {boolean} false, if block was already added\n\t */\n\taddBlock(block) {\n\t\tif (!this._blocks.has(block)) {\n\t\t\tthis._blocks.add(block);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Module} module origin module\n\t * @param {DependencyLocation} loc location of the reference in the origin module\n\t * @param {string} request request name of the reference\n\t * @returns {void}\n\t */\n\taddOrigin(module, loc, request) {\n\t\tthis.origins.push({\n\t\t\tmodule,\n\t\t\tloc,\n\t\t\trequest\n\t\t});\n\t}\n\n\t/**\n\t * @returns {string[]} the files contained this chunk group\n\t */\n\tgetFiles() {\n\t\tconst files = new Set();\n\n\t\tfor (const chunk of this.chunks) {\n\t\t\tfor (const file of chunk.files) {\n\t\t\t\tfiles.add(file);\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(files);\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tremove() {\n\t\t// cleanup parents\n\t\tfor (const parentChunkGroup of this._parents) {\n\t\t\t// remove this chunk from its parents\n\t\t\tparentChunkGroup._children.delete(this);\n\n\t\t\t// cleanup \"sub chunks\"\n\t\t\tfor (const chunkGroup of this._children) {\n\t\t\t\t/**\n\t\t\t\t * remove this chunk as \"intermediary\" and connect\n\t\t\t\t * it \"sub chunks\" and parents directly\n\t\t\t\t */\n\t\t\t\t// add parent to each \"sub chunk\"\n\t\t\t\tchunkGroup.addParent(parentChunkGroup);\n\t\t\t\t// add \"sub chunk\" to parent\n\t\t\t\tparentChunkGroup.addChild(chunkGroup);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * we need to iterate again over the children\n\t\t * to remove this from the child's parents.\n\t\t * This can not be done in the above loop\n\t\t * as it is not guaranteed that `this._parents` contains anything.\n\t\t */\n\t\tfor (const chunkGroup of this._children) {\n\t\t\t// remove this as parent of every \"sub chunk\"\n\t\t\tchunkGroup._parents.delete(this);\n\t\t}\n\n\t\t// remove chunks\n\t\tfor (const chunk of this.chunks) {\n\t\t\tchunk.removeGroup(this);\n\t\t}\n\t}\n\n\tsortItems() {\n\t\tthis.origins.sort(sortOrigin);\n\t}\n\n\t/**\n\t * Sorting predicate which allows current ChunkGroup to be compared against another.\n\t * Sorting values are based off of number of chunks in ChunkGroup.\n\t *\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {ChunkGroup} otherGroup the chunkGroup to compare this against\n\t * @returns {-1|0|1} sort position for comparison\n\t */\n\tcompareTo(chunkGraph, otherGroup) {\n\t\tif (this.chunks.length > otherGroup.chunks.length) return -1;\n\t\tif (this.chunks.length < otherGroup.chunks.length) return 1;\n\t\treturn compareIterables(compareChunks(chunkGraph))(\n\t\t\tthis.chunks,\n\t\t\totherGroup.chunks\n\t\t);\n\t}\n\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {Record<string, ChunkGroup[]>} mapping from children type to ordered list of ChunkGroups\n\t */\n\tgetChildrenByOrders(moduleGraph, chunkGraph) {\n\t\t/** @type {Map<string, {order: number, group: ChunkGroup}[]>} */\n\t\tconst lists = new Map();\n\t\tfor (const childGroup of this._children) {\n\t\t\tfor (const key of Object.keys(childGroup.options)) {\n\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\tconst name = key.slice(0, key.length - \"Order\".length);\n\t\t\t\t\tlet list = lists.get(name);\n\t\t\t\t\tif (list === undefined) {\n\t\t\t\t\t\tlists.set(name, (list = []));\n\t\t\t\t\t}\n\t\t\t\t\tlist.push({\n\t\t\t\t\t\torder: childGroup.options[key],\n\t\t\t\t\t\tgroup: childGroup\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/** @type {Record<string, ChunkGroup[]>} */\n\t\tconst result = Object.create(null);\n\t\tfor (const [name, list] of lists) {\n\t\t\tlist.sort((a, b) => {\n\t\t\t\tconst cmp = b.order - a.order;\n\t\t\t\tif (cmp !== 0) return cmp;\n\t\t\t\treturn a.group.compareTo(chunkGraph, b.group);\n\t\t\t});\n\t\t\tresult[name] = list.map(i => i.group);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Sets the top-down index of a module in this ChunkGroup\n\t * @param {Module} module module for which the index should be set\n\t * @param {number} index the index of the module\n\t * @returns {void}\n\t */\n\tsetModulePreOrderIndex(module, index) {\n\t\tthis._modulePreOrderIndices.set(module, index);\n\t}\n\n\t/**\n\t * Gets the top-down index of a module in this ChunkGroup\n\t * @param {Module} module the module\n\t * @returns {number} index\n\t */\n\tgetModulePreOrderIndex(module) {\n\t\treturn this._modulePreOrderIndices.get(module);\n\t}\n\n\t/**\n\t * Sets the bottom-up index of a module in this ChunkGroup\n\t * @param {Module} module module for which the index should be set\n\t * @param {number} index the index of the module\n\t * @returns {void}\n\t */\n\tsetModulePostOrderIndex(module, index) {\n\t\tthis._modulePostOrderIndices.set(module, index);\n\t}\n\n\t/**\n\t * Gets the bottom-up index of a module in this ChunkGroup\n\t * @param {Module} module the module\n\t * @returns {number} index\n\t */\n\tgetModulePostOrderIndex(module) {\n\t\treturn this._modulePostOrderIndices.get(module);\n\t}\n\n\t/* istanbul ignore next */\n\tcheckConstraints() {\n\t\tconst chunk = this;\n\t\tfor (const child of chunk._children) {\n\t\t\tif (!child._parents.has(chunk)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`checkConstraints: child missing parent ${chunk.debugId} -> ${child.debugId}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tfor (const parentChunk of chunk._parents) {\n\t\t\tif (!parentChunk._children.has(chunk)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`checkConstraints: parent missing child ${parentChunk.debugId} <- ${chunk.debugId}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\nChunkGroup.prototype.getModuleIndex = util.deprecate(\n\tChunkGroup.prototype.getModulePreOrderIndex,\n\t\"ChunkGroup.getModuleIndex was renamed to getModulePreOrderIndex\",\n\t\"DEP_WEBPACK_CHUNK_GROUP_GET_MODULE_INDEX\"\n);\n\nChunkGroup.prototype.getModuleIndex2 = util.deprecate(\n\tChunkGroup.prototype.getModulePostOrderIndex,\n\t\"ChunkGroup.getModuleIndex2 was renamed to getModulePostOrderIndex\",\n\t\"DEP_WEBPACK_CHUNK_GROUP_GET_MODULE_INDEX_2\"\n);\n\nmodule.exports = ChunkGroup;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}