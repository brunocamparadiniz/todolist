{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar Cache = require(\"../Cache\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\nvar MemoryCachePlugin = /*#__PURE__*/function () {\n  function MemoryCachePlugin() {\n    _classCallCheck(this, MemoryCachePlugin);\n  }\n  _createClass(MemoryCachePlugin, [{\n    key: \"apply\",\n    value:\n    /**\n     * Apply the plugin\n     * @param {Compiler} compiler the compiler instance\n     * @returns {void}\n     */\n    function apply(compiler) {\n      /** @type {Map<string, { etag: Etag | null, data: any }>} */\n      var cache = new Map();\n      compiler.cache.hooks.store.tap({\n        name: \"MemoryCachePlugin\",\n        stage: Cache.STAGE_MEMORY\n      }, function (identifier, etag, data) {\n        cache.set(identifier, {\n          etag: etag,\n          data: data\n        });\n      });\n      compiler.cache.hooks.get.tap({\n        name: \"MemoryCachePlugin\",\n        stage: Cache.STAGE_MEMORY\n      }, function (identifier, etag, gotHandlers) {\n        var cacheEntry = cache.get(identifier);\n        if (cacheEntry === null) {\n          return null;\n        } else if (cacheEntry !== undefined) {\n          return cacheEntry.etag === etag ? cacheEntry.data : null;\n        }\n        gotHandlers.push(function (result, callback) {\n          if (result === undefined) {\n            cache.set(identifier, null);\n          } else {\n            cache.set(identifier, {\n              etag: etag,\n              data: result\n            });\n          }\n          return callback();\n        });\n      });\n      compiler.cache.hooks.shutdown.tap({\n        name: \"MemoryCachePlugin\",\n        stage: Cache.STAGE_MEMORY\n      }, function () {\n        cache.clear();\n      });\n    }\n  }]);\n  return MemoryCachePlugin;\n}();\nmodule.exports = MemoryCachePlugin;","map":{"version":3,"names":["Cache","require","MemoryCachePlugin","compiler","cache","Map","hooks","store","tap","name","stage","STAGE_MEMORY","identifier","etag","data","set","get","gotHandlers","cacheEntry","undefined","push","result","callback","shutdown","clear","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/cache/MemoryCachePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Cache = require(\"../Cache\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nclass MemoryCachePlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\t/** @type {Map<string, { etag: Etag | null, data: any }>} */\n\t\tconst cache = new Map();\n\t\tcompiler.cache.hooks.store.tap(\n\t\t\t{ name: \"MemoryCachePlugin\", stage: Cache.STAGE_MEMORY },\n\t\t\t(identifier, etag, data) => {\n\t\t\t\tcache.set(identifier, { etag, data });\n\t\t\t}\n\t\t);\n\t\tcompiler.cache.hooks.get.tap(\n\t\t\t{ name: \"MemoryCachePlugin\", stage: Cache.STAGE_MEMORY },\n\t\t\t(identifier, etag, gotHandlers) => {\n\t\t\t\tconst cacheEntry = cache.get(identifier);\n\t\t\t\tif (cacheEntry === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (cacheEntry !== undefined) {\n\t\t\t\t\treturn cacheEntry.etag === etag ? cacheEntry.data : null;\n\t\t\t\t}\n\t\t\t\tgotHandlers.push((result, callback) => {\n\t\t\t\t\tif (result === undefined) {\n\t\t\t\t\t\tcache.set(identifier, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcache.set(identifier, { etag, data: result });\n\t\t\t\t\t}\n\t\t\t\t\treturn callback();\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t\tcompiler.cache.hooks.shutdown.tap(\n\t\t\t{ name: \"MemoryCachePlugin\", stage: Cache.STAGE_MEMORY },\n\t\t\t() => {\n\t\t\t\tcache.clear();\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = MemoryCachePlugin;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAAC;AAAA;AAEb,IAAMA,KAAK,GAAGC,OAAO,CAAC,UAAU,CAAC;;AAEjC;AACA;AACA;AACA;AAAA,IAEMC,iBAAiB;EAAA;IAAA;EAAA;EAAA;IAAA;IAAA;IACtB;AACD;AACA;AACA;AACA;IACC,eAAMC,QAAQ,EAAE;MACf;MACA,IAAMC,KAAK,GAAG,IAAIC,GAAG,EAAE;MACvBF,QAAQ,CAACC,KAAK,CAACE,KAAK,CAACC,KAAK,CAACC,GAAG,CAC7B;QAAEC,IAAI,EAAE,mBAAmB;QAAEC,KAAK,EAAEV,KAAK,CAACW;MAAa,CAAC,EACxD,UAACC,UAAU,EAAEC,IAAI,EAAEC,IAAI,EAAK;QAC3BV,KAAK,CAACW,GAAG,CAACH,UAAU,EAAE;UAAEC,IAAI,EAAJA,IAAI;UAAEC,IAAI,EAAJA;QAAK,CAAC,CAAC;MACtC,CAAC,CACD;MACDX,QAAQ,CAACC,KAAK,CAACE,KAAK,CAACU,GAAG,CAACR,GAAG,CAC3B;QAAEC,IAAI,EAAE,mBAAmB;QAAEC,KAAK,EAAEV,KAAK,CAACW;MAAa,CAAC,EACxD,UAACC,UAAU,EAAEC,IAAI,EAAEI,WAAW,EAAK;QAClC,IAAMC,UAAU,GAAGd,KAAK,CAACY,GAAG,CAACJ,UAAU,CAAC;QACxC,IAAIM,UAAU,KAAK,IAAI,EAAE;UACxB,OAAO,IAAI;QACZ,CAAC,MAAM,IAAIA,UAAU,KAAKC,SAAS,EAAE;UACpC,OAAOD,UAAU,CAACL,IAAI,KAAKA,IAAI,GAAGK,UAAU,CAACJ,IAAI,GAAG,IAAI;QACzD;QACAG,WAAW,CAACG,IAAI,CAAC,UAACC,MAAM,EAAEC,QAAQ,EAAK;UACtC,IAAID,MAAM,KAAKF,SAAS,EAAE;YACzBf,KAAK,CAACW,GAAG,CAACH,UAAU,EAAE,IAAI,CAAC;UAC5B,CAAC,MAAM;YACNR,KAAK,CAACW,GAAG,CAACH,UAAU,EAAE;cAAEC,IAAI,EAAJA,IAAI;cAAEC,IAAI,EAAEO;YAAO,CAAC,CAAC;UAC9C;UACA,OAAOC,QAAQ,EAAE;QAClB,CAAC,CAAC;MACH,CAAC,CACD;MACDnB,QAAQ,CAACC,KAAK,CAACE,KAAK,CAACiB,QAAQ,CAACf,GAAG,CAChC;QAAEC,IAAI,EAAE,mBAAmB;QAAEC,KAAK,EAAEV,KAAK,CAACW;MAAa,CAAC,EACxD,YAAM;QACLP,KAAK,CAACoB,KAAK,EAAE;MACd,CAAC,CACD;IACF;EAAC;EAAA;AAAA;AAEFC,MAAM,CAACC,OAAO,GAAGxB,iBAAiB"},"metadata":{},"sourceType":"script","externalDependencies":[]}