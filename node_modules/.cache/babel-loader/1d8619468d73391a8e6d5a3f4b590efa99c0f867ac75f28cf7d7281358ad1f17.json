{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _objectSpread = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar asyncLib = require(\"neo-async\");\nvar _require = require(\"webpack-sources\"),\n  ConcatSource = _require.ConcatSource,\n  RawSource = _require.RawSource;\nvar Compilation = require(\"./Compilation\");\nvar ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\nvar ProgressPlugin = require(\"./ProgressPlugin\");\nvar SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\nvar createSchemaValidation = require(\"./util/create-schema-validation\");\nvar createHash = require(\"./util/createHash\");\nvar _require2 = require(\"./util/fs\"),\n  relative = _require2.relative,\n  dirname = _require2.dirname;\nvar _require3 = require(\"./util/identifier\"),\n  makePathsAbsolute = _require3.makePathsAbsolute;\n\n/** @typedef {import(\"webpack-sources\").MapOptions} MapOptions */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\n/** @typedef {import(\"./Cache\").Etag} Etag */\n/** @typedef {import(\"./CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./NormalModule\").SourceMap} SourceMap */\n/** @typedef {import(\"./util/Hash\")} Hash */\n\nvar validate = createSchemaValidation(require(\"../schemas/plugins/SourceMapDevToolPlugin.check.js\"), function () {\n  return require(\"../schemas/plugins/SourceMapDevToolPlugin.json\");\n}, {\n  name: \"SourceMap DevTool Plugin\",\n  baseDataPath: \"options\"\n});\n/**\n * @typedef {object} SourceMapTask\n * @property {Source} asset\n * @property {AssetInfo} assetInfo\n * @property {(string | Module)[]} modules\n * @property {string} source\n * @property {string} file\n * @property {SourceMap} sourceMap\n * @property {ItemCacheFacade} cacheItem cache item\n */\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nvar quoteMeta = function quoteMeta(str) {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\n/**\n * Creating {@link SourceMapTask} for given file\n * @param {string} file current compiled file\n * @param {Source} asset the asset\n * @param {AssetInfo} assetInfo the asset info\n * @param {MapOptions} options source map options\n * @param {Compilation} compilation compilation instance\n * @param {ItemCacheFacade} cacheItem cache item\n * @returns {SourceMapTask | undefined} created task instance or `undefined`\n */\nvar getTaskForFile = function getTaskForFile(file, asset, assetInfo, options, compilation, cacheItem) {\n  var source;\n  /** @type {SourceMap} */\n  var sourceMap;\n  /**\n   * Check if asset can build source map\n   */\n  if (asset.sourceAndMap) {\n    var sourceAndMap = asset.sourceAndMap(options);\n    sourceMap = /** @type {SourceMap} */sourceAndMap.map;\n    source = sourceAndMap.source;\n  } else {\n    sourceMap = /** @type {SourceMap} */asset.map(options);\n    source = asset.source();\n  }\n  if (!sourceMap || typeof source !== \"string\") return;\n  var context = compilation.options.context;\n  var root = compilation.compiler.root;\n  var cachedAbsolutify = makePathsAbsolute.bindContextCache(context, root);\n  var modules = sourceMap.sources.map(function (source) {\n    if (!source.startsWith(\"webpack://\")) return source;\n    source = cachedAbsolutify(source.slice(10));\n    var module = compilation.findModule(source);\n    return module || source;\n  });\n  return {\n    file: file,\n    asset: asset,\n    source: source,\n    assetInfo: assetInfo,\n    sourceMap: sourceMap,\n    modules: modules,\n    cacheItem: cacheItem\n  };\n};\nvar SourceMapDevToolPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {SourceMapDevToolPluginOptions} [options] options object\n   * @throws {Error} throws error, if got more than 1 arguments\n   */\n  function SourceMapDevToolPlugin() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, SourceMapDevToolPlugin);\n    validate(options);\n\n    /** @type {string | false} */\n    this.sourceMapFilename = options.filename;\n    /** @type {string | false} */\n    this.sourceMappingURLComment = options.append === false ? false : options.append || \"\\n//# source\" + \"MappingURL=[url]\";\n    /** @type {string | Function} */\n    this.moduleFilenameTemplate = options.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n    /** @type {string | Function} */\n    this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || \"webpack://[namespace]/[resourcePath]?[hash]\";\n    /** @type {string} */\n    this.namespace = options.namespace || \"\";\n    /** @type {SourceMapDevToolPluginOptions} */\n    this.options = options;\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler compiler instance\n   * @returns {void}\n   */\n  _createClass(SourceMapDevToolPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var outputFs = compiler.outputFileSystem;\n      var sourceMapFilename = this.sourceMapFilename;\n      var sourceMappingURLComment = this.sourceMappingURLComment;\n      var moduleFilenameTemplate = this.moduleFilenameTemplate;\n      var namespace = this.namespace;\n      var fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n      var requestShortener = compiler.requestShortener;\n      var options = this.options;\n      options.test = options.test || /\\.((c|m)?js|css)($|\\?)/i;\n      var matchObject = ModuleFilenameHelpers.matchObject.bind(undefined, options);\n      compiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", function (compilation) {\n        new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n        compilation.hooks.processAssets.tapAsync({\n          name: \"SourceMapDevToolPlugin\",\n          stage: Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING,\n          additionalAssets: true\n        }, function (assets, callback) {\n          var chunkGraph = compilation.chunkGraph;\n          var cache = compilation.getCache(\"SourceMapDevToolPlugin\");\n          /** @type {Map<string | Module, string>} */\n          var moduleToSourceNameMapping = new Map();\n          /**\n           * @type {Function}\n           * @returns {void}\n           */\n          var reportProgress = ProgressPlugin.getReporter(compilation.compiler) || function () {};\n\n          /** @type {Map<string, Chunk>} */\n          var fileToChunk = new Map();\n          var _iterator = _createForOfIteratorHelper(compilation.chunks),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var chunk = _step.value;\n              var _iterator2 = _createForOfIteratorHelper(chunk.files),\n                _step2;\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var _file = _step2.value;\n                  fileToChunk.set(_file, chunk);\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n              var _iterator3 = _createForOfIteratorHelper(chunk.auxiliaryFiles),\n                _step3;\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  var _file2 = _step3.value;\n                  fileToChunk.set(_file2, chunk);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            }\n\n            /** @type {string[]} */\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          var files = [];\n          for (var _i = 0, _Object$keys = Object.keys(assets); _i < _Object$keys.length; _i++) {\n            var file = _Object$keys[_i];\n            if (matchObject(file)) {\n              files.push(file);\n            }\n          }\n          reportProgress(0.0);\n          /** @type {SourceMapTask[]} */\n          var tasks = [];\n          var fileIndex = 0;\n          asyncLib.each(files, function (file, callback) {\n            var asset = compilation.getAsset(file);\n            if (asset.info.related && asset.info.related.sourceMap) {\n              fileIndex++;\n              return callback();\n            }\n            var cacheItem = cache.getItemCache(file, cache.mergeEtags(cache.getLazyHashedEtag(asset.source), namespace));\n            cacheItem.get(function (err, cacheEntry) {\n              if (err) {\n                return callback(err);\n              }\n              /**\n               * If presented in cache, reassigns assets. Cache assets already have source maps.\n               */\n              if (cacheEntry) {\n                var _assets = cacheEntry.assets,\n                  assetsInfo = cacheEntry.assetsInfo;\n                for (var _i2 = 0, _Object$keys2 = Object.keys(_assets); _i2 < _Object$keys2.length; _i2++) {\n                  var cachedFile = _Object$keys2[_i2];\n                  if (cachedFile === file) {\n                    compilation.updateAsset(cachedFile, _assets[cachedFile], assetsInfo[cachedFile]);\n                  } else {\n                    compilation.emitAsset(cachedFile, _assets[cachedFile], assetsInfo[cachedFile]);\n                  }\n                  /**\n                   * Add file to chunk, if not presented there\n                   */\n                  if (cachedFile !== file) {\n                    var chunk = fileToChunk.get(file);\n                    if (chunk !== undefined) chunk.auxiliaryFiles.add(cachedFile);\n                  }\n                }\n                reportProgress(0.5 * ++fileIndex / files.length, file, \"restored cached SourceMap\");\n                return callback();\n              }\n              reportProgress(0.5 * fileIndex / files.length, file, \"generate SourceMap\");\n\n              /** @type {SourceMapTask | undefined} */\n              var task = getTaskForFile(file, asset.source, asset.info, {\n                module: options.module,\n                columns: options.columns\n              }, compilation, cacheItem);\n              if (task) {\n                var modules = task.modules;\n                for (var idx = 0; idx < modules.length; idx++) {\n                  var _module = modules[idx];\n                  if (!moduleToSourceNameMapping.get(_module)) {\n                    moduleToSourceNameMapping.set(_module, ModuleFilenameHelpers.createFilename(_module, {\n                      moduleFilenameTemplate: moduleFilenameTemplate,\n                      namespace: namespace\n                    }, {\n                      requestShortener: requestShortener,\n                      chunkGraph: chunkGraph,\n                      hashFunction: compilation.outputOptions.hashFunction\n                    }));\n                  }\n                }\n                tasks.push(task);\n              }\n              reportProgress(0.5 * ++fileIndex / files.length, file, \"generated SourceMap\");\n              callback();\n            });\n          }, function (err) {\n            if (err) {\n              return callback(err);\n            }\n            reportProgress(0.5, \"resolve sources\");\n            /** @type {Set<string>} */\n            var usedNamesSet = new Set(moduleToSourceNameMapping.values());\n            /** @type {Set<string>} */\n            var conflictDetectionSet = new Set();\n\n            /**\n             * all modules in defined order (longest identifier first)\n             * @type {Array<string | Module>}\n             */\n            var allModules = Array.from(moduleToSourceNameMapping.keys()).sort(function (a, b) {\n              var ai = typeof a === \"string\" ? a : a.identifier();\n              var bi = typeof b === \"string\" ? b : b.identifier();\n              return ai.length - bi.length;\n            });\n\n            // find modules with conflicting source names\n            for (var idx = 0; idx < allModules.length; idx++) {\n              var _module2 = allModules[idx];\n              var sourceName = moduleToSourceNameMapping.get(_module2);\n              var hasName = conflictDetectionSet.has(sourceName);\n              if (!hasName) {\n                conflictDetectionSet.add(sourceName);\n                continue;\n              }\n\n              // try the fallback name first\n              sourceName = ModuleFilenameHelpers.createFilename(_module2, {\n                moduleFilenameTemplate: fallbackModuleFilenameTemplate,\n                namespace: namespace\n              }, {\n                requestShortener: requestShortener,\n                chunkGraph: chunkGraph,\n                hashFunction: compilation.outputOptions.hashFunction\n              });\n              hasName = usedNamesSet.has(sourceName);\n              if (!hasName) {\n                moduleToSourceNameMapping.set(_module2, sourceName);\n                usedNamesSet.add(sourceName);\n                continue;\n              }\n\n              // otherwise just append stars until we have a valid name\n              while (hasName) {\n                sourceName += \"*\";\n                hasName = usedNamesSet.has(sourceName);\n              }\n              moduleToSourceNameMapping.set(_module2, sourceName);\n              usedNamesSet.add(sourceName);\n            }\n            var taskIndex = 0;\n            asyncLib.each(tasks, function (task, callback) {\n              var assets = Object.create(null);\n              var assetsInfo = Object.create(null);\n              var file = task.file;\n              var chunk = fileToChunk.get(file);\n              var sourceMap = task.sourceMap;\n              var source = task.source;\n              var modules = task.modules;\n              reportProgress(0.5 + 0.5 * taskIndex / tasks.length, file, \"attach SourceMap\");\n              var moduleFilenames = modules.map(function (m) {\n                return moduleToSourceNameMapping.get(m);\n              });\n              sourceMap.sources = moduleFilenames;\n              if (options.noSources) {\n                sourceMap.sourcesContent = undefined;\n              }\n              sourceMap.sourceRoot = options.sourceRoot || \"\";\n              sourceMap.file = file;\n              var usesContentHash = sourceMapFilename && /\\[contenthash(:\\w+)?\\]/.test(sourceMapFilename);\n\n              // If SourceMap and asset uses contenthash, avoid a circular dependency by hiding hash in `file`\n              if (usesContentHash && task.assetInfo.contenthash) {\n                var contenthash = task.assetInfo.contenthash;\n                var pattern;\n                if (Array.isArray(contenthash)) {\n                  pattern = contenthash.map(quoteMeta).join(\"|\");\n                } else {\n                  pattern = quoteMeta(contenthash);\n                }\n                sourceMap.file = sourceMap.file.replace(new RegExp(pattern, \"g\"), function (m) {\n                  return \"x\".repeat(m.length);\n                });\n              }\n\n              /** @type {string | false} */\n              var currentSourceMappingURLComment = sourceMappingURLComment;\n              if (currentSourceMappingURLComment !== false && /\\.css($|\\?)/i.test(file)) {\n                currentSourceMappingURLComment = currentSourceMappingURLComment.replace(/^\\n\\/\\/(.*)$/, \"\\n/*$1*/\");\n              }\n              var sourceMapString = JSON.stringify(sourceMap);\n              if (sourceMapFilename) {\n                var filename = file;\n                var sourceMapContentHash = usesContentHash && /** @type {string} */\n                createHash(compilation.outputOptions.hashFunction).update(sourceMapString).digest(\"hex\");\n                var pathParams = {\n                  chunk: chunk,\n                  filename: options.fileContext ? relative(outputFs, \"/\".concat(options.fileContext), \"/\".concat(filename)) : filename,\n                  contentHash: sourceMapContentHash\n                };\n                var _compilation$getPathW = compilation.getPathWithInfo(sourceMapFilename, pathParams),\n                  sourceMapFile = _compilation$getPathW.path,\n                  sourceMapInfo = _compilation$getPathW.info;\n                var sourceMapUrl = options.publicPath ? options.publicPath + sourceMapFile : relative(outputFs, dirname(outputFs, \"/\".concat(file)), \"/\".concat(sourceMapFile));\n                /** @type {Source} */\n                var asset = new RawSource(source);\n                if (currentSourceMappingURLComment !== false) {\n                  // Add source map url to compilation asset, if currentSourceMappingURLComment is set\n                  asset = new ConcatSource(asset, compilation.getPath(currentSourceMappingURLComment, Object.assign({\n                    url: sourceMapUrl\n                  }, pathParams)));\n                }\n                var assetInfo = {\n                  related: {\n                    sourceMap: sourceMapFile\n                  }\n                };\n                assets[file] = asset;\n                assetsInfo[file] = assetInfo;\n                compilation.updateAsset(file, asset, assetInfo);\n                // Add source map file to compilation assets and chunk files\n                var sourceMapAsset = new RawSource(sourceMapString);\n                var sourceMapAssetInfo = _objectSpread(_objectSpread({}, sourceMapInfo), {}, {\n                  development: true\n                });\n                assets[sourceMapFile] = sourceMapAsset;\n                assetsInfo[sourceMapFile] = sourceMapAssetInfo;\n                compilation.emitAsset(sourceMapFile, sourceMapAsset, sourceMapAssetInfo);\n                if (chunk !== undefined) chunk.auxiliaryFiles.add(sourceMapFile);\n              } else {\n                if (currentSourceMappingURLComment === false) {\n                  throw new Error(\"SourceMapDevToolPlugin: append can't be false when no filename is provided\");\n                }\n                /**\n                 * Add source map as data url to asset\n                 */\n                var _asset = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(/\\[map\\]/g, function () {\n                  return sourceMapString;\n                }).replace(/\\[url\\]/g, function () {\n                  return \"data:application/json;charset=utf-8;base64,\".concat(Buffer.from(sourceMapString, \"utf-8\").toString(\"base64\"));\n                }));\n                assets[file] = _asset;\n                assetsInfo[file] = undefined;\n                compilation.updateAsset(file, _asset);\n              }\n              task.cacheItem.store({\n                assets: assets,\n                assetsInfo: assetsInfo\n              }, function (err) {\n                reportProgress(0.5 + 0.5 * ++taskIndex / tasks.length, task.file, \"attached SourceMap\");\n                if (err) {\n                  return callback(err);\n                }\n                callback();\n              });\n            }, function (err) {\n              reportProgress(1.0);\n              callback(err);\n            });\n          });\n        });\n      });\n    }\n  }]);\n  return SourceMapDevToolPlugin;\n}();\nmodule.exports = SourceMapDevToolPlugin;","map":{"version":3,"names":["asyncLib","require","ConcatSource","RawSource","Compilation","ModuleFilenameHelpers","ProgressPlugin","SourceMapDevToolModuleOptionsPlugin","createSchemaValidation","createHash","relative","dirname","makePathsAbsolute","validate","name","baseDataPath","quoteMeta","str","replace","getTaskForFile","file","asset","assetInfo","options","compilation","cacheItem","source","sourceMap","sourceAndMap","map","context","root","compiler","cachedAbsolutify","bindContextCache","modules","sources","startsWith","slice","module","findModule","SourceMapDevToolPlugin","sourceMapFilename","filename","sourceMappingURLComment","append","moduleFilenameTemplate","fallbackModuleFilenameTemplate","namespace","outputFs","outputFileSystem","requestShortener","test","matchObject","bind","undefined","hooks","tap","apply","processAssets","tapAsync","stage","PROCESS_ASSETS_STAGE_DEV_TOOLING","additionalAssets","assets","callback","chunkGraph","cache","getCache","moduleToSourceNameMapping","Map","reportProgress","getReporter","fileToChunk","chunks","chunk","files","set","auxiliaryFiles","Object","keys","push","tasks","fileIndex","each","getAsset","info","related","getItemCache","mergeEtags","getLazyHashedEtag","get","err","cacheEntry","assetsInfo","cachedFile","updateAsset","emitAsset","add","length","task","columns","idx","createFilename","hashFunction","outputOptions","usedNamesSet","Set","values","conflictDetectionSet","allModules","Array","from","sort","a","b","ai","identifier","bi","sourceName","hasName","has","taskIndex","create","moduleFilenames","m","noSources","sourcesContent","sourceRoot","usesContentHash","contenthash","pattern","isArray","join","RegExp","repeat","currentSourceMappingURLComment","sourceMapString","JSON","stringify","sourceMapContentHash","update","digest","pathParams","fileContext","contentHash","getPathWithInfo","sourceMapFile","path","sourceMapInfo","sourceMapUrl","publicPath","getPath","assign","url","sourceMapAsset","sourceMapAssetInfo","development","Error","Buffer","toString","store","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/SourceMapDevToolPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { ConcatSource, RawSource } = require(\"webpack-sources\");\nconst Compilation = require(\"./Compilation\");\nconst ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\nconst ProgressPlugin = require(\"./ProgressPlugin\");\nconst SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\nconst createSchemaValidation = require(\"./util/create-schema-validation\");\nconst createHash = require(\"./util/createHash\");\nconst { relative, dirname } = require(\"./util/fs\");\nconst { makePathsAbsolute } = require(\"./util/identifier\");\n\n/** @typedef {import(\"webpack-sources\").MapOptions} MapOptions */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\n/** @typedef {import(\"./Cache\").Etag} Etag */\n/** @typedef {import(\"./CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./NormalModule\").SourceMap} SourceMap */\n/** @typedef {import(\"./util/Hash\")} Hash */\n\nconst validate = createSchemaValidation(\n\trequire(\"../schemas/plugins/SourceMapDevToolPlugin.check.js\"),\n\t() => require(\"../schemas/plugins/SourceMapDevToolPlugin.json\"),\n\t{\n\t\tname: \"SourceMap DevTool Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n/**\n * @typedef {object} SourceMapTask\n * @property {Source} asset\n * @property {AssetInfo} assetInfo\n * @property {(string | Module)[]} modules\n * @property {string} source\n * @property {string} file\n * @property {SourceMap} sourceMap\n * @property {ItemCacheFacade} cacheItem cache item\n */\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quoteMeta = str => {\n\treturn str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\n/**\n * Creating {@link SourceMapTask} for given file\n * @param {string} file current compiled file\n * @param {Source} asset the asset\n * @param {AssetInfo} assetInfo the asset info\n * @param {MapOptions} options source map options\n * @param {Compilation} compilation compilation instance\n * @param {ItemCacheFacade} cacheItem cache item\n * @returns {SourceMapTask | undefined} created task instance or `undefined`\n */\nconst getTaskForFile = (\n\tfile,\n\tasset,\n\tassetInfo,\n\toptions,\n\tcompilation,\n\tcacheItem\n) => {\n\tlet source;\n\t/** @type {SourceMap} */\n\tlet sourceMap;\n\t/**\n\t * Check if asset can build source map\n\t */\n\tif (asset.sourceAndMap) {\n\t\tconst sourceAndMap = asset.sourceAndMap(options);\n\t\tsourceMap = /** @type {SourceMap} */ (sourceAndMap.map);\n\t\tsource = sourceAndMap.source;\n\t} else {\n\t\tsourceMap = /** @type {SourceMap} */ (asset.map(options));\n\t\tsource = asset.source();\n\t}\n\tif (!sourceMap || typeof source !== \"string\") return;\n\tconst context = compilation.options.context;\n\tconst root = compilation.compiler.root;\n\tconst cachedAbsolutify = makePathsAbsolute.bindContextCache(context, root);\n\tconst modules = sourceMap.sources.map(source => {\n\t\tif (!source.startsWith(\"webpack://\")) return source;\n\t\tsource = cachedAbsolutify(source.slice(10));\n\t\tconst module = compilation.findModule(source);\n\t\treturn module || source;\n\t});\n\n\treturn {\n\t\tfile,\n\t\tasset,\n\t\tsource,\n\t\tassetInfo,\n\t\tsourceMap,\n\t\tmodules,\n\t\tcacheItem\n\t};\n};\n\nclass SourceMapDevToolPlugin {\n\t/**\n\t * @param {SourceMapDevToolPluginOptions} [options] options object\n\t * @throws {Error} throws error, if got more than 1 arguments\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\n\t\t/** @type {string | false} */\n\t\tthis.sourceMapFilename = options.filename;\n\t\t/** @type {string | false} */\n\t\tthis.sourceMappingURLComment =\n\t\t\toptions.append === false\n\t\t\t\t? false\n\t\t\t\t: options.append || \"\\n//# source\" + \"MappingURL=[url]\";\n\t\t/** @type {string | Function} */\n\t\tthis.moduleFilenameTemplate =\n\t\t\toptions.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n\t\t/** @type {string | Function} */\n\t\tthis.fallbackModuleFilenameTemplate =\n\t\t\toptions.fallbackModuleFilenameTemplate ||\n\t\t\t\"webpack://[namespace]/[resourcePath]?[hash]\";\n\t\t/** @type {string} */\n\t\tthis.namespace = options.namespace || \"\";\n\t\t/** @type {SourceMapDevToolPluginOptions} */\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst outputFs = compiler.outputFileSystem;\n\t\tconst sourceMapFilename = this.sourceMapFilename;\n\t\tconst sourceMappingURLComment = this.sourceMappingURLComment;\n\t\tconst moduleFilenameTemplate = this.moduleFilenameTemplate;\n\t\tconst namespace = this.namespace;\n\t\tconst fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n\t\tconst requestShortener = compiler.requestShortener;\n\t\tconst options = this.options;\n\t\toptions.test = options.test || /\\.((c|m)?js|css)($|\\?)/i;\n\n\t\tconst matchObject = ModuleFilenameHelpers.matchObject.bind(\n\t\t\tundefined,\n\t\t\toptions\n\t\t);\n\n\t\tcompiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", compilation => {\n\t\t\tnew SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n\n\t\t\tcompilation.hooks.processAssets.tapAsync(\n\t\t\t\t{\n\t\t\t\t\tname: \"SourceMapDevToolPlugin\",\n\t\t\t\t\tstage: Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING,\n\t\t\t\t\tadditionalAssets: true\n\t\t\t\t},\n\t\t\t\t(assets, callback) => {\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst cache = compilation.getCache(\"SourceMapDevToolPlugin\");\n\t\t\t\t\t/** @type {Map<string | Module, string>} */\n\t\t\t\t\tconst moduleToSourceNameMapping = new Map();\n\t\t\t\t\t/**\n\t\t\t\t\t * @type {Function}\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst reportProgress =\n\t\t\t\t\t\tProgressPlugin.getReporter(compilation.compiler) || (() => {});\n\n\t\t\t\t\t/** @type {Map<string, Chunk>} */\n\t\t\t\t\tconst fileToChunk = new Map();\n\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\tfor (const file of chunk.files) {\n\t\t\t\t\t\t\tfileToChunk.set(file, chunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const file of chunk.auxiliaryFiles) {\n\t\t\t\t\t\t\tfileToChunk.set(file, chunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/** @type {string[]} */\n\t\t\t\t\tconst files = [];\n\t\t\t\t\tfor (const file of Object.keys(assets)) {\n\t\t\t\t\t\tif (matchObject(file)) {\n\t\t\t\t\t\t\tfiles.push(file);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treportProgress(0.0);\n\t\t\t\t\t/** @type {SourceMapTask[]} */\n\t\t\t\t\tconst tasks = [];\n\t\t\t\t\tlet fileIndex = 0;\n\n\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\tfiles,\n\t\t\t\t\t\t(file, callback) => {\n\t\t\t\t\t\t\tconst asset = compilation.getAsset(file);\n\t\t\t\t\t\t\tif (asset.info.related && asset.info.related.sourceMap) {\n\t\t\t\t\t\t\t\tfileIndex++;\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst cacheItem = cache.getItemCache(\n\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\tcache.mergeEtags(\n\t\t\t\t\t\t\t\t\tcache.getLazyHashedEtag(asset.source),\n\t\t\t\t\t\t\t\t\tnamespace\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tcacheItem.get((err, cacheEntry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * If presented in cache, reassigns assets. Cache assets already have source maps.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tif (cacheEntry) {\n\t\t\t\t\t\t\t\t\tconst { assets, assetsInfo } = cacheEntry;\n\t\t\t\t\t\t\t\t\tfor (const cachedFile of Object.keys(assets)) {\n\t\t\t\t\t\t\t\t\t\tif (cachedFile === file) {\n\t\t\t\t\t\t\t\t\t\t\tcompilation.updateAsset(\n\t\t\t\t\t\t\t\t\t\t\t\tcachedFile,\n\t\t\t\t\t\t\t\t\t\t\t\tassets[cachedFile],\n\t\t\t\t\t\t\t\t\t\t\t\tassetsInfo[cachedFile]\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tcompilation.emitAsset(\n\t\t\t\t\t\t\t\t\t\t\t\tcachedFile,\n\t\t\t\t\t\t\t\t\t\t\t\tassets[cachedFile],\n\t\t\t\t\t\t\t\t\t\t\t\tassetsInfo[cachedFile]\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t\t * Add file to chunk, if not presented there\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\t\tif (cachedFile !== file) {\n\t\t\t\t\t\t\t\t\t\t\tconst chunk = fileToChunk.get(file);\n\t\t\t\t\t\t\t\t\t\t\tif (chunk !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\tchunk.auxiliaryFiles.add(cachedFile);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t(0.5 * ++fileIndex) / files.length,\n\t\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\t\"restored cached SourceMap\"\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t(0.5 * fileIndex) / files.length,\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\"generate SourceMap\"\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t/** @type {SourceMapTask | undefined} */\n\t\t\t\t\t\t\t\tconst task = getTaskForFile(\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\tasset.source,\n\t\t\t\t\t\t\t\t\tasset.info,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmodule: options.module,\n\t\t\t\t\t\t\t\t\t\tcolumns: options.columns\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\t\tcacheItem\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (task) {\n\t\t\t\t\t\t\t\t\tconst modules = task.modules;\n\n\t\t\t\t\t\t\t\t\tfor (let idx = 0; idx < modules.length; idx++) {\n\t\t\t\t\t\t\t\t\t\tconst module = modules[idx];\n\t\t\t\t\t\t\t\t\t\tif (!moduleToSourceNameMapping.get(module)) {\n\t\t\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(\n\t\t\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\t\t\tModuleFilenameHelpers.createFilename(\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleFilenameTemplate: moduleFilenameTemplate,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnamespace: namespace\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trequestShortener,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thashFunction: compilation.outputOptions.hashFunction\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttasks.push(task);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t(0.5 * ++fileIndex) / files.length,\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\"generated SourceMap\"\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treportProgress(0.5, \"resolve sources\");\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\tconst usedNamesSet = new Set(moduleToSourceNameMapping.values());\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\tconst conflictDetectionSet = new Set();\n\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * all modules in defined order (longest identifier first)\n\t\t\t\t\t\t\t * @type {Array<string | Module>}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst allModules = Array.from(\n\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.keys()\n\t\t\t\t\t\t\t).sort((a, b) => {\n\t\t\t\t\t\t\t\tconst ai = typeof a === \"string\" ? a : a.identifier();\n\t\t\t\t\t\t\t\tconst bi = typeof b === \"string\" ? b : b.identifier();\n\t\t\t\t\t\t\t\treturn ai.length - bi.length;\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// find modules with conflicting source names\n\t\t\t\t\t\t\tfor (let idx = 0; idx < allModules.length; idx++) {\n\t\t\t\t\t\t\t\tconst module = allModules[idx];\n\t\t\t\t\t\t\t\tlet sourceName = moduleToSourceNameMapping.get(module);\n\t\t\t\t\t\t\t\tlet hasName = conflictDetectionSet.has(sourceName);\n\t\t\t\t\t\t\t\tif (!hasName) {\n\t\t\t\t\t\t\t\t\tconflictDetectionSet.add(sourceName);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// try the fallback name first\n\t\t\t\t\t\t\t\tsourceName = ModuleFilenameHelpers.createFilename(\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmoduleFilenameTemplate: fallbackModuleFilenameTemplate,\n\t\t\t\t\t\t\t\t\t\tnamespace: namespace\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\trequestShortener,\n\t\t\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\t\t\thashFunction: compilation.outputOptions.hashFunction\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\thasName = usedNamesSet.has(sourceName);\n\t\t\t\t\t\t\t\tif (!hasName) {\n\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(module, sourceName);\n\t\t\t\t\t\t\t\t\tusedNamesSet.add(sourceName);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// otherwise just append stars until we have a valid name\n\t\t\t\t\t\t\t\twhile (hasName) {\n\t\t\t\t\t\t\t\t\tsourceName += \"*\";\n\t\t\t\t\t\t\t\t\thasName = usedNamesSet.has(sourceName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(module, sourceName);\n\t\t\t\t\t\t\t\tusedNamesSet.add(sourceName);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet taskIndex = 0;\n\n\t\t\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\t\t\ttasks,\n\t\t\t\t\t\t\t\t(task, callback) => {\n\t\t\t\t\t\t\t\t\tconst assets = Object.create(null);\n\t\t\t\t\t\t\t\t\tconst assetsInfo = Object.create(null);\n\t\t\t\t\t\t\t\t\tconst file = task.file;\n\t\t\t\t\t\t\t\t\tconst chunk = fileToChunk.get(file);\n\t\t\t\t\t\t\t\t\tconst sourceMap = task.sourceMap;\n\t\t\t\t\t\t\t\t\tconst source = task.source;\n\t\t\t\t\t\t\t\t\tconst modules = task.modules;\n\n\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t0.5 + (0.5 * taskIndex) / tasks.length,\n\t\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\t\"attach SourceMap\"\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst moduleFilenames = modules.map(m =>\n\t\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.get(m)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tsourceMap.sources = moduleFilenames;\n\t\t\t\t\t\t\t\t\tif (options.noSources) {\n\t\t\t\t\t\t\t\t\t\tsourceMap.sourcesContent = undefined;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tsourceMap.sourceRoot = options.sourceRoot || \"\";\n\t\t\t\t\t\t\t\t\tsourceMap.file = file;\n\t\t\t\t\t\t\t\t\tconst usesContentHash =\n\t\t\t\t\t\t\t\t\t\tsourceMapFilename &&\n\t\t\t\t\t\t\t\t\t\t/\\[contenthash(:\\w+)?\\]/.test(sourceMapFilename);\n\n\t\t\t\t\t\t\t\t\t// If SourceMap and asset uses contenthash, avoid a circular dependency by hiding hash in `file`\n\t\t\t\t\t\t\t\t\tif (usesContentHash && task.assetInfo.contenthash) {\n\t\t\t\t\t\t\t\t\t\tconst contenthash = task.assetInfo.contenthash;\n\t\t\t\t\t\t\t\t\t\tlet pattern;\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(contenthash)) {\n\t\t\t\t\t\t\t\t\t\t\tpattern = contenthash.map(quoteMeta).join(\"|\");\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tpattern = quoteMeta(contenthash);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tsourceMap.file = sourceMap.file.replace(\n\t\t\t\t\t\t\t\t\t\t\tnew RegExp(pattern, \"g\"),\n\t\t\t\t\t\t\t\t\t\t\tm => \"x\".repeat(m.length)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t/** @type {string | false} */\n\t\t\t\t\t\t\t\t\tlet currentSourceMappingURLComment = sourceMappingURLComment;\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment !== false &&\n\t\t\t\t\t\t\t\t\t\t/\\.css($|\\?)/i.test(file)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment =\n\t\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment.replace(\n\t\t\t\t\t\t\t\t\t\t\t\t/^\\n\\/\\/(.*)$/,\n\t\t\t\t\t\t\t\t\t\t\t\t\"\\n/*$1*/\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst sourceMapString = JSON.stringify(sourceMap);\n\t\t\t\t\t\t\t\t\tif (sourceMapFilename) {\n\t\t\t\t\t\t\t\t\t\tlet filename = file;\n\t\t\t\t\t\t\t\t\t\tconst sourceMapContentHash =\n\t\t\t\t\t\t\t\t\t\t\tusesContentHash &&\n\t\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (\n\t\t\t\t\t\t\t\t\t\t\t\tcreateHash(compilation.outputOptions.hashFunction)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.update(sourceMapString)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.digest(\"hex\")\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tconst pathParams = {\n\t\t\t\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\t\t\t\tfilename: options.fileContext\n\t\t\t\t\t\t\t\t\t\t\t\t? relative(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\toutputFs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`/${options.fileContext}`,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`/${filename}`\n\t\t\t\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t\t\t\t: filename,\n\t\t\t\t\t\t\t\t\t\t\tcontentHash: sourceMapContentHash\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tconst { path: sourceMapFile, info: sourceMapInfo } =\n\t\t\t\t\t\t\t\t\t\t\tcompilation.getPathWithInfo(\n\t\t\t\t\t\t\t\t\t\t\t\tsourceMapFilename,\n\t\t\t\t\t\t\t\t\t\t\t\tpathParams\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tconst sourceMapUrl = options.publicPath\n\t\t\t\t\t\t\t\t\t\t\t? options.publicPath + sourceMapFile\n\t\t\t\t\t\t\t\t\t\t\t: relative(\n\t\t\t\t\t\t\t\t\t\t\t\t\toutputFs,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdirname(outputFs, `/${file}`),\n\t\t\t\t\t\t\t\t\t\t\t\t\t`/${sourceMapFile}`\n\t\t\t\t\t\t\t\t\t\t\t  );\n\t\t\t\t\t\t\t\t\t\t/** @type {Source} */\n\t\t\t\t\t\t\t\t\t\tlet asset = new RawSource(source);\n\t\t\t\t\t\t\t\t\t\tif (currentSourceMappingURLComment !== false) {\n\t\t\t\t\t\t\t\t\t\t\t// Add source map url to compilation asset, if currentSourceMappingURLComment is set\n\t\t\t\t\t\t\t\t\t\t\tasset = new ConcatSource(\n\t\t\t\t\t\t\t\t\t\t\t\tasset,\n\t\t\t\t\t\t\t\t\t\t\t\tcompilation.getPath(\n\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment,\n\t\t\t\t\t\t\t\t\t\t\t\t\tObject.assign({ url: sourceMapUrl }, pathParams)\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst assetInfo = {\n\t\t\t\t\t\t\t\t\t\t\trelated: { sourceMap: sourceMapFile }\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tassets[file] = asset;\n\t\t\t\t\t\t\t\t\t\tassetsInfo[file] = assetInfo;\n\t\t\t\t\t\t\t\t\t\tcompilation.updateAsset(file, asset, assetInfo);\n\t\t\t\t\t\t\t\t\t\t// Add source map file to compilation assets and chunk files\n\t\t\t\t\t\t\t\t\t\tconst sourceMapAsset = new RawSource(sourceMapString);\n\t\t\t\t\t\t\t\t\t\tconst sourceMapAssetInfo = {\n\t\t\t\t\t\t\t\t\t\t\t...sourceMapInfo,\n\t\t\t\t\t\t\t\t\t\t\tdevelopment: true\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tassets[sourceMapFile] = sourceMapAsset;\n\t\t\t\t\t\t\t\t\t\tassetsInfo[sourceMapFile] = sourceMapAssetInfo;\n\t\t\t\t\t\t\t\t\t\tcompilation.emitAsset(\n\t\t\t\t\t\t\t\t\t\t\tsourceMapFile,\n\t\t\t\t\t\t\t\t\t\t\tsourceMapAsset,\n\t\t\t\t\t\t\t\t\t\t\tsourceMapAssetInfo\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tif (chunk !== undefined)\n\t\t\t\t\t\t\t\t\t\t\tchunk.auxiliaryFiles.add(sourceMapFile);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif (currentSourceMappingURLComment === false) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\"SourceMapDevToolPlugin: append can't be false when no filename is provided\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t\t * Add source map as data url to asset\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\t\tconst asset = new ConcatSource(\n\t\t\t\t\t\t\t\t\t\t\tnew RawSource(source),\n\t\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment\n\t\t\t\t\t\t\t\t\t\t\t\t.replace(/\\[map\\]/g, () => sourceMapString)\n\t\t\t\t\t\t\t\t\t\t\t\t.replace(\n\t\t\t\t\t\t\t\t\t\t\t\t\t/\\[url\\]/g,\n\t\t\t\t\t\t\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`data:application/json;charset=utf-8;base64,${Buffer.from(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsourceMapString,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"utf-8\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t).toString(\"base64\")}`\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tassets[file] = asset;\n\t\t\t\t\t\t\t\t\t\tassetsInfo[file] = undefined;\n\t\t\t\t\t\t\t\t\t\tcompilation.updateAsset(file, asset);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttask.cacheItem.store({ assets, assetsInfo }, err => {\n\t\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t\t0.5 + (0.5 * ++taskIndex) / tasks.length,\n\t\t\t\t\t\t\t\t\t\t\ttask.file,\n\t\t\t\t\t\t\t\t\t\t\t\"attached SourceMap\"\n\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\treportProgress(1.0);\n\t\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = SourceMapDevToolPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}