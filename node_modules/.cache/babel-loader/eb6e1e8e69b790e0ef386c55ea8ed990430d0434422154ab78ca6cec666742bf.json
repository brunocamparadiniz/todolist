{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _assertThisInitialized = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _inherits = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _wrapNativeSuper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/wrapNativeSuper.js\").default;\nvar hexify = function hexify(char) {\n  var h = char.charCodeAt(0).toString(16).toUpperCase();\n  return '0x' + (h.length % 2 ? '0' : '') + h;\n};\nvar parseError = function parseError(e, txt, context) {\n  if (!txt) {\n    return {\n      message: e.message + ' while parsing empty string',\n      position: 0\n    };\n  }\n  var badToken = e.message.match(/^Unexpected token (.) .*position\\s+(\\d+)/i);\n  var errIdx = badToken ? +badToken[2] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;\n  var msg = badToken ? e.message.replace(/^Unexpected token ./, \"Unexpected token \".concat(JSON.stringify(badToken[1]), \" (\").concat(hexify(badToken[1]), \")\")) : e.message;\n  if (errIdx !== null && errIdx !== undefined) {\n    var start = errIdx <= context ? 0 : errIdx - context;\n    var end = errIdx + context >= txt.length ? txt.length : errIdx + context;\n    var slice = (start === 0 ? '' : '...') + txt.slice(start, end) + (end === txt.length ? '' : '...');\n    var near = txt === slice ? '' : 'near ';\n    return {\n      message: msg + \" while parsing \".concat(near).concat(JSON.stringify(slice)),\n      position: errIdx\n    };\n  } else {\n    return {\n      message: msg + \" while parsing '\".concat(txt.slice(0, context * 2), \"'\"),\n      position: 0\n    };\n  }\n};\nvar JSONParseError = /*#__PURE__*/function (_SyntaxError, _Symbol$toStringTag) {\n  _inherits(JSONParseError, _SyntaxError);\n  var _super = _createSuper(JSONParseError);\n  function JSONParseError(er, txt, context, caller) {\n    var _this;\n    _classCallCheck(this, JSONParseError);\n    context = context || 20;\n    var metadata = parseError(er, txt, context);\n    _this = _super.call(this, metadata.message);\n    Object.assign(_assertThisInitialized(_this), metadata);\n    _this.code = 'EJSONPARSE';\n    _this.systemError = er;\n    Error.captureStackTrace(_assertThisInitialized(_this), caller || _this.constructor);\n    return _this;\n  }\n  _createClass(JSONParseError, [{\n    key: \"name\",\n    get: function get() {\n      return this.constructor.name;\n    },\n    set: function set(n) {}\n  }, {\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return this.constructor.name;\n    }\n  }]);\n  return JSONParseError;\n}( /*#__PURE__*/_wrapNativeSuper(SyntaxError), Symbol.toStringTag);\nvar kIndent = Symbol.for('indent');\nvar kNewline = Symbol.for('newline');\n// only respect indentation if we got a line break, otherwise squash it\n// things other than objects and arrays aren't indented, so ignore those\n// Important: in both of these regexps, the $1 capture group is the newline\n// or undefined, and the $2 capture group is the indent, or undefined.\nvar formatRE = /^\\s*[{\\[]((?:\\r?\\n)+)([\\s\\t]*)/;\nvar emptyRE = /^(?:\\{\\}|\\[\\])((?:\\r?\\n)+)?$/;\nvar parseJson = function parseJson(txt, reviver, context) {\n  var parseText = stripBOM(txt);\n  context = context || 20;\n  try {\n    // get the indentation so that we can save it back nicely\n    // if the file starts with {\" then we have an indent of '', ie, none\n    // otherwise, pick the indentation of the next line after the first \\n\n    // If the pattern doesn't match, then it means no indentation.\n    // JSON.stringify ignores symbols, so this is reasonably safe.\n    // if the string is '{}' or '[]', then use the default 2-space indent.\n    var _ref = parseText.match(emptyRE) || parseText.match(formatRE) || [, '', ''],\n      _ref2 = _slicedToArray(_ref, 3),\n      _ref2$ = _ref2[1],\n      newline = _ref2$ === void 0 ? '\\n' : _ref2$,\n      _ref2$2 = _ref2[2],\n      indent = _ref2$2 === void 0 ? '  ' : _ref2$2;\n    var result = JSON.parse(parseText, reviver);\n    if (result && typeof result === 'object') {\n      result[kNewline] = newline;\n      result[kIndent] = indent;\n    }\n    return result;\n  } catch (e) {\n    if (typeof txt !== 'string' && !Buffer.isBuffer(txt)) {\n      var isEmptyArray = Array.isArray(txt) && txt.length === 0;\n      throw Object.assign(new TypeError(\"Cannot parse \".concat(isEmptyArray ? 'an empty array' : String(txt))), {\n        code: 'EJSONPARSE',\n        systemError: e\n      });\n    }\n    throw new JSONParseError(e, parseText, context, parseJson);\n  }\n};\n\n// Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n// because the buffer-to-string conversion in `fs.readFileSync()`\n// translates it to FEFF, the UTF-16 BOM.\nvar stripBOM = function stripBOM(txt) {\n  return String(txt).replace(/^\\uFEFF/, '');\n};\nmodule.exports = parseJson;\nparseJson.JSONParseError = JSONParseError;\nparseJson.noExceptions = function (txt, reviver) {\n  try {\n    return JSON.parse(stripBOM(txt), reviver);\n  } catch (e) {}\n};","map":{"version":3,"names":["hexify","char","h","charCodeAt","toString","toUpperCase","length","parseError","e","txt","context","message","position","badToken","match","errIdx","msg","replace","JSON","stringify","undefined","start","end","slice","near","JSONParseError","er","caller","metadata","Object","assign","code","systemError","Error","captureStackTrace","constructor","name","n","SyntaxError","Symbol","toStringTag","kIndent","for","kNewline","formatRE","emptyRE","parseJson","reviver","parseText","stripBOM","newline","indent","result","parse","Buffer","isBuffer","isEmptyArray","Array","isArray","TypeError","String","module","exports","noExceptions"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/json-parse-even-better-errors/index.js"],"sourcesContent":["'use strict'\n\nconst hexify = char => {\n  const h = char.charCodeAt(0).toString(16).toUpperCase()\n  return '0x' + (h.length % 2 ? '0' : '') + h\n}\n\nconst parseError = (e, txt, context) => {\n  if (!txt) {\n    return {\n      message: e.message + ' while parsing empty string',\n      position: 0,\n    }\n  }\n  const badToken = e.message.match(/^Unexpected token (.) .*position\\s+(\\d+)/i)\n  const errIdx = badToken ? +badToken[2]\n    : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1\n    : null\n\n  const msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${\n      JSON.stringify(badToken[1])\n    } (${hexify(badToken[1])})`)\n    : e.message\n\n  if (errIdx !== null && errIdx !== undefined) {\n    const start = errIdx <= context ? 0\n      : errIdx - context\n\n    const end = errIdx + context >= txt.length ? txt.length\n      : errIdx + context\n\n    const slice = (start === 0 ? '' : '...') +\n      txt.slice(start, end) +\n      (end === txt.length ? '' : '...')\n\n    const near = txt === slice ? '' : 'near '\n\n    return {\n      message: msg + ` while parsing ${near}${JSON.stringify(slice)}`,\n      position: errIdx,\n    }\n  } else {\n    return {\n      message: msg + ` while parsing '${txt.slice(0, context * 2)}'`,\n      position: 0,\n    }\n  }\n}\n\nclass JSONParseError extends SyntaxError {\n  constructor (er, txt, context, caller) {\n    context = context || 20\n    const metadata = parseError(er, txt, context)\n    super(metadata.message)\n    Object.assign(this, metadata)\n    this.code = 'EJSONPARSE'\n    this.systemError = er\n    Error.captureStackTrace(this, caller || this.constructor)\n  }\n  get name () { return this.constructor.name }\n  set name (n) {}\n  get [Symbol.toStringTag] () { return this.constructor.name }\n}\n\nconst kIndent = Symbol.for('indent')\nconst kNewline = Symbol.for('newline')\n// only respect indentation if we got a line break, otherwise squash it\n// things other than objects and arrays aren't indented, so ignore those\n// Important: in both of these regexps, the $1 capture group is the newline\n// or undefined, and the $2 capture group is the indent, or undefined.\nconst formatRE = /^\\s*[{\\[]((?:\\r?\\n)+)([\\s\\t]*)/\nconst emptyRE = /^(?:\\{\\}|\\[\\])((?:\\r?\\n)+)?$/\n\nconst parseJson = (txt, reviver, context) => {\n  const parseText = stripBOM(txt)\n  context = context || 20\n  try {\n    // get the indentation so that we can save it back nicely\n    // if the file starts with {\" then we have an indent of '', ie, none\n    // otherwise, pick the indentation of the next line after the first \\n\n    // If the pattern doesn't match, then it means no indentation.\n    // JSON.stringify ignores symbols, so this is reasonably safe.\n    // if the string is '{}' or '[]', then use the default 2-space indent.\n    const [, newline = '\\n', indent = '  '] = parseText.match(emptyRE) ||\n      parseText.match(formatRE) ||\n      [, '', '']\n\n    const result = JSON.parse(parseText, reviver)\n    if (result && typeof result === 'object') {\n      result[kNewline] = newline\n      result[kIndent] = indent\n    }\n    return result\n  } catch (e) {\n    if (typeof txt !== 'string' && !Buffer.isBuffer(txt)) {\n      const isEmptyArray = Array.isArray(txt) && txt.length === 0\n      throw Object.assign(new TypeError(\n        `Cannot parse ${isEmptyArray ? 'an empty array' : String(txt)}`\n      ), {\n        code: 'EJSONPARSE',\n        systemError: e,\n      })\n    }\n\n    throw new JSONParseError(e, parseText, context, parseJson)\n  }\n}\n\n// Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n// because the buffer-to-string conversion in `fs.readFileSync()`\n// translates it to FEFF, the UTF-16 BOM.\nconst stripBOM = txt => String(txt).replace(/^\\uFEFF/, '')\n\nmodule.exports = parseJson\nparseJson.JSONParseError = JSONParseError\n\nparseJson.noExceptions = (txt, reviver) => {\n  try {\n    return JSON.parse(stripBOM(txt), reviver)\n  } catch (e) {}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}