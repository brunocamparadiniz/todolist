{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _require = require(\"../OptimizationStages\"),\n  STAGE_BASIC = _require.STAGE_BASIC;\nvar _require2 = require(\"../util/runtime\"),\n  runtimeEqual = _require2.runtimeEqual;\n\n/** @typedef {import(\"../Compiler\")} Compiler */\nvar MergeDuplicateChunksPlugin = /*#__PURE__*/function () {\n  function MergeDuplicateChunksPlugin() {\n    _classCallCheck(this, MergeDuplicateChunksPlugin);\n  }\n  _createClass(MergeDuplicateChunksPlugin, [{\n    key: \"apply\",\n    value:\n    /**\n     * @param {Compiler} compiler the compiler\n     * @returns {void}\n     */\n    function apply(compiler) {\n      compiler.hooks.compilation.tap(\"MergeDuplicateChunksPlugin\", function (compilation) {\n        compilation.hooks.optimizeChunks.tap({\n          name: \"MergeDuplicateChunksPlugin\",\n          stage: STAGE_BASIC\n        }, function (chunks) {\n          var chunkGraph = compilation.chunkGraph,\n            moduleGraph = compilation.moduleGraph;\n\n          // remember already tested chunks for performance\n          var notDuplicates = new Set();\n\n          // for each chunk\n          var _iterator = _createForOfIteratorHelper(chunks),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var chunk = _step.value;\n              // track a Set of all chunk that could be duplicates\n              var possibleDuplicates = void 0;\n              var _iterator2 = _createForOfIteratorHelper(chunkGraph.getChunkModulesIterable(chunk)),\n                _step2;\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var _module2 = _step2.value;\n                  if (possibleDuplicates === undefined) {\n                    // when possibleDuplicates is not yet set,\n                    // create a new Set from chunks of the current module\n                    // including only chunks with the same number of modules\n                    var _iterator5 = _createForOfIteratorHelper(chunkGraph.getModuleChunksIterable(_module2)),\n                      _step5;\n                    try {\n                      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                        var dup = _step5.value;\n                        if (dup !== chunk && chunkGraph.getNumberOfChunkModules(chunk) === chunkGraph.getNumberOfChunkModules(dup) && !notDuplicates.has(dup)) {\n                          // delay allocating the new Set until here, reduce memory pressure\n                          if (possibleDuplicates === undefined) {\n                            possibleDuplicates = new Set();\n                          }\n                          possibleDuplicates.add(dup);\n                        }\n                      }\n                      // when no chunk is possible we can break here\n                    } catch (err) {\n                      _iterator5.e(err);\n                    } finally {\n                      _iterator5.f();\n                    }\n                    if (possibleDuplicates === undefined) break;\n                  } else {\n                    // validate existing possible duplicates\n                    var _iterator6 = _createForOfIteratorHelper(possibleDuplicates),\n                      _step6;\n                    try {\n                      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                        var _dup = _step6.value;\n                        // remove possible duplicate when module is not contained\n                        if (!chunkGraph.isModuleInChunk(_module2, _dup)) {\n                          possibleDuplicates.delete(_dup);\n                        }\n                      }\n                      // when all chunks has been removed we can break here\n                    } catch (err) {\n                      _iterator6.e(err);\n                    } finally {\n                      _iterator6.f();\n                    }\n                    if (possibleDuplicates.size === 0) break;\n                  }\n                }\n\n                // when we found duplicates\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n              if (possibleDuplicates !== undefined && possibleDuplicates.size > 0) {\n                var _iterator3 = _createForOfIteratorHelper(possibleDuplicates),\n                  _step3;\n                try {\n                  outer: for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    var otherChunk = _step3.value;\n                    if (otherChunk.hasRuntime() !== chunk.hasRuntime()) continue;\n                    if (chunkGraph.getNumberOfEntryModules(chunk) > 0) continue;\n                    if (chunkGraph.getNumberOfEntryModules(otherChunk) > 0) continue;\n                    if (!runtimeEqual(chunk.runtime, otherChunk.runtime)) {\n                      var _iterator4 = _createForOfIteratorHelper(chunkGraph.getChunkModulesIterable(chunk)),\n                        _step4;\n                      try {\n                        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                          var _module = _step4.value;\n                          var exportsInfo = moduleGraph.getExportsInfo(_module);\n                          if (!exportsInfo.isEquallyUsed(chunk.runtime, otherChunk.runtime)) {\n                            continue outer;\n                          }\n                        }\n                      } catch (err) {\n                        _iterator4.e(err);\n                      } finally {\n                        _iterator4.f();\n                      }\n                    }\n                    // merge them\n                    if (chunkGraph.canChunksBeIntegrated(chunk, otherChunk)) {\n                      chunkGraph.integrateChunks(chunk, otherChunk);\n                      compilation.chunks.delete(otherChunk);\n                    }\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n              }\n\n              // don't check already processed chunks twice\n              notDuplicates.add(chunk);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        });\n      });\n    }\n  }]);\n  return MergeDuplicateChunksPlugin;\n}();\nmodule.exports = MergeDuplicateChunksPlugin;","map":{"version":3,"names":["require","STAGE_BASIC","runtimeEqual","MergeDuplicateChunksPlugin","compiler","hooks","compilation","tap","optimizeChunks","name","stage","chunks","chunkGraph","moduleGraph","notDuplicates","Set","chunk","possibleDuplicates","getChunkModulesIterable","module","undefined","getModuleChunksIterable","dup","getNumberOfChunkModules","has","add","isModuleInChunk","delete","size","outer","otherChunk","hasRuntime","getNumberOfEntryModules","runtime","exportsInfo","getExportsInfo","isEquallyUsed","canChunksBeIntegrated","integrateChunks","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/optimize/MergeDuplicateChunksPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_BASIC } = require(\"../OptimizationStages\");\nconst { runtimeEqual } = require(\"../util/runtime\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nclass MergeDuplicateChunksPlugin {\n\t/**\n\t * @param {Compiler} compiler the compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"MergeDuplicateChunksPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"MergeDuplicateChunksPlugin\",\n\t\t\t\t\t\tstage: STAGE_BASIC\n\t\t\t\t\t},\n\t\t\t\t\tchunks => {\n\t\t\t\t\t\tconst { chunkGraph, moduleGraph } = compilation;\n\n\t\t\t\t\t\t// remember already tested chunks for performance\n\t\t\t\t\t\tconst notDuplicates = new Set();\n\n\t\t\t\t\t\t// for each chunk\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\t// track a Set of all chunk that could be duplicates\n\t\t\t\t\t\t\tlet possibleDuplicates;\n\t\t\t\t\t\t\tfor (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\t\t\t\t\tif (possibleDuplicates === undefined) {\n\t\t\t\t\t\t\t\t\t// when possibleDuplicates is not yet set,\n\t\t\t\t\t\t\t\t\t// create a new Set from chunks of the current module\n\t\t\t\t\t\t\t\t\t// including only chunks with the same number of modules\n\t\t\t\t\t\t\t\t\tfor (const dup of chunkGraph.getModuleChunksIterable(\n\t\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tdup !== chunk &&\n\t\t\t\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(chunk) ===\n\t\t\t\t\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(dup) &&\n\t\t\t\t\t\t\t\t\t\t\t!notDuplicates.has(dup)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t// delay allocating the new Set until here, reduce memory pressure\n\t\t\t\t\t\t\t\t\t\t\tif (possibleDuplicates === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\tpossibleDuplicates = new Set();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tpossibleDuplicates.add(dup);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// when no chunk is possible we can break here\n\t\t\t\t\t\t\t\t\tif (possibleDuplicates === undefined) break;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// validate existing possible duplicates\n\t\t\t\t\t\t\t\t\tfor (const dup of possibleDuplicates) {\n\t\t\t\t\t\t\t\t\t\t// remove possible duplicate when module is not contained\n\t\t\t\t\t\t\t\t\t\tif (!chunkGraph.isModuleInChunk(module, dup)) {\n\t\t\t\t\t\t\t\t\t\t\tpossibleDuplicates.delete(dup);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// when all chunks has been removed we can break here\n\t\t\t\t\t\t\t\t\tif (possibleDuplicates.size === 0) break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// when we found duplicates\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tpossibleDuplicates !== undefined &&\n\t\t\t\t\t\t\t\tpossibleDuplicates.size > 0\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\touter: for (const otherChunk of possibleDuplicates) {\n\t\t\t\t\t\t\t\t\tif (otherChunk.hasRuntime() !== chunk.hasRuntime()) continue;\n\t\t\t\t\t\t\t\t\tif (chunkGraph.getNumberOfEntryModules(chunk) > 0) continue;\n\t\t\t\t\t\t\t\t\tif (chunkGraph.getNumberOfEntryModules(otherChunk) > 0)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\tif (!runtimeEqual(chunk.runtime, otherChunk.runtime)) {\n\t\t\t\t\t\t\t\t\t\tfor (const module of chunkGraph.getChunkModulesIterable(\n\t\t\t\t\t\t\t\t\t\t\tchunk\n\t\t\t\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t!exportsInfo.isEquallyUsed(\n\t\t\t\t\t\t\t\t\t\t\t\t\tchunk.runtime,\n\t\t\t\t\t\t\t\t\t\t\t\t\totherChunk.runtime\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// merge them\n\t\t\t\t\t\t\t\t\tif (chunkGraph.canChunksBeIntegrated(chunk, otherChunk)) {\n\t\t\t\t\t\t\t\t\t\tchunkGraph.integrateChunks(chunk, otherChunk);\n\t\t\t\t\t\t\t\t\t\tcompilation.chunks.delete(otherChunk);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// don't check already processed chunks twice\n\t\t\t\t\t\t\tnotDuplicates.add(chunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = MergeDuplicateChunksPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}