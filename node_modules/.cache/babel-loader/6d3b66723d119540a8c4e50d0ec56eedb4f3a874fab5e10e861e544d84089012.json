{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _require = require(\"./util/MapHelpers\"),\n  provide = _require.provide;\nvar _require2 = require(\"./util/SetHelpers\"),\n  first = _require2.first;\nvar createHash = require(\"./util/createHash\");\nvar _require3 = require(\"./util/runtime\"),\n  runtimeToString = _require3.runtimeToString,\n  RuntimeSpecMap = _require3.RuntimeSpecMap;\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Module\").CodeGenerationResult} CodeGenerationResult */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\nvar CodeGenerationResults = /*#__PURE__*/function () {\n  /**\n   * @param {string | Hash} hashFunction the hash function to use\n   */\n  function CodeGenerationResults() {\n    var hashFunction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"md4\";\n    _classCallCheck(this, CodeGenerationResults);\n    /** @type {Map<Module, RuntimeSpecMap<CodeGenerationResult>>} */\n    this.map = new Map();\n    this._hashFunction = hashFunction;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @returns {CodeGenerationResult} the CodeGenerationResult\n   */\n  _createClass(CodeGenerationResults, [{\n    key: \"get\",\n    value: function get(module, runtime) {\n      var entry = this.map.get(module);\n      if (entry === undefined) {\n        throw new Error(\"No code generation entry for \".concat(module.identifier(), \" (existing entries: \").concat(Array.from(this.map.keys(), function (m) {\n          return m.identifier();\n        }).join(\", \"), \")\"));\n      }\n      if (runtime === undefined) {\n        if (entry.size > 1) {\n          var results = new Set(entry.values());\n          if (results.size !== 1) {\n            throw new Error(\"No unique code generation entry for unspecified runtime for \".concat(module.identifier(), \" (existing runtimes: \").concat(Array.from(entry.keys(), function (r) {\n              return runtimeToString(r);\n            }).join(\", \"), \").\\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \\\"global\\\").\"));\n          }\n          return first(results);\n        }\n        return entry.values().next().value;\n      }\n      var result = entry.get(runtime);\n      if (result === undefined) {\n        throw new Error(\"No code generation entry for runtime \".concat(runtimeToString(runtime), \" for \").concat(module.identifier(), \" (existing runtimes: \").concat(Array.from(entry.keys(), function (r) {\n          return runtimeToString(r);\n        }).join(\", \"), \")\"));\n      }\n      return result;\n    }\n\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime runtime(s)\n     * @returns {boolean} true, when we have data for this\n     */\n  }, {\n    key: \"has\",\n    value: function has(module, runtime) {\n      var entry = this.map.get(module);\n      if (entry === undefined) {\n        return false;\n      }\n      if (runtime !== undefined) {\n        return entry.has(runtime);\n      } else if (entry.size > 1) {\n        var results = new Set(entry.values());\n        return results.size === 1;\n      } else {\n        return entry.size === 1;\n      }\n    }\n\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime runtime(s)\n     * @param {string} sourceType the source type\n     * @returns {Source} a source\n     */\n  }, {\n    key: \"getSource\",\n    value: function getSource(module, runtime, sourceType) {\n      return this.get(module, runtime).sources.get(sourceType);\n    }\n\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime runtime(s)\n     * @returns {ReadonlySet<string>} runtime requirements\n     */\n  }, {\n    key: \"getRuntimeRequirements\",\n    value: function getRuntimeRequirements(module, runtime) {\n      return this.get(module, runtime).runtimeRequirements;\n    }\n\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime runtime(s)\n     * @param {string} key data key\n     * @returns {any} data generated by code generation\n     */\n  }, {\n    key: \"getData\",\n    value: function getData(module, runtime, key) {\n      var data = this.get(module, runtime).data;\n      return data === undefined ? undefined : data.get(key);\n    }\n\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime runtime(s)\n     * @returns {any} hash of the code generation\n     */\n  }, {\n    key: \"getHash\",\n    value: function getHash(module, runtime) {\n      var info = this.get(module, runtime);\n      if (info.hash !== undefined) return info.hash;\n      var hash = createHash(this._hashFunction);\n      var _iterator = _createForOfIteratorHelper(info.sources),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            type = _step$value[0],\n            source = _step$value[1];\n          hash.update(type);\n          source.updateHash(hash);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      if (info.runtimeRequirements) {\n        var _iterator2 = _createForOfIteratorHelper(info.runtimeRequirements),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var rr = _step2.value;\n            hash.update(rr);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      return info.hash = /** @type {string} */hash.digest(\"hex\");\n    }\n\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime runtime(s)\n     * @param {CodeGenerationResult} result result from module\n     * @returns {void}\n     */\n  }, {\n    key: \"add\",\n    value: function add(module, runtime, result) {\n      var map = provide(this.map, module, function () {\n        return new RuntimeSpecMap();\n      });\n      map.set(runtime, result);\n    }\n  }]);\n  return CodeGenerationResults;\n}();\nmodule.exports = CodeGenerationResults;","map":{"version":3,"names":["require","provide","first","createHash","runtimeToString","RuntimeSpecMap","CodeGenerationResults","hashFunction","map","Map","_hashFunction","module","runtime","entry","get","undefined","Error","identifier","Array","from","keys","m","join","size","results","Set","values","r","next","value","result","has","sourceType","sources","runtimeRequirements","key","data","info","hash","type","source","update","updateHash","rr","digest","set","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/CodeGenerationResults.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { provide } = require(\"./util/MapHelpers\");\nconst { first } = require(\"./util/SetHelpers\");\nconst createHash = require(\"./util/createHash\");\nconst { runtimeToString, RuntimeSpecMap } = require(\"./util/runtime\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Module\").CodeGenerationResult} CodeGenerationResult */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nclass CodeGenerationResults {\n\t/**\n\t * @param {string | Hash} hashFunction the hash function to use\n\t */\n\tconstructor(hashFunction = \"md4\") {\n\t\t/** @type {Map<Module, RuntimeSpecMap<CodeGenerationResult>>} */\n\t\tthis.map = new Map();\n\t\tthis._hashFunction = hashFunction;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {CodeGenerationResult} the CodeGenerationResult\n\t */\n\tget(module, runtime) {\n\t\tconst entry = this.map.get(module);\n\t\tif (entry === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t`No code generation entry for ${module.identifier()} (existing entries: ${Array.from(\n\t\t\t\t\tthis.map.keys(),\n\t\t\t\t\tm => m.identifier()\n\t\t\t\t).join(\", \")})`\n\t\t\t);\n\t\t}\n\t\tif (runtime === undefined) {\n\t\t\tif (entry.size > 1) {\n\t\t\t\tconst results = new Set(entry.values());\n\t\t\t\tif (results.size !== 1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`No unique code generation entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(\n\t\t\t\t\t\t\tentry.keys(),\n\t\t\t\t\t\t\tr => runtimeToString(r)\n\t\t\t\t\t\t).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn first(results);\n\t\t\t}\n\t\t\treturn entry.values().next().value;\n\t\t}\n\t\tconst result = entry.get(runtime);\n\t\tif (result === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t`No code generation entry for runtime ${runtimeToString(\n\t\t\t\t\truntime\n\t\t\t\t)} for ${module.identifier()} (existing runtimes: ${Array.from(\n\t\t\t\t\tentry.keys(),\n\t\t\t\t\tr => runtimeToString(r)\n\t\t\t\t).join(\", \")})`\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {boolean} true, when we have data for this\n\t */\n\thas(module, runtime) {\n\t\tconst entry = this.map.get(module);\n\t\tif (entry === undefined) {\n\t\t\treturn false;\n\t\t}\n\t\tif (runtime !== undefined) {\n\t\t\treturn entry.has(runtime);\n\t\t} else if (entry.size > 1) {\n\t\t\tconst results = new Set(entry.values());\n\t\t\treturn results.size === 1;\n\t\t} else {\n\t\t\treturn entry.size === 1;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @param {string} sourceType the source type\n\t * @returns {Source} a source\n\t */\n\tgetSource(module, runtime, sourceType) {\n\t\treturn this.get(module, runtime).sources.get(sourceType);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetRuntimeRequirements(module, runtime) {\n\t\treturn this.get(module, runtime).runtimeRequirements;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @param {string} key data key\n\t * @returns {any} data generated by code generation\n\t */\n\tgetData(module, runtime, key) {\n\t\tconst data = this.get(module, runtime).data;\n\t\treturn data === undefined ? undefined : data.get(key);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {any} hash of the code generation\n\t */\n\tgetHash(module, runtime) {\n\t\tconst info = this.get(module, runtime);\n\t\tif (info.hash !== undefined) return info.hash;\n\t\tconst hash = createHash(this._hashFunction);\n\t\tfor (const [type, source] of info.sources) {\n\t\t\thash.update(type);\n\t\t\tsource.updateHash(hash);\n\t\t}\n\t\tif (info.runtimeRequirements) {\n\t\t\tfor (const rr of info.runtimeRequirements) hash.update(rr);\n\t\t}\n\t\treturn (info.hash = /** @type {string} */ (hash.digest(\"hex\")));\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @param {CodeGenerationResult} result result from module\n\t * @returns {void}\n\t */\n\tadd(module, runtime, result) {\n\t\tconst map = provide(this.map, module, () => new RuntimeSpecMap());\n\t\tmap.set(runtime, result);\n\t}\n}\n\nmodule.exports = CodeGenerationResults;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}