{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar WebpackError = require(\"../WebpackError\");\nvar _require = require(\"../javascript/JavascriptParserHelpers\"),\n  evaluateToIdentifier = _require.evaluateToIdentifier;\nvar ImportMetaContextDependency = require(\"./ImportMetaContextDependency\");\n\n/** @typedef {import(\"estree\").Expression} ExpressionNode */\n/** @typedef {import(\"estree\").ObjectExpression} ObjectExpressionNode */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../ContextModule\").ContextModuleOptions} ContextModuleOptions */\n/** @typedef {import(\"../ChunkGroup\").RawChunkGroupOptions} RawChunkGroupOptions */\n/** @typedef {Pick<ContextModuleOptions, 'mode'|'recursive'|'regExp'|'include'|'exclude'|'chunkName'>&{groupOptions: RawChunkGroupOptions, exports?: ContextModuleOptions[\"referencedExports\"]}} ImportMetaContextOptions */\n\nfunction createPropertyParseError(prop, expect) {\n  return createError(\"Parsing import.meta.webpackContext options failed. Unknown value for property \".concat(JSON.stringify(prop.key.name), \", expected type \").concat(expect, \".\"), prop.value.loc);\n}\nfunction createError(msg, loc) {\n  var error = new WebpackError(msg);\n  error.name = \"ImportMetaContextError\";\n  error.loc = loc;\n  return error;\n}\nmodule.exports = /*#__PURE__*/function () {\n  function ImportMetaContextDependencyParserPlugin() {\n    _classCallCheck(this, ImportMetaContextDependencyParserPlugin);\n  }\n  _createClass(ImportMetaContextDependencyParserPlugin, [{\n    key: \"apply\",\n    value: function apply(parser) {\n      parser.hooks.evaluateIdentifier.for(\"import.meta.webpackContext\").tap(\"ImportMetaContextDependencyParserPlugin\", function (expr) {\n        return evaluateToIdentifier(\"import.meta.webpackContext\", \"import.meta\", function () {\n          return [\"webpackContext\"];\n        }, true)(expr);\n      });\n      parser.hooks.call.for(\"import.meta.webpackContext\").tap(\"ImportMetaContextDependencyParserPlugin\", function (expr) {\n        if (expr.arguments.length < 1 || expr.arguments.length > 2) return;\n        var _expr$arguments = _slicedToArray(expr.arguments, 2),\n          directoryNode = _expr$arguments[0],\n          optionsNode = _expr$arguments[1];\n        if (optionsNode && optionsNode.type !== \"ObjectExpression\") return;\n        var requestExpr = parser.evaluateExpression(directoryNode);\n        if (!requestExpr.isString()) return;\n        var request = requestExpr.string;\n        var errors = [];\n        var regExp = /^\\.\\/.*$/;\n        var recursive = true;\n        /** @type {ContextModuleOptions[\"mode\"]} */\n        var mode = \"sync\";\n        /** @type {ContextModuleOptions[\"include\"]} */\n        var include;\n        /** @type {ContextModuleOptions[\"exclude\"]} */\n        var exclude;\n        /** @type {RawChunkGroupOptions} */\n        var groupOptions = {};\n        /** @type {ContextModuleOptions[\"chunkName\"]} */\n        var chunkName;\n        /** @type {ContextModuleOptions[\"referencedExports\"]} */\n        var exports;\n        if (optionsNode) {\n          var _iterator = _createForOfIteratorHelper(optionsNode.properties),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var prop = _step.value;\n              if (prop.type !== \"Property\" || prop.key.type !== \"Identifier\") {\n                errors.push(createError(\"Parsing import.meta.webpackContext options failed.\", optionsNode.loc));\n                break;\n              }\n              switch (prop.key.name) {\n                case \"regExp\":\n                  {\n                    var regExpExpr = parser.evaluateExpression( /** @type {ExpressionNode} */prop.value);\n                    if (!regExpExpr.isRegExp()) {\n                      errors.push(createPropertyParseError(prop, \"RegExp\"));\n                    } else {\n                      regExp = regExpExpr.regExp;\n                    }\n                    break;\n                  }\n                case \"include\":\n                  {\n                    var _regExpExpr = parser.evaluateExpression( /** @type {ExpressionNode} */prop.value);\n                    if (!_regExpExpr.isRegExp()) {\n                      errors.push(createPropertyParseError(prop, \"RegExp\"));\n                    } else {\n                      include = _regExpExpr.regExp;\n                    }\n                    break;\n                  }\n                case \"exclude\":\n                  {\n                    var _regExpExpr2 = parser.evaluateExpression( /** @type {ExpressionNode} */prop.value);\n                    if (!_regExpExpr2.isRegExp()) {\n                      errors.push(createPropertyParseError(prop, \"RegExp\"));\n                    } else {\n                      exclude = _regExpExpr2.regExp;\n                    }\n                    break;\n                  }\n                case \"mode\":\n                  {\n                    var modeExpr = parser.evaluateExpression( /** @type {ExpressionNode} */prop.value);\n                    if (!modeExpr.isString()) {\n                      errors.push(createPropertyParseError(prop, \"string\"));\n                    } else {\n                      mode = /** @type {ContextModuleOptions[\"mode\"]} */\n                      modeExpr.string;\n                    }\n                    break;\n                  }\n                case \"chunkName\":\n                  {\n                    var _expr = parser.evaluateExpression( /** @type {ExpressionNode} */prop.value);\n                    if (!_expr.isString()) {\n                      errors.push(createPropertyParseError(prop, \"string\"));\n                    } else {\n                      chunkName = _expr.string;\n                    }\n                    break;\n                  }\n                case \"exports\":\n                  {\n                    var _expr2 = parser.evaluateExpression( /** @type {ExpressionNode} */prop.value);\n                    if (_expr2.isString()) {\n                      exports = [[_expr2.string]];\n                    } else if (_expr2.isArray()) {\n                      var items = _expr2.items;\n                      if (items.every(function (i) {\n                        if (!i.isArray()) return false;\n                        var innerItems = i.items;\n                        return innerItems.every(function (i) {\n                          return i.isString();\n                        });\n                      })) {\n                        exports = [];\n                        var _iterator2 = _createForOfIteratorHelper(items),\n                          _step2;\n                        try {\n                          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                            var i1 = _step2.value;\n                            var export_ = [];\n                            var _iterator3 = _createForOfIteratorHelper(i1.items),\n                              _step3;\n                            try {\n                              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                                var i2 = _step3.value;\n                                export_.push(i2.string);\n                              }\n                            } catch (err) {\n                              _iterator3.e(err);\n                            } finally {\n                              _iterator3.f();\n                            }\n                            exports.push(export_);\n                          }\n                        } catch (err) {\n                          _iterator2.e(err);\n                        } finally {\n                          _iterator2.f();\n                        }\n                      } else {\n                        errors.push(createPropertyParseError(prop, \"string|string[][]\"));\n                      }\n                    } else {\n                      errors.push(createPropertyParseError(prop, \"string|string[][]\"));\n                    }\n                    break;\n                  }\n                case \"prefetch\":\n                  {\n                    var _expr3 = parser.evaluateExpression( /** @type {ExpressionNode} */prop.value);\n                    if (_expr3.isBoolean()) {\n                      groupOptions.prefetchOrder = 0;\n                    } else if (_expr3.isNumber()) {\n                      groupOptions.prefetchOrder = _expr3.number;\n                    } else {\n                      errors.push(createPropertyParseError(prop, \"boolean|number\"));\n                    }\n                    break;\n                  }\n                case \"preload\":\n                  {\n                    var _expr4 = parser.evaluateExpression( /** @type {ExpressionNode} */prop.value);\n                    if (_expr4.isBoolean()) {\n                      groupOptions.preloadOrder = 0;\n                    } else if (_expr4.isNumber()) {\n                      groupOptions.preloadOrder = _expr4.number;\n                    } else {\n                      errors.push(createPropertyParseError(prop, \"boolean|number\"));\n                    }\n                    break;\n                  }\n                case \"recursive\":\n                  {\n                    var recursiveExpr = parser.evaluateExpression( /** @type {ExpressionNode} */prop.value);\n                    if (!recursiveExpr.isBoolean()) {\n                      errors.push(createPropertyParseError(prop, \"boolean\"));\n                    } else {\n                      recursive = recursiveExpr.bool;\n                    }\n                    break;\n                  }\n                default:\n                  errors.push(createError(\"Parsing import.meta.webpackContext options failed. Unknown property \".concat(JSON.stringify(prop.key.name), \".\"), optionsNode.loc));\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n        if (errors.length) {\n          var _iterator4 = _createForOfIteratorHelper(errors),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var error = _step4.value;\n              parser.state.current.addError(error);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          return;\n        }\n        var dep = new ImportMetaContextDependency({\n          request: request,\n          include: include,\n          exclude: exclude,\n          recursive: recursive,\n          regExp: regExp,\n          groupOptions: groupOptions,\n          chunkName: chunkName,\n          referencedExports: exports,\n          mode: mode,\n          category: \"esm\"\n        }, expr.range);\n        dep.loc = expr.loc;\n        dep.optional = !!parser.scope.inTry;\n        parser.state.current.addDependency(dep);\n        return true;\n      });\n    }\n  }]);\n  return ImportMetaContextDependencyParserPlugin;\n}();","map":{"version":3,"names":["WebpackError","require","evaluateToIdentifier","ImportMetaContextDependency","createPropertyParseError","prop","expect","createError","JSON","stringify","key","name","value","loc","msg","error","module","exports","parser","hooks","evaluateIdentifier","for","tap","expr","call","arguments","length","directoryNode","optionsNode","type","requestExpr","evaluateExpression","isString","request","string","errors","regExp","recursive","mode","include","exclude","groupOptions","chunkName","properties","push","regExpExpr","isRegExp","modeExpr","isArray","items","every","i","innerItems","i1","export_","i2","isBoolean","prefetchOrder","isNumber","number","preloadOrder","recursiveExpr","bool","state","current","addError","dep","referencedExports","category","range","optional","scope","inTry","addDependency"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/dependencies/ImportMetaContextDependencyParserPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst WebpackError = require(\"../WebpackError\");\nconst {\n\tevaluateToIdentifier\n} = require(\"../javascript/JavascriptParserHelpers\");\nconst ImportMetaContextDependency = require(\"./ImportMetaContextDependency\");\n\n/** @typedef {import(\"estree\").Expression} ExpressionNode */\n/** @typedef {import(\"estree\").ObjectExpression} ObjectExpressionNode */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../ContextModule\").ContextModuleOptions} ContextModuleOptions */\n/** @typedef {import(\"../ChunkGroup\").RawChunkGroupOptions} RawChunkGroupOptions */\n/** @typedef {Pick<ContextModuleOptions, 'mode'|'recursive'|'regExp'|'include'|'exclude'|'chunkName'>&{groupOptions: RawChunkGroupOptions, exports?: ContextModuleOptions[\"referencedExports\"]}} ImportMetaContextOptions */\n\nfunction createPropertyParseError(prop, expect) {\n\treturn createError(\n\t\t`Parsing import.meta.webpackContext options failed. Unknown value for property ${JSON.stringify(\n\t\t\tprop.key.name\n\t\t)}, expected type ${expect}.`,\n\t\tprop.value.loc\n\t);\n}\n\nfunction createError(msg, loc) {\n\tconst error = new WebpackError(msg);\n\terror.name = \"ImportMetaContextError\";\n\terror.loc = loc;\n\treturn error;\n}\n\nmodule.exports = class ImportMetaContextDependencyParserPlugin {\n\tapply(parser) {\n\t\tparser.hooks.evaluateIdentifier\n\t\t\t.for(\"import.meta.webpackContext\")\n\t\t\t.tap(\"ImportMetaContextDependencyParserPlugin\", expr => {\n\t\t\t\treturn evaluateToIdentifier(\n\t\t\t\t\t\"import.meta.webpackContext\",\n\t\t\t\t\t\"import.meta\",\n\t\t\t\t\t() => [\"webpackContext\"],\n\t\t\t\t\ttrue\n\t\t\t\t)(expr);\n\t\t\t});\n\t\tparser.hooks.call\n\t\t\t.for(\"import.meta.webpackContext\")\n\t\t\t.tap(\"ImportMetaContextDependencyParserPlugin\", expr => {\n\t\t\t\tif (expr.arguments.length < 1 || expr.arguments.length > 2) return;\n\t\t\t\tconst [directoryNode, optionsNode] = expr.arguments;\n\t\t\t\tif (optionsNode && optionsNode.type !== \"ObjectExpression\") return;\n\t\t\t\tconst requestExpr = parser.evaluateExpression(directoryNode);\n\t\t\t\tif (!requestExpr.isString()) return;\n\t\t\t\tconst request = requestExpr.string;\n\t\t\t\tconst errors = [];\n\t\t\t\tlet regExp = /^\\.\\/.*$/;\n\t\t\t\tlet recursive = true;\n\t\t\t\t/** @type {ContextModuleOptions[\"mode\"]} */\n\t\t\t\tlet mode = \"sync\";\n\t\t\t\t/** @type {ContextModuleOptions[\"include\"]} */\n\t\t\t\tlet include;\n\t\t\t\t/** @type {ContextModuleOptions[\"exclude\"]} */\n\t\t\t\tlet exclude;\n\t\t\t\t/** @type {RawChunkGroupOptions} */\n\t\t\t\tconst groupOptions = {};\n\t\t\t\t/** @type {ContextModuleOptions[\"chunkName\"]} */\n\t\t\t\tlet chunkName;\n\t\t\t\t/** @type {ContextModuleOptions[\"referencedExports\"]} */\n\t\t\t\tlet exports;\n\t\t\t\tif (optionsNode) {\n\t\t\t\t\tfor (const prop of optionsNode.properties) {\n\t\t\t\t\t\tif (prop.type !== \"Property\" || prop.key.type !== \"Identifier\") {\n\t\t\t\t\t\t\terrors.push(\n\t\t\t\t\t\t\t\tcreateError(\n\t\t\t\t\t\t\t\t\t\"Parsing import.meta.webpackContext options failed.\",\n\t\t\t\t\t\t\t\t\toptionsNode.loc\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswitch (prop.key.name) {\n\t\t\t\t\t\t\tcase \"regExp\": {\n\t\t\t\t\t\t\t\tconst regExpExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (!regExpExpr.isRegExp()) {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"RegExp\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tregExp = regExpExpr.regExp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"include\": {\n\t\t\t\t\t\t\t\tconst regExpExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (!regExpExpr.isRegExp()) {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"RegExp\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tinclude = regExpExpr.regExp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"exclude\": {\n\t\t\t\t\t\t\t\tconst regExpExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (!regExpExpr.isRegExp()) {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"RegExp\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\texclude = regExpExpr.regExp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"mode\": {\n\t\t\t\t\t\t\t\tconst modeExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (!modeExpr.isString()) {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"string\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmode = /** @type {ContextModuleOptions[\"mode\"]} */ (\n\t\t\t\t\t\t\t\t\t\tmodeExpr.string\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"chunkName\": {\n\t\t\t\t\t\t\t\tconst expr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (!expr.isString()) {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"string\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tchunkName = expr.string;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"exports\": {\n\t\t\t\t\t\t\t\tconst expr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (expr.isString()) {\n\t\t\t\t\t\t\t\t\texports = [[expr.string]];\n\t\t\t\t\t\t\t\t} else if (expr.isArray()) {\n\t\t\t\t\t\t\t\t\tconst items = expr.items;\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\titems.every(i => {\n\t\t\t\t\t\t\t\t\t\t\tif (!i.isArray()) return false;\n\t\t\t\t\t\t\t\t\t\t\tconst innerItems = i.items;\n\t\t\t\t\t\t\t\t\t\t\treturn innerItems.every(i => i.isString());\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\texports = [];\n\t\t\t\t\t\t\t\t\t\tfor (const i1 of items) {\n\t\t\t\t\t\t\t\t\t\t\tconst export_ = [];\n\t\t\t\t\t\t\t\t\t\t\tfor (const i2 of i1.items) {\n\t\t\t\t\t\t\t\t\t\t\t\texport_.push(i2.string);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\texports.push(export_);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\terrors.push(\n\t\t\t\t\t\t\t\t\t\t\tcreatePropertyParseError(prop, \"string|string[][]\")\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\terrors.push(\n\t\t\t\t\t\t\t\t\t\tcreatePropertyParseError(prop, \"string|string[][]\")\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"prefetch\": {\n\t\t\t\t\t\t\t\tconst expr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (expr.isBoolean()) {\n\t\t\t\t\t\t\t\t\tgroupOptions.prefetchOrder = 0;\n\t\t\t\t\t\t\t\t} else if (expr.isNumber()) {\n\t\t\t\t\t\t\t\t\tgroupOptions.prefetchOrder = expr.number;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"boolean|number\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"preload\": {\n\t\t\t\t\t\t\t\tconst expr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (expr.isBoolean()) {\n\t\t\t\t\t\t\t\t\tgroupOptions.preloadOrder = 0;\n\t\t\t\t\t\t\t\t} else if (expr.isNumber()) {\n\t\t\t\t\t\t\t\t\tgroupOptions.preloadOrder = expr.number;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"boolean|number\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcase \"recursive\": {\n\t\t\t\t\t\t\t\tconst recursiveExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (!recursiveExpr.isBoolean()) {\n\t\t\t\t\t\t\t\t\terrors.push(createPropertyParseError(prop, \"boolean\"));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\trecursive = recursiveExpr.bool;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\terrors.push(\n\t\t\t\t\t\t\t\t\tcreateError(\n\t\t\t\t\t\t\t\t\t\t`Parsing import.meta.webpackContext options failed. Unknown property ${JSON.stringify(\n\t\t\t\t\t\t\t\t\t\t\tprop.key.name\n\t\t\t\t\t\t\t\t\t\t)}.`,\n\t\t\t\t\t\t\t\t\t\toptionsNode.loc\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (errors.length) {\n\t\t\t\t\tfor (const error of errors) parser.state.current.addError(error);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst dep = new ImportMetaContextDependency(\n\t\t\t\t\t{\n\t\t\t\t\t\trequest,\n\t\t\t\t\t\tinclude,\n\t\t\t\t\t\texclude,\n\t\t\t\t\t\trecursive,\n\t\t\t\t\t\tregExp,\n\t\t\t\t\t\tgroupOptions,\n\t\t\t\t\t\tchunkName,\n\t\t\t\t\t\treferencedExports: exports,\n\t\t\t\t\t\tmode,\n\t\t\t\t\t\tcategory: \"esm\"\n\t\t\t\t\t},\n\t\t\t\t\texpr.range\n\t\t\t\t);\n\t\t\t\tdep.loc = expr.loc;\n\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\treturn true;\n\t\t\t});\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}