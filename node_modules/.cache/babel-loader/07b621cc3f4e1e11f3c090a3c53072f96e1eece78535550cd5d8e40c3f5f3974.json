{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _require = require(\"../OptimizationStages\"),\n  STAGE_ADVANCED = _require.STAGE_ADVANCED;\nvar LazyBucketSortedSet = require(\"../util/LazyBucketSortedSet\");\nvar _require2 = require(\"../util/comparators\"),\n  compareChunks = _require2.compareChunks;\nvar createSchemaValidation = require(\"../util/create-schema-validation\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nvar validate = createSchemaValidation(require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.check.js\"), function () {\n  return require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\");\n}, {\n  name: \"Limit Chunk Count Plugin\",\n  baseDataPath: \"options\"\n});\n\n/**\n * @typedef {Object} ChunkCombination\n * @property {boolean} deleted this is set to true when combination was removed\n * @property {number} sizeDiff\n * @property {number} integratedSize\n * @property {Chunk} a\n * @property {Chunk} b\n * @property {number} aIdx\n * @property {number} bIdx\n * @property {number} aSize\n * @property {number} bSize\n */\n\nvar addToSetMap = function addToSetMap(map, key, value) {\n  var set = map.get(key);\n  if (set === undefined) {\n    map.set(key, new Set([value]));\n  } else {\n    set.add(value);\n  }\n};\nvar LimitChunkCountPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {LimitChunkCountPluginOptions=} options options object\n   */\n  function LimitChunkCountPlugin(options) {\n    _classCallCheck(this, LimitChunkCountPlugin);\n    validate(options);\n    this.options = options;\n  }\n\n  /**\n   * @param {Compiler} compiler the webpack compiler\n   * @returns {void}\n   */\n  _createClass(LimitChunkCountPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var options = this.options;\n      compiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", function (compilation) {\n        compilation.hooks.optimizeChunks.tap({\n          name: \"LimitChunkCountPlugin\",\n          stage: STAGE_ADVANCED\n        }, function (chunks) {\n          var chunkGraph = compilation.chunkGraph;\n          var maxChunks = options.maxChunks;\n          if (!maxChunks) return;\n          if (maxChunks < 1) return;\n          if (compilation.chunks.size <= maxChunks) return;\n          var remainingChunksToMerge = compilation.chunks.size - maxChunks;\n\n          // order chunks in a deterministic way\n          var compareChunksWithGraph = compareChunks(chunkGraph);\n          var orderedChunks = Array.from(chunks).sort(compareChunksWithGraph);\n\n          // create a lazy sorted data structure to keep all combinations\n          // this is large. Size = chunks * (chunks - 1) / 2\n          // It uses a multi layer bucket sort plus normal sort in the last layer\n          // It's also lazy so only accessed buckets are sorted\n          var combinations = new LazyBucketSortedSet(\n          // Layer 1: ordered by largest size benefit\n          function (c) {\n            return c.sizeDiff;\n          }, function (a, b) {\n            return b - a;\n          },\n          // Layer 2: ordered by smallest combined size\n          function (c) {\n            return c.integratedSize;\n          }, function (a, b) {\n            return a - b;\n          },\n          // Layer 3: ordered by position difference in orderedChunk (-> to be deterministic)\n          function (c) {\n            return c.bIdx - c.aIdx;\n          }, function (a, b) {\n            return a - b;\n          },\n          // Layer 4: ordered by position in orderedChunk (-> to be deterministic)\n          function (a, b) {\n            return a.bIdx - b.bIdx;\n          });\n\n          // we keep a mapping from chunk to all combinations\n          // but this mapping is not kept up-to-date with deletions\n          // so `deleted` flag need to be considered when iterating this\n          /** @type {Map<Chunk, Set<ChunkCombination>>} */\n          var combinationsByChunk = new Map();\n          orderedChunks.forEach(function (b, bIdx) {\n            // create combination pairs with size and integrated size\n            for (var aIdx = 0; aIdx < bIdx; aIdx++) {\n              var a = orderedChunks[aIdx];\n              // filter pairs that can not be integrated!\n              if (!chunkGraph.canChunksBeIntegrated(a, b)) continue;\n              var integratedSize = chunkGraph.getIntegratedChunksSize(a, b, options);\n              var aSize = chunkGraph.getChunkSize(a, options);\n              var bSize = chunkGraph.getChunkSize(b, options);\n              var c = {\n                deleted: false,\n                sizeDiff: aSize + bSize - integratedSize,\n                integratedSize: integratedSize,\n                a: a,\n                b: b,\n                aIdx: aIdx,\n                bIdx: bIdx,\n                aSize: aSize,\n                bSize: bSize\n              };\n              combinations.add(c);\n              addToSetMap(combinationsByChunk, a, c);\n              addToSetMap(combinationsByChunk, b, c);\n            }\n            return combinations;\n          });\n\n          // list of modified chunks during this run\n          // combinations affected by this change are skipped to allow\n          // further optimizations\n          /** @type {Set<Chunk>} */\n          var modifiedChunks = new Set();\n          var changed = false;\n          // eslint-disable-next-line no-constant-condition\n          loop: while (true) {\n            var combination = combinations.popFirst();\n            if (combination === undefined) break;\n            combination.deleted = true;\n            var a = combination.a,\n              b = combination.b,\n              integratedSize = combination.integratedSize;\n\n            // skip over pair when\n            // one of the already merged chunks is a parent of one of the chunks\n            if (modifiedChunks.size > 0) {\n              var queue = new Set(a.groupsIterable);\n              var _iterator = _createForOfIteratorHelper(b.groupsIterable),\n                _step;\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var group = _step.value;\n                  queue.add(group);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              var _iterator2 = _createForOfIteratorHelper(queue),\n                _step2;\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var _group = _step2.value;\n                  var _iterator3 = _createForOfIteratorHelper(modifiedChunks),\n                    _step3;\n                  try {\n                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                      var mChunk = _step3.value;\n                      if (mChunk !== a && mChunk !== b && mChunk.isInGroup(_group)) {\n                        // This is a potential pair which needs recalculation\n                        // We can't do that now, but it merge before following pairs\n                        // so we leave space for it, and consider chunks as modified\n                        // just for the worse case\n                        remainingChunksToMerge--;\n                        if (remainingChunksToMerge <= 0) break loop;\n                        modifiedChunks.add(a);\n                        modifiedChunks.add(b);\n                        continue loop;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator3.e(err);\n                  } finally {\n                    _iterator3.f();\n                  }\n                  var _iterator4 = _createForOfIteratorHelper(_group.parentsIterable),\n                    _step4;\n                  try {\n                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                      var parent = _step4.value;\n                      queue.add(parent);\n                    }\n                  } catch (err) {\n                    _iterator4.e(err);\n                  } finally {\n                    _iterator4.f();\n                  }\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            }\n\n            // merge the chunks\n            if (chunkGraph.canChunksBeIntegrated(a, b)) {\n              chunkGraph.integrateChunks(a, b);\n              compilation.chunks.delete(b);\n\n              // flag chunk a as modified as further optimization are possible for all children here\n              modifiedChunks.add(a);\n              changed = true;\n              remainingChunksToMerge--;\n              if (remainingChunksToMerge <= 0) break;\n\n              // Update all affected combinations\n              // delete all combination with the removed chunk\n              // we will use combinations with the kept chunk instead\n              var _iterator5 = _createForOfIteratorHelper(combinationsByChunk.get(a)),\n                _step5;\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  var _combination = _step5.value;\n                  if (_combination.deleted) continue;\n                  _combination.deleted = true;\n                  combinations.delete(_combination);\n                }\n\n                // Update combinations with the kept chunk with new sizes\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n              var _iterator6 = _createForOfIteratorHelper(combinationsByChunk.get(b)),\n                _step6;\n              try {\n                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                  var _combination2 = _step6.value;\n                  if (_combination2.deleted) continue;\n                  if (_combination2.a === b) {\n                    if (!chunkGraph.canChunksBeIntegrated(a, _combination2.b)) {\n                      _combination2.deleted = true;\n                      combinations.delete(_combination2);\n                      continue;\n                    }\n                    // Update size\n                    var newIntegratedSize = chunkGraph.getIntegratedChunksSize(a, _combination2.b, options);\n                    var finishUpdate = combinations.startUpdate(_combination2);\n                    _combination2.a = a;\n                    _combination2.integratedSize = newIntegratedSize;\n                    _combination2.aSize = integratedSize;\n                    _combination2.sizeDiff = _combination2.bSize + integratedSize - newIntegratedSize;\n                    finishUpdate();\n                  } else if (_combination2.b === b) {\n                    if (!chunkGraph.canChunksBeIntegrated(_combination2.a, a)) {\n                      _combination2.deleted = true;\n                      combinations.delete(_combination2);\n                      continue;\n                    }\n                    // Update size\n                    var _newIntegratedSize = chunkGraph.getIntegratedChunksSize(_combination2.a, a, options);\n                    var _finishUpdate = combinations.startUpdate(_combination2);\n                    _combination2.b = a;\n                    _combination2.integratedSize = _newIntegratedSize;\n                    _combination2.bSize = integratedSize;\n                    _combination2.sizeDiff = integratedSize + _combination2.aSize - _newIntegratedSize;\n                    _finishUpdate();\n                  }\n                }\n              } catch (err) {\n                _iterator6.e(err);\n              } finally {\n                _iterator6.f();\n              }\n              combinationsByChunk.set(a, combinationsByChunk.get(b));\n              combinationsByChunk.delete(b);\n            }\n          }\n          if (changed) return true;\n        });\n      });\n    }\n  }]);\n  return LimitChunkCountPlugin;\n}();\nmodule.exports = LimitChunkCountPlugin;","map":{"version":3,"names":["require","STAGE_ADVANCED","LazyBucketSortedSet","compareChunks","createSchemaValidation","validate","name","baseDataPath","addToSetMap","map","key","value","set","get","undefined","Set","add","LimitChunkCountPlugin","options","compiler","hooks","compilation","tap","optimizeChunks","stage","chunks","chunkGraph","maxChunks","size","remainingChunksToMerge","compareChunksWithGraph","orderedChunks","Array","from","sort","combinations","c","sizeDiff","a","b","integratedSize","bIdx","aIdx","combinationsByChunk","Map","forEach","canChunksBeIntegrated","getIntegratedChunksSize","aSize","getChunkSize","bSize","deleted","modifiedChunks","changed","loop","combination","popFirst","queue","groupsIterable","group","mChunk","isInGroup","parentsIterable","parent","integrateChunks","delete","newIntegratedSize","finishUpdate","startUpdate","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/optimize/LimitChunkCountPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\nconst LazyBucketSortedSet = require(\"../util/LazyBucketSortedSet\");\nconst { compareChunks } = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.check.js\"),\n\t() => require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\"),\n\t{\n\t\tname: \"Limit Chunk Count Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\n/**\n * @typedef {Object} ChunkCombination\n * @property {boolean} deleted this is set to true when combination was removed\n * @property {number} sizeDiff\n * @property {number} integratedSize\n * @property {Chunk} a\n * @property {Chunk} b\n * @property {number} aIdx\n * @property {number} bIdx\n * @property {number} aSize\n * @property {number} bSize\n */\n\nconst addToSetMap = (map, key, value) => {\n\tconst set = map.get(key);\n\tif (set === undefined) {\n\t\tmap.set(key, new Set([value]));\n\t} else {\n\t\tset.add(value);\n\t}\n};\n\nclass LimitChunkCountPlugin {\n\t/**\n\t * @param {LimitChunkCountPluginOptions=} options options object\n\t */\n\tconstructor(options) {\n\t\tvalidate(options);\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tcompiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", compilation => {\n\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"LimitChunkCountPlugin\",\n\t\t\t\t\tstage: STAGE_ADVANCED\n\t\t\t\t},\n\t\t\t\tchunks => {\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst maxChunks = options.maxChunks;\n\t\t\t\t\tif (!maxChunks) return;\n\t\t\t\t\tif (maxChunks < 1) return;\n\t\t\t\t\tif (compilation.chunks.size <= maxChunks) return;\n\n\t\t\t\t\tlet remainingChunksToMerge = compilation.chunks.size - maxChunks;\n\n\t\t\t\t\t// order chunks in a deterministic way\n\t\t\t\t\tconst compareChunksWithGraph = compareChunks(chunkGraph);\n\t\t\t\t\tconst orderedChunks = Array.from(chunks).sort(compareChunksWithGraph);\n\n\t\t\t\t\t// create a lazy sorted data structure to keep all combinations\n\t\t\t\t\t// this is large. Size = chunks * (chunks - 1) / 2\n\t\t\t\t\t// It uses a multi layer bucket sort plus normal sort in the last layer\n\t\t\t\t\t// It's also lazy so only accessed buckets are sorted\n\t\t\t\t\tconst combinations = new LazyBucketSortedSet(\n\t\t\t\t\t\t// Layer 1: ordered by largest size benefit\n\t\t\t\t\t\tc => c.sizeDiff,\n\t\t\t\t\t\t(a, b) => b - a,\n\t\t\t\t\t\t// Layer 2: ordered by smallest combined size\n\t\t\t\t\t\tc => c.integratedSize,\n\t\t\t\t\t\t(a, b) => a - b,\n\t\t\t\t\t\t// Layer 3: ordered by position difference in orderedChunk (-> to be deterministic)\n\t\t\t\t\t\tc => c.bIdx - c.aIdx,\n\t\t\t\t\t\t(a, b) => a - b,\n\t\t\t\t\t\t// Layer 4: ordered by position in orderedChunk (-> to be deterministic)\n\t\t\t\t\t\t(a, b) => a.bIdx - b.bIdx\n\t\t\t\t\t);\n\n\t\t\t\t\t// we keep a mapping from chunk to all combinations\n\t\t\t\t\t// but this mapping is not kept up-to-date with deletions\n\t\t\t\t\t// so `deleted` flag need to be considered when iterating this\n\t\t\t\t\t/** @type {Map<Chunk, Set<ChunkCombination>>} */\n\t\t\t\t\tconst combinationsByChunk = new Map();\n\n\t\t\t\t\torderedChunks.forEach((b, bIdx) => {\n\t\t\t\t\t\t// create combination pairs with size and integrated size\n\t\t\t\t\t\tfor (let aIdx = 0; aIdx < bIdx; aIdx++) {\n\t\t\t\t\t\t\tconst a = orderedChunks[aIdx];\n\t\t\t\t\t\t\t// filter pairs that can not be integrated!\n\t\t\t\t\t\t\tif (!chunkGraph.canChunksBeIntegrated(a, b)) continue;\n\n\t\t\t\t\t\t\tconst integratedSize = chunkGraph.getIntegratedChunksSize(\n\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\tb,\n\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tconst aSize = chunkGraph.getChunkSize(a, options);\n\t\t\t\t\t\t\tconst bSize = chunkGraph.getChunkSize(b, options);\n\t\t\t\t\t\t\tconst c = {\n\t\t\t\t\t\t\t\tdeleted: false,\n\t\t\t\t\t\t\t\tsizeDiff: aSize + bSize - integratedSize,\n\t\t\t\t\t\t\t\tintegratedSize,\n\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\tb,\n\t\t\t\t\t\t\t\taIdx,\n\t\t\t\t\t\t\t\tbIdx,\n\t\t\t\t\t\t\t\taSize,\n\t\t\t\t\t\t\t\tbSize\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcombinations.add(c);\n\t\t\t\t\t\t\taddToSetMap(combinationsByChunk, a, c);\n\t\t\t\t\t\t\taddToSetMap(combinationsByChunk, b, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn combinations;\n\t\t\t\t\t});\n\n\t\t\t\t\t// list of modified chunks during this run\n\t\t\t\t\t// combinations affected by this change are skipped to allow\n\t\t\t\t\t// further optimizations\n\t\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\t\tconst modifiedChunks = new Set();\n\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\t\t\tloop: while (true) {\n\t\t\t\t\t\tconst combination = combinations.popFirst();\n\t\t\t\t\t\tif (combination === undefined) break;\n\n\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\tconst { a, b, integratedSize } = combination;\n\n\t\t\t\t\t\t// skip over pair when\n\t\t\t\t\t\t// one of the already merged chunks is a parent of one of the chunks\n\t\t\t\t\t\tif (modifiedChunks.size > 0) {\n\t\t\t\t\t\t\tconst queue = new Set(a.groupsIterable);\n\t\t\t\t\t\t\tfor (const group of b.groupsIterable) {\n\t\t\t\t\t\t\t\tqueue.add(group);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const group of queue) {\n\t\t\t\t\t\t\t\tfor (const mChunk of modifiedChunks) {\n\t\t\t\t\t\t\t\t\tif (mChunk !== a && mChunk !== b && mChunk.isInGroup(group)) {\n\t\t\t\t\t\t\t\t\t\t// This is a potential pair which needs recalculation\n\t\t\t\t\t\t\t\t\t\t// We can't do that now, but it merge before following pairs\n\t\t\t\t\t\t\t\t\t\t// so we leave space for it, and consider chunks as modified\n\t\t\t\t\t\t\t\t\t\t// just for the worse case\n\t\t\t\t\t\t\t\t\t\tremainingChunksToMerge--;\n\t\t\t\t\t\t\t\t\t\tif (remainingChunksToMerge <= 0) break loop;\n\t\t\t\t\t\t\t\t\t\tmodifiedChunks.add(a);\n\t\t\t\t\t\t\t\t\t\tmodifiedChunks.add(b);\n\t\t\t\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const parent of group.parentsIterable) {\n\t\t\t\t\t\t\t\t\tqueue.add(parent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// merge the chunks\n\t\t\t\t\t\tif (chunkGraph.canChunksBeIntegrated(a, b)) {\n\t\t\t\t\t\t\tchunkGraph.integrateChunks(a, b);\n\t\t\t\t\t\t\tcompilation.chunks.delete(b);\n\n\t\t\t\t\t\t\t// flag chunk a as modified as further optimization are possible for all children here\n\t\t\t\t\t\t\tmodifiedChunks.add(a);\n\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tremainingChunksToMerge--;\n\t\t\t\t\t\t\tif (remainingChunksToMerge <= 0) break;\n\n\t\t\t\t\t\t\t// Update all affected combinations\n\t\t\t\t\t\t\t// delete all combination with the removed chunk\n\t\t\t\t\t\t\t// we will use combinations with the kept chunk instead\n\t\t\t\t\t\t\tfor (const combination of combinationsByChunk.get(a)) {\n\t\t\t\t\t\t\t\tif (combination.deleted) continue;\n\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Update combinations with the kept chunk with new sizes\n\t\t\t\t\t\t\tfor (const combination of combinationsByChunk.get(b)) {\n\t\t\t\t\t\t\t\tif (combination.deleted) continue;\n\t\t\t\t\t\t\t\tif (combination.a === b) {\n\t\t\t\t\t\t\t\t\tif (!chunkGraph.canChunksBeIntegrated(a, combination.b)) {\n\t\t\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Update size\n\t\t\t\t\t\t\t\t\tconst newIntegratedSize = chunkGraph.getIntegratedChunksSize(\n\t\t\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\t\t\tcombination.b,\n\t\t\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tconst finishUpdate = combinations.startUpdate(combination);\n\t\t\t\t\t\t\t\t\tcombination.a = a;\n\t\t\t\t\t\t\t\t\tcombination.integratedSize = newIntegratedSize;\n\t\t\t\t\t\t\t\t\tcombination.aSize = integratedSize;\n\t\t\t\t\t\t\t\t\tcombination.sizeDiff =\n\t\t\t\t\t\t\t\t\t\tcombination.bSize + integratedSize - newIntegratedSize;\n\t\t\t\t\t\t\t\t\tfinishUpdate();\n\t\t\t\t\t\t\t\t} else if (combination.b === b) {\n\t\t\t\t\t\t\t\t\tif (!chunkGraph.canChunksBeIntegrated(combination.a, a)) {\n\t\t\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Update size\n\t\t\t\t\t\t\t\t\tconst newIntegratedSize = chunkGraph.getIntegratedChunksSize(\n\t\t\t\t\t\t\t\t\t\tcombination.a,\n\t\t\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst finishUpdate = combinations.startUpdate(combination);\n\t\t\t\t\t\t\t\t\tcombination.b = a;\n\t\t\t\t\t\t\t\t\tcombination.integratedSize = newIntegratedSize;\n\t\t\t\t\t\t\t\t\tcombination.bSize = integratedSize;\n\t\t\t\t\t\t\t\t\tcombination.sizeDiff =\n\t\t\t\t\t\t\t\t\t\tintegratedSize + combination.aSize - newIntegratedSize;\n\t\t\t\t\t\t\t\t\tfinishUpdate();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcombinationsByChunk.set(a, combinationsByChunk.get(b));\n\t\t\t\t\t\t\tcombinationsByChunk.delete(b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) return true;\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = LimitChunkCountPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}