{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _objectSpread = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _require = require(\"url\"),\n  pathToFileURL = _require.pathToFileURL;\nvar AsyncDependenciesBlock = require(\"../AsyncDependenciesBlock\");\nvar CommentCompilationWarning = require(\"../CommentCompilationWarning\");\nvar UnsupportedFeatureWarning = require(\"../UnsupportedFeatureWarning\");\nvar EnableChunkLoadingPlugin = require(\"../javascript/EnableChunkLoadingPlugin\");\nvar _require2 = require(\"../util/ArrayHelpers\"),\n  equals = _require2.equals;\nvar createHash = require(\"../util/createHash\");\nvar _require3 = require(\"../util/identifier\"),\n  contextify = _require3.contextify;\nvar EnableWasmLoadingPlugin = require(\"../wasm/EnableWasmLoadingPlugin\");\nvar ConstDependency = require(\"./ConstDependency\");\nvar CreateScriptUrlDependency = require(\"./CreateScriptUrlDependency\");\nvar _require4 = require(\"./HarmonyImportDependencyParserPlugin\"),\n  harmonySpecifierTag = _require4.harmonySpecifierTag;\nvar WorkerDependency = require(\"./WorkerDependency\");\n\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"estree\").ObjectExpression} ObjectExpression */\n/** @typedef {import(\"estree\").Pattern} Pattern */\n/** @typedef {import(\"estree\").Property} Property */\n/** @typedef {import(\"estree\").SpreadElement} SpreadElement */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Entrypoint\").EntryOptions} EntryOptions */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"./HarmonyImportDependencyParserPlugin\").HarmonySettings} HarmonySettings */\n\nvar getUrl = function getUrl(module) {\n  return pathToFileURL(module.resource).toString();\n};\nvar DEFAULT_SYNTAX = [\"Worker\", \"SharedWorker\", \"navigator.serviceWorker.register()\", \"Worker from worker_threads\"];\n\n/** @type {WeakMap<ParserState, number>} */\nvar workerIndexMap = new WeakMap();\nvar WorkerPlugin = /*#__PURE__*/function () {\n  function WorkerPlugin(chunkLoading, wasmLoading, module) {\n    _classCallCheck(this, WorkerPlugin);\n    this._chunkLoading = chunkLoading;\n    this._wasmLoading = wasmLoading;\n    this._module = module;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  _createClass(WorkerPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this = this;\n      if (this._chunkLoading) {\n        new EnableChunkLoadingPlugin(this._chunkLoading).apply(compiler);\n      }\n      if (this._wasmLoading) {\n        new EnableWasmLoadingPlugin(this._wasmLoading).apply(compiler);\n      }\n      var cachedContextify = contextify.bindContextCache(compiler.context, compiler.root);\n      compiler.hooks.thisCompilation.tap(\"WorkerPlugin\", function (compilation, _ref) {\n        var normalModuleFactory = _ref.normalModuleFactory;\n        compilation.dependencyFactories.set(WorkerDependency, normalModuleFactory);\n        compilation.dependencyTemplates.set(WorkerDependency, new WorkerDependency.Template());\n        compilation.dependencyTemplates.set(CreateScriptUrlDependency, new CreateScriptUrlDependency.Template());\n\n        /**\n         * @param {JavascriptParser} parser the parser\n         * @param {Expression} expr expression\n         * @returns {[BasicEvaluatedExpression, [number, number]]} parsed\n         */\n        var parseModuleUrl = function parseModuleUrl(parser, expr) {\n          if (expr.type !== \"NewExpression\" || expr.callee.type === \"Super\" || expr.arguments.length !== 2) return;\n          var _expr$arguments = _slicedToArray(expr.arguments, 2),\n            arg1 = _expr$arguments[0],\n            arg2 = _expr$arguments[1];\n          if (arg1.type === \"SpreadElement\") return;\n          if (arg2.type === \"SpreadElement\") return;\n          var callee = parser.evaluateExpression(expr.callee);\n          if (!callee.isIdentifier() || callee.identifier !== \"URL\") return;\n          var arg2Value = parser.evaluateExpression(arg2);\n          if (!arg2Value.isString() || !arg2Value.string.startsWith(\"file://\") || arg2Value.string !== getUrl(parser.state.module)) {\n            return;\n          }\n          var arg1Value = parser.evaluateExpression(arg1);\n          return [arg1Value, [arg1.range[0], arg2.range[1]]];\n        };\n\n        /**\n         * @param {JavascriptParser} parser the parser\n         * @param {ObjectExpression} expr expression\n         * @returns {{ expressions: Record<string, Expression | Pattern>, otherElements: (Property | SpreadElement)[], values: Record<string, any>, spread: boolean, insertType: \"comma\" | \"single\", insertLocation: number }} parsed object\n         */\n        var parseObjectExpression = function parseObjectExpression(parser, expr) {\n          /** @type {Record<string, any>} */\n          var values = {};\n          /** @type {Record<string, Expression | Pattern>} */\n          var expressions = {};\n          /** @type {(Property | SpreadElement)[]} */\n          var otherElements = [];\n          var spread = false;\n          var _iterator = _createForOfIteratorHelper(expr.properties),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var prop = _step.value;\n              if (prop.type === \"SpreadElement\") {\n                spread = true;\n              } else if (prop.type === \"Property\" && !prop.method && !prop.computed && prop.key.type === \"Identifier\") {\n                expressions[prop.key.name] = prop.value;\n                if (!prop.shorthand && !prop.value.type.endsWith(\"Pattern\")) {\n                  var value = parser.evaluateExpression( /** @type {Expression} */prop.value);\n                  if (value.isCompileTimeValue()) values[prop.key.name] = value.asCompileTimeValue();\n                }\n              } else {\n                otherElements.push(prop);\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          var insertType = expr.properties.length > 0 ? \"comma\" : \"single\";\n          var insertLocation = expr.properties[expr.properties.length - 1].range[1];\n          return {\n            expressions: expressions,\n            otherElements: otherElements,\n            values: values,\n            spread: spread,\n            insertType: insertType,\n            insertLocation: insertLocation\n          };\n        };\n\n        /**\n         * @param {JavascriptParser} parser the parser\n         * @param {object} parserOptions options\n         */\n        var parserPlugin = function parserPlugin(parser, parserOptions) {\n          if (parserOptions.worker === false) return;\n          var options = !Array.isArray(parserOptions.worker) ? [\"...\"] : parserOptions.worker;\n          var handleNewWorker = function handleNewWorker(expr) {\n            if (expr.arguments.length === 0 || expr.arguments.length > 2) return;\n            var _expr$arguments2 = _slicedToArray(expr.arguments, 2),\n              arg1 = _expr$arguments2[0],\n              arg2 = _expr$arguments2[1];\n            if (arg1.type === \"SpreadElement\") return;\n            if (arg2 && arg2.type === \"SpreadElement\") return;\n            var parsedUrl = parseModuleUrl(parser, arg1);\n            if (!parsedUrl) return;\n            var _parsedUrl = _slicedToArray(parsedUrl, 2),\n              url = _parsedUrl[0],\n              range = _parsedUrl[1];\n            if (!url.isString()) return;\n            var _ref2 = arg2 && arg2.type === \"ObjectExpression\" ? parseObjectExpression(parser, arg2) : {\n                /** @type {Record<string, Expression | Pattern>} */\n                expressions: {},\n                otherElements: [],\n                /** @type {Record<string, any>} */\n                values: {},\n                spread: false,\n                insertType: arg2 ? \"spread\" : \"argument\",\n                insertLocation: arg2 ? arg2.range : arg1.range[1]\n              },\n              expressions = _ref2.expressions,\n              otherElements = _ref2.otherElements,\n              options = _ref2.values,\n              hasSpreadInOptions = _ref2.spread,\n              insertType = _ref2.insertType,\n              insertLocation = _ref2.insertLocation;\n            var _parser$parseCommentO = parser.parseCommentOptions(expr.range),\n              importOptions = _parser$parseCommentO.options,\n              commentErrors = _parser$parseCommentO.errors;\n            if (commentErrors) {\n              var _iterator2 = _createForOfIteratorHelper(commentErrors),\n                _step2;\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var e = _step2.value;\n                  var comment = e.comment;\n                  parser.state.module.addWarning(new CommentCompilationWarning(\"Compilation error while processing magic comment(-s): /*\".concat(comment.value, \"*/: \").concat(e.message), comment.loc));\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            }\n\n            /** @type {EntryOptions} */\n            var entryOptions = {};\n            if (importOptions) {\n              if (importOptions.webpackIgnore !== undefined) {\n                if (typeof importOptions.webpackIgnore !== \"boolean\") {\n                  parser.state.module.addWarning(new UnsupportedFeatureWarning(\"`webpackIgnore` expected a boolean, but received: \".concat(importOptions.webpackIgnore, \".\"), expr.loc));\n                } else {\n                  if (importOptions.webpackIgnore) {\n                    return false;\n                  }\n                }\n              }\n              if (importOptions.webpackEntryOptions !== undefined) {\n                if (typeof importOptions.webpackEntryOptions !== \"object\" || importOptions.webpackEntryOptions === null) {\n                  parser.state.module.addWarning(new UnsupportedFeatureWarning(\"`webpackEntryOptions` expected a object, but received: \".concat(importOptions.webpackEntryOptions, \".\"), expr.loc));\n                } else {\n                  Object.assign(entryOptions, importOptions.webpackEntryOptions);\n                }\n              }\n              if (importOptions.webpackChunkName !== undefined) {\n                if (typeof importOptions.webpackChunkName !== \"string\") {\n                  parser.state.module.addWarning(new UnsupportedFeatureWarning(\"`webpackChunkName` expected a string, but received: \".concat(importOptions.webpackChunkName, \".\"), expr.loc));\n                } else {\n                  entryOptions.name = importOptions.webpackChunkName;\n                }\n              }\n            }\n            if (!Object.prototype.hasOwnProperty.call(entryOptions, \"name\") && options && typeof options.name === \"string\") {\n              entryOptions.name = options.name;\n            }\n            if (entryOptions.runtime === undefined) {\n              var i = workerIndexMap.get(parser.state) || 0;\n              workerIndexMap.set(parser.state, i + 1);\n              var name = \"\".concat(cachedContextify(parser.state.module.identifier()), \"|\").concat(i);\n              var hash = createHash(compilation.outputOptions.hashFunction);\n              hash.update(name);\n              var digest = /** @type {string} */\n              hash.digest(compilation.outputOptions.hashDigest);\n              entryOptions.runtime = digest.slice(0, compilation.outputOptions.hashDigestLength);\n            }\n            var block = new AsyncDependenciesBlock({\n              name: entryOptions.name,\n              entryOptions: _objectSpread({\n                chunkLoading: _this._chunkLoading,\n                wasmLoading: _this._wasmLoading\n              }, entryOptions)\n            });\n            block.loc = expr.loc;\n            var dep = new WorkerDependency(url.string, range);\n            dep.loc = expr.loc;\n            block.addDependency(dep);\n            parser.state.module.addBlock(block);\n            if (compilation.outputOptions.trustedTypes) {\n              var _dep = new CreateScriptUrlDependency(expr.arguments[0].range);\n              _dep.loc = expr.loc;\n              parser.state.module.addDependency(_dep);\n            }\n            if (expressions.type) {\n              var _expr = expressions.type;\n              if (options.type !== false) {\n                var _dep2 = new ConstDependency(_this._module ? '\"module\"' : \"undefined\", _expr.range);\n                _dep2.loc = _expr.loc;\n                parser.state.module.addPresentationalDependency(_dep2);\n                expressions.type = undefined;\n              }\n            } else if (insertType === \"comma\") {\n              if (_this._module || hasSpreadInOptions) {\n                var _dep3 = new ConstDependency(\", type: \".concat(_this._module ? '\"module\"' : \"undefined\"), insertLocation);\n                _dep3.loc = expr.loc;\n                parser.state.module.addPresentationalDependency(_dep3);\n              }\n            } else if (insertType === \"spread\") {\n              var dep1 = new ConstDependency(\"Object.assign({}, \", insertLocation[0]);\n              var dep2 = new ConstDependency(\", { type: \".concat(_this._module ? '\"module\"' : \"undefined\", \" })\"), insertLocation[1]);\n              dep1.loc = expr.loc;\n              dep2.loc = expr.loc;\n              parser.state.module.addPresentationalDependency(dep1);\n              parser.state.module.addPresentationalDependency(dep2);\n            } else if (insertType === \"argument\") {\n              if (_this._module) {\n                var _dep4 = new ConstDependency(', { type: \"module\" }', insertLocation);\n                _dep4.loc = expr.loc;\n                parser.state.module.addPresentationalDependency(_dep4);\n              }\n            }\n            parser.walkExpression(expr.callee);\n            for (var _i = 0, _Object$keys = Object.keys(expressions); _i < _Object$keys.length; _i++) {\n              var key = _Object$keys[_i];\n              if (expressions[key]) parser.walkExpression(expressions[key]);\n            }\n            var _iterator3 = _createForOfIteratorHelper(otherElements),\n              _step3;\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var prop = _step3.value;\n                parser.walkProperty(prop);\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n            if (insertType === \"spread\") {\n              parser.walkExpression(arg2);\n            }\n            return true;\n          };\n          var processItem = function processItem(item) {\n            if (item.endsWith(\"()\")) {\n              parser.hooks.call.for(item.slice(0, -2)).tap(\"WorkerPlugin\", handleNewWorker);\n            } else {\n              var match = /^(.+?)(\\(\\))?\\s+from\\s+(.+)$/.exec(item);\n              if (match) {\n                var ids = match[1].split(\".\");\n                var call = match[2];\n                var source = match[3];\n                (call ? parser.hooks.call : parser.hooks.new).for(harmonySpecifierTag).tap(\"WorkerPlugin\", function (expr) {\n                  var settings = /** @type {HarmonySettings} */\n                  parser.currentTagData;\n                  if (!settings || settings.source !== source || !equals(settings.ids, ids)) {\n                    return;\n                  }\n                  return handleNewWorker(expr);\n                });\n              } else {\n                parser.hooks.new.for(item).tap(\"WorkerPlugin\", handleNewWorker);\n              }\n            }\n          };\n          var _iterator4 = _createForOfIteratorHelper(options),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var item = _step4.value;\n              if (item === \"...\") {\n                DEFAULT_SYNTAX.forEach(processItem);\n              } else processItem(item);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        };\n        normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"WorkerPlugin\", parserPlugin);\n        normalModuleFactory.hooks.parser.for(\"javascript/esm\").tap(\"WorkerPlugin\", parserPlugin);\n      });\n    }\n  }]);\n  return WorkerPlugin;\n}();\nmodule.exports = WorkerPlugin;","map":{"version":3,"names":["require","pathToFileURL","AsyncDependenciesBlock","CommentCompilationWarning","UnsupportedFeatureWarning","EnableChunkLoadingPlugin","equals","createHash","contextify","EnableWasmLoadingPlugin","ConstDependency","CreateScriptUrlDependency","harmonySpecifierTag","WorkerDependency","getUrl","module","resource","toString","DEFAULT_SYNTAX","workerIndexMap","WeakMap","WorkerPlugin","chunkLoading","wasmLoading","_chunkLoading","_wasmLoading","_module","compiler","apply","cachedContextify","bindContextCache","context","root","hooks","thisCompilation","tap","compilation","normalModuleFactory","dependencyFactories","set","dependencyTemplates","Template","parseModuleUrl","parser","expr","type","callee","arguments","length","arg1","arg2","evaluateExpression","isIdentifier","identifier","arg2Value","isString","string","startsWith","state","arg1Value","range","parseObjectExpression","values","expressions","otherElements","spread","properties","prop","method","computed","key","name","value","shorthand","endsWith","isCompileTimeValue","asCompileTimeValue","push","insertType","insertLocation","parserPlugin","parserOptions","worker","options","Array","isArray","handleNewWorker","parsedUrl","url","hasSpreadInOptions","parseCommentOptions","importOptions","commentErrors","errors","e","comment","addWarning","message","loc","entryOptions","webpackIgnore","undefined","webpackEntryOptions","Object","assign","webpackChunkName","prototype","hasOwnProperty","call","runtime","i","get","hash","outputOptions","hashFunction","update","digest","hashDigest","slice","hashDigestLength","block","dep","addDependency","addBlock","trustedTypes","addPresentationalDependency","dep1","dep2","walkExpression","keys","walkProperty","processItem","item","for","match","exec","ids","split","source","new","settings","currentTagData","forEach","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/dependencies/WorkerPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { pathToFileURL } = require(\"url\");\nconst AsyncDependenciesBlock = require(\"../AsyncDependenciesBlock\");\nconst CommentCompilationWarning = require(\"../CommentCompilationWarning\");\nconst UnsupportedFeatureWarning = require(\"../UnsupportedFeatureWarning\");\nconst EnableChunkLoadingPlugin = require(\"../javascript/EnableChunkLoadingPlugin\");\nconst { equals } = require(\"../util/ArrayHelpers\");\nconst createHash = require(\"../util/createHash\");\nconst { contextify } = require(\"../util/identifier\");\nconst EnableWasmLoadingPlugin = require(\"../wasm/EnableWasmLoadingPlugin\");\nconst ConstDependency = require(\"./ConstDependency\");\nconst CreateScriptUrlDependency = require(\"./CreateScriptUrlDependency\");\nconst {\n\tharmonySpecifierTag\n} = require(\"./HarmonyImportDependencyParserPlugin\");\nconst WorkerDependency = require(\"./WorkerDependency\");\n\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"estree\").ObjectExpression} ObjectExpression */\n/** @typedef {import(\"estree\").Pattern} Pattern */\n/** @typedef {import(\"estree\").Property} Property */\n/** @typedef {import(\"estree\").SpreadElement} SpreadElement */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Entrypoint\").EntryOptions} EntryOptions */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"./HarmonyImportDependencyParserPlugin\").HarmonySettings} HarmonySettings */\n\nconst getUrl = module => {\n\treturn pathToFileURL(module.resource).toString();\n};\n\nconst DEFAULT_SYNTAX = [\n\t\"Worker\",\n\t\"SharedWorker\",\n\t\"navigator.serviceWorker.register()\",\n\t\"Worker from worker_threads\"\n];\n\n/** @type {WeakMap<ParserState, number>} */\nconst workerIndexMap = new WeakMap();\n\nclass WorkerPlugin {\n\tconstructor(chunkLoading, wasmLoading, module) {\n\t\tthis._chunkLoading = chunkLoading;\n\t\tthis._wasmLoading = wasmLoading;\n\t\tthis._module = module;\n\t}\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tif (this._chunkLoading) {\n\t\t\tnew EnableChunkLoadingPlugin(this._chunkLoading).apply(compiler);\n\t\t}\n\t\tif (this._wasmLoading) {\n\t\t\tnew EnableWasmLoadingPlugin(this._wasmLoading).apply(compiler);\n\t\t}\n\t\tconst cachedContextify = contextify.bindContextCache(\n\t\t\tcompiler.context,\n\t\t\tcompiler.root\n\t\t);\n\t\tcompiler.hooks.thisCompilation.tap(\n\t\t\t\"WorkerPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tWorkerDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tWorkerDependency,\n\t\t\t\t\tnew WorkerDependency.Template()\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tCreateScriptUrlDependency,\n\t\t\t\t\tnew CreateScriptUrlDependency.Template()\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * @param {JavascriptParser} parser the parser\n\t\t\t\t * @param {Expression} expr expression\n\t\t\t\t * @returns {[BasicEvaluatedExpression, [number, number]]} parsed\n\t\t\t\t */\n\t\t\t\tconst parseModuleUrl = (parser, expr) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\texpr.type !== \"NewExpression\" ||\n\t\t\t\t\t\texpr.callee.type === \"Super\" ||\n\t\t\t\t\t\texpr.arguments.length !== 2\n\t\t\t\t\t)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tconst [arg1, arg2] = expr.arguments;\n\t\t\t\t\tif (arg1.type === \"SpreadElement\") return;\n\t\t\t\t\tif (arg2.type === \"SpreadElement\") return;\n\t\t\t\t\tconst callee = parser.evaluateExpression(expr.callee);\n\t\t\t\t\tif (!callee.isIdentifier() || callee.identifier !== \"URL\") return;\n\t\t\t\t\tconst arg2Value = parser.evaluateExpression(arg2);\n\t\t\t\t\tif (\n\t\t\t\t\t\t!arg2Value.isString() ||\n\t\t\t\t\t\t!arg2Value.string.startsWith(\"file://\") ||\n\t\t\t\t\t\targ2Value.string !== getUrl(parser.state.module)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst arg1Value = parser.evaluateExpression(arg1);\n\t\t\t\t\treturn [arg1Value, [arg1.range[0], arg2.range[1]]];\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * @param {JavascriptParser} parser the parser\n\t\t\t\t * @param {ObjectExpression} expr expression\n\t\t\t\t * @returns {{ expressions: Record<string, Expression | Pattern>, otherElements: (Property | SpreadElement)[], values: Record<string, any>, spread: boolean, insertType: \"comma\" | \"single\", insertLocation: number }} parsed object\n\t\t\t\t */\n\t\t\t\tconst parseObjectExpression = (parser, expr) => {\n\t\t\t\t\t/** @type {Record<string, any>} */\n\t\t\t\t\tconst values = {};\n\t\t\t\t\t/** @type {Record<string, Expression | Pattern>} */\n\t\t\t\t\tconst expressions = {};\n\t\t\t\t\t/** @type {(Property | SpreadElement)[]} */\n\t\t\t\t\tconst otherElements = [];\n\t\t\t\t\tlet spread = false;\n\t\t\t\t\tfor (const prop of expr.properties) {\n\t\t\t\t\t\tif (prop.type === \"SpreadElement\") {\n\t\t\t\t\t\t\tspread = true;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tprop.type === \"Property\" &&\n\t\t\t\t\t\t\t!prop.method &&\n\t\t\t\t\t\t\t!prop.computed &&\n\t\t\t\t\t\t\tprop.key.type === \"Identifier\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\texpressions[prop.key.name] = prop.value;\n\t\t\t\t\t\t\tif (!prop.shorthand && !prop.value.type.endsWith(\"Pattern\")) {\n\t\t\t\t\t\t\t\tconst value = parser.evaluateExpression(\n\t\t\t\t\t\t\t\t\t/** @type {Expression} */ (prop.value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (value.isCompileTimeValue())\n\t\t\t\t\t\t\t\t\tvalues[prop.key.name] = value.asCompileTimeValue();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\totherElements.push(prop);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst insertType = expr.properties.length > 0 ? \"comma\" : \"single\";\n\t\t\t\t\tconst insertLocation =\n\t\t\t\t\t\texpr.properties[expr.properties.length - 1].range[1];\n\t\t\t\t\treturn {\n\t\t\t\t\t\texpressions,\n\t\t\t\t\t\totherElements,\n\t\t\t\t\t\tvalues,\n\t\t\t\t\t\tspread,\n\t\t\t\t\t\tinsertType,\n\t\t\t\t\t\tinsertLocation\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * @param {JavascriptParser} parser the parser\n\t\t\t\t * @param {object} parserOptions options\n\t\t\t\t */\n\t\t\t\tconst parserPlugin = (parser, parserOptions) => {\n\t\t\t\t\tif (parserOptions.worker === false) return;\n\t\t\t\t\tconst options = !Array.isArray(parserOptions.worker)\n\t\t\t\t\t\t? [\"...\"]\n\t\t\t\t\t\t: parserOptions.worker;\n\t\t\t\t\tconst handleNewWorker = expr => {\n\t\t\t\t\t\tif (expr.arguments.length === 0 || expr.arguments.length > 2)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tconst [arg1, arg2] = expr.arguments;\n\t\t\t\t\t\tif (arg1.type === \"SpreadElement\") return;\n\t\t\t\t\t\tif (arg2 && arg2.type === \"SpreadElement\") return;\n\t\t\t\t\t\tconst parsedUrl = parseModuleUrl(parser, arg1);\n\t\t\t\t\t\tif (!parsedUrl) return;\n\t\t\t\t\t\tconst [url, range] = parsedUrl;\n\t\t\t\t\t\tif (!url.isString()) return;\n\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\texpressions,\n\t\t\t\t\t\t\totherElements,\n\t\t\t\t\t\t\tvalues: options,\n\t\t\t\t\t\t\tspread: hasSpreadInOptions,\n\t\t\t\t\t\t\tinsertType,\n\t\t\t\t\t\t\tinsertLocation\n\t\t\t\t\t\t} = arg2 && arg2.type === \"ObjectExpression\"\n\t\t\t\t\t\t\t? parseObjectExpression(parser, arg2)\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t/** @type {Record<string, Expression | Pattern>} */\n\t\t\t\t\t\t\t\t\texpressions: {},\n\t\t\t\t\t\t\t\t\totherElements: [],\n\t\t\t\t\t\t\t\t\t/** @type {Record<string, any>} */\n\t\t\t\t\t\t\t\t\tvalues: {},\n\t\t\t\t\t\t\t\t\tspread: false,\n\t\t\t\t\t\t\t\t\tinsertType: arg2 ? \"spread\" : \"argument\",\n\t\t\t\t\t\t\t\t\tinsertLocation: arg2 ? arg2.range : arg1.range[1]\n\t\t\t\t\t\t\t  };\n\t\t\t\t\t\tconst { options: importOptions, errors: commentErrors } =\n\t\t\t\t\t\t\tparser.parseCommentOptions(expr.range);\n\n\t\t\t\t\t\tif (commentErrors) {\n\t\t\t\t\t\t\tfor (const e of commentErrors) {\n\t\t\t\t\t\t\t\tconst { comment } = e;\n\t\t\t\t\t\t\t\tparser.state.module.addWarning(\n\t\t\t\t\t\t\t\t\tnew CommentCompilationWarning(\n\t\t\t\t\t\t\t\t\t\t`Compilation error while processing magic comment(-s): /*${comment.value}*/: ${e.message}`,\n\t\t\t\t\t\t\t\t\t\tcomment.loc\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/** @type {EntryOptions} */\n\t\t\t\t\t\tlet entryOptions = {};\n\n\t\t\t\t\t\tif (importOptions) {\n\t\t\t\t\t\t\tif (importOptions.webpackIgnore !== undefined) {\n\t\t\t\t\t\t\t\tif (typeof importOptions.webpackIgnore !== \"boolean\") {\n\t\t\t\t\t\t\t\t\tparser.state.module.addWarning(\n\t\t\t\t\t\t\t\t\t\tnew UnsupportedFeatureWarning(\n\t\t\t\t\t\t\t\t\t\t\t`\\`webpackIgnore\\` expected a boolean, but received: ${importOptions.webpackIgnore}.`,\n\t\t\t\t\t\t\t\t\t\t\texpr.loc\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (importOptions.webpackIgnore) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (importOptions.webpackEntryOptions !== undefined) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\ttypeof importOptions.webpackEntryOptions !== \"object\" ||\n\t\t\t\t\t\t\t\t\timportOptions.webpackEntryOptions === null\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tparser.state.module.addWarning(\n\t\t\t\t\t\t\t\t\t\tnew UnsupportedFeatureWarning(\n\t\t\t\t\t\t\t\t\t\t\t`\\`webpackEntryOptions\\` expected a object, but received: ${importOptions.webpackEntryOptions}.`,\n\t\t\t\t\t\t\t\t\t\t\texpr.loc\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tObject.assign(\n\t\t\t\t\t\t\t\t\t\tentryOptions,\n\t\t\t\t\t\t\t\t\t\timportOptions.webpackEntryOptions\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (importOptions.webpackChunkName !== undefined) {\n\t\t\t\t\t\t\t\tif (typeof importOptions.webpackChunkName !== \"string\") {\n\t\t\t\t\t\t\t\t\tparser.state.module.addWarning(\n\t\t\t\t\t\t\t\t\t\tnew UnsupportedFeatureWarning(\n\t\t\t\t\t\t\t\t\t\t\t`\\`webpackChunkName\\` expected a string, but received: ${importOptions.webpackChunkName}.`,\n\t\t\t\t\t\t\t\t\t\t\texpr.loc\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tentryOptions.name = importOptions.webpackChunkName;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!Object.prototype.hasOwnProperty.call(entryOptions, \"name\") &&\n\t\t\t\t\t\t\toptions &&\n\t\t\t\t\t\t\ttypeof options.name === \"string\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tentryOptions.name = options.name;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (entryOptions.runtime === undefined) {\n\t\t\t\t\t\t\tlet i = workerIndexMap.get(parser.state) || 0;\n\t\t\t\t\t\t\tworkerIndexMap.set(parser.state, i + 1);\n\t\t\t\t\t\t\tlet name = `${cachedContextify(\n\t\t\t\t\t\t\t\tparser.state.module.identifier()\n\t\t\t\t\t\t\t)}|${i}`;\n\t\t\t\t\t\t\tconst hash = createHash(compilation.outputOptions.hashFunction);\n\t\t\t\t\t\t\thash.update(name);\n\t\t\t\t\t\t\tconst digest = /** @type {string} */ (\n\t\t\t\t\t\t\t\thash.digest(compilation.outputOptions.hashDigest)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tentryOptions.runtime = digest.slice(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tcompilation.outputOptions.hashDigestLength\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst block = new AsyncDependenciesBlock({\n\t\t\t\t\t\t\tname: entryOptions.name,\n\t\t\t\t\t\t\tentryOptions: {\n\t\t\t\t\t\t\t\tchunkLoading: this._chunkLoading,\n\t\t\t\t\t\t\t\twasmLoading: this._wasmLoading,\n\t\t\t\t\t\t\t\t...entryOptions\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tblock.loc = expr.loc;\n\t\t\t\t\t\tconst dep = new WorkerDependency(url.string, range);\n\t\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\t\tblock.addDependency(dep);\n\t\t\t\t\t\tparser.state.module.addBlock(block);\n\n\t\t\t\t\t\tif (compilation.outputOptions.trustedTypes) {\n\t\t\t\t\t\t\tconst dep = new CreateScriptUrlDependency(\n\t\t\t\t\t\t\t\texpr.arguments[0].range\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\t\t\tparser.state.module.addDependency(dep);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (expressions.type) {\n\t\t\t\t\t\t\tconst expr = expressions.type;\n\t\t\t\t\t\t\tif (options.type !== false) {\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\tthis._module ? '\"module\"' : \"undefined\",\n\t\t\t\t\t\t\t\t\texpr.range\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t\texpressions.type = undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (insertType === \"comma\") {\n\t\t\t\t\t\t\tif (this._module || hasSpreadInOptions) {\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t`, type: ${this._module ? '\"module\"' : \"undefined\"}`,\n\t\t\t\t\t\t\t\t\tinsertLocation\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (insertType === \"spread\") {\n\t\t\t\t\t\t\tconst dep1 = new ConstDependency(\n\t\t\t\t\t\t\t\t\"Object.assign({}, \",\n\t\t\t\t\t\t\t\tinsertLocation[0]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst dep2 = new ConstDependency(\n\t\t\t\t\t\t\t\t`, { type: ${this._module ? '\"module\"' : \"undefined\"} })`,\n\t\t\t\t\t\t\t\tinsertLocation[1]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdep1.loc = expr.loc;\n\t\t\t\t\t\t\tdep2.loc = expr.loc;\n\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep1);\n\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep2);\n\t\t\t\t\t\t} else if (insertType === \"argument\") {\n\t\t\t\t\t\t\tif (this._module) {\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t', { type: \"module\" }',\n\t\t\t\t\t\t\t\t\tinsertLocation\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\t\t\t\tparser.state.module.addPresentationalDependency(dep);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparser.walkExpression(expr.callee);\n\t\t\t\t\t\tfor (const key of Object.keys(expressions)) {\n\t\t\t\t\t\t\tif (expressions[key]) parser.walkExpression(expressions[key]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const prop of otherElements) {\n\t\t\t\t\t\t\tparser.walkProperty(prop);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (insertType === \"spread\") {\n\t\t\t\t\t\t\tparser.walkExpression(arg2);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t};\n\t\t\t\t\tconst processItem = item => {\n\t\t\t\t\t\tif (item.endsWith(\"()\")) {\n\t\t\t\t\t\t\tparser.hooks.call\n\t\t\t\t\t\t\t\t.for(item.slice(0, -2))\n\t\t\t\t\t\t\t\t.tap(\"WorkerPlugin\", handleNewWorker);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst match = /^(.+?)(\\(\\))?\\s+from\\s+(.+)$/.exec(item);\n\t\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\t\tconst ids = match[1].split(\".\");\n\t\t\t\t\t\t\t\tconst call = match[2];\n\t\t\t\t\t\t\t\tconst source = match[3];\n\t\t\t\t\t\t\t\t(call ? parser.hooks.call : parser.hooks.new)\n\t\t\t\t\t\t\t\t\t.for(harmonySpecifierTag)\n\t\t\t\t\t\t\t\t\t.tap(\"WorkerPlugin\", expr => {\n\t\t\t\t\t\t\t\t\t\tconst settings = /** @type {HarmonySettings} */ (\n\t\t\t\t\t\t\t\t\t\t\tparser.currentTagData\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!settings ||\n\t\t\t\t\t\t\t\t\t\t\tsettings.source !== source ||\n\t\t\t\t\t\t\t\t\t\t\t!equals(settings.ids, ids)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn handleNewWorker(expr);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparser.hooks.new.for(item).tap(\"WorkerPlugin\", handleNewWorker);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tfor (const item of options) {\n\t\t\t\t\t\tif (item === \"...\") {\n\t\t\t\t\t\t\tDEFAULT_SYNTAX.forEach(processItem);\n\t\t\t\t\t\t} else processItem(item);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/auto\")\n\t\t\t\t\t.tap(\"WorkerPlugin\", parserPlugin);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/esm\")\n\t\t\t\t\t.tap(\"WorkerPlugin\", parserPlugin);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = WorkerPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}