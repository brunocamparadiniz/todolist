{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _asyncToGenerator = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar FileSystemInfo = require(\"../FileSystemInfo\");\nvar ProgressPlugin = require(\"../ProgressPlugin\");\nvar _require = require(\"../SizeFormatHelpers\"),\n  formatSize = _require.formatSize;\nvar SerializerMiddleware = require(\"../serialization/SerializerMiddleware\");\nvar LazySet = require(\"../util/LazySet\");\nvar makeSerializable = require(\"../util/makeSerializable\");\nvar memoize = require(\"../util/memoize\");\nvar _require2 = require(\"../util/serialization\"),\n  createFileSerializer = _require2.createFileSerializer,\n  NOT_SERIALIZABLE = _require2.NOT_SERIALIZABLE;\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").SnapshotOptions} SnapshotOptions */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n/** @typedef {import(\"../logging/Logger\").Logger} Logger */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\nvar PackContainer = /*#__PURE__*/function () {\n  /**\n   * @param {Object} data stored data\n   * @param {string} version version identifier\n   * @param {Snapshot} buildSnapshot snapshot of all build dependencies\n   * @param {Set<string>} buildDependencies list of all unresolved build dependencies captured\n   * @param {Map<string, string | false>} resolveResults result of the resolved build dependencies\n   * @param {Snapshot} resolveBuildDependenciesSnapshot snapshot of the dependencies of the build dependencies resolving\n   */\n  function PackContainer(data, version, buildSnapshot, buildDependencies, resolveResults, resolveBuildDependenciesSnapshot) {\n    _classCallCheck(this, PackContainer);\n    this.data = data;\n    this.version = version;\n    this.buildSnapshot = buildSnapshot;\n    this.buildDependencies = buildDependencies;\n    this.resolveResults = resolveResults;\n    this.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;\n  }\n  _createClass(PackContainer, [{\n    key: \"serialize\",\n    value: function serialize(_ref) {\n      var write = _ref.write,\n        writeLazy = _ref.writeLazy;\n      write(this.version);\n      write(this.buildSnapshot);\n      write(this.buildDependencies);\n      write(this.resolveResults);\n      write(this.resolveBuildDependenciesSnapshot);\n      writeLazy(this.data);\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(_ref2) {\n      var read = _ref2.read;\n      this.version = read();\n      this.buildSnapshot = read();\n      this.buildDependencies = read();\n      this.resolveResults = read();\n      this.resolveBuildDependenciesSnapshot = read();\n      this.data = read();\n    }\n  }]);\n  return PackContainer;\n}();\nmakeSerializable(PackContainer, \"webpack/lib/cache/PackFileCacheStrategy\", \"PackContainer\");\nvar MIN_CONTENT_SIZE = 1024 * 1024; // 1 MB\nvar CONTENT_COUNT_TO_MERGE = 10;\nvar MIN_ITEMS_IN_FRESH_PACK = 100;\nvar MAX_ITEMS_IN_FRESH_PACK = 50000;\nvar MAX_TIME_IN_FRESH_PACK = 1 * 60 * 1000; // 1 min\nvar PackItemInfo = /*#__PURE__*/_createClass(\n/**\n * @param {string} identifier identifier of item\n * @param {string | null} etag etag of item\n * @param {any} value fresh value of item\n */\nfunction PackItemInfo(identifier, etag, value) {\n  _classCallCheck(this, PackItemInfo);\n  this.identifier = identifier;\n  this.etag = etag;\n  this.location = -1;\n  this.lastAccess = Date.now();\n  this.freshValue = value;\n});\nvar Pack = /*#__PURE__*/function () {\n  function Pack(logger, maxAge) {\n    _classCallCheck(this, Pack);\n    /** @type {Map<string, PackItemInfo>} */\n    this.itemInfo = new Map();\n    /** @type {string[]} */\n    this.requests = [];\n    this.requestsTimeout = undefined;\n    /** @type {Map<string, PackItemInfo>} */\n    this.freshContent = new Map();\n    /** @type {(undefined | PackContent)[]} */\n    this.content = [];\n    this.invalid = false;\n    this.logger = logger;\n    this.maxAge = maxAge;\n  }\n  _createClass(Pack, [{\n    key: \"_addRequest\",\n    value: function _addRequest(identifier) {\n      var _this = this;\n      this.requests.push(identifier);\n      if (this.requestsTimeout === undefined) {\n        this.requestsTimeout = setTimeout(function () {\n          _this.requests.push(undefined);\n          _this.requestsTimeout = undefined;\n        }, MAX_TIME_IN_FRESH_PACK);\n        if (this.requestsTimeout.unref) this.requestsTimeout.unref();\n      }\n    }\n  }, {\n    key: \"stopCapturingRequests\",\n    value: function stopCapturingRequests() {\n      if (this.requestsTimeout !== undefined) {\n        clearTimeout(this.requestsTimeout);\n        this.requestsTimeout = undefined;\n      }\n    }\n\n    /**\n     * @param {string} identifier unique name for the resource\n     * @param {string | null} etag etag of the resource\n     * @returns {any} cached content\n     */\n  }, {\n    key: \"get\",\n    value: function get(identifier, etag) {\n      var info = this.itemInfo.get(identifier);\n      this._addRequest(identifier);\n      if (info === undefined) {\n        return undefined;\n      }\n      if (info.etag !== etag) return null;\n      info.lastAccess = Date.now();\n      var loc = info.location;\n      if (loc === -1) {\n        return info.freshValue;\n      } else {\n        if (!this.content[loc]) {\n          return undefined;\n        }\n        return this.content[loc].get(identifier);\n      }\n    }\n\n    /**\n     * @param {string} identifier unique name for the resource\n     * @param {string | null} etag etag of the resource\n     * @param {any} data cached content\n     * @returns {void}\n     */\n  }, {\n    key: \"set\",\n    value: function set(identifier, etag, data) {\n      if (!this.invalid) {\n        this.invalid = true;\n        this.logger.log(\"Pack got invalid because of write to: \".concat(identifier));\n      }\n      var info = this.itemInfo.get(identifier);\n      if (info === undefined) {\n        var newInfo = new PackItemInfo(identifier, etag, data);\n        this.itemInfo.set(identifier, newInfo);\n        this._addRequest(identifier);\n        this.freshContent.set(identifier, newInfo);\n      } else {\n        var loc = info.location;\n        if (loc >= 0) {\n          this._addRequest(identifier);\n          this.freshContent.set(identifier, info);\n          var content = this.content[loc];\n          content.delete(identifier);\n          if (content.items.size === 0) {\n            this.content[loc] = undefined;\n            this.logger.debug(\"Pack %d got empty and is removed\", loc);\n          }\n        }\n        info.freshValue = data;\n        info.lastAccess = Date.now();\n        info.etag = etag;\n        info.location = -1;\n      }\n    }\n  }, {\n    key: \"getContentStats\",\n    value: function getContentStats() {\n      var count = 0;\n      var size = 0;\n      var _iterator = _createForOfIteratorHelper(this.content),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var content = _step.value;\n          if (content !== undefined) {\n            count++;\n            var s = content.getSize();\n            if (s > 0) {\n              size += s;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return {\n        count: count,\n        size: size\n      };\n    }\n\n    /**\n     * @returns {number} new location of data entries\n     */\n  }, {\n    key: \"_findLocation\",\n    value: function _findLocation() {\n      var i;\n      for (i = 0; i < this.content.length && this.content[i] !== undefined; i++);\n      return i;\n    }\n  }, {\n    key: \"_gcAndUpdateLocation\",\n    value: function _gcAndUpdateLocation(items, usedItems, newLoc) {\n      var count = 0;\n      var lastGC;\n      var now = Date.now();\n      var _iterator2 = _createForOfIteratorHelper(items),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var identifier = _step2.value;\n          var info = this.itemInfo.get(identifier);\n          if (now - info.lastAccess > this.maxAge) {\n            this.itemInfo.delete(identifier);\n            items.delete(identifier);\n            usedItems.delete(identifier);\n            count++;\n            lastGC = identifier;\n          } else {\n            info.location = newLoc;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      if (count > 0) {\n        this.logger.log(\"Garbage Collected %d old items at pack %d (%d items remaining) e. g. %s\", count, newLoc, items.size, lastGC);\n      }\n    }\n  }, {\n    key: \"_persistFreshContent\",\n    value: function _persistFreshContent() {\n      var _this2 = this;\n      var itemsCount = this.freshContent.size;\n      if (itemsCount > 0) {\n        var packCount = Math.ceil(itemsCount / MAX_ITEMS_IN_FRESH_PACK);\n        var itemsPerPack = Math.ceil(itemsCount / packCount);\n        var packs = [];\n        var i = 0;\n        var ignoreNextTimeTick = false;\n        var createNextPack = function createNextPack() {\n          var loc = _this2._findLocation();\n          _this2.content[loc] = null; // reserve\n          var pack = {\n            /** @type {Set<string>} */\n            items: new Set(),\n            /** @type {Map<string, any>} */\n            map: new Map(),\n            loc: loc\n          };\n          packs.push(pack);\n          return pack;\n        };\n        var pack = createNextPack();\n        if (this.requestsTimeout !== undefined) clearTimeout(this.requestsTimeout);\n        var _iterator3 = _createForOfIteratorHelper(this.requests),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var identifier = _step3.value;\n            if (identifier === undefined) {\n              if (ignoreNextTimeTick) {\n                ignoreNextTimeTick = false;\n              } else if (pack.items.size >= MIN_ITEMS_IN_FRESH_PACK) {\n                i = 0;\n                pack = createNextPack();\n              }\n              continue;\n            }\n            var info = this.freshContent.get(identifier);\n            if (info === undefined) continue;\n            pack.items.add(identifier);\n            pack.map.set(identifier, info.freshValue);\n            info.location = pack.loc;\n            info.freshValue = undefined;\n            this.freshContent.delete(identifier);\n            if (++i > itemsPerPack) {\n              i = 0;\n              pack = createNextPack();\n              ignoreNextTimeTick = true;\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        this.requests.length = 0;\n        for (var _i = 0, _packs = packs; _i < _packs.length; _i++) {\n          var _pack = _packs[_i];\n          this.content[_pack.loc] = new PackContent(_pack.items, new Set(_pack.items), new PackContentItems(_pack.map));\n        }\n        this.logger.log(\"\".concat(itemsCount, \" fresh items in cache put into pack \").concat(packs.length > 1 ? packs.map(function (pack) {\n          return \"\".concat(pack.loc, \" (\").concat(pack.items.size, \" items)\");\n        }).join(\", \") : packs[0].loc));\n      }\n    }\n\n    /**\n     * Merges small content files to a single content file\n     */\n  }, {\n    key: \"_optimizeSmallContent\",\n    value: function _optimizeSmallContent() {\n      // 1. Find all small content files\n      // Treat unused content files separately to avoid\n      // a merge-split cycle\n      /** @type {number[]} */\n      var smallUsedContents = [];\n      /** @type {number} */\n      var smallUsedContentSize = 0;\n      /** @type {number[]} */\n      var smallUnusedContents = [];\n      /** @type {number} */\n      var smallUnusedContentSize = 0;\n      for (var i = 0; i < this.content.length; i++) {\n        var content = this.content[i];\n        if (content === undefined) continue;\n        if (content.outdated) continue;\n        var size = content.getSize();\n        if (size < 0 || size > MIN_CONTENT_SIZE) continue;\n        if (content.used.size > 0) {\n          smallUsedContents.push(i);\n          smallUsedContentSize += size;\n        } else {\n          smallUnusedContents.push(i);\n          smallUnusedContentSize += size;\n        }\n      }\n\n      // 2. Check if minimum number is reached\n      var mergedIndices;\n      if (smallUsedContents.length >= CONTENT_COUNT_TO_MERGE || smallUsedContentSize > MIN_CONTENT_SIZE) {\n        mergedIndices = smallUsedContents;\n      } else if (smallUnusedContents.length >= CONTENT_COUNT_TO_MERGE || smallUnusedContentSize > MIN_CONTENT_SIZE) {\n        mergedIndices = smallUnusedContents;\n      } else return;\n      var mergedContent = [];\n\n      // 3. Remove old content entries\n      var _iterator4 = _createForOfIteratorHelper(mergedIndices),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _i3 = _step4.value;\n          mergedContent.push(this.content[_i3]);\n          this.content[_i3] = undefined;\n        }\n\n        // 4. Determine merged items\n        /** @type {Set<string>} */\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      var mergedItems = new Set();\n      /** @type {Set<string>} */\n      var mergedUsedItems = new Set();\n      /** @type {(function(Map<string, any>): Promise)[]} */\n      var addToMergedMap = [];\n      var _loop = function _loop() {\n        var content = _mergedContent[_i2];\n        var _iterator5 = _createForOfIteratorHelper(content.items),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var identifier = _step5.value;\n            mergedItems.add(identifier);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n        var _iterator6 = _createForOfIteratorHelper(content.used),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var _identifier = _step6.value;\n            mergedUsedItems.add(_identifier);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n        addToMergedMap.push( /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(map) {\n            var _iterator7, _step7, _step7$value, identifier, value;\n            return _regeneratorRuntime().wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return content.unpack(\"it should be merged with other small pack contents\");\n                case 2:\n                  _iterator7 = _createForOfIteratorHelper(content.content);\n                  try {\n                    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                      _step7$value = _slicedToArray(_step7.value, 2), identifier = _step7$value[0], value = _step7$value[1];\n                      map.set(identifier, value);\n                    }\n                  } catch (err) {\n                    _iterator7.e(err);\n                  } finally {\n                    _iterator7.f();\n                  }\n                case 4:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          }));\n          return function (_x) {\n            return _ref3.apply(this, arguments);\n          };\n        }());\n      };\n      for (var _i2 = 0, _mergedContent = mergedContent; _i2 < _mergedContent.length; _i2++) {\n        _loop();\n      }\n\n      // 5. GC and update location of merged items\n      var newLoc = this._findLocation();\n      this._gcAndUpdateLocation(mergedItems, mergedUsedItems, newLoc);\n\n      // 6. If not empty, store content somewhere\n      if (mergedItems.size > 0) {\n        this.content[newLoc] = new PackContent(mergedItems, mergedUsedItems, memoize( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n          var map;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) switch (_context2.prev = _context2.next) {\n              case 0:\n                /** @type {Map<string, any>} */\n                map = new Map();\n                _context2.next = 3;\n                return Promise.all(addToMergedMap.map(function (fn) {\n                  return fn(map);\n                }));\n              case 3:\n                return _context2.abrupt(\"return\", new PackContentItems(map));\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }, _callee2);\n        }))));\n        this.logger.log(\"Merged %d small files with %d cache items into pack %d\", mergedContent.length, mergedItems.size, newLoc);\n      }\n    }\n\n    /**\n     * Split large content files with used and unused items\n     * into two parts to separate used from unused items\n     */\n  }, {\n    key: \"_optimizeUnusedContent\",\n    value: function _optimizeUnusedContent() {\n      var _this3 = this;\n      var _loop2 = function _loop2() {\n        var content = _this3.content[i];\n        if (content === undefined) return \"continue\";\n        var size = content.getSize();\n        if (size < MIN_CONTENT_SIZE) return \"continue\";\n        var used = content.used.size;\n        var total = content.items.size;\n        if (used > 0 && used < total) {\n          // 2. Remove this content\n          _this3.content[i] = undefined;\n\n          // 3. Determine items for the used content file\n          var usedItems = new Set(content.used);\n          var newLoc = _this3._findLocation();\n          _this3._gcAndUpdateLocation(usedItems, usedItems, newLoc);\n\n          // 4. Create content file for used items\n          if (usedItems.size > 0) {\n            _this3.content[newLoc] = new PackContent(usedItems, new Set(usedItems), /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n              var map, _iterator8, _step8, identifier;\n              return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                while (1) switch (_context3.prev = _context3.next) {\n                  case 0:\n                    _context3.next = 2;\n                    return content.unpack(\"it should be splitted into used and unused items\");\n                  case 2:\n                    map = new Map();\n                    _iterator8 = _createForOfIteratorHelper(usedItems);\n                    try {\n                      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                        identifier = _step8.value;\n                        map.set(identifier, content.content.get(identifier));\n                      }\n                    } catch (err) {\n                      _iterator8.e(err);\n                    } finally {\n                      _iterator8.f();\n                    }\n                    return _context3.abrupt(\"return\", new PackContentItems(map));\n                  case 6:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }, _callee3);\n            })));\n          }\n\n          // 5. Determine items for the unused content file\n          var unusedItems = new Set(content.items);\n          var usedOfUnusedItems = new Set();\n          var _iterator9 = _createForOfIteratorHelper(usedItems),\n            _step9;\n          try {\n            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n              var identifier = _step9.value;\n              unusedItems.delete(identifier);\n            }\n          } catch (err) {\n            _iterator9.e(err);\n          } finally {\n            _iterator9.f();\n          }\n          var newUnusedLoc = _this3._findLocation();\n          _this3._gcAndUpdateLocation(unusedItems, usedOfUnusedItems, newUnusedLoc);\n\n          // 6. Create content file for unused items\n          if (unusedItems.size > 0) {\n            _this3.content[newUnusedLoc] = new PackContent(unusedItems, usedOfUnusedItems, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n              var map, _iterator10, _step10, identifier;\n              return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                while (1) switch (_context4.prev = _context4.next) {\n                  case 0:\n                    _context4.next = 2;\n                    return content.unpack(\"it should be splitted into used and unused items\");\n                  case 2:\n                    map = new Map();\n                    _iterator10 = _createForOfIteratorHelper(unusedItems);\n                    try {\n                      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                        identifier = _step10.value;\n                        map.set(identifier, content.content.get(identifier));\n                      }\n                    } catch (err) {\n                      _iterator10.e(err);\n                    } finally {\n                      _iterator10.f();\n                    }\n                    return _context4.abrupt(\"return\", new PackContentItems(map));\n                  case 6:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }, _callee4);\n            })));\n          }\n          _this3.logger.log(\"Split pack %d into pack %d with %d used items and pack %d with %d unused items\", i, newLoc, usedItems.size, newUnusedLoc, unusedItems.size);\n\n          // optimizing only one of them is good enough and\n          // reduces the amount of serialization needed\n          return {\n            v: void 0\n          };\n        }\n      };\n      // 1. Find a large content file with used and unused items\n      for (var i = 0; i < this.content.length; i++) {\n        var _ret = _loop2();\n        if (_ret === \"continue\") continue;\n        if (typeof _ret === \"object\") return _ret.v;\n      }\n    }\n\n    /**\n     * Find the content with the oldest item and run GC on that.\n     * Only runs for one content to avoid large invalidation.\n     */\n  }, {\n    key: \"_gcOldestContent\",\n    value: function _gcOldestContent() {\n      /** @type {PackItemInfo} */\n      var oldest = undefined;\n      var _iterator11 = _createForOfIteratorHelper(this.itemInfo.values()),\n        _step11;\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var info = _step11.value;\n          if (oldest === undefined || info.lastAccess < oldest.lastAccess) {\n            oldest = info;\n          }\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n      if (Date.now() - oldest.lastAccess > this.maxAge) {\n        var loc = oldest.location;\n        if (loc < 0) return;\n        var content = this.content[loc];\n        var items = new Set(content.items);\n        var usedItems = new Set(content.used);\n        this._gcAndUpdateLocation(items, usedItems, loc);\n        this.content[loc] = items.size > 0 ? new PackContent(items, usedItems, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n          var map, _iterator12, _step12, identifier;\n          return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n            while (1) switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return content.unpack(\"it contains old items that should be garbage collected\");\n              case 2:\n                map = new Map();\n                _iterator12 = _createForOfIteratorHelper(items);\n                try {\n                  for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                    identifier = _step12.value;\n                    map.set(identifier, content.content.get(identifier));\n                  }\n                } catch (err) {\n                  _iterator12.e(err);\n                } finally {\n                  _iterator12.f();\n                }\n                return _context5.abrupt(\"return\", new PackContentItems(map));\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }, _callee5);\n        }))) : undefined;\n      }\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(_ref8) {\n      var _this4 = this;\n      var write = _ref8.write,\n        writeSeparate = _ref8.writeSeparate;\n      this._persistFreshContent();\n      this._optimizeSmallContent();\n      this._optimizeUnusedContent();\n      this._gcOldestContent();\n      var _iterator13 = _createForOfIteratorHelper(this.itemInfo.keys()),\n        _step13;\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var identifier = _step13.value;\n          write(identifier);\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n      write(null); // null as marker of the end of keys\n      var _iterator14 = _createForOfIteratorHelper(this.itemInfo.values()),\n        _step14;\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var info = _step14.value;\n          write(info.etag);\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n      var _iterator15 = _createForOfIteratorHelper(this.itemInfo.values()),\n        _step15;\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var _info = _step15.value;\n          write(_info.lastAccess);\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n      var _loop3 = function _loop3(i) {\n        var content = _this4.content[i];\n        if (content !== undefined) {\n          write(content.items);\n          content.writeLazy(function (lazy) {\n            return writeSeparate(lazy, {\n              name: \"\".concat(i)\n            });\n          });\n        } else {\n          write(undefined); // undefined marks an empty content slot\n        }\n      };\n      for (var i = 0; i < this.content.length; i++) {\n        _loop3(i);\n      }\n      write(null); // null as marker of the end of items\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(_ref9) {\n      var _this5 = this;\n      var read = _ref9.read,\n        logger = _ref9.logger;\n      this.logger = logger;\n      {\n        var _items = [];\n        var item = read();\n        while (item !== null) {\n          _items.push(item);\n          item = read();\n        }\n        this.itemInfo.clear();\n        var infoItems = _items.map(function (identifier) {\n          var info = new PackItemInfo(identifier, undefined, undefined);\n          _this5.itemInfo.set(identifier, info);\n          return info;\n        });\n        var _iterator16 = _createForOfIteratorHelper(infoItems),\n          _step16;\n        try {\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            var info = _step16.value;\n            info.etag = read();\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n        var _iterator17 = _createForOfIteratorHelper(infoItems),\n          _step17;\n        try {\n          for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n            var _info2 = _step17.value;\n            _info2.lastAccess = read();\n          }\n        } catch (err) {\n          _iterator17.e(err);\n        } finally {\n          _iterator17.f();\n        }\n      }\n      this.content.length = 0;\n      var items = read();\n      while (items !== null) {\n        if (items === undefined) {\n          this.content.push(items);\n        } else {\n          var idx = this.content.length;\n          var lazy = read();\n          this.content.push(new PackContent(items, new Set(), lazy, logger, \"\".concat(this.content.length)));\n          var _iterator18 = _createForOfIteratorHelper(items),\n            _step18;\n          try {\n            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n              var identifier = _step18.value;\n              this.itemInfo.get(identifier).location = idx;\n            }\n          } catch (err) {\n            _iterator18.e(err);\n          } finally {\n            _iterator18.f();\n          }\n        }\n        items = read();\n      }\n    }\n  }]);\n  return Pack;\n}();\nmakeSerializable(Pack, \"webpack/lib/cache/PackFileCacheStrategy\", \"Pack\");\nvar PackContentItems = /*#__PURE__*/function () {\n  /**\n   * @param {Map<string, any>} map items\n   */\n  function PackContentItems(map) {\n    _classCallCheck(this, PackContentItems);\n    this.map = map;\n  }\n  _createClass(PackContentItems, [{\n    key: \"serialize\",\n    value: function serialize(_ref10) {\n      var write = _ref10.write,\n        snapshot = _ref10.snapshot,\n        rollback = _ref10.rollback,\n        logger = _ref10.logger,\n        profile = _ref10.profile;\n      if (profile) {\n        write(false);\n        var _iterator19 = _createForOfIteratorHelper(this.map),\n          _step19;\n        try {\n          for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n            var _step19$value = _slicedToArray(_step19.value, 2),\n              key = _step19$value[0],\n              value = _step19$value[1];\n            var _s = snapshot();\n            try {\n              write(key);\n              var start = process.hrtime();\n              write(value);\n              var durationHr = process.hrtime(start);\n              var duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n              if (duration > 1) {\n                if (duration > 500) logger.error(\"Serialization of '\".concat(key, \"': \").concat(duration, \" ms\"));else if (duration > 50) logger.warn(\"Serialization of '\".concat(key, \"': \").concat(duration, \" ms\"));else if (duration > 10) logger.info(\"Serialization of '\".concat(key, \"': \").concat(duration, \" ms\"));else if (duration > 5) logger.log(\"Serialization of '\".concat(key, \"': \").concat(duration, \" ms\"));else logger.debug(\"Serialization of '\".concat(key, \"': \").concat(duration, \" ms\"));\n              }\n            } catch (e) {\n              rollback(_s);\n              if (e === NOT_SERIALIZABLE) continue;\n              var msg = \"Skipped not serializable cache item\";\n              if (e.message.includes(\"ModuleBuildError\")) {\n                logger.log(\"\".concat(msg, \" (in build error): \").concat(e.message));\n                logger.debug(\"\".concat(msg, \" '\").concat(key, \"' (in build error): \").concat(e.stack));\n              } else {\n                logger.warn(\"\".concat(msg, \": \").concat(e.message));\n                logger.debug(\"\".concat(msg, \" '\").concat(key, \"': \").concat(e.stack));\n              }\n            }\n          }\n        } catch (err) {\n          _iterator19.e(err);\n        } finally {\n          _iterator19.f();\n        }\n        write(null);\n        return;\n      }\n      // Try to serialize all at once\n      var s = snapshot();\n      try {\n        write(true);\n        write(this.map);\n      } catch (e) {\n        rollback(s);\n\n        // Try to serialize each item on it's own\n        write(false);\n        var _iterator20 = _createForOfIteratorHelper(this.map),\n          _step20;\n        try {\n          for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n            var _step20$value = _slicedToArray(_step20.value, 2),\n              _key = _step20$value[0],\n              _value = _step20$value[1];\n            var _s2 = snapshot();\n            try {\n              write(_key);\n              write(_value);\n            } catch (e) {\n              rollback(_s2);\n              if (e === NOT_SERIALIZABLE) continue;\n              logger.warn(\"Skipped not serializable cache item '\".concat(_key, \"': \").concat(e.message));\n              logger.debug(e.stack);\n            }\n          }\n        } catch (err) {\n          _iterator20.e(err);\n        } finally {\n          _iterator20.f();\n        }\n        write(null);\n      }\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(_ref11) {\n      var read = _ref11.read,\n        logger = _ref11.logger,\n        profile = _ref11.profile;\n      if (read()) {\n        this.map = read();\n      } else if (profile) {\n        var map = new Map();\n        var key = read();\n        while (key !== null) {\n          var start = process.hrtime();\n          var value = read();\n          var durationHr = process.hrtime(start);\n          var duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n          if (duration > 1) {\n            if (duration > 100) logger.error(\"Deserialization of '\".concat(key, \"': \").concat(duration, \" ms\"));else if (duration > 20) logger.warn(\"Deserialization of '\".concat(key, \"': \").concat(duration, \" ms\"));else if (duration > 5) logger.info(\"Deserialization of '\".concat(key, \"': \").concat(duration, \" ms\"));else if (duration > 2) logger.log(\"Deserialization of '\".concat(key, \"': \").concat(duration, \" ms\"));else logger.debug(\"Deserialization of '\".concat(key, \"': \").concat(duration, \" ms\"));\n          }\n          map.set(key, value);\n          key = read();\n        }\n        this.map = map;\n      } else {\n        var _map = new Map();\n        var _key2 = read();\n        while (_key2 !== null) {\n          _map.set(_key2, read());\n          _key2 = read();\n        }\n        this.map = _map;\n      }\n    }\n  }]);\n  return PackContentItems;\n}();\nmakeSerializable(PackContentItems, \"webpack/lib/cache/PackFileCacheStrategy\", \"PackContentItems\");\nvar PackContent = /*#__PURE__*/function () {\n  /*\n  \tThis class can be in these states:\n  \t   |   this.lazy    | this.content | this.outdated | state\n  \tA1 |   undefined    |     Map      |     false     | fresh content\n  \tA2 |   undefined    |     Map      |     true      | (will not happen)\n  \tB1 | lazy () => {}  |  undefined   |     false     | not deserialized\n  \tB2 | lazy () => {}  |  undefined   |     true      | not deserialized, but some items has been removed\n  \tC1 | lazy* () => {} |     Map      |     false     | deserialized\n  \tC2 | lazy* () => {} |     Map      |     true      | deserialized, and some items has been removed\n  \t\tthis.used is a subset of this.items.\n  \tthis.items is a subset of this.content.keys() resp. this.lazy().map.keys()\n  \tWhen this.outdated === false, this.items === this.content.keys() resp. this.lazy().map.keys()\n  \tWhen this.outdated === true, this.items should be used to recreated this.lazy/this.content.\n  \tWhen this.lazy and this.content is set, they contain the same data.\n  \tthis.get must only be called with a valid item from this.items.\n  \tIn state C this.lazy is unMemoized\n  */\n\n  /**\n   * @param {Set<string>} items keys\n   * @param {Set<string>} usedItems used keys\n   * @param {PackContentItems | function(): Promise<PackContentItems>} dataOrFn sync or async content\n   * @param {Logger=} logger logger for logging\n   * @param {string=} lazyName name of dataOrFn for logging\n   */\n  function PackContent(items, usedItems, dataOrFn, logger, lazyName) {\n    _classCallCheck(this, PackContent);\n    this.items = items;\n    /** @type {function(): Promise<PackContentItems> | PackContentItems} */\n    this.lazy = typeof dataOrFn === \"function\" ? dataOrFn : undefined;\n    /** @type {Map<string, any>} */\n    this.content = typeof dataOrFn === \"function\" ? undefined : dataOrFn.map;\n    this.outdated = false;\n    this.used = usedItems;\n    this.logger = logger;\n    this.lazyName = lazyName;\n  }\n  _createClass(PackContent, [{\n    key: \"get\",\n    value: function get(identifier) {\n      var _this6 = this;\n      this.used.add(identifier);\n      if (this.content) {\n        return this.content.get(identifier);\n      }\n\n      // We are in state B\n      var lazyName = this.lazyName;\n      var timeMessage;\n      if (lazyName) {\n        // only log once\n        this.lazyName = undefined;\n        timeMessage = \"restore cache content \".concat(lazyName, \" (\").concat(formatSize(this.getSize()), \")\");\n        this.logger.log(\"starting to restore cache content \".concat(lazyName, \" (\").concat(formatSize(this.getSize()), \") because of request to: \").concat(identifier));\n        this.logger.time(timeMessage);\n      }\n      var value = this.lazy();\n      if (\"then\" in value) {\n        return value.then(function (data) {\n          var map = data.map;\n          if (timeMessage) {\n            _this6.logger.timeEnd(timeMessage);\n          }\n          // Move to state C\n          _this6.content = map;\n          _this6.lazy = SerializerMiddleware.unMemoizeLazy(_this6.lazy);\n          return map.get(identifier);\n        });\n      } else {\n        var map = value.map;\n        if (timeMessage) {\n          this.logger.timeEnd(timeMessage);\n        }\n        // Move to state C\n        this.content = map;\n        this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n        return map.get(identifier);\n      }\n    }\n\n    /**\n     * @param {string} reason explanation why unpack is necessary\n     * @returns {void | Promise} maybe a promise if lazy\n     */\n  }, {\n    key: \"unpack\",\n    value: function unpack(reason) {\n      var _this7 = this;\n      if (this.content) return;\n\n      // Move from state B to C\n      if (this.lazy) {\n        var lazyName = this.lazyName;\n        var timeMessage;\n        if (lazyName) {\n          // only log once\n          this.lazyName = undefined;\n          timeMessage = \"unpack cache content \".concat(lazyName, \" (\").concat(formatSize(this.getSize()), \")\");\n          this.logger.log(\"starting to unpack cache content \".concat(lazyName, \" (\").concat(formatSize(this.getSize()), \") because \").concat(reason));\n          this.logger.time(timeMessage);\n        }\n        var value = this.lazy();\n        if (\"then\" in value) {\n          return value.then(function (data) {\n            if (timeMessage) {\n              _this7.logger.timeEnd(timeMessage);\n            }\n            _this7.content = data.map;\n          });\n        } else {\n          if (timeMessage) {\n            this.logger.timeEnd(timeMessage);\n          }\n          this.content = value.map;\n        }\n      }\n    }\n\n    /**\n     * @returns {number} size of the content or -1 if not known\n     */\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      if (!this.lazy) return -1;\n      var options = /** @type {any} */this.lazy.options;\n      if (!options) return -1;\n      var size = options.size;\n      if (typeof size !== \"number\") return -1;\n      return size;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(identifier) {\n      this.items.delete(identifier);\n      this.used.delete(identifier);\n      this.outdated = true;\n    }\n\n    /**\n     * @template T\n     * @param {function(any): function(): Promise<PackContentItems> | PackContentItems} write write function\n     * @returns {void}\n     */\n  }, {\n    key: \"writeLazy\",\n    value: function writeLazy(write) {\n      var _this8 = this;\n      if (!this.outdated && this.lazy) {\n        // State B1 or C1\n        // this.lazy is still the valid deserialized version\n        write(this.lazy);\n        return;\n      }\n      if (!this.outdated && this.content) {\n        // State A1\n        var map = new Map(this.content);\n        // Move to state C1\n        this.lazy = SerializerMiddleware.unMemoizeLazy(write(function () {\n          return new PackContentItems(map);\n        }));\n        return;\n      }\n      if (this.content) {\n        // State A2 or C2\n        /** @type {Map<string, any>} */\n        var _map2 = new Map();\n        var _iterator21 = _createForOfIteratorHelper(this.items),\n          _step21;\n        try {\n          for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n            var item = _step21.value;\n            _map2.set(item, this.content.get(item));\n          }\n          // Move to state C1\n        } catch (err) {\n          _iterator21.e(err);\n        } finally {\n          _iterator21.f();\n        }\n        this.outdated = false;\n        this.content = _map2;\n        this.lazy = SerializerMiddleware.unMemoizeLazy(write(function () {\n          return new PackContentItems(_map2);\n        }));\n        return;\n      }\n      // State B2\n      var lazyName = this.lazyName;\n      var timeMessage;\n      if (lazyName) {\n        // only log once\n        this.lazyName = undefined;\n        timeMessage = \"unpack cache content \".concat(lazyName, \" (\").concat(formatSize(this.getSize()), \")\");\n        this.logger.log(\"starting to unpack cache content \".concat(lazyName, \" (\").concat(formatSize(this.getSize()), \") because it's outdated and need to be serialized\"));\n        this.logger.time(timeMessage);\n      }\n      var value = this.lazy();\n      this.outdated = false;\n      if (\"then\" in value) {\n        // Move to state B1\n        this.lazy = write(function () {\n          return value.then(function (data) {\n            if (timeMessage) {\n              _this8.logger.timeEnd(timeMessage);\n            }\n            var oldMap = data.map;\n            /** @type {Map<string, any>} */\n            var map = new Map();\n            var _iterator22 = _createForOfIteratorHelper(_this8.items),\n              _step22;\n            try {\n              for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n                var _item = _step22.value;\n                map.set(_item, oldMap.get(_item));\n              }\n              // Move to state C1 (or maybe C2)\n            } catch (err) {\n              _iterator22.e(err);\n            } finally {\n              _iterator22.f();\n            }\n            _this8.content = map;\n            _this8.lazy = SerializerMiddleware.unMemoizeLazy(_this8.lazy);\n            return new PackContentItems(map);\n          });\n        });\n      } else {\n        // Move to state C1\n        if (timeMessage) {\n          this.logger.timeEnd(timeMessage);\n        }\n        var oldMap = value.map;\n        /** @type {Map<string, any>} */\n        var _map3 = new Map();\n        var _iterator23 = _createForOfIteratorHelper(this.items),\n          _step23;\n        try {\n          for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n            var _item2 = _step23.value;\n            _map3.set(_item2, oldMap.get(_item2));\n          }\n        } catch (err) {\n          _iterator23.e(err);\n        } finally {\n          _iterator23.f();\n        }\n        this.content = _map3;\n        this.lazy = write(function () {\n          return new PackContentItems(_map3);\n        });\n      }\n    }\n  }]);\n  return PackContent;\n}();\nvar allowCollectingMemory = function allowCollectingMemory(buf) {\n  var wasted = buf.buffer.byteLength - buf.byteLength;\n  if (wasted > 8192 && (wasted > 1048576 || wasted > buf.byteLength)) {\n    return Buffer.from(buf);\n  }\n  return buf;\n};\nvar PackFileCacheStrategy = /*#__PURE__*/function () {\n  /**\n   * @param {Object} options options\n   * @param {Compiler} options.compiler the compiler\n   * @param {IntermediateFileSystem} options.fs the filesystem\n   * @param {string} options.context the context directory\n   * @param {string} options.cacheLocation the location of the cache data\n   * @param {string} options.version version identifier\n   * @param {Logger} options.logger a logger\n   * @param {SnapshotOptions} options.snapshot options regarding snapshotting\n   * @param {number} options.maxAge max age of cache items\n   * @param {boolean} options.profile track and log detailed timing information for individual cache items\n   * @param {boolean} options.allowCollectingMemory allow to collect unused memory created during deserialization\n   * @param {false | \"gzip\" | \"brotli\"} options.compression compression used\n   */\n  function PackFileCacheStrategy(_ref12) {\n    var compiler = _ref12.compiler,\n      fs = _ref12.fs,\n      context = _ref12.context,\n      cacheLocation = _ref12.cacheLocation,\n      version = _ref12.version,\n      logger = _ref12.logger,\n      snapshot = _ref12.snapshot,\n      maxAge = _ref12.maxAge,\n      profile = _ref12.profile,\n      allowCollectingMemory = _ref12.allowCollectingMemory,\n      compression = _ref12.compression;\n    _classCallCheck(this, PackFileCacheStrategy);\n    this.fileSerializer = createFileSerializer(fs, compiler.options.output.hashFunction);\n    this.fileSystemInfo = new FileSystemInfo(fs, {\n      managedPaths: snapshot.managedPaths,\n      immutablePaths: snapshot.immutablePaths,\n      logger: logger.getChildLogger(\"webpack.FileSystemInfo\"),\n      hashFunction: compiler.options.output.hashFunction\n    });\n    this.compiler = compiler;\n    this.context = context;\n    this.cacheLocation = cacheLocation;\n    this.version = version;\n    this.logger = logger;\n    this.maxAge = maxAge;\n    this.profile = profile;\n    this.allowCollectingMemory = allowCollectingMemory;\n    this.compression = compression;\n    this._extension = compression === \"brotli\" ? \".pack.br\" : compression === \"gzip\" ? \".pack.gz\" : \".pack\";\n    this.snapshot = snapshot;\n    /** @type {Set<string>} */\n    this.buildDependencies = new Set();\n    /** @type {LazySet<string>} */\n    this.newBuildDependencies = new LazySet();\n    /** @type {Snapshot} */\n    this.resolveBuildDependenciesSnapshot = undefined;\n    /** @type {Map<string, string | false>} */\n    this.resolveResults = undefined;\n    /** @type {Snapshot} */\n    this.buildSnapshot = undefined;\n    /** @type {Promise<Pack>} */\n    this.packPromise = this._openPack();\n    this.storePromise = Promise.resolve();\n  }\n  _createClass(PackFileCacheStrategy, [{\n    key: \"_getPack\",\n    value: function _getPack() {\n      var _this9 = this;\n      if (this.packPromise === undefined) {\n        this.packPromise = this.storePromise.then(function () {\n          return _this9._openPack();\n        });\n      }\n      return this.packPromise;\n    }\n\n    /**\n     * @returns {Promise<Pack>} the pack\n     */\n  }, {\n    key: \"_openPack\",\n    value: function _openPack() {\n      var _this10 = this;\n      var logger = this.logger,\n        profile = this.profile,\n        cacheLocation = this.cacheLocation,\n        version = this.version;\n      /** @type {Snapshot} */\n      var buildSnapshot;\n      /** @type {Set<string>} */\n      var buildDependencies;\n      /** @type {Set<string>} */\n      var newBuildDependencies;\n      /** @type {Snapshot} */\n      var resolveBuildDependenciesSnapshot;\n      /** @type {Map<string, string | false>} */\n      var resolveResults;\n      logger.time(\"restore cache container\");\n      return this.fileSerializer.deserialize(null, {\n        filename: \"\".concat(cacheLocation, \"/index\").concat(this._extension),\n        extension: \"\".concat(this._extension),\n        logger: logger,\n        profile: profile,\n        retainedBuffer: this.allowCollectingMemory ? allowCollectingMemory : undefined\n      }).catch(function (err) {\n        if (err.code !== \"ENOENT\") {\n          logger.warn(\"Restoring pack failed from \".concat(cacheLocation).concat(_this10._extension, \": \").concat(err));\n          logger.debug(err.stack);\n        } else {\n          logger.debug(\"No pack exists at \".concat(cacheLocation).concat(_this10._extension, \": \").concat(err));\n        }\n        return undefined;\n      }).then(function (packContainer) {\n        logger.timeEnd(\"restore cache container\");\n        if (!packContainer) return undefined;\n        if (!(packContainer instanceof PackContainer)) {\n          logger.warn(\"Restored pack from \".concat(cacheLocation).concat(_this10._extension, \", but contained content is unexpected.\"), packContainer);\n          return undefined;\n        }\n        if (packContainer.version !== version) {\n          logger.log(\"Restored pack from \".concat(cacheLocation).concat(_this10._extension, \", but version doesn't match.\"));\n          return undefined;\n        }\n        logger.time(\"check build dependencies\");\n        return Promise.all([new Promise(function (resolve, reject) {\n          _this10.fileSystemInfo.checkSnapshotValid(packContainer.buildSnapshot, function (err, valid) {\n            if (err) {\n              logger.log(\"Restored pack from \".concat(cacheLocation).concat(_this10._extension, \", but checking snapshot of build dependencies errored: \").concat(err, \".\"));\n              logger.debug(err.stack);\n              return resolve(false);\n            }\n            if (!valid) {\n              logger.log(\"Restored pack from \".concat(cacheLocation).concat(_this10._extension, \", but build dependencies have changed.\"));\n              return resolve(false);\n            }\n            buildSnapshot = packContainer.buildSnapshot;\n            return resolve(true);\n          });\n        }), new Promise(function (resolve, reject) {\n          _this10.fileSystemInfo.checkSnapshotValid(packContainer.resolveBuildDependenciesSnapshot, function (err, valid) {\n            if (err) {\n              logger.log(\"Restored pack from \".concat(cacheLocation).concat(_this10._extension, \", but checking snapshot of resolving of build dependencies errored: \").concat(err, \".\"));\n              logger.debug(err.stack);\n              return resolve(false);\n            }\n            if (valid) {\n              resolveBuildDependenciesSnapshot = packContainer.resolveBuildDependenciesSnapshot;\n              buildDependencies = packContainer.buildDependencies;\n              resolveResults = packContainer.resolveResults;\n              return resolve(true);\n            }\n            logger.log(\"resolving of build dependencies is invalid, will re-resolve build dependencies\");\n            _this10.fileSystemInfo.checkResolveResultsValid(packContainer.resolveResults, function (err, valid) {\n              if (err) {\n                logger.log(\"Restored pack from \".concat(cacheLocation).concat(_this10._extension, \", but resolving of build dependencies errored: \").concat(err, \".\"));\n                logger.debug(err.stack);\n                return resolve(false);\n              }\n              if (valid) {\n                newBuildDependencies = packContainer.buildDependencies;\n                resolveResults = packContainer.resolveResults;\n                return resolve(true);\n              }\n              logger.log(\"Restored pack from \".concat(cacheLocation).concat(_this10._extension, \", but build dependencies resolve to different locations.\"));\n              return resolve(false);\n            });\n          });\n        })]).catch(function (err) {\n          logger.timeEnd(\"check build dependencies\");\n          throw err;\n        }).then(function (_ref13) {\n          var _ref14 = _slicedToArray(_ref13, 2),\n            buildSnapshotValid = _ref14[0],\n            resolveValid = _ref14[1];\n          logger.timeEnd(\"check build dependencies\");\n          if (buildSnapshotValid && resolveValid) {\n            logger.time(\"restore cache content metadata\");\n            var d = packContainer.data();\n            logger.timeEnd(\"restore cache content metadata\");\n            return d;\n          }\n          return undefined;\n        });\n      }).then(function (pack) {\n        if (pack) {\n          pack.maxAge = _this10.maxAge;\n          _this10.buildSnapshot = buildSnapshot;\n          if (buildDependencies) _this10.buildDependencies = buildDependencies;\n          if (newBuildDependencies) _this10.newBuildDependencies.addAll(newBuildDependencies);\n          _this10.resolveResults = resolveResults;\n          _this10.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;\n          return pack;\n        }\n        return new Pack(logger, _this10.maxAge);\n      }).catch(function (err) {\n        _this10.logger.warn(\"Restoring pack from \".concat(cacheLocation).concat(_this10._extension, \" failed: \").concat(err));\n        _this10.logger.debug(err.stack);\n        return new Pack(logger, _this10.maxAge);\n      });\n    }\n\n    /**\n     * @param {string} identifier unique name for the resource\n     * @param {Etag | null} etag etag of the resource\n     * @param {any} data cached content\n     * @returns {Promise<void>} promise\n     */\n  }, {\n    key: \"store\",\n    value: function store(identifier, etag, data) {\n      return this._getPack().then(function (pack) {\n        pack.set(identifier, etag === null ? null : etag.toString(), data);\n      });\n    }\n\n    /**\n     * @param {string} identifier unique name for the resource\n     * @param {Etag | null} etag etag of the resource\n     * @returns {Promise<any>} promise to the cached content\n     */\n  }, {\n    key: \"restore\",\n    value: function restore(identifier, etag) {\n      var _this11 = this;\n      return this._getPack().then(function (pack) {\n        return pack.get(identifier, etag === null ? null : etag.toString());\n      }).catch(function (err) {\n        if (err && err.code !== \"ENOENT\") {\n          _this11.logger.warn(\"Restoring failed for \".concat(identifier, \" from pack: \").concat(err));\n          _this11.logger.debug(err.stack);\n        }\n      });\n    }\n  }, {\n    key: \"storeBuildDependencies\",\n    value: function storeBuildDependencies(dependencies) {\n      this.newBuildDependencies.addAll(dependencies);\n    }\n  }, {\n    key: \"afterAllStored\",\n    value: function afterAllStored() {\n      var _this12 = this;\n      var packPromise = this.packPromise;\n      if (packPromise === undefined) return Promise.resolve();\n      var reportProgress = ProgressPlugin.getReporter(this.compiler);\n      return this.storePromise = packPromise.then(function (pack) {\n        pack.stopCapturingRequests();\n        if (!pack.invalid) return;\n        _this12.packPromise = undefined;\n        _this12.logger.log(\"Storing pack...\");\n        var promise;\n        var newBuildDependencies = new Set();\n        var _iterator24 = _createForOfIteratorHelper(_this12.newBuildDependencies),\n          _step24;\n        try {\n          for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n            var dep = _step24.value;\n            if (!_this12.buildDependencies.has(dep)) {\n              newBuildDependencies.add(dep);\n            }\n          }\n        } catch (err) {\n          _iterator24.e(err);\n        } finally {\n          _iterator24.f();\n        }\n        if (newBuildDependencies.size > 0 || !_this12.buildSnapshot) {\n          if (reportProgress) reportProgress(0.5, \"resolve build dependencies\");\n          _this12.logger.debug(\"Capturing build dependencies... (\".concat(Array.from(newBuildDependencies).join(\", \"), \")\"));\n          promise = new Promise(function (resolve, reject) {\n            _this12.logger.time(\"resolve build dependencies\");\n            _this12.fileSystemInfo.resolveBuildDependencies(_this12.context, newBuildDependencies, function (err, result) {\n              _this12.logger.timeEnd(\"resolve build dependencies\");\n              if (err) return reject(err);\n              _this12.logger.time(\"snapshot build dependencies\");\n              var files = result.files,\n                directories = result.directories,\n                missing = result.missing,\n                resolveResults = result.resolveResults,\n                resolveDependencies = result.resolveDependencies;\n              if (_this12.resolveResults) {\n                var _iterator25 = _createForOfIteratorHelper(resolveResults),\n                  _step25;\n                try {\n                  for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n                    var _step25$value = _slicedToArray(_step25.value, 2),\n                      key = _step25$value[0],\n                      value = _step25$value[1];\n                    _this12.resolveResults.set(key, value);\n                  }\n                } catch (err) {\n                  _iterator25.e(err);\n                } finally {\n                  _iterator25.f();\n                }\n              } else {\n                _this12.resolveResults = resolveResults;\n              }\n              if (reportProgress) {\n                reportProgress(0.6, \"snapshot build dependencies\", \"resolving\");\n              }\n              _this12.fileSystemInfo.createSnapshot(undefined, resolveDependencies.files, resolveDependencies.directories, resolveDependencies.missing, _this12.snapshot.resolveBuildDependencies, function (err, snapshot) {\n                if (err) {\n                  _this12.logger.timeEnd(\"snapshot build dependencies\");\n                  return reject(err);\n                }\n                if (!snapshot) {\n                  _this12.logger.timeEnd(\"snapshot build dependencies\");\n                  return reject(new Error(\"Unable to snapshot resolve dependencies\"));\n                }\n                if (_this12.resolveBuildDependenciesSnapshot) {\n                  _this12.resolveBuildDependenciesSnapshot = _this12.fileSystemInfo.mergeSnapshots(_this12.resolveBuildDependenciesSnapshot, snapshot);\n                } else {\n                  _this12.resolveBuildDependenciesSnapshot = snapshot;\n                }\n                if (reportProgress) {\n                  reportProgress(0.7, \"snapshot build dependencies\", \"modules\");\n                }\n                _this12.fileSystemInfo.createSnapshot(undefined, files, directories, missing, _this12.snapshot.buildDependencies, function (err, snapshot) {\n                  _this12.logger.timeEnd(\"snapshot build dependencies\");\n                  if (err) return reject(err);\n                  if (!snapshot) {\n                    return reject(new Error(\"Unable to snapshot build dependencies\"));\n                  }\n                  _this12.logger.debug(\"Captured build dependencies\");\n                  if (_this12.buildSnapshot) {\n                    _this12.buildSnapshot = _this12.fileSystemInfo.mergeSnapshots(_this12.buildSnapshot, snapshot);\n                  } else {\n                    _this12.buildSnapshot = snapshot;\n                  }\n                  resolve();\n                });\n              });\n            });\n          });\n        } else {\n          promise = Promise.resolve();\n        }\n        return promise.then(function () {\n          if (reportProgress) reportProgress(0.8, \"serialize pack\");\n          _this12.logger.time(\"store pack\");\n          var updatedBuildDependencies = new Set(_this12.buildDependencies);\n          var _iterator26 = _createForOfIteratorHelper(newBuildDependencies),\n            _step26;\n          try {\n            for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n              var dep = _step26.value;\n              updatedBuildDependencies.add(dep);\n            }\n          } catch (err) {\n            _iterator26.e(err);\n          } finally {\n            _iterator26.f();\n          }\n          var content = new PackContainer(pack, _this12.version, _this12.buildSnapshot, updatedBuildDependencies, _this12.resolveResults, _this12.resolveBuildDependenciesSnapshot);\n          return _this12.fileSerializer.serialize(content, {\n            filename: \"\".concat(_this12.cacheLocation, \"/index\").concat(_this12._extension),\n            extension: \"\".concat(_this12._extension),\n            logger: _this12.logger,\n            profile: _this12.profile\n          }).then(function () {\n            var _iterator27 = _createForOfIteratorHelper(newBuildDependencies),\n              _step27;\n            try {\n              for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n                var dep = _step27.value;\n                _this12.buildDependencies.add(dep);\n              }\n            } catch (err) {\n              _iterator27.e(err);\n            } finally {\n              _iterator27.f();\n            }\n            _this12.newBuildDependencies.clear();\n            _this12.logger.timeEnd(\"store pack\");\n            var stats = pack.getContentStats();\n            _this12.logger.log(\"Stored pack (%d items, %d files, %d MiB)\", pack.itemInfo.size, stats.count, Math.round(stats.size / 1024 / 1024));\n          }).catch(function (err) {\n            _this12.logger.timeEnd(\"store pack\");\n            _this12.logger.warn(\"Caching failed for pack: \".concat(err));\n            _this12.logger.debug(err.stack);\n          });\n        });\n      }).catch(function (err) {\n        _this12.logger.warn(\"Caching failed for pack: \".concat(err));\n        _this12.logger.debug(err.stack);\n      });\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.fileSystemInfo.clear();\n      this.buildDependencies.clear();\n      this.newBuildDependencies.clear();\n      this.resolveBuildDependenciesSnapshot = undefined;\n      this.resolveResults = undefined;\n      this.buildSnapshot = undefined;\n      this.packPromise = undefined;\n    }\n  }]);\n  return PackFileCacheStrategy;\n}();\nmodule.exports = PackFileCacheStrategy;","map":{"version":3,"names":["FileSystemInfo","require","ProgressPlugin","formatSize","SerializerMiddleware","LazySet","makeSerializable","memoize","createFileSerializer","NOT_SERIALIZABLE","PackContainer","data","version","buildSnapshot","buildDependencies","resolveResults","resolveBuildDependenciesSnapshot","write","writeLazy","read","MIN_CONTENT_SIZE","CONTENT_COUNT_TO_MERGE","MIN_ITEMS_IN_FRESH_PACK","MAX_ITEMS_IN_FRESH_PACK","MAX_TIME_IN_FRESH_PACK","PackItemInfo","identifier","etag","value","location","lastAccess","Date","now","freshValue","Pack","logger","maxAge","itemInfo","Map","requests","requestsTimeout","undefined","freshContent","content","invalid","push","setTimeout","unref","clearTimeout","info","get","_addRequest","loc","log","newInfo","set","delete","items","size","debug","count","s","getSize","i","length","usedItems","newLoc","lastGC","itemsCount","packCount","Math","ceil","itemsPerPack","packs","ignoreNextTimeTick","createNextPack","_findLocation","pack","Set","map","add","PackContent","PackContentItems","join","smallUsedContents","smallUsedContentSize","smallUnusedContents","smallUnusedContentSize","outdated","used","mergedIndices","mergedContent","mergedItems","mergedUsedItems","addToMergedMap","unpack","_gcAndUpdateLocation","Promise","all","fn","total","unusedItems","usedOfUnusedItems","newUnusedLoc","oldest","values","writeSeparate","_persistFreshContent","_optimizeSmallContent","_optimizeUnusedContent","_gcOldestContent","keys","lazy","name","item","clear","infoItems","idx","snapshot","rollback","profile","key","start","process","hrtime","durationHr","duration","error","warn","e","msg","message","includes","stack","dataOrFn","lazyName","timeMessage","time","then","timeEnd","unMemoizeLazy","reason","options","oldMap","allowCollectingMemory","buf","wasted","buffer","byteLength","Buffer","from","PackFileCacheStrategy","compiler","fs","context","cacheLocation","compression","fileSerializer","output","hashFunction","fileSystemInfo","managedPaths","immutablePaths","getChildLogger","_extension","newBuildDependencies","packPromise","_openPack","storePromise","resolve","deserialize","filename","extension","retainedBuffer","catch","err","code","packContainer","reject","checkSnapshotValid","valid","checkResolveResultsValid","buildSnapshotValid","resolveValid","d","addAll","_getPack","toString","dependencies","reportProgress","getReporter","stopCapturingRequests","promise","dep","has","Array","resolveBuildDependencies","result","files","directories","missing","resolveDependencies","createSnapshot","Error","mergeSnapshots","updatedBuildDependencies","serialize","stats","getContentStats","round","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/cache/PackFileCacheStrategy.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst FileSystemInfo = require(\"../FileSystemInfo\");\nconst ProgressPlugin = require(\"../ProgressPlugin\");\nconst { formatSize } = require(\"../SizeFormatHelpers\");\nconst SerializerMiddleware = require(\"../serialization/SerializerMiddleware\");\nconst LazySet = require(\"../util/LazySet\");\nconst makeSerializable = require(\"../util/makeSerializable\");\nconst memoize = require(\"../util/memoize\");\nconst {\n\tcreateFileSerializer,\n\tNOT_SERIALIZABLE\n} = require(\"../util/serialization\");\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").SnapshotOptions} SnapshotOptions */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n/** @typedef {import(\"../logging/Logger\").Logger} Logger */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\nclass PackContainer {\n\t/**\n\t * @param {Object} data stored data\n\t * @param {string} version version identifier\n\t * @param {Snapshot} buildSnapshot snapshot of all build dependencies\n\t * @param {Set<string>} buildDependencies list of all unresolved build dependencies captured\n\t * @param {Map<string, string | false>} resolveResults result of the resolved build dependencies\n\t * @param {Snapshot} resolveBuildDependenciesSnapshot snapshot of the dependencies of the build dependencies resolving\n\t */\n\tconstructor(\n\t\tdata,\n\t\tversion,\n\t\tbuildSnapshot,\n\t\tbuildDependencies,\n\t\tresolveResults,\n\t\tresolveBuildDependenciesSnapshot\n\t) {\n\t\tthis.data = data;\n\t\tthis.version = version;\n\t\tthis.buildSnapshot = buildSnapshot;\n\t\tthis.buildDependencies = buildDependencies;\n\t\tthis.resolveResults = resolveResults;\n\t\tthis.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;\n\t}\n\n\tserialize({ write, writeLazy }) {\n\t\twrite(this.version);\n\t\twrite(this.buildSnapshot);\n\t\twrite(this.buildDependencies);\n\t\twrite(this.resolveResults);\n\t\twrite(this.resolveBuildDependenciesSnapshot);\n\t\twriteLazy(this.data);\n\t}\n\n\tdeserialize({ read }) {\n\t\tthis.version = read();\n\t\tthis.buildSnapshot = read();\n\t\tthis.buildDependencies = read();\n\t\tthis.resolveResults = read();\n\t\tthis.resolveBuildDependenciesSnapshot = read();\n\t\tthis.data = read();\n\t}\n}\n\nmakeSerializable(\n\tPackContainer,\n\t\"webpack/lib/cache/PackFileCacheStrategy\",\n\t\"PackContainer\"\n);\n\nconst MIN_CONTENT_SIZE = 1024 * 1024; // 1 MB\nconst CONTENT_COUNT_TO_MERGE = 10;\nconst MIN_ITEMS_IN_FRESH_PACK = 100;\nconst MAX_ITEMS_IN_FRESH_PACK = 50000;\nconst MAX_TIME_IN_FRESH_PACK = 1 * 60 * 1000; // 1 min\n\nclass PackItemInfo {\n\t/**\n\t * @param {string} identifier identifier of item\n\t * @param {string | null} etag etag of item\n\t * @param {any} value fresh value of item\n\t */\n\tconstructor(identifier, etag, value) {\n\t\tthis.identifier = identifier;\n\t\tthis.etag = etag;\n\t\tthis.location = -1;\n\t\tthis.lastAccess = Date.now();\n\t\tthis.freshValue = value;\n\t}\n}\n\nclass Pack {\n\tconstructor(logger, maxAge) {\n\t\t/** @type {Map<string, PackItemInfo>} */\n\t\tthis.itemInfo = new Map();\n\t\t/** @type {string[]} */\n\t\tthis.requests = [];\n\t\tthis.requestsTimeout = undefined;\n\t\t/** @type {Map<string, PackItemInfo>} */\n\t\tthis.freshContent = new Map();\n\t\t/** @type {(undefined | PackContent)[]} */\n\t\tthis.content = [];\n\t\tthis.invalid = false;\n\t\tthis.logger = logger;\n\t\tthis.maxAge = maxAge;\n\t}\n\n\t_addRequest(identifier) {\n\t\tthis.requests.push(identifier);\n\t\tif (this.requestsTimeout === undefined) {\n\t\t\tthis.requestsTimeout = setTimeout(() => {\n\t\t\t\tthis.requests.push(undefined);\n\t\t\t\tthis.requestsTimeout = undefined;\n\t\t\t}, MAX_TIME_IN_FRESH_PACK);\n\t\t\tif (this.requestsTimeout.unref) this.requestsTimeout.unref();\n\t\t}\n\t}\n\n\tstopCapturingRequests() {\n\t\tif (this.requestsTimeout !== undefined) {\n\t\t\tclearTimeout(this.requestsTimeout);\n\t\t\tthis.requestsTimeout = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {string | null} etag etag of the resource\n\t * @returns {any} cached content\n\t */\n\tget(identifier, etag) {\n\t\tconst info = this.itemInfo.get(identifier);\n\t\tthis._addRequest(identifier);\n\t\tif (info === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (info.etag !== etag) return null;\n\t\tinfo.lastAccess = Date.now();\n\t\tconst loc = info.location;\n\t\tif (loc === -1) {\n\t\t\treturn info.freshValue;\n\t\t} else {\n\t\t\tif (!this.content[loc]) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\treturn this.content[loc].get(identifier);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {string | null} etag etag of the resource\n\t * @param {any} data cached content\n\t * @returns {void}\n\t */\n\tset(identifier, etag, data) {\n\t\tif (!this.invalid) {\n\t\t\tthis.invalid = true;\n\t\t\tthis.logger.log(`Pack got invalid because of write to: ${identifier}`);\n\t\t}\n\t\tconst info = this.itemInfo.get(identifier);\n\t\tif (info === undefined) {\n\t\t\tconst newInfo = new PackItemInfo(identifier, etag, data);\n\t\t\tthis.itemInfo.set(identifier, newInfo);\n\t\t\tthis._addRequest(identifier);\n\t\t\tthis.freshContent.set(identifier, newInfo);\n\t\t} else {\n\t\t\tconst loc = info.location;\n\t\t\tif (loc >= 0) {\n\t\t\t\tthis._addRequest(identifier);\n\t\t\t\tthis.freshContent.set(identifier, info);\n\t\t\t\tconst content = this.content[loc];\n\t\t\t\tcontent.delete(identifier);\n\t\t\t\tif (content.items.size === 0) {\n\t\t\t\t\tthis.content[loc] = undefined;\n\t\t\t\t\tthis.logger.debug(\"Pack %d got empty and is removed\", loc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tinfo.freshValue = data;\n\t\t\tinfo.lastAccess = Date.now();\n\t\t\tinfo.etag = etag;\n\t\t\tinfo.location = -1;\n\t\t}\n\t}\n\n\tgetContentStats() {\n\t\tlet count = 0;\n\t\tlet size = 0;\n\t\tfor (const content of this.content) {\n\t\t\tif (content !== undefined) {\n\t\t\t\tcount++;\n\t\t\t\tconst s = content.getSize();\n\t\t\t\tif (s > 0) {\n\t\t\t\t\tsize += s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { count, size };\n\t}\n\n\t/**\n\t * @returns {number} new location of data entries\n\t */\n\t_findLocation() {\n\t\tlet i;\n\t\tfor (i = 0; i < this.content.length && this.content[i] !== undefined; i++);\n\t\treturn i;\n\t}\n\n\t_gcAndUpdateLocation(items, usedItems, newLoc) {\n\t\tlet count = 0;\n\t\tlet lastGC;\n\t\tconst now = Date.now();\n\t\tfor (const identifier of items) {\n\t\t\tconst info = this.itemInfo.get(identifier);\n\t\t\tif (now - info.lastAccess > this.maxAge) {\n\t\t\t\tthis.itemInfo.delete(identifier);\n\t\t\t\titems.delete(identifier);\n\t\t\t\tusedItems.delete(identifier);\n\t\t\t\tcount++;\n\t\t\t\tlastGC = identifier;\n\t\t\t} else {\n\t\t\t\tinfo.location = newLoc;\n\t\t\t}\n\t\t}\n\t\tif (count > 0) {\n\t\t\tthis.logger.log(\n\t\t\t\t\"Garbage Collected %d old items at pack %d (%d items remaining) e. g. %s\",\n\t\t\t\tcount,\n\t\t\t\tnewLoc,\n\t\t\t\titems.size,\n\t\t\t\tlastGC\n\t\t\t);\n\t\t}\n\t}\n\n\t_persistFreshContent() {\n\t\tconst itemsCount = this.freshContent.size;\n\t\tif (itemsCount > 0) {\n\t\t\tconst packCount = Math.ceil(itemsCount / MAX_ITEMS_IN_FRESH_PACK);\n\t\t\tconst itemsPerPack = Math.ceil(itemsCount / packCount);\n\t\t\tconst packs = [];\n\t\t\tlet i = 0;\n\t\t\tlet ignoreNextTimeTick = false;\n\t\t\tconst createNextPack = () => {\n\t\t\t\tconst loc = this._findLocation();\n\t\t\t\tthis.content[loc] = null; // reserve\n\t\t\t\tconst pack = {\n\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\titems: new Set(),\n\t\t\t\t\t/** @type {Map<string, any>} */\n\t\t\t\t\tmap: new Map(),\n\t\t\t\t\tloc\n\t\t\t\t};\n\t\t\t\tpacks.push(pack);\n\t\t\t\treturn pack;\n\t\t\t};\n\t\t\tlet pack = createNextPack();\n\t\t\tif (this.requestsTimeout !== undefined)\n\t\t\t\tclearTimeout(this.requestsTimeout);\n\t\t\tfor (const identifier of this.requests) {\n\t\t\t\tif (identifier === undefined) {\n\t\t\t\t\tif (ignoreNextTimeTick) {\n\t\t\t\t\t\tignoreNextTimeTick = false;\n\t\t\t\t\t} else if (pack.items.size >= MIN_ITEMS_IN_FRESH_PACK) {\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\tpack = createNextPack();\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst info = this.freshContent.get(identifier);\n\t\t\t\tif (info === undefined) continue;\n\t\t\t\tpack.items.add(identifier);\n\t\t\t\tpack.map.set(identifier, info.freshValue);\n\t\t\t\tinfo.location = pack.loc;\n\t\t\t\tinfo.freshValue = undefined;\n\t\t\t\tthis.freshContent.delete(identifier);\n\t\t\t\tif (++i > itemsPerPack) {\n\t\t\t\t\ti = 0;\n\t\t\t\t\tpack = createNextPack();\n\t\t\t\t\tignoreNextTimeTick = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.requests.length = 0;\n\t\t\tfor (const pack of packs) {\n\t\t\t\tthis.content[pack.loc] = new PackContent(\n\t\t\t\t\tpack.items,\n\t\t\t\t\tnew Set(pack.items),\n\t\t\t\t\tnew PackContentItems(pack.map)\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.logger.log(\n\t\t\t\t`${itemsCount} fresh items in cache put into pack ${\n\t\t\t\t\tpacks.length > 1\n\t\t\t\t\t\t? packs\n\t\t\t\t\t\t\t\t.map(pack => `${pack.loc} (${pack.items.size} items)`)\n\t\t\t\t\t\t\t\t.join(\", \")\n\t\t\t\t\t\t: packs[0].loc\n\t\t\t\t}`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Merges small content files to a single content file\n\t */\n\t_optimizeSmallContent() {\n\t\t// 1. Find all small content files\n\t\t// Treat unused content files separately to avoid\n\t\t// a merge-split cycle\n\t\t/** @type {number[]} */\n\t\tconst smallUsedContents = [];\n\t\t/** @type {number} */\n\t\tlet smallUsedContentSize = 0;\n\t\t/** @type {number[]} */\n\t\tconst smallUnusedContents = [];\n\t\t/** @type {number} */\n\t\tlet smallUnusedContentSize = 0;\n\t\tfor (let i = 0; i < this.content.length; i++) {\n\t\t\tconst content = this.content[i];\n\t\t\tif (content === undefined) continue;\n\t\t\tif (content.outdated) continue;\n\t\t\tconst size = content.getSize();\n\t\t\tif (size < 0 || size > MIN_CONTENT_SIZE) continue;\n\t\t\tif (content.used.size > 0) {\n\t\t\t\tsmallUsedContents.push(i);\n\t\t\t\tsmallUsedContentSize += size;\n\t\t\t} else {\n\t\t\t\tsmallUnusedContents.push(i);\n\t\t\t\tsmallUnusedContentSize += size;\n\t\t\t}\n\t\t}\n\n\t\t// 2. Check if minimum number is reached\n\t\tlet mergedIndices;\n\t\tif (\n\t\t\tsmallUsedContents.length >= CONTENT_COUNT_TO_MERGE ||\n\t\t\tsmallUsedContentSize > MIN_CONTENT_SIZE\n\t\t) {\n\t\t\tmergedIndices = smallUsedContents;\n\t\t} else if (\n\t\t\tsmallUnusedContents.length >= CONTENT_COUNT_TO_MERGE ||\n\t\t\tsmallUnusedContentSize > MIN_CONTENT_SIZE\n\t\t) {\n\t\t\tmergedIndices = smallUnusedContents;\n\t\t} else return;\n\n\t\tconst mergedContent = [];\n\n\t\t// 3. Remove old content entries\n\t\tfor (const i of mergedIndices) {\n\t\t\tmergedContent.push(this.content[i]);\n\t\t\tthis.content[i] = undefined;\n\t\t}\n\n\t\t// 4. Determine merged items\n\t\t/** @type {Set<string>} */\n\t\tconst mergedItems = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst mergedUsedItems = new Set();\n\t\t/** @type {(function(Map<string, any>): Promise)[]} */\n\t\tconst addToMergedMap = [];\n\t\tfor (const content of mergedContent) {\n\t\t\tfor (const identifier of content.items) {\n\t\t\t\tmergedItems.add(identifier);\n\t\t\t}\n\t\t\tfor (const identifier of content.used) {\n\t\t\t\tmergedUsedItems.add(identifier);\n\t\t\t}\n\t\t\taddToMergedMap.push(async map => {\n\t\t\t\t// unpack existing content\n\t\t\t\t// after that values are accessible in .content\n\t\t\t\tawait content.unpack(\n\t\t\t\t\t\"it should be merged with other small pack contents\"\n\t\t\t\t);\n\t\t\t\tfor (const [identifier, value] of content.content) {\n\t\t\t\t\tmap.set(identifier, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// 5. GC and update location of merged items\n\t\tconst newLoc = this._findLocation();\n\t\tthis._gcAndUpdateLocation(mergedItems, mergedUsedItems, newLoc);\n\n\t\t// 6. If not empty, store content somewhere\n\t\tif (mergedItems.size > 0) {\n\t\t\tthis.content[newLoc] = new PackContent(\n\t\t\t\tmergedItems,\n\t\t\t\tmergedUsedItems,\n\t\t\t\tmemoize(async () => {\n\t\t\t\t\t/** @type {Map<string, any>} */\n\t\t\t\t\tconst map = new Map();\n\t\t\t\t\tawait Promise.all(addToMergedMap.map(fn => fn(map)));\n\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.logger.log(\n\t\t\t\t\"Merged %d small files with %d cache items into pack %d\",\n\t\t\t\tmergedContent.length,\n\t\t\t\tmergedItems.size,\n\t\t\t\tnewLoc\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Split large content files with used and unused items\n\t * into two parts to separate used from unused items\n\t */\n\t_optimizeUnusedContent() {\n\t\t// 1. Find a large content file with used and unused items\n\t\tfor (let i = 0; i < this.content.length; i++) {\n\t\t\tconst content = this.content[i];\n\t\t\tif (content === undefined) continue;\n\t\t\tconst size = content.getSize();\n\t\t\tif (size < MIN_CONTENT_SIZE) continue;\n\t\t\tconst used = content.used.size;\n\t\t\tconst total = content.items.size;\n\t\t\tif (used > 0 && used < total) {\n\t\t\t\t// 2. Remove this content\n\t\t\t\tthis.content[i] = undefined;\n\n\t\t\t\t// 3. Determine items for the used content file\n\t\t\t\tconst usedItems = new Set(content.used);\n\t\t\t\tconst newLoc = this._findLocation();\n\t\t\t\tthis._gcAndUpdateLocation(usedItems, usedItems, newLoc);\n\n\t\t\t\t// 4. Create content file for used items\n\t\t\t\tif (usedItems.size > 0) {\n\t\t\t\t\tthis.content[newLoc] = new PackContent(\n\t\t\t\t\t\tusedItems,\n\t\t\t\t\t\tnew Set(usedItems),\n\t\t\t\t\t\tasync () => {\n\t\t\t\t\t\t\tawait content.unpack(\n\t\t\t\t\t\t\t\t\"it should be splitted into used and unused items\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst map = new Map();\n\t\t\t\t\t\t\tfor (const identifier of usedItems) {\n\t\t\t\t\t\t\t\tmap.set(identifier, content.content.get(identifier));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// 5. Determine items for the unused content file\n\t\t\t\tconst unusedItems = new Set(content.items);\n\t\t\t\tconst usedOfUnusedItems = new Set();\n\t\t\t\tfor (const identifier of usedItems) {\n\t\t\t\t\tunusedItems.delete(identifier);\n\t\t\t\t}\n\t\t\t\tconst newUnusedLoc = this._findLocation();\n\t\t\t\tthis._gcAndUpdateLocation(unusedItems, usedOfUnusedItems, newUnusedLoc);\n\n\t\t\t\t// 6. Create content file for unused items\n\t\t\t\tif (unusedItems.size > 0) {\n\t\t\t\t\tthis.content[newUnusedLoc] = new PackContent(\n\t\t\t\t\t\tunusedItems,\n\t\t\t\t\t\tusedOfUnusedItems,\n\t\t\t\t\t\tasync () => {\n\t\t\t\t\t\t\tawait content.unpack(\n\t\t\t\t\t\t\t\t\"it should be splitted into used and unused items\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst map = new Map();\n\t\t\t\t\t\t\tfor (const identifier of unusedItems) {\n\t\t\t\t\t\t\t\tmap.set(identifier, content.content.get(identifier));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthis.logger.log(\n\t\t\t\t\t\"Split pack %d into pack %d with %d used items and pack %d with %d unused items\",\n\t\t\t\t\ti,\n\t\t\t\t\tnewLoc,\n\t\t\t\t\tusedItems.size,\n\t\t\t\t\tnewUnusedLoc,\n\t\t\t\t\tunusedItems.size\n\t\t\t\t);\n\n\t\t\t\t// optimizing only one of them is good enough and\n\t\t\t\t// reduces the amount of serialization needed\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Find the content with the oldest item and run GC on that.\n\t * Only runs for one content to avoid large invalidation.\n\t */\n\t_gcOldestContent() {\n\t\t/** @type {PackItemInfo} */\n\t\tlet oldest = undefined;\n\t\tfor (const info of this.itemInfo.values()) {\n\t\t\tif (oldest === undefined || info.lastAccess < oldest.lastAccess) {\n\t\t\t\toldest = info;\n\t\t\t}\n\t\t}\n\t\tif (Date.now() - oldest.lastAccess > this.maxAge) {\n\t\t\tconst loc = oldest.location;\n\t\t\tif (loc < 0) return;\n\t\t\tconst content = this.content[loc];\n\t\t\tconst items = new Set(content.items);\n\t\t\tconst usedItems = new Set(content.used);\n\t\t\tthis._gcAndUpdateLocation(items, usedItems, loc);\n\n\t\t\tthis.content[loc] =\n\t\t\t\titems.size > 0\n\t\t\t\t\t? new PackContent(items, usedItems, async () => {\n\t\t\t\t\t\t\tawait content.unpack(\n\t\t\t\t\t\t\t\t\"it contains old items that should be garbage collected\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst map = new Map();\n\t\t\t\t\t\t\tfor (const identifier of items) {\n\t\t\t\t\t\t\t\tmap.set(identifier, content.content.get(identifier));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t\t  })\n\t\t\t\t\t: undefined;\n\t\t}\n\t}\n\n\tserialize({ write, writeSeparate }) {\n\t\tthis._persistFreshContent();\n\t\tthis._optimizeSmallContent();\n\t\tthis._optimizeUnusedContent();\n\t\tthis._gcOldestContent();\n\t\tfor (const identifier of this.itemInfo.keys()) {\n\t\t\twrite(identifier);\n\t\t}\n\t\twrite(null); // null as marker of the end of keys\n\t\tfor (const info of this.itemInfo.values()) {\n\t\t\twrite(info.etag);\n\t\t}\n\t\tfor (const info of this.itemInfo.values()) {\n\t\t\twrite(info.lastAccess);\n\t\t}\n\t\tfor (let i = 0; i < this.content.length; i++) {\n\t\t\tconst content = this.content[i];\n\t\t\tif (content !== undefined) {\n\t\t\t\twrite(content.items);\n\t\t\t\tcontent.writeLazy(lazy => writeSeparate(lazy, { name: `${i}` }));\n\t\t\t} else {\n\t\t\t\twrite(undefined); // undefined marks an empty content slot\n\t\t\t}\n\t\t}\n\t\twrite(null); // null as marker of the end of items\n\t}\n\n\tdeserialize({ read, logger }) {\n\t\tthis.logger = logger;\n\t\t{\n\t\t\tconst items = [];\n\t\t\tlet item = read();\n\t\t\twhile (item !== null) {\n\t\t\t\titems.push(item);\n\t\t\t\titem = read();\n\t\t\t}\n\t\t\tthis.itemInfo.clear();\n\t\t\tconst infoItems = items.map(identifier => {\n\t\t\t\tconst info = new PackItemInfo(identifier, undefined, undefined);\n\t\t\t\tthis.itemInfo.set(identifier, info);\n\t\t\t\treturn info;\n\t\t\t});\n\t\t\tfor (const info of infoItems) {\n\t\t\t\tinfo.etag = read();\n\t\t\t}\n\t\t\tfor (const info of infoItems) {\n\t\t\t\tinfo.lastAccess = read();\n\t\t\t}\n\t\t}\n\t\tthis.content.length = 0;\n\t\tlet items = read();\n\t\twhile (items !== null) {\n\t\t\tif (items === undefined) {\n\t\t\t\tthis.content.push(items);\n\t\t\t} else {\n\t\t\t\tconst idx = this.content.length;\n\t\t\t\tconst lazy = read();\n\t\t\t\tthis.content.push(\n\t\t\t\t\tnew PackContent(\n\t\t\t\t\t\titems,\n\t\t\t\t\t\tnew Set(),\n\t\t\t\t\t\tlazy,\n\t\t\t\t\t\tlogger,\n\t\t\t\t\t\t`${this.content.length}`\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tfor (const identifier of items) {\n\t\t\t\t\tthis.itemInfo.get(identifier).location = idx;\n\t\t\t\t}\n\t\t\t}\n\t\t\titems = read();\n\t\t}\n\t}\n}\n\nmakeSerializable(Pack, \"webpack/lib/cache/PackFileCacheStrategy\", \"Pack\");\n\nclass PackContentItems {\n\t/**\n\t * @param {Map<string, any>} map items\n\t */\n\tconstructor(map) {\n\t\tthis.map = map;\n\t}\n\n\tserialize({ write, snapshot, rollback, logger, profile }) {\n\t\tif (profile) {\n\t\t\twrite(false);\n\t\t\tfor (const [key, value] of this.map) {\n\t\t\t\tconst s = snapshot();\n\t\t\t\ttry {\n\t\t\t\t\twrite(key);\n\t\t\t\t\tconst start = process.hrtime();\n\t\t\t\t\twrite(value);\n\t\t\t\t\tconst durationHr = process.hrtime(start);\n\t\t\t\t\tconst duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n\t\t\t\t\tif (duration > 1) {\n\t\t\t\t\t\tif (duration > 500)\n\t\t\t\t\t\t\tlogger.error(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse if (duration > 50)\n\t\t\t\t\t\t\tlogger.warn(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse if (duration > 10)\n\t\t\t\t\t\t\tlogger.info(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse if (duration > 5)\n\t\t\t\t\t\t\tlogger.log(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse logger.debug(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\trollback(s);\n\t\t\t\t\tif (e === NOT_SERIALIZABLE) continue;\n\t\t\t\t\tconst msg = \"Skipped not serializable cache item\";\n\t\t\t\t\tif (e.message.includes(\"ModuleBuildError\")) {\n\t\t\t\t\t\tlogger.log(`${msg} (in build error): ${e.message}`);\n\t\t\t\t\t\tlogger.debug(`${msg} '${key}' (in build error): ${e.stack}`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.warn(`${msg}: ${e.message}`);\n\t\t\t\t\t\tlogger.debug(`${msg} '${key}': ${e.stack}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite(null);\n\t\t\treturn;\n\t\t}\n\t\t// Try to serialize all at once\n\t\tconst s = snapshot();\n\t\ttry {\n\t\t\twrite(true);\n\t\t\twrite(this.map);\n\t\t} catch (e) {\n\t\t\trollback(s);\n\n\t\t\t// Try to serialize each item on it's own\n\t\t\twrite(false);\n\t\t\tfor (const [key, value] of this.map) {\n\t\t\t\tconst s = snapshot();\n\t\t\t\ttry {\n\t\t\t\t\twrite(key);\n\t\t\t\t\twrite(value);\n\t\t\t\t} catch (e) {\n\t\t\t\t\trollback(s);\n\t\t\t\t\tif (e === NOT_SERIALIZABLE) continue;\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Skipped not serializable cache item '${key}': ${e.message}`\n\t\t\t\t\t);\n\t\t\t\t\tlogger.debug(e.stack);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite(null);\n\t\t}\n\t}\n\n\tdeserialize({ read, logger, profile }) {\n\t\tif (read()) {\n\t\t\tthis.map = read();\n\t\t} else if (profile) {\n\t\t\tconst map = new Map();\n\t\t\tlet key = read();\n\t\t\twhile (key !== null) {\n\t\t\t\tconst start = process.hrtime();\n\t\t\t\tconst value = read();\n\t\t\t\tconst durationHr = process.hrtime(start);\n\t\t\t\tconst duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n\t\t\t\tif (duration > 1) {\n\t\t\t\t\tif (duration > 100)\n\t\t\t\t\t\tlogger.error(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse if (duration > 20)\n\t\t\t\t\t\tlogger.warn(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse if (duration > 5)\n\t\t\t\t\t\tlogger.info(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse if (duration > 2)\n\t\t\t\t\t\tlogger.log(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse logger.debug(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t}\n\t\t\t\tmap.set(key, value);\n\t\t\t\tkey = read();\n\t\t\t}\n\t\t\tthis.map = map;\n\t\t} else {\n\t\t\tconst map = new Map();\n\t\t\tlet key = read();\n\t\t\twhile (key !== null) {\n\t\t\t\tmap.set(key, read());\n\t\t\t\tkey = read();\n\t\t\t}\n\t\t\tthis.map = map;\n\t\t}\n\t}\n}\n\nmakeSerializable(\n\tPackContentItems,\n\t\"webpack/lib/cache/PackFileCacheStrategy\",\n\t\"PackContentItems\"\n);\n\nclass PackContent {\n\t/*\n\t\tThis class can be in these states:\n\t\t   |   this.lazy    | this.content | this.outdated | state\n\t\tA1 |   undefined    |     Map      |     false     | fresh content\n\t\tA2 |   undefined    |     Map      |     true      | (will not happen)\n\t\tB1 | lazy () => {}  |  undefined   |     false     | not deserialized\n\t\tB2 | lazy () => {}  |  undefined   |     true      | not deserialized, but some items has been removed\n\t\tC1 | lazy* () => {} |     Map      |     false     | deserialized\n\t\tC2 | lazy* () => {} |     Map      |     true      | deserialized, and some items has been removed\n\n\t\tthis.used is a subset of this.items.\n\t\tthis.items is a subset of this.content.keys() resp. this.lazy().map.keys()\n\t\tWhen this.outdated === false, this.items === this.content.keys() resp. this.lazy().map.keys()\n\t\tWhen this.outdated === true, this.items should be used to recreated this.lazy/this.content.\n\t\tWhen this.lazy and this.content is set, they contain the same data.\n\t\tthis.get must only be called with a valid item from this.items.\n\t\tIn state C this.lazy is unMemoized\n\t*/\n\n\t/**\n\t * @param {Set<string>} items keys\n\t * @param {Set<string>} usedItems used keys\n\t * @param {PackContentItems | function(): Promise<PackContentItems>} dataOrFn sync or async content\n\t * @param {Logger=} logger logger for logging\n\t * @param {string=} lazyName name of dataOrFn for logging\n\t */\n\tconstructor(items, usedItems, dataOrFn, logger, lazyName) {\n\t\tthis.items = items;\n\t\t/** @type {function(): Promise<PackContentItems> | PackContentItems} */\n\t\tthis.lazy = typeof dataOrFn === \"function\" ? dataOrFn : undefined;\n\t\t/** @type {Map<string, any>} */\n\t\tthis.content = typeof dataOrFn === \"function\" ? undefined : dataOrFn.map;\n\t\tthis.outdated = false;\n\t\tthis.used = usedItems;\n\t\tthis.logger = logger;\n\t\tthis.lazyName = lazyName;\n\t}\n\n\tget(identifier) {\n\t\tthis.used.add(identifier);\n\t\tif (this.content) {\n\t\t\treturn this.content.get(identifier);\n\t\t}\n\n\t\t// We are in state B\n\t\tconst { lazyName } = this;\n\t\tlet timeMessage;\n\t\tif (lazyName) {\n\t\t\t// only log once\n\t\t\tthis.lazyName = undefined;\n\t\t\ttimeMessage = `restore cache content ${lazyName} (${formatSize(\n\t\t\t\tthis.getSize()\n\t\t\t)})`;\n\t\t\tthis.logger.log(\n\t\t\t\t`starting to restore cache content ${lazyName} (${formatSize(\n\t\t\t\t\tthis.getSize()\n\t\t\t\t)}) because of request to: ${identifier}`\n\t\t\t);\n\t\t\tthis.logger.time(timeMessage);\n\t\t}\n\t\tconst value = this.lazy();\n\t\tif (\"then\" in value) {\n\t\t\treturn value.then(data => {\n\t\t\t\tconst map = data.map;\n\t\t\t\tif (timeMessage) {\n\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t}\n\t\t\t\t// Move to state C\n\t\t\t\tthis.content = map;\n\t\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n\t\t\t\treturn map.get(identifier);\n\t\t\t});\n\t\t} else {\n\t\t\tconst map = value.map;\n\t\t\tif (timeMessage) {\n\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t}\n\t\t\t// Move to state C\n\t\t\tthis.content = map;\n\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n\t\t\treturn map.get(identifier);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} reason explanation why unpack is necessary\n\t * @returns {void | Promise} maybe a promise if lazy\n\t */\n\tunpack(reason) {\n\t\tif (this.content) return;\n\n\t\t// Move from state B to C\n\t\tif (this.lazy) {\n\t\t\tconst { lazyName } = this;\n\t\t\tlet timeMessage;\n\t\t\tif (lazyName) {\n\t\t\t\t// only log once\n\t\t\t\tthis.lazyName = undefined;\n\t\t\t\ttimeMessage = `unpack cache content ${lazyName} (${formatSize(\n\t\t\t\t\tthis.getSize()\n\t\t\t\t)})`;\n\t\t\t\tthis.logger.log(\n\t\t\t\t\t`starting to unpack cache content ${lazyName} (${formatSize(\n\t\t\t\t\t\tthis.getSize()\n\t\t\t\t\t)}) because ${reason}`\n\t\t\t\t);\n\t\t\t\tthis.logger.time(timeMessage);\n\t\t\t}\n\t\t\tconst value = this.lazy();\n\t\t\tif (\"then\" in value) {\n\t\t\t\treturn value.then(data => {\n\t\t\t\t\tif (timeMessage) {\n\t\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t\t}\n\t\t\t\t\tthis.content = data.map;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (timeMessage) {\n\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t}\n\t\t\t\tthis.content = value.map;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @returns {number} size of the content or -1 if not known\n\t */\n\tgetSize() {\n\t\tif (!this.lazy) return -1;\n\t\tconst options = /** @type {any} */ (this.lazy).options;\n\t\tif (!options) return -1;\n\t\tconst size = options.size;\n\t\tif (typeof size !== \"number\") return -1;\n\t\treturn size;\n\t}\n\n\tdelete(identifier) {\n\t\tthis.items.delete(identifier);\n\t\tthis.used.delete(identifier);\n\t\tthis.outdated = true;\n\t}\n\n\t/**\n\t * @template T\n\t * @param {function(any): function(): Promise<PackContentItems> | PackContentItems} write write function\n\t * @returns {void}\n\t */\n\twriteLazy(write) {\n\t\tif (!this.outdated && this.lazy) {\n\t\t\t// State B1 or C1\n\t\t\t// this.lazy is still the valid deserialized version\n\t\t\twrite(this.lazy);\n\t\t\treturn;\n\t\t}\n\t\tif (!this.outdated && this.content) {\n\t\t\t// State A1\n\t\t\tconst map = new Map(this.content);\n\t\t\t// Move to state C1\n\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(\n\t\t\t\twrite(() => new PackContentItems(map))\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\tif (this.content) {\n\t\t\t// State A2 or C2\n\t\t\t/** @type {Map<string, any>} */\n\t\t\tconst map = new Map();\n\t\t\tfor (const item of this.items) {\n\t\t\t\tmap.set(item, this.content.get(item));\n\t\t\t}\n\t\t\t// Move to state C1\n\t\t\tthis.outdated = false;\n\t\t\tthis.content = map;\n\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(\n\t\t\t\twrite(() => new PackContentItems(map))\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\t// State B2\n\t\tconst { lazyName } = this;\n\t\tlet timeMessage;\n\t\tif (lazyName) {\n\t\t\t// only log once\n\t\t\tthis.lazyName = undefined;\n\t\t\ttimeMessage = `unpack cache content ${lazyName} (${formatSize(\n\t\t\t\tthis.getSize()\n\t\t\t)})`;\n\t\t\tthis.logger.log(\n\t\t\t\t`starting to unpack cache content ${lazyName} (${formatSize(\n\t\t\t\t\tthis.getSize()\n\t\t\t\t)}) because it's outdated and need to be serialized`\n\t\t\t);\n\t\t\tthis.logger.time(timeMessage);\n\t\t}\n\t\tconst value = this.lazy();\n\t\tthis.outdated = false;\n\t\tif (\"then\" in value) {\n\t\t\t// Move to state B1\n\t\t\tthis.lazy = write(() =>\n\t\t\t\tvalue.then(data => {\n\t\t\t\t\tif (timeMessage) {\n\t\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t\t}\n\t\t\t\t\tconst oldMap = data.map;\n\t\t\t\t\t/** @type {Map<string, any>} */\n\t\t\t\t\tconst map = new Map();\n\t\t\t\t\tfor (const item of this.items) {\n\t\t\t\t\t\tmap.set(item, oldMap.get(item));\n\t\t\t\t\t}\n\t\t\t\t\t// Move to state C1 (or maybe C2)\n\t\t\t\t\tthis.content = map;\n\t\t\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n\n\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t})\n\t\t\t);\n\t\t} else {\n\t\t\t// Move to state C1\n\t\t\tif (timeMessage) {\n\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t}\n\t\t\tconst oldMap = value.map;\n\t\t\t/** @type {Map<string, any>} */\n\t\t\tconst map = new Map();\n\t\t\tfor (const item of this.items) {\n\t\t\t\tmap.set(item, oldMap.get(item));\n\t\t\t}\n\t\t\tthis.content = map;\n\t\t\tthis.lazy = write(() => new PackContentItems(map));\n\t\t}\n\t}\n}\n\nconst allowCollectingMemory = buf => {\n\tconst wasted = buf.buffer.byteLength - buf.byteLength;\n\tif (wasted > 8192 && (wasted > 1048576 || wasted > buf.byteLength)) {\n\t\treturn Buffer.from(buf);\n\t}\n\treturn buf;\n};\n\nclass PackFileCacheStrategy {\n\t/**\n\t * @param {Object} options options\n\t * @param {Compiler} options.compiler the compiler\n\t * @param {IntermediateFileSystem} options.fs the filesystem\n\t * @param {string} options.context the context directory\n\t * @param {string} options.cacheLocation the location of the cache data\n\t * @param {string} options.version version identifier\n\t * @param {Logger} options.logger a logger\n\t * @param {SnapshotOptions} options.snapshot options regarding snapshotting\n\t * @param {number} options.maxAge max age of cache items\n\t * @param {boolean} options.profile track and log detailed timing information for individual cache items\n\t * @param {boolean} options.allowCollectingMemory allow to collect unused memory created during deserialization\n\t * @param {false | \"gzip\" | \"brotli\"} options.compression compression used\n\t */\n\tconstructor({\n\t\tcompiler,\n\t\tfs,\n\t\tcontext,\n\t\tcacheLocation,\n\t\tversion,\n\t\tlogger,\n\t\tsnapshot,\n\t\tmaxAge,\n\t\tprofile,\n\t\tallowCollectingMemory,\n\t\tcompression\n\t}) {\n\t\tthis.fileSerializer = createFileSerializer(\n\t\t\tfs,\n\t\t\tcompiler.options.output.hashFunction\n\t\t);\n\t\tthis.fileSystemInfo = new FileSystemInfo(fs, {\n\t\t\tmanagedPaths: snapshot.managedPaths,\n\t\t\timmutablePaths: snapshot.immutablePaths,\n\t\t\tlogger: logger.getChildLogger(\"webpack.FileSystemInfo\"),\n\t\t\thashFunction: compiler.options.output.hashFunction\n\t\t});\n\t\tthis.compiler = compiler;\n\t\tthis.context = context;\n\t\tthis.cacheLocation = cacheLocation;\n\t\tthis.version = version;\n\t\tthis.logger = logger;\n\t\tthis.maxAge = maxAge;\n\t\tthis.profile = profile;\n\t\tthis.allowCollectingMemory = allowCollectingMemory;\n\t\tthis.compression = compression;\n\t\tthis._extension =\n\t\t\tcompression === \"brotli\"\n\t\t\t\t? \".pack.br\"\n\t\t\t\t: compression === \"gzip\"\n\t\t\t\t? \".pack.gz\"\n\t\t\t\t: \".pack\";\n\t\tthis.snapshot = snapshot;\n\t\t/** @type {Set<string>} */\n\t\tthis.buildDependencies = new Set();\n\t\t/** @type {LazySet<string>} */\n\t\tthis.newBuildDependencies = new LazySet();\n\t\t/** @type {Snapshot} */\n\t\tthis.resolveBuildDependenciesSnapshot = undefined;\n\t\t/** @type {Map<string, string | false>} */\n\t\tthis.resolveResults = undefined;\n\t\t/** @type {Snapshot} */\n\t\tthis.buildSnapshot = undefined;\n\t\t/** @type {Promise<Pack>} */\n\t\tthis.packPromise = this._openPack();\n\t\tthis.storePromise = Promise.resolve();\n\t}\n\n\t_getPack() {\n\t\tif (this.packPromise === undefined) {\n\t\t\tthis.packPromise = this.storePromise.then(() => this._openPack());\n\t\t}\n\t\treturn this.packPromise;\n\t}\n\n\t/**\n\t * @returns {Promise<Pack>} the pack\n\t */\n\t_openPack() {\n\t\tconst { logger, profile, cacheLocation, version } = this;\n\t\t/** @type {Snapshot} */\n\t\tlet buildSnapshot;\n\t\t/** @type {Set<string>} */\n\t\tlet buildDependencies;\n\t\t/** @type {Set<string>} */\n\t\tlet newBuildDependencies;\n\t\t/** @type {Snapshot} */\n\t\tlet resolveBuildDependenciesSnapshot;\n\t\t/** @type {Map<string, string | false>} */\n\t\tlet resolveResults;\n\t\tlogger.time(\"restore cache container\");\n\t\treturn this.fileSerializer\n\t\t\t.deserialize(null, {\n\t\t\t\tfilename: `${cacheLocation}/index${this._extension}`,\n\t\t\t\textension: `${this._extension}`,\n\t\t\t\tlogger,\n\t\t\t\tprofile,\n\t\t\t\tretainedBuffer: this.allowCollectingMemory\n\t\t\t\t\t? allowCollectingMemory\n\t\t\t\t\t: undefined\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tif (err.code !== \"ENOENT\") {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Restoring pack failed from ${cacheLocation}${this._extension}: ${err}`\n\t\t\t\t\t);\n\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`No pack exists at ${cacheLocation}${this._extension}: ${err}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t})\n\t\t\t.then(packContainer => {\n\t\t\t\tlogger.timeEnd(\"restore cache container\");\n\t\t\t\tif (!packContainer) return undefined;\n\t\t\t\tif (!(packContainer instanceof PackContainer)) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but contained content is unexpected.`,\n\t\t\t\t\t\tpackContainer\n\t\t\t\t\t);\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif (packContainer.version !== version) {\n\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but version doesn't match.`\n\t\t\t\t\t);\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tlogger.time(\"check build dependencies\");\n\t\t\t\treturn Promise.all([\n\t\t\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t\t\tthis.fileSystemInfo.checkSnapshotValid(\n\t\t\t\t\t\t\tpackContainer.buildSnapshot,\n\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of build dependencies errored: ${err}.`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but build dependencies have changed.`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbuildSnapshot = packContainer.buildSnapshot;\n\t\t\t\t\t\t\t\treturn resolve(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}),\n\t\t\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t\t\tthis.fileSystemInfo.checkSnapshotValid(\n\t\t\t\t\t\t\tpackContainer.resolveBuildDependenciesSnapshot,\n\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of resolving of build dependencies errored: ${err}.`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\t\tresolveBuildDependenciesSnapshot =\n\t\t\t\t\t\t\t\t\t\tpackContainer.resolveBuildDependenciesSnapshot;\n\t\t\t\t\t\t\t\t\tbuildDependencies = packContainer.buildDependencies;\n\t\t\t\t\t\t\t\t\tresolveResults = packContainer.resolveResults;\n\t\t\t\t\t\t\t\t\treturn resolve(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\"resolving of build dependencies is invalid, will re-resolve build dependencies\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tthis.fileSystemInfo.checkResolveResultsValid(\n\t\t\t\t\t\t\t\t\tpackContainer.resolveResults,\n\t\t\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but resolving of build dependencies errored: ${err}.`\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\t\t\t\tnewBuildDependencies = packContainer.buildDependencies;\n\t\t\t\t\t\t\t\t\t\t\tresolveResults = packContainer.resolveResults;\n\t\t\t\t\t\t\t\t\t\t\treturn resolve(true);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but build dependencies resolve to different locations.`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t})\n\t\t\t\t])\n\t\t\t\t\t.catch(err => {\n\t\t\t\t\t\tlogger.timeEnd(\"check build dependencies\");\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t})\n\t\t\t\t\t.then(([buildSnapshotValid, resolveValid]) => {\n\t\t\t\t\t\tlogger.timeEnd(\"check build dependencies\");\n\t\t\t\t\t\tif (buildSnapshotValid && resolveValid) {\n\t\t\t\t\t\t\tlogger.time(\"restore cache content metadata\");\n\t\t\t\t\t\t\tconst d = packContainer.data();\n\t\t\t\t\t\t\tlogger.timeEnd(\"restore cache content metadata\");\n\t\t\t\t\t\t\treturn d;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t});\n\t\t\t})\n\t\t\t.then(pack => {\n\t\t\t\tif (pack) {\n\t\t\t\t\tpack.maxAge = this.maxAge;\n\t\t\t\t\tthis.buildSnapshot = buildSnapshot;\n\t\t\t\t\tif (buildDependencies) this.buildDependencies = buildDependencies;\n\t\t\t\t\tif (newBuildDependencies)\n\t\t\t\t\t\tthis.newBuildDependencies.addAll(newBuildDependencies);\n\t\t\t\t\tthis.resolveResults = resolveResults;\n\t\t\t\t\tthis.resolveBuildDependenciesSnapshot =\n\t\t\t\t\t\tresolveBuildDependenciesSnapshot;\n\t\t\t\t\treturn pack;\n\t\t\t\t}\n\t\t\t\treturn new Pack(logger, this.maxAge);\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tthis.logger.warn(\n\t\t\t\t\t`Restoring pack from ${cacheLocation}${this._extension} failed: ${err}`\n\t\t\t\t);\n\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t\treturn new Pack(logger, this.maxAge);\n\t\t\t});\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {Etag | null} etag etag of the resource\n\t * @param {any} data cached content\n\t * @returns {Promise<void>} promise\n\t */\n\tstore(identifier, etag, data) {\n\t\treturn this._getPack().then(pack => {\n\t\t\tpack.set(identifier, etag === null ? null : etag.toString(), data);\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {Etag | null} etag etag of the resource\n\t * @returns {Promise<any>} promise to the cached content\n\t */\n\trestore(identifier, etag) {\n\t\treturn this._getPack()\n\t\t\t.then(pack =>\n\t\t\t\tpack.get(identifier, etag === null ? null : etag.toString())\n\t\t\t)\n\t\t\t.catch(err => {\n\t\t\t\tif (err && err.code !== \"ENOENT\") {\n\t\t\t\t\tthis.logger.warn(\n\t\t\t\t\t\t`Restoring failed for ${identifier} from pack: ${err}`\n\t\t\t\t\t);\n\t\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\tstoreBuildDependencies(dependencies) {\n\t\tthis.newBuildDependencies.addAll(dependencies);\n\t}\n\n\tafterAllStored() {\n\t\tconst packPromise = this.packPromise;\n\t\tif (packPromise === undefined) return Promise.resolve();\n\t\tconst reportProgress = ProgressPlugin.getReporter(this.compiler);\n\t\treturn (this.storePromise = packPromise\n\t\t\t.then(pack => {\n\t\t\t\tpack.stopCapturingRequests();\n\t\t\t\tif (!pack.invalid) return;\n\t\t\t\tthis.packPromise = undefined;\n\t\t\t\tthis.logger.log(`Storing pack...`);\n\t\t\t\tlet promise;\n\t\t\t\tconst newBuildDependencies = new Set();\n\t\t\t\tfor (const dep of this.newBuildDependencies) {\n\t\t\t\t\tif (!this.buildDependencies.has(dep)) {\n\t\t\t\t\t\tnewBuildDependencies.add(dep);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (newBuildDependencies.size > 0 || !this.buildSnapshot) {\n\t\t\t\t\tif (reportProgress) reportProgress(0.5, \"resolve build dependencies\");\n\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t`Capturing build dependencies... (${Array.from(\n\t\t\t\t\t\t\tnewBuildDependencies\n\t\t\t\t\t\t).join(\", \")})`\n\t\t\t\t\t);\n\t\t\t\t\tpromise = new Promise((resolve, reject) => {\n\t\t\t\t\t\tthis.logger.time(\"resolve build dependencies\");\n\t\t\t\t\t\tthis.fileSystemInfo.resolveBuildDependencies(\n\t\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\t\tnewBuildDependencies,\n\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"resolve build dependencies\");\n\t\t\t\t\t\t\t\tif (err) return reject(err);\n\n\t\t\t\t\t\t\t\tthis.logger.time(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\t\tfiles,\n\t\t\t\t\t\t\t\t\tdirectories,\n\t\t\t\t\t\t\t\t\tmissing,\n\t\t\t\t\t\t\t\t\tresolveResults,\n\t\t\t\t\t\t\t\t\tresolveDependencies\n\t\t\t\t\t\t\t\t} = result;\n\t\t\t\t\t\t\t\tif (this.resolveResults) {\n\t\t\t\t\t\t\t\t\tfor (const [key, value] of resolveResults) {\n\t\t\t\t\t\t\t\t\t\tthis.resolveResults.set(key, value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis.resolveResults = resolveResults;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (reportProgress) {\n\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t0.6,\n\t\t\t\t\t\t\t\t\t\t\"snapshot build dependencies\",\n\t\t\t\t\t\t\t\t\t\t\"resolving\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.fileSystemInfo.createSnapshot(\n\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\tresolveDependencies.files,\n\t\t\t\t\t\t\t\t\tresolveDependencies.directories,\n\t\t\t\t\t\t\t\t\tresolveDependencies.missing,\n\t\t\t\t\t\t\t\t\tthis.snapshot.resolveBuildDependencies,\n\t\t\t\t\t\t\t\t\t(err, snapshot) => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!snapshot) {\n\t\t\t\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\t\t\t\treturn reject(\n\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\"Unable to snapshot resolve dependencies\")\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (this.resolveBuildDependenciesSnapshot) {\n\t\t\t\t\t\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot =\n\t\t\t\t\t\t\t\t\t\t\t\tthis.fileSystemInfo.mergeSnapshots(\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot = snapshot;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (reportProgress) {\n\t\t\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t\t\t0.7,\n\t\t\t\t\t\t\t\t\t\t\t\t\"snapshot build dependencies\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"modules\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tthis.fileSystemInfo.createSnapshot(\n\t\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\t\tfiles,\n\t\t\t\t\t\t\t\t\t\t\tdirectories,\n\t\t\t\t\t\t\t\t\t\t\tmissing,\n\t\t\t\t\t\t\t\t\t\t\tthis.snapshot.buildDependencies,\n\t\t\t\t\t\t\t\t\t\t\t(err, snapshot) => {\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) return reject(err);\n\t\t\t\t\t\t\t\t\t\t\t\tif (!snapshot) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn reject(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\"Unable to snapshot build dependencies\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\"Captured build dependencies\");\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (this.buildSnapshot) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.buildSnapshot =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.fileSystemInfo.mergeSnapshots(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.buildSnapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.buildSnapshot = snapshot;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tpromise = Promise.resolve();\n\t\t\t\t}\n\t\t\t\treturn promise.then(() => {\n\t\t\t\t\tif (reportProgress) reportProgress(0.8, \"serialize pack\");\n\t\t\t\t\tthis.logger.time(`store pack`);\n\t\t\t\t\tconst updatedBuildDependencies = new Set(this.buildDependencies);\n\t\t\t\t\tfor (const dep of newBuildDependencies) {\n\t\t\t\t\t\tupdatedBuildDependencies.add(dep);\n\t\t\t\t\t}\n\t\t\t\t\tconst content = new PackContainer(\n\t\t\t\t\t\tpack,\n\t\t\t\t\t\tthis.version,\n\t\t\t\t\t\tthis.buildSnapshot,\n\t\t\t\t\t\tupdatedBuildDependencies,\n\t\t\t\t\t\tthis.resolveResults,\n\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot\n\t\t\t\t\t);\n\t\t\t\t\treturn this.fileSerializer\n\t\t\t\t\t\t.serialize(content, {\n\t\t\t\t\t\t\tfilename: `${this.cacheLocation}/index${this._extension}`,\n\t\t\t\t\t\t\textension: `${this._extension}`,\n\t\t\t\t\t\t\tlogger: this.logger,\n\t\t\t\t\t\t\tprofile: this.profile\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\tfor (const dep of newBuildDependencies) {\n\t\t\t\t\t\t\t\tthis.buildDependencies.add(dep);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.newBuildDependencies.clear();\n\t\t\t\t\t\t\tthis.logger.timeEnd(`store pack`);\n\t\t\t\t\t\t\tconst stats = pack.getContentStats();\n\t\t\t\t\t\t\tthis.logger.log(\n\t\t\t\t\t\t\t\t\"Stored pack (%d items, %d files, %d MiB)\",\n\t\t\t\t\t\t\t\tpack.itemInfo.size,\n\t\t\t\t\t\t\t\tstats.count,\n\t\t\t\t\t\t\t\tMath.round(stats.size / 1024 / 1024)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(err => {\n\t\t\t\t\t\t\tthis.logger.timeEnd(`store pack`);\n\t\t\t\t\t\t\tthis.logger.warn(`Caching failed for pack: ${err}`);\n\t\t\t\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tthis.logger.warn(`Caching failed for pack: ${err}`);\n\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t}));\n\t}\n\n\tclear() {\n\t\tthis.fileSystemInfo.clear();\n\t\tthis.buildDependencies.clear();\n\t\tthis.newBuildDependencies.clear();\n\t\tthis.resolveBuildDependenciesSnapshot = undefined;\n\t\tthis.resolveResults = undefined;\n\t\tthis.buildSnapshot = undefined;\n\t\tthis.packPromise = undefined;\n\t}\n}\n\nmodule.exports = PackFileCacheStrategy;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}