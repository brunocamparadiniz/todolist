{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar Cache = require(\"../Cache\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\nvar MemoryWithGcCachePlugin = /*#__PURE__*/function () {\n  function MemoryWithGcCachePlugin(_ref) {\n    var maxGenerations = _ref.maxGenerations;\n    _classCallCheck(this, MemoryWithGcCachePlugin);\n    this._maxGenerations = maxGenerations;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  _createClass(MemoryWithGcCachePlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var maxGenerations = this._maxGenerations;\n      /** @type {Map<string, { etag: Etag | null, data: any }>} */\n      var cache = new Map();\n      /** @type {Map<string, { entry: { etag: Etag | null, data: any }, until: number }>} */\n      var oldCache = new Map();\n      var generation = 0;\n      var cachePosition = 0;\n      var logger = compiler.getInfrastructureLogger(\"MemoryWithGcCachePlugin\");\n      compiler.hooks.afterDone.tap(\"MemoryWithGcCachePlugin\", function () {\n        generation++;\n        var clearedEntries = 0;\n        var lastClearedIdentifier;\n        var _iterator = _createForOfIteratorHelper(oldCache),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _slicedToArray(_step.value, 2),\n              identifier = _step$value[0],\n              entry = _step$value[1];\n            if (entry.until > generation) break;\n            oldCache.delete(identifier);\n            if (cache.get(identifier) === undefined) {\n              cache.delete(identifier);\n              clearedEntries++;\n              lastClearedIdentifier = identifier;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        if (clearedEntries > 0 || oldCache.size > 0) {\n          logger.log(\"\".concat(cache.size - oldCache.size, \" active entries, \").concat(oldCache.size, \" recently unused cached entries\").concat(clearedEntries > 0 ? \", \".concat(clearedEntries, \" old unused cache entries removed e. g. \").concat(lastClearedIdentifier) : \"\"));\n        }\n        var i = cache.size / maxGenerations | 0;\n        var j = cachePosition >= cache.size ? 0 : cachePosition;\n        cachePosition = j + i;\n        var _iterator2 = _createForOfIteratorHelper(cache),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _step2$value = _slicedToArray(_step2.value, 2),\n              _identifier = _step2$value[0],\n              _entry = _step2$value[1];\n            if (j !== 0) {\n              j--;\n              continue;\n            }\n            if (_entry !== undefined) {\n              // We don't delete the cache entry, but set it to undefined instead\n              // This reserves the location in the data table and avoids rehashing\n              // when constantly adding and removing entries.\n              // It will be deleted when removed from oldCache.\n              cache.set(_identifier, undefined);\n              oldCache.delete(_identifier);\n              oldCache.set(_identifier, {\n                entry: _entry,\n                until: generation + maxGenerations\n              });\n              if (i-- === 0) break;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      });\n      compiler.cache.hooks.store.tap({\n        name: \"MemoryWithGcCachePlugin\",\n        stage: Cache.STAGE_MEMORY\n      }, function (identifier, etag, data) {\n        cache.set(identifier, {\n          etag: etag,\n          data: data\n        });\n      });\n      compiler.cache.hooks.get.tap({\n        name: \"MemoryWithGcCachePlugin\",\n        stage: Cache.STAGE_MEMORY\n      }, function (identifier, etag, gotHandlers) {\n        var cacheEntry = cache.get(identifier);\n        if (cacheEntry === null) {\n          return null;\n        } else if (cacheEntry !== undefined) {\n          return cacheEntry.etag === etag ? cacheEntry.data : null;\n        }\n        var oldCacheEntry = oldCache.get(identifier);\n        if (oldCacheEntry !== undefined) {\n          var _cacheEntry = oldCacheEntry.entry;\n          if (_cacheEntry === null) {\n            oldCache.delete(identifier);\n            cache.set(identifier, _cacheEntry);\n            return null;\n          } else {\n            if (_cacheEntry.etag !== etag) return null;\n            oldCache.delete(identifier);\n            cache.set(identifier, _cacheEntry);\n            return _cacheEntry.data;\n          }\n        }\n        gotHandlers.push(function (result, callback) {\n          if (result === undefined) {\n            cache.set(identifier, null);\n          } else {\n            cache.set(identifier, {\n              etag: etag,\n              data: result\n            });\n          }\n          return callback();\n        });\n      });\n      compiler.cache.hooks.shutdown.tap({\n        name: \"MemoryWithGcCachePlugin\",\n        stage: Cache.STAGE_MEMORY\n      }, function () {\n        cache.clear();\n        oldCache.clear();\n      });\n    }\n  }]);\n  return MemoryWithGcCachePlugin;\n}();\nmodule.exports = MemoryWithGcCachePlugin;","map":{"version":3,"names":["Cache","require","MemoryWithGcCachePlugin","maxGenerations","_maxGenerations","compiler","cache","Map","oldCache","generation","cachePosition","logger","getInfrastructureLogger","hooks","afterDone","tap","clearedEntries","lastClearedIdentifier","identifier","entry","until","delete","get","undefined","size","log","i","j","set","store","name","stage","STAGE_MEMORY","etag","data","gotHandlers","cacheEntry","oldCacheEntry","push","result","callback","shutdown","clear","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/cache/MemoryWithGcCachePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Cache = require(\"../Cache\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nclass MemoryWithGcCachePlugin {\n\tconstructor({ maxGenerations }) {\n\t\tthis._maxGenerations = maxGenerations;\n\t}\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst maxGenerations = this._maxGenerations;\n\t\t/** @type {Map<string, { etag: Etag | null, data: any }>} */\n\t\tconst cache = new Map();\n\t\t/** @type {Map<string, { entry: { etag: Etag | null, data: any }, until: number }>} */\n\t\tconst oldCache = new Map();\n\t\tlet generation = 0;\n\t\tlet cachePosition = 0;\n\t\tconst logger = compiler.getInfrastructureLogger(\"MemoryWithGcCachePlugin\");\n\t\tcompiler.hooks.afterDone.tap(\"MemoryWithGcCachePlugin\", () => {\n\t\t\tgeneration++;\n\t\t\tlet clearedEntries = 0;\n\t\t\tlet lastClearedIdentifier;\n\t\t\tfor (const [identifier, entry] of oldCache) {\n\t\t\t\tif (entry.until > generation) break;\n\n\t\t\t\toldCache.delete(identifier);\n\t\t\t\tif (cache.get(identifier) === undefined) {\n\t\t\t\t\tcache.delete(identifier);\n\t\t\t\t\tclearedEntries++;\n\t\t\t\t\tlastClearedIdentifier = identifier;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (clearedEntries > 0 || oldCache.size > 0) {\n\t\t\t\tlogger.log(\n\t\t\t\t\t`${cache.size - oldCache.size} active entries, ${\n\t\t\t\t\t\toldCache.size\n\t\t\t\t\t} recently unused cached entries${\n\t\t\t\t\t\tclearedEntries > 0\n\t\t\t\t\t\t\t? `, ${clearedEntries} old unused cache entries removed e. g. ${lastClearedIdentifier}`\n\t\t\t\t\t\t\t: \"\"\n\t\t\t\t\t}`\n\t\t\t\t);\n\t\t\t}\n\t\t\tlet i = (cache.size / maxGenerations) | 0;\n\t\t\tlet j = cachePosition >= cache.size ? 0 : cachePosition;\n\t\t\tcachePosition = j + i;\n\t\t\tfor (const [identifier, entry] of cache) {\n\t\t\t\tif (j !== 0) {\n\t\t\t\t\tj--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (entry !== undefined) {\n\t\t\t\t\t// We don't delete the cache entry, but set it to undefined instead\n\t\t\t\t\t// This reserves the location in the data table and avoids rehashing\n\t\t\t\t\t// when constantly adding and removing entries.\n\t\t\t\t\t// It will be deleted when removed from oldCache.\n\t\t\t\t\tcache.set(identifier, undefined);\n\t\t\t\t\toldCache.delete(identifier);\n\t\t\t\t\toldCache.set(identifier, {\n\t\t\t\t\t\tentry,\n\t\t\t\t\t\tuntil: generation + maxGenerations\n\t\t\t\t\t});\n\t\t\t\t\tif (i-- === 0) break;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tcompiler.cache.hooks.store.tap(\n\t\t\t{ name: \"MemoryWithGcCachePlugin\", stage: Cache.STAGE_MEMORY },\n\t\t\t(identifier, etag, data) => {\n\t\t\t\tcache.set(identifier, { etag, data });\n\t\t\t}\n\t\t);\n\t\tcompiler.cache.hooks.get.tap(\n\t\t\t{ name: \"MemoryWithGcCachePlugin\", stage: Cache.STAGE_MEMORY },\n\t\t\t(identifier, etag, gotHandlers) => {\n\t\t\t\tconst cacheEntry = cache.get(identifier);\n\t\t\t\tif (cacheEntry === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (cacheEntry !== undefined) {\n\t\t\t\t\treturn cacheEntry.etag === etag ? cacheEntry.data : null;\n\t\t\t\t}\n\t\t\t\tconst oldCacheEntry = oldCache.get(identifier);\n\t\t\t\tif (oldCacheEntry !== undefined) {\n\t\t\t\t\tconst cacheEntry = oldCacheEntry.entry;\n\t\t\t\t\tif (cacheEntry === null) {\n\t\t\t\t\t\toldCache.delete(identifier);\n\t\t\t\t\t\tcache.set(identifier, cacheEntry);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cacheEntry.etag !== etag) return null;\n\t\t\t\t\t\toldCache.delete(identifier);\n\t\t\t\t\t\tcache.set(identifier, cacheEntry);\n\t\t\t\t\t\treturn cacheEntry.data;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgotHandlers.push((result, callback) => {\n\t\t\t\t\tif (result === undefined) {\n\t\t\t\t\t\tcache.set(identifier, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcache.set(identifier, { etag, data: result });\n\t\t\t\t\t}\n\t\t\t\t\treturn callback();\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t\tcompiler.cache.hooks.shutdown.tap(\n\t\t\t{ name: \"MemoryWithGcCachePlugin\", stage: Cache.STAGE_MEMORY },\n\t\t\t() => {\n\t\t\t\tcache.clear();\n\t\t\t\toldCache.clear();\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = MemoryWithGcCachePlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}