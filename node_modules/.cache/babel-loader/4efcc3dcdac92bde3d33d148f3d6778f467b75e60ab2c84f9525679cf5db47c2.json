{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar ChunkGraph = require(\"./ChunkGraph\");\nvar Entrypoint = require(\"./Entrypoint\");\nvar _require = require(\"./util/SetHelpers\"),\n  intersect = _require.intersect;\nvar SortableSet = require(\"./util/SortableSet\");\nvar StringXor = require(\"./util/StringXor\");\nvar _require2 = require(\"./util/comparators\"),\n  compareModulesByIdentifier = _require2.compareModulesByIdentifier,\n  compareChunkGroupsByIndex = _require2.compareChunkGroupsByIndex,\n  compareModulesById = _require2.compareModulesById;\nvar _require3 = require(\"./util/deprecation\"),\n  createArrayToSetDeprecationSet = _require3.createArrayToSetDeprecationSet;\nvar _require4 = require(\"./util/runtime\"),\n  mergeRuntime = _require4.mergeRuntime;\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./ChunkGraph\").ChunkFilterPredicate} ChunkFilterPredicate */\n/** @typedef {import(\"./ChunkGraph\").ChunkSizeOptions} ChunkSizeOptions */\n/** @typedef {import(\"./ChunkGraph\").ModuleFilterPredicate} ModuleFilterPredicate */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compilation\").PathData} PathData */\n/** @typedef {import(\"./Entrypoint\").EntryOptions} EntryOptions */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nvar ChunkFilesSet = createArrayToSetDeprecationSet(\"chunk.files\");\n\n/**\n * @typedef {Object} WithId an object who has an id property *\n * @property {string | number} id the id of the object\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkMaps\n * @property {Record<string|number, string>} hash\n * @property {Record<string|number, Record<string, string>>} contentHash\n * @property {Record<string|number, string>} name\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkModuleMaps\n * @property {Record<string|number, (string|number)[]>} id\n * @property {Record<string|number, string>} hash\n */\n\nvar debugId = 1000;\n\n/**\n * A Chunk is a unit of encapsulation for Modules.\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\n */\nvar Chunk = /*#__PURE__*/function () {\n  /**\n   * @param {string=} name of chunk being created, is optional (for subclasses)\n   * @param {boolean} backCompat enable backward-compatibility\n   */\n  function Chunk(name) {\n    var backCompat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    _classCallCheck(this, Chunk);\n    /** @type {number | string | null} */\n    this.id = null;\n    /** @type {(number|string)[] | null} */\n    this.ids = null;\n    /** @type {number} */\n    this.debugId = debugId++;\n    /** @type {string} */\n    this.name = name;\n    /** @type {SortableSet<string>} */\n    this.idNameHints = new SortableSet();\n    /** @type {boolean} */\n    this.preventIntegration = false;\n    /** @type {(string | function(PathData, AssetInfo=): string)?} */\n    this.filenameTemplate = undefined;\n    /** @type {(string | function(PathData, AssetInfo=): string)?} */\n    this.cssFilenameTemplate = undefined;\n    /** @private @type {SortableSet<ChunkGroup>} */\n    this._groups = new SortableSet(undefined, compareChunkGroupsByIndex);\n    /** @type {RuntimeSpec} */\n    this.runtime = undefined;\n    /** @type {Set<string>} */\n    this.files = backCompat ? new ChunkFilesSet() : new Set();\n    /** @type {Set<string>} */\n    this.auxiliaryFiles = new Set();\n    /** @type {boolean} */\n    this.rendered = false;\n    /** @type {string=} */\n    this.hash = undefined;\n    /** @type {Record<string, string>} */\n    this.contentHash = Object.create(null);\n    /** @type {string=} */\n    this.renderedHash = undefined;\n    /** @type {string=} */\n    this.chunkReason = undefined;\n    /** @type {boolean} */\n    this.extraAsync = false;\n  }\n\n  // TODO remove in webpack 6\n  // BACKWARD-COMPAT START\n  _createClass(Chunk, [{\n    key: \"entryModule\",\n    get: function get() {\n      var entryModules = Array.from(ChunkGraph.getChunkGraphForChunk(this, \"Chunk.entryModule\", \"DEP_WEBPACK_CHUNK_ENTRY_MODULE\").getChunkEntryModulesIterable(this));\n      if (entryModules.length === 0) {\n        return undefined;\n      } else if (entryModules.length === 1) {\n        return entryModules[0];\n      } else {\n        throw new Error(\"Module.entryModule: Multiple entry modules are not supported by the deprecated API (Use the new ChunkGroup API)\");\n      }\n    }\n\n    /**\n     * @returns {boolean} true, if the chunk contains an entry module\n     */\n  }, {\n    key: \"hasEntryModule\",\n    value: function hasEntryModule() {\n      return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.hasEntryModule\", \"DEP_WEBPACK_CHUNK_HAS_ENTRY_MODULE\").getNumberOfEntryModules(this) > 0;\n    }\n\n    /**\n     * @param {Module} module the module\n     * @returns {boolean} true, if the chunk could be added\n     */\n  }, {\n    key: \"addModule\",\n    value: function addModule(module) {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.addModule\", \"DEP_WEBPACK_CHUNK_ADD_MODULE\");\n      if (chunkGraph.isModuleInChunk(module, this)) return false;\n      chunkGraph.connectChunkAndModule(this, module);\n      return true;\n    }\n\n    /**\n     * @param {Module} module the module\n     * @returns {void}\n     */\n  }, {\n    key: \"removeModule\",\n    value: function removeModule(module) {\n      ChunkGraph.getChunkGraphForChunk(this, \"Chunk.removeModule\", \"DEP_WEBPACK_CHUNK_REMOVE_MODULE\").disconnectChunkAndModule(this, module);\n    }\n\n    /**\n     * @returns {number} the number of module which are contained in this chunk\n     */\n  }, {\n    key: \"getNumberOfModules\",\n    value: function getNumberOfModules() {\n      return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.getNumberOfModules\", \"DEP_WEBPACK_CHUNK_GET_NUMBER_OF_MODULES\").getNumberOfChunkModules(this);\n    }\n  }, {\n    key: \"modulesIterable\",\n    get: function get() {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.modulesIterable\", \"DEP_WEBPACK_CHUNK_MODULES_ITERABLE\");\n      return chunkGraph.getOrderedChunkModulesIterable(this, compareModulesByIdentifier);\n    }\n\n    /**\n     * @param {Chunk} otherChunk the chunk to compare with\n     * @returns {-1|0|1} the comparison result\n     */\n  }, {\n    key: \"compareTo\",\n    value: function compareTo(otherChunk) {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.compareTo\", \"DEP_WEBPACK_CHUNK_COMPARE_TO\");\n      return chunkGraph.compareChunks(this, otherChunk);\n    }\n\n    /**\n     * @param {Module} module the module\n     * @returns {boolean} true, if the chunk contains the module\n     */\n  }, {\n    key: \"containsModule\",\n    value: function containsModule(module) {\n      return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.containsModule\", \"DEP_WEBPACK_CHUNK_CONTAINS_MODULE\").isModuleInChunk(module, this);\n    }\n\n    /**\n     * @returns {Module[]} the modules for this chunk\n     */\n  }, {\n    key: \"getModules\",\n    value: function getModules() {\n      return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.getModules\", \"DEP_WEBPACK_CHUNK_GET_MODULES\").getChunkModules(this);\n    }\n\n    /**\n     * @returns {void}\n     */\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.remove\", \"DEP_WEBPACK_CHUNK_REMOVE\");\n      chunkGraph.disconnectChunk(this);\n      this.disconnectFromGroups();\n    }\n\n    /**\n     * @param {Module} module the module\n     * @param {Chunk} otherChunk the target chunk\n     * @returns {void}\n     */\n  }, {\n    key: \"moveModule\",\n    value: function moveModule(module, otherChunk) {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.moveModule\", \"DEP_WEBPACK_CHUNK_MOVE_MODULE\");\n      chunkGraph.disconnectChunkAndModule(this, module);\n      chunkGraph.connectChunkAndModule(otherChunk, module);\n    }\n\n    /**\n     * @param {Chunk} otherChunk the other chunk\n     * @returns {boolean} true, if the specified chunk has been integrated\n     */\n  }, {\n    key: \"integrate\",\n    value: function integrate(otherChunk) {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.integrate\", \"DEP_WEBPACK_CHUNK_INTEGRATE\");\n      if (chunkGraph.canChunksBeIntegrated(this, otherChunk)) {\n        chunkGraph.integrateChunks(this, otherChunk);\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * @param {Chunk} otherChunk the other chunk\n     * @returns {boolean} true, if chunks could be integrated\n     */\n  }, {\n    key: \"canBeIntegrated\",\n    value: function canBeIntegrated(otherChunk) {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.canBeIntegrated\", \"DEP_WEBPACK_CHUNK_CAN_BE_INTEGRATED\");\n      return chunkGraph.canChunksBeIntegrated(this, otherChunk);\n    }\n\n    /**\n     * @returns {boolean} true, if this chunk contains no module\n     */\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.isEmpty\", \"DEP_WEBPACK_CHUNK_IS_EMPTY\");\n      return chunkGraph.getNumberOfChunkModules(this) === 0;\n    }\n\n    /**\n     * @returns {number} total size of all modules in this chunk\n     */\n  }, {\n    key: \"modulesSize\",\n    value: function modulesSize() {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.modulesSize\", \"DEP_WEBPACK_CHUNK_MODULES_SIZE\");\n      return chunkGraph.getChunkModulesSize(this);\n    }\n\n    /**\n     * @param {ChunkSizeOptions} options options object\n     * @returns {number} total size of this chunk\n     */\n  }, {\n    key: \"size\",\n    value: function size() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.size\", \"DEP_WEBPACK_CHUNK_SIZE\");\n      return chunkGraph.getChunkSize(this, options);\n    }\n\n    /**\n     * @param {Chunk} otherChunk the other chunk\n     * @param {ChunkSizeOptions} options options object\n     * @returns {number} total size of the chunk or false if the chunk can't be integrated\n     */\n  }, {\n    key: \"integratedSize\",\n    value: function integratedSize(otherChunk, options) {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.integratedSize\", \"DEP_WEBPACK_CHUNK_INTEGRATED_SIZE\");\n      return chunkGraph.getIntegratedChunksSize(this, otherChunk, options);\n    }\n\n    /**\n     * @param {ModuleFilterPredicate} filterFn function used to filter modules\n     * @returns {ChunkModuleMaps} module map information\n     */\n  }, {\n    key: \"getChunkModuleMaps\",\n    value: function getChunkModuleMaps(filterFn) {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.getChunkModuleMaps\", \"DEP_WEBPACK_CHUNK_GET_CHUNK_MODULE_MAPS\");\n      /** @type {Record<string|number, (string|number)[]>} */\n      var chunkModuleIdMap = Object.create(null);\n      /** @type {Record<string|number, string>} */\n      var chunkModuleHashMap = Object.create(null);\n      var _iterator = _createForOfIteratorHelper(this.getAllAsyncChunks()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var asyncChunk = _step.value;\n          /** @type {(string|number)[]} */\n          var array = void 0;\n          var _iterator2 = _createForOfIteratorHelper(chunkGraph.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(chunkGraph))),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _module = _step2.value;\n              if (filterFn(_module)) {\n                if (array === undefined) {\n                  array = [];\n                  chunkModuleIdMap[asyncChunk.id] = array;\n                }\n                var moduleId = chunkGraph.getModuleId(_module);\n                array.push(moduleId);\n                chunkModuleHashMap[moduleId] = chunkGraph.getRenderedModuleHash(_module, undefined);\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return {\n        id: chunkModuleIdMap,\n        hash: chunkModuleHashMap\n      };\n    }\n\n    /**\n     * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n     * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n     * @returns {boolean} return true if module exists in graph\n     */\n  }, {\n    key: \"hasModuleInGraph\",\n    value: function hasModuleInGraph(filterFn, filterChunkFn) {\n      var chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.hasModuleInGraph\", \"DEP_WEBPACK_CHUNK_HAS_MODULE_IN_GRAPH\");\n      return chunkGraph.hasModuleInGraph(this, filterFn, filterChunkFn);\n    }\n\n    /**\n     * @deprecated\n     * @param {boolean} realHash whether the full hash or the rendered hash is to be used\n     * @returns {ChunkMaps} the chunk map information\n     */\n  }, {\n    key: \"getChunkMaps\",\n    value: function getChunkMaps(realHash) {\n      /** @type {Record<string|number, string>} */\n      var chunkHashMap = Object.create(null);\n      /** @type {Record<string|number, Record<string, string>>} */\n      var chunkContentHashMap = Object.create(null);\n      /** @type {Record<string|number, string>} */\n      var chunkNameMap = Object.create(null);\n      var _iterator3 = _createForOfIteratorHelper(this.getAllAsyncChunks()),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var chunk = _step3.value;\n          chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n          for (var _i = 0, _Object$keys = Object.keys(chunk.contentHash); _i < _Object$keys.length; _i++) {\n            var key = _Object$keys[_i];\n            if (!chunkContentHashMap[key]) {\n              chunkContentHashMap[key] = Object.create(null);\n            }\n            chunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n          }\n          if (chunk.name) {\n            chunkNameMap[chunk.id] = chunk.name;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return {\n        hash: chunkHashMap,\n        contentHash: chunkContentHashMap,\n        name: chunkNameMap\n      };\n    }\n    // BACKWARD-COMPAT END\n\n    /**\n     * @returns {boolean} whether or not the Chunk will have a runtime\n     */\n  }, {\n    key: \"hasRuntime\",\n    value: function hasRuntime() {\n      var _iterator4 = _createForOfIteratorHelper(this._groups),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var chunkGroup = _step4.value;\n          if (chunkGroup instanceof Entrypoint && chunkGroup.getRuntimeChunk() === this) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      return false;\n    }\n\n    /**\n     * @returns {boolean} whether or not this chunk can be an initial chunk\n     */\n  }, {\n    key: \"canBeInitial\",\n    value: function canBeInitial() {\n      var _iterator5 = _createForOfIteratorHelper(this._groups),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var chunkGroup = _step5.value;\n          if (chunkGroup.isInitial()) return true;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      return false;\n    }\n\n    /**\n     * @returns {boolean} whether this chunk can only be an initial chunk\n     */\n  }, {\n    key: \"isOnlyInitial\",\n    value: function isOnlyInitial() {\n      if (this._groups.size <= 0) return false;\n      var _iterator6 = _createForOfIteratorHelper(this._groups),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var chunkGroup = _step6.value;\n          if (!chunkGroup.isInitial()) return false;\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      return true;\n    }\n\n    /**\n     * @returns {EntryOptions | undefined} the entry options for this chunk\n     */\n  }, {\n    key: \"getEntryOptions\",\n    value: function getEntryOptions() {\n      var _iterator7 = _createForOfIteratorHelper(this._groups),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var chunkGroup = _step7.value;\n          if (chunkGroup instanceof Entrypoint) {\n            return chunkGroup.options;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      return undefined;\n    }\n\n    /**\n     * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\n     * @returns {void}\n     */\n  }, {\n    key: \"addGroup\",\n    value: function addGroup(chunkGroup) {\n      this._groups.add(chunkGroup);\n    }\n\n    /**\n     * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\n     * @returns {void}\n     */\n  }, {\n    key: \"removeGroup\",\n    value: function removeGroup(chunkGroup) {\n      this._groups.delete(chunkGroup);\n    }\n\n    /**\n     * @param {ChunkGroup} chunkGroup the chunkGroup to check\n     * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\n     */\n  }, {\n    key: \"isInGroup\",\n    value: function isInGroup(chunkGroup) {\n      return this._groups.has(chunkGroup);\n    }\n\n    /**\n     * @returns {number} the amount of groups that the said chunk is in\n     */\n  }, {\n    key: \"getNumberOfGroups\",\n    value: function getNumberOfGroups() {\n      return this._groups.size;\n    }\n\n    /**\n     * @returns {Iterable<ChunkGroup>} the chunkGroups that the said chunk is referenced in\n     */\n  }, {\n    key: \"groupsIterable\",\n    get: function get() {\n      this._groups.sort();\n      return this._groups;\n    }\n\n    /**\n     * @returns {void}\n     */\n  }, {\n    key: \"disconnectFromGroups\",\n    value: function disconnectFromGroups() {\n      var _iterator8 = _createForOfIteratorHelper(this._groups),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var chunkGroup = _step8.value;\n          chunkGroup.removeChunk(this);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n\n    /**\n     * @param {Chunk} newChunk the new chunk that will be split out of\n     * @returns {void}\n     */\n  }, {\n    key: \"split\",\n    value: function split(newChunk) {\n      var _iterator9 = _createForOfIteratorHelper(this._groups),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var chunkGroup = _step9.value;\n          chunkGroup.insertChunk(newChunk, this);\n          newChunk.addGroup(chunkGroup);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n      var _iterator10 = _createForOfIteratorHelper(this.idNameHints),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var idHint = _step10.value;\n          newChunk.idNameHints.add(idHint);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n      newChunk.runtime = mergeRuntime(newChunk.runtime, this.runtime);\n    }\n\n    /**\n     * @param {Hash} hash hash (will be modified)\n     * @param {ChunkGraph} chunkGraph the chunk graph\n     * @returns {void}\n     */\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash, chunkGraph) {\n      hash.update(\"\".concat(this.id, \" \").concat(this.ids ? this.ids.join() : \"\", \" \").concat(this.name || \"\", \" \"));\n      var xor = new StringXor();\n      var _iterator11 = _createForOfIteratorHelper(chunkGraph.getChunkModulesIterable(this)),\n        _step11;\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var m = _step11.value;\n          xor.add(chunkGraph.getModuleHash(m, this.runtime));\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n      xor.updateHash(hash);\n      var entryModules = chunkGraph.getChunkEntryModulesWithChunkGroupIterable(this);\n      var _iterator12 = _createForOfIteratorHelper(entryModules),\n        _step12;\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var _step12$value = _slicedToArray(_step12.value, 2),\n            _m = _step12$value[0],\n            chunkGroup = _step12$value[1];\n          hash.update(\"entry\".concat(chunkGraph.getModuleId(_m)).concat(chunkGroup.id));\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n    }\n\n    /**\n     * @returns {Set<Chunk>} a set of all the async chunks\n     */\n  }, {\n    key: \"getAllAsyncChunks\",\n    value: function getAllAsyncChunks() {\n      var queue = new Set();\n      var chunks = new Set();\n      var initialChunks = intersect(Array.from(this.groupsIterable, function (g) {\n        return new Set(g.chunks);\n      }));\n      var initialQueue = new Set(this.groupsIterable);\n      var _iterator13 = _createForOfIteratorHelper(initialQueue),\n        _step13;\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var chunkGroup = _step13.value;\n          var _iterator15 = _createForOfIteratorHelper(chunkGroup.childrenIterable),\n            _step15;\n          try {\n            for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n              var child = _step15.value;\n              if (child instanceof Entrypoint) {\n                initialQueue.add(child);\n              } else {\n                queue.add(child);\n              }\n            }\n          } catch (err) {\n            _iterator15.e(err);\n          } finally {\n            _iterator15.f();\n          }\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n      var _iterator14 = _createForOfIteratorHelper(queue),\n        _step14;\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var _chunkGroup = _step14.value;\n          var _iterator16 = _createForOfIteratorHelper(_chunkGroup.chunks),\n            _step16;\n          try {\n            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n              var chunk = _step16.value;\n              if (!initialChunks.has(chunk)) {\n                chunks.add(chunk);\n              }\n            }\n          } catch (err) {\n            _iterator16.e(err);\n          } finally {\n            _iterator16.f();\n          }\n          var _iterator17 = _createForOfIteratorHelper(_chunkGroup.childrenIterable),\n            _step17;\n          try {\n            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n              var _child = _step17.value;\n              queue.add(_child);\n            }\n          } catch (err) {\n            _iterator17.e(err);\n          } finally {\n            _iterator17.f();\n          }\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n      return chunks;\n    }\n\n    /**\n     * @returns {Set<Chunk>} a set of all the initial chunks (including itself)\n     */\n  }, {\n    key: \"getAllInitialChunks\",\n    value: function getAllInitialChunks() {\n      var chunks = new Set();\n      var queue = new Set(this.groupsIterable);\n      var _iterator18 = _createForOfIteratorHelper(queue),\n        _step18;\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var group = _step18.value;\n          if (group.isInitial()) {\n            var _iterator19 = _createForOfIteratorHelper(group.chunks),\n              _step19;\n            try {\n              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                var c = _step19.value;\n                chunks.add(c);\n              }\n            } catch (err) {\n              _iterator19.e(err);\n            } finally {\n              _iterator19.f();\n            }\n            var _iterator20 = _createForOfIteratorHelper(group.childrenIterable),\n              _step20;\n            try {\n              for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                var g = _step20.value;\n                queue.add(g);\n              }\n            } catch (err) {\n              _iterator20.e(err);\n            } finally {\n              _iterator20.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n      return chunks;\n    }\n\n    /**\n     * @returns {Set<Chunk>} a set of all the referenced chunks (including itself)\n     */\n  }, {\n    key: \"getAllReferencedChunks\",\n    value: function getAllReferencedChunks() {\n      var queue = new Set(this.groupsIterable);\n      var chunks = new Set();\n      var _iterator21 = _createForOfIteratorHelper(queue),\n        _step21;\n      try {\n        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n          var chunkGroup = _step21.value;\n          var _iterator22 = _createForOfIteratorHelper(chunkGroup.chunks),\n            _step22;\n          try {\n            for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n              var chunk = _step22.value;\n              chunks.add(chunk);\n            }\n          } catch (err) {\n            _iterator22.e(err);\n          } finally {\n            _iterator22.f();\n          }\n          var _iterator23 = _createForOfIteratorHelper(chunkGroup.childrenIterable),\n            _step23;\n          try {\n            for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n              var child = _step23.value;\n              queue.add(child);\n            }\n          } catch (err) {\n            _iterator23.e(err);\n          } finally {\n            _iterator23.f();\n          }\n        }\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n      return chunks;\n    }\n\n    /**\n     * @returns {Set<Entrypoint>} a set of all the referenced entrypoints\n     */\n  }, {\n    key: \"getAllReferencedAsyncEntrypoints\",\n    value: function getAllReferencedAsyncEntrypoints() {\n      var queue = new Set(this.groupsIterable);\n      var entrypoints = new Set();\n      var _iterator24 = _createForOfIteratorHelper(queue),\n        _step24;\n      try {\n        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n          var chunkGroup = _step24.value;\n          var _iterator25 = _createForOfIteratorHelper(chunkGroup.asyncEntrypointsIterable),\n            _step25;\n          try {\n            for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n              var entrypoint = _step25.value;\n              entrypoints.add(entrypoint);\n            }\n          } catch (err) {\n            _iterator25.e(err);\n          } finally {\n            _iterator25.f();\n          }\n          var _iterator26 = _createForOfIteratorHelper(chunkGroup.childrenIterable),\n            _step26;\n          try {\n            for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n              var child = _step26.value;\n              queue.add(child);\n            }\n          } catch (err) {\n            _iterator26.e(err);\n          } finally {\n            _iterator26.f();\n          }\n        }\n      } catch (err) {\n        _iterator24.e(err);\n      } finally {\n        _iterator24.f();\n      }\n      return entrypoints;\n    }\n\n    /**\n     * @returns {boolean} true, if the chunk references async chunks\n     */\n  }, {\n    key: \"hasAsyncChunks\",\n    value: function hasAsyncChunks() {\n      var queue = new Set();\n      var initialChunks = intersect(Array.from(this.groupsIterable, function (g) {\n        return new Set(g.chunks);\n      }));\n      var _iterator27 = _createForOfIteratorHelper(this.groupsIterable),\n        _step27;\n      try {\n        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n          var chunkGroup = _step27.value;\n          var _iterator29 = _createForOfIteratorHelper(chunkGroup.childrenIterable),\n            _step29;\n          try {\n            for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n              var child = _step29.value;\n              queue.add(child);\n            }\n          } catch (err) {\n            _iterator29.e(err);\n          } finally {\n            _iterator29.f();\n          }\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n      var _iterator28 = _createForOfIteratorHelper(queue),\n        _step28;\n      try {\n        for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n          var _chunkGroup2 = _step28.value;\n          var _iterator30 = _createForOfIteratorHelper(_chunkGroup2.chunks),\n            _step30;\n          try {\n            for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n              var chunk = _step30.value;\n              if (!initialChunks.has(chunk)) {\n                return true;\n              }\n            }\n          } catch (err) {\n            _iterator30.e(err);\n          } finally {\n            _iterator30.f();\n          }\n          var _iterator31 = _createForOfIteratorHelper(_chunkGroup2.childrenIterable),\n            _step31;\n          try {\n            for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n              var _child2 = _step31.value;\n              queue.add(_child2);\n            }\n          } catch (err) {\n            _iterator31.e(err);\n          } finally {\n            _iterator31.f();\n          }\n        }\n      } catch (err) {\n        _iterator28.e(err);\n      } finally {\n        _iterator28.f();\n      }\n      return false;\n    }\n\n    /**\n     * @param {ChunkGraph} chunkGraph the chunk graph\n     * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n     * @returns {Record<string, (string | number)[]>} a record object of names to lists of child ids(?)\n     */\n  }, {\n    key: \"getChildIdsByOrders\",\n    value: function getChildIdsByOrders(chunkGraph, filterFn) {\n      /** @type {Map<string, {order: number, group: ChunkGroup}[]>} */\n      var lists = new Map();\n      var _iterator32 = _createForOfIteratorHelper(this.groupsIterable),\n        _step32;\n      try {\n        for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n          var group = _step32.value;\n          if (group.chunks[group.chunks.length - 1] === this) {\n            var _iterator34 = _createForOfIteratorHelper(group.childrenIterable),\n              _step34;\n            try {\n              for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n                var childGroup = _step34.value;\n                for (var _i2 = 0, _Object$keys2 = Object.keys(childGroup.options); _i2 < _Object$keys2.length; _i2++) {\n                  var key = _Object$keys2[_i2];\n                  if (key.endsWith(\"Order\")) {\n                    var name = key.slice(0, key.length - \"Order\".length);\n                    var list = lists.get(name);\n                    if (list === undefined) {\n                      list = [];\n                      lists.set(name, list);\n                    }\n                    list.push({\n                      order: childGroup.options[key],\n                      group: childGroup\n                    });\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator34.e(err);\n            } finally {\n              _iterator34.f();\n            }\n          }\n        }\n        /** @type {Record<string, (string | number)[]>} */\n      } catch (err) {\n        _iterator32.e(err);\n      } finally {\n        _iterator32.f();\n      }\n      var result = Object.create(null);\n      var _iterator33 = _createForOfIteratorHelper(lists),\n        _step33;\n      try {\n        for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n          var _step33$value = _slicedToArray(_step33.value, 2),\n            _name = _step33$value[0],\n            _list = _step33$value[1];\n          _list.sort(function (a, b) {\n            var cmp = b.order - a.order;\n            if (cmp !== 0) return cmp;\n            return a.group.compareTo(chunkGraph, b.group);\n          });\n          /** @type {Set<string | number>} */\n          var chunkIdSet = new Set();\n          var _iterator35 = _createForOfIteratorHelper(_list),\n            _step35;\n          try {\n            for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n              var item = _step35.value;\n              var _iterator36 = _createForOfIteratorHelper(item.group.chunks),\n                _step36;\n              try {\n                for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n                  var chunk = _step36.value;\n                  if (filterFn && !filterFn(chunk, chunkGraph)) continue;\n                  chunkIdSet.add(chunk.id);\n                }\n              } catch (err) {\n                _iterator36.e(err);\n              } finally {\n                _iterator36.f();\n              }\n            }\n          } catch (err) {\n            _iterator35.e(err);\n          } finally {\n            _iterator35.f();\n          }\n          if (chunkIdSet.size > 0) {\n            result[_name] = Array.from(chunkIdSet);\n          }\n        }\n      } catch (err) {\n        _iterator33.e(err);\n      } finally {\n        _iterator33.f();\n      }\n      return result;\n    }\n\n    /**\n     * @param {ChunkGraph} chunkGraph the chunk graph\n     * @param {string} type option name\n     * @returns {{ onChunks: Chunk[], chunks: Set<Chunk> }[]} referenced chunks for a specific type\n     */\n  }, {\n    key: \"getChildrenOfTypeInOrder\",\n    value: function getChildrenOfTypeInOrder(chunkGraph, type) {\n      var list = [];\n      var _iterator37 = _createForOfIteratorHelper(this.groupsIterable),\n        _step37;\n      try {\n        for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {\n          var _group = _step37.value;\n          var _iterator39 = _createForOfIteratorHelper(_group.childrenIterable),\n            _step39;\n          try {\n            for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {\n              var _childGroup = _step39.value;\n              var order = _childGroup.options[type];\n              if (order === undefined) continue;\n              list.push({\n                order: order,\n                group: _group,\n                childGroup: _childGroup\n              });\n            }\n          } catch (err) {\n            _iterator39.e(err);\n          } finally {\n            _iterator39.f();\n          }\n        }\n      } catch (err) {\n        _iterator37.e(err);\n      } finally {\n        _iterator37.f();\n      }\n      if (list.length === 0) return undefined;\n      list.sort(function (a, b) {\n        var cmp = b.order - a.order;\n        if (cmp !== 0) return cmp;\n        return a.group.compareTo(chunkGraph, b.group);\n      });\n      var result = [];\n      var lastEntry;\n      for (var _i3 = 0, _list2 = list; _i3 < _list2.length; _i3++) {\n        var _list2$_i = _list2[_i3],\n          group = _list2$_i.group,\n          childGroup = _list2$_i.childGroup;\n        if (lastEntry && lastEntry.onChunks === group.chunks) {\n          var _iterator38 = _createForOfIteratorHelper(childGroup.chunks),\n            _step38;\n          try {\n            for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {\n              var chunk = _step38.value;\n              lastEntry.chunks.add(chunk);\n            }\n          } catch (err) {\n            _iterator38.e(err);\n          } finally {\n            _iterator38.f();\n          }\n        } else {\n          result.push(lastEntry = {\n            onChunks: group.chunks,\n            chunks: new Set(childGroup.chunks)\n          });\n        }\n      }\n      return result;\n    }\n\n    /**\n     * @param {ChunkGraph} chunkGraph the chunk graph\n     * @param {boolean=} includeDirectChildren include direct children (by default only children of async children are included)\n     * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n     * @returns {Record<string|number, Record<string, (string | number)[]>>} a record object of names to lists of child ids(?) by chunk id\n     */\n  }, {\n    key: \"getChildIdsByOrdersMap\",\n    value: function getChildIdsByOrdersMap(chunkGraph, includeDirectChildren, filterFn) {\n      /** @type {Record<string|number, Record<string, (string | number)[]>>} */\n      var chunkMaps = Object.create(null);\n\n      /**\n       * @param {Chunk} chunk a chunk\n       * @returns {void}\n       */\n      var addChildIdsByOrdersToMap = function addChildIdsByOrdersToMap(chunk) {\n        var data = chunk.getChildIdsByOrders(chunkGraph, filterFn);\n        for (var _i4 = 0, _Object$keys3 = Object.keys(data); _i4 < _Object$keys3.length; _i4++) {\n          var key = _Object$keys3[_i4];\n          var chunkMap = chunkMaps[key];\n          if (chunkMap === undefined) {\n            chunkMaps[key] = chunkMap = Object.create(null);\n          }\n          chunkMap[chunk.id] = data[key];\n        }\n      };\n      if (includeDirectChildren) {\n        /** @type {Set<Chunk>} */\n        var chunks = new Set();\n        var _iterator40 = _createForOfIteratorHelper(this.groupsIterable),\n          _step40;\n        try {\n          for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {\n            var chunkGroup = _step40.value;\n            var _iterator42 = _createForOfIteratorHelper(chunkGroup.chunks),\n              _step42;\n            try {\n              for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {\n                var chunk = _step42.value;\n                chunks.add(chunk);\n              }\n            } catch (err) {\n              _iterator42.e(err);\n            } finally {\n              _iterator42.f();\n            }\n          }\n        } catch (err) {\n          _iterator40.e(err);\n        } finally {\n          _iterator40.f();\n        }\n        var _iterator41 = _createForOfIteratorHelper(chunks),\n          _step41;\n        try {\n          for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {\n            var _chunk = _step41.value;\n            addChildIdsByOrdersToMap(_chunk);\n          }\n        } catch (err) {\n          _iterator41.e(err);\n        } finally {\n          _iterator41.f();\n        }\n      }\n      var _iterator43 = _createForOfIteratorHelper(this.getAllAsyncChunks()),\n        _step43;\n      try {\n        for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {\n          var _chunk2 = _step43.value;\n          addChildIdsByOrdersToMap(_chunk2);\n        }\n      } catch (err) {\n        _iterator43.e(err);\n      } finally {\n        _iterator43.f();\n      }\n      return chunkMaps;\n    }\n  }]);\n  return Chunk;\n}();\nmodule.exports = Chunk;","map":{"version":3,"names":["ChunkGraph","require","Entrypoint","intersect","SortableSet","StringXor","compareModulesByIdentifier","compareChunkGroupsByIndex","compareModulesById","createArrayToSetDeprecationSet","mergeRuntime","ChunkFilesSet","debugId","Chunk","name","backCompat","id","ids","idNameHints","preventIntegration","filenameTemplate","undefined","cssFilenameTemplate","_groups","runtime","files","Set","auxiliaryFiles","rendered","hash","contentHash","Object","create","renderedHash","chunkReason","extraAsync","entryModules","Array","from","getChunkGraphForChunk","getChunkEntryModulesIterable","length","Error","getNumberOfEntryModules","module","chunkGraph","isModuleInChunk","connectChunkAndModule","disconnectChunkAndModule","getNumberOfChunkModules","getOrderedChunkModulesIterable","otherChunk","compareChunks","getChunkModules","disconnectChunk","disconnectFromGroups","canChunksBeIntegrated","integrateChunks","getChunkModulesSize","options","getChunkSize","getIntegratedChunksSize","filterFn","chunkModuleIdMap","chunkModuleHashMap","getAllAsyncChunks","asyncChunk","array","moduleId","getModuleId","push","getRenderedModuleHash","filterChunkFn","hasModuleInGraph","realHash","chunkHashMap","chunkContentHashMap","chunkNameMap","chunk","keys","key","chunkGroup","getRuntimeChunk","isInitial","size","add","delete","has","sort","removeChunk","newChunk","insertChunk","addGroup","idHint","update","join","xor","getChunkModulesIterable","m","getModuleHash","updateHash","getChunkEntryModulesWithChunkGroupIterable","queue","chunks","initialChunks","groupsIterable","g","initialQueue","childrenIterable","child","group","c","entrypoints","asyncEntrypointsIterable","entrypoint","lists","Map","childGroup","endsWith","slice","list","get","set","order","result","a","b","cmp","compareTo","chunkIdSet","item","type","lastEntry","onChunks","includeDirectChildren","chunkMaps","addChildIdsByOrdersToMap","data","getChildIdsByOrders","chunkMap","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/Chunk.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst ChunkGraph = require(\"./ChunkGraph\");\nconst Entrypoint = require(\"./Entrypoint\");\nconst { intersect } = require(\"./util/SetHelpers\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst StringXor = require(\"./util/StringXor\");\nconst {\n\tcompareModulesByIdentifier,\n\tcompareChunkGroupsByIndex,\n\tcompareModulesById\n} = require(\"./util/comparators\");\nconst { createArrayToSetDeprecationSet } = require(\"./util/deprecation\");\nconst { mergeRuntime } = require(\"./util/runtime\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./ChunkGraph\").ChunkFilterPredicate} ChunkFilterPredicate */\n/** @typedef {import(\"./ChunkGraph\").ChunkSizeOptions} ChunkSizeOptions */\n/** @typedef {import(\"./ChunkGraph\").ModuleFilterPredicate} ModuleFilterPredicate */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compilation\").PathData} PathData */\n/** @typedef {import(\"./Entrypoint\").EntryOptions} EntryOptions */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nconst ChunkFilesSet = createArrayToSetDeprecationSet(\"chunk.files\");\n\n/**\n * @typedef {Object} WithId an object who has an id property *\n * @property {string | number} id the id of the object\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkMaps\n * @property {Record<string|number, string>} hash\n * @property {Record<string|number, Record<string, string>>} contentHash\n * @property {Record<string|number, string>} name\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkModuleMaps\n * @property {Record<string|number, (string|number)[]>} id\n * @property {Record<string|number, string>} hash\n */\n\nlet debugId = 1000;\n\n/**\n * A Chunk is a unit of encapsulation for Modules.\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\n */\nclass Chunk {\n\t/**\n\t * @param {string=} name of chunk being created, is optional (for subclasses)\n\t * @param {boolean} backCompat enable backward-compatibility\n\t */\n\tconstructor(name, backCompat = true) {\n\t\t/** @type {number | string | null} */\n\t\tthis.id = null;\n\t\t/** @type {(number|string)[] | null} */\n\t\tthis.ids = null;\n\t\t/** @type {number} */\n\t\tthis.debugId = debugId++;\n\t\t/** @type {string} */\n\t\tthis.name = name;\n\t\t/** @type {SortableSet<string>} */\n\t\tthis.idNameHints = new SortableSet();\n\t\t/** @type {boolean} */\n\t\tthis.preventIntegration = false;\n\t\t/** @type {(string | function(PathData, AssetInfo=): string)?} */\n\t\tthis.filenameTemplate = undefined;\n\t\t/** @type {(string | function(PathData, AssetInfo=): string)?} */\n\t\tthis.cssFilenameTemplate = undefined;\n\t\t/** @private @type {SortableSet<ChunkGroup>} */\n\t\tthis._groups = new SortableSet(undefined, compareChunkGroupsByIndex);\n\t\t/** @type {RuntimeSpec} */\n\t\tthis.runtime = undefined;\n\t\t/** @type {Set<string>} */\n\t\tthis.files = backCompat ? new ChunkFilesSet() : new Set();\n\t\t/** @type {Set<string>} */\n\t\tthis.auxiliaryFiles = new Set();\n\t\t/** @type {boolean} */\n\t\tthis.rendered = false;\n\t\t/** @type {string=} */\n\t\tthis.hash = undefined;\n\t\t/** @type {Record<string, string>} */\n\t\tthis.contentHash = Object.create(null);\n\t\t/** @type {string=} */\n\t\tthis.renderedHash = undefined;\n\t\t/** @type {string=} */\n\t\tthis.chunkReason = undefined;\n\t\t/** @type {boolean} */\n\t\tthis.extraAsync = false;\n\t}\n\n\t// TODO remove in webpack 6\n\t// BACKWARD-COMPAT START\n\tget entryModule() {\n\t\tconst entryModules = Array.from(\n\t\t\tChunkGraph.getChunkGraphForChunk(\n\t\t\t\tthis,\n\t\t\t\t\"Chunk.entryModule\",\n\t\t\t\t\"DEP_WEBPACK_CHUNK_ENTRY_MODULE\"\n\t\t\t).getChunkEntryModulesIterable(this)\n\t\t);\n\t\tif (entryModules.length === 0) {\n\t\t\treturn undefined;\n\t\t} else if (entryModules.length === 1) {\n\t\t\treturn entryModules[0];\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t\"Module.entryModule: Multiple entry modules are not supported by the deprecated API (Use the new ChunkGroup API)\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {boolean} true, if the chunk contains an entry module\n\t */\n\thasEntryModule() {\n\t\treturn (\n\t\t\tChunkGraph.getChunkGraphForChunk(\n\t\t\t\tthis,\n\t\t\t\t\"Chunk.hasEntryModule\",\n\t\t\t\t\"DEP_WEBPACK_CHUNK_HAS_ENTRY_MODULE\"\n\t\t\t).getNumberOfEntryModules(this) > 0\n\t\t);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {boolean} true, if the chunk could be added\n\t */\n\taddModule(module) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.addModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_ADD_MODULE\"\n\t\t);\n\t\tif (chunkGraph.isModuleInChunk(module, this)) return false;\n\t\tchunkGraph.connectChunkAndModule(this, module);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tremoveModule(module) {\n\t\tChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.removeModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_REMOVE_MODULE\"\n\t\t).disconnectChunkAndModule(this, module);\n\t}\n\n\t/**\n\t * @returns {number} the number of module which are contained in this chunk\n\t */\n\tgetNumberOfModules() {\n\t\treturn ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.getNumberOfModules\",\n\t\t\t\"DEP_WEBPACK_CHUNK_GET_NUMBER_OF_MODULES\"\n\t\t).getNumberOfChunkModules(this);\n\t}\n\n\tget modulesIterable() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.modulesIterable\",\n\t\t\t\"DEP_WEBPACK_CHUNK_MODULES_ITERABLE\"\n\t\t);\n\t\treturn chunkGraph.getOrderedChunkModulesIterable(\n\t\t\tthis,\n\t\t\tcompareModulesByIdentifier\n\t\t);\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the chunk to compare with\n\t * @returns {-1|0|1} the comparison result\n\t */\n\tcompareTo(otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.compareTo\",\n\t\t\t\"DEP_WEBPACK_CHUNK_COMPARE_TO\"\n\t\t);\n\t\treturn chunkGraph.compareChunks(this, otherChunk);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {boolean} true, if the chunk contains the module\n\t */\n\tcontainsModule(module) {\n\t\treturn ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.containsModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_CONTAINS_MODULE\"\n\t\t).isModuleInChunk(module, this);\n\t}\n\n\t/**\n\t * @returns {Module[]} the modules for this chunk\n\t */\n\tgetModules() {\n\t\treturn ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.getModules\",\n\t\t\t\"DEP_WEBPACK_CHUNK_GET_MODULES\"\n\t\t).getChunkModules(this);\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tremove() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.remove\",\n\t\t\t\"DEP_WEBPACK_CHUNK_REMOVE\"\n\t\t);\n\t\tchunkGraph.disconnectChunk(this);\n\t\tthis.disconnectFromGroups();\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {Chunk} otherChunk the target chunk\n\t * @returns {void}\n\t */\n\tmoveModule(module, otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.moveModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_MOVE_MODULE\"\n\t\t);\n\t\tchunkGraph.disconnectChunkAndModule(this, module);\n\t\tchunkGraph.connectChunkAndModule(otherChunk, module);\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the other chunk\n\t * @returns {boolean} true, if the specified chunk has been integrated\n\t */\n\tintegrate(otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.integrate\",\n\t\t\t\"DEP_WEBPACK_CHUNK_INTEGRATE\"\n\t\t);\n\t\tif (chunkGraph.canChunksBeIntegrated(this, otherChunk)) {\n\t\t\tchunkGraph.integrateChunks(this, otherChunk);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the other chunk\n\t * @returns {boolean} true, if chunks could be integrated\n\t */\n\tcanBeIntegrated(otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.canBeIntegrated\",\n\t\t\t\"DEP_WEBPACK_CHUNK_CAN_BE_INTEGRATED\"\n\t\t);\n\t\treturn chunkGraph.canChunksBeIntegrated(this, otherChunk);\n\t}\n\n\t/**\n\t * @returns {boolean} true, if this chunk contains no module\n\t */\n\tisEmpty() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.isEmpty\",\n\t\t\t\"DEP_WEBPACK_CHUNK_IS_EMPTY\"\n\t\t);\n\t\treturn chunkGraph.getNumberOfChunkModules(this) === 0;\n\t}\n\n\t/**\n\t * @returns {number} total size of all modules in this chunk\n\t */\n\tmodulesSize() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.modulesSize\",\n\t\t\t\"DEP_WEBPACK_CHUNK_MODULES_SIZE\"\n\t\t);\n\t\treturn chunkGraph.getChunkModulesSize(this);\n\t}\n\n\t/**\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of this chunk\n\t */\n\tsize(options = {}) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.size\",\n\t\t\t\"DEP_WEBPACK_CHUNK_SIZE\"\n\t\t);\n\t\treturn chunkGraph.getChunkSize(this, options);\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the other chunk\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of the chunk or false if the chunk can't be integrated\n\t */\n\tintegratedSize(otherChunk, options) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.integratedSize\",\n\t\t\t\"DEP_WEBPACK_CHUNK_INTEGRATED_SIZE\"\n\t\t);\n\t\treturn chunkGraph.getIntegratedChunksSize(this, otherChunk, options);\n\t}\n\n\t/**\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @returns {ChunkModuleMaps} module map information\n\t */\n\tgetChunkModuleMaps(filterFn) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.getChunkModuleMaps\",\n\t\t\t\"DEP_WEBPACK_CHUNK_GET_CHUNK_MODULE_MAPS\"\n\t\t);\n\t\t/** @type {Record<string|number, (string|number)[]>} */\n\t\tconst chunkModuleIdMap = Object.create(null);\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkModuleHashMap = Object.create(null);\n\n\t\tfor (const asyncChunk of this.getAllAsyncChunks()) {\n\t\t\t/** @type {(string|number)[]} */\n\t\t\tlet array;\n\t\t\tfor (const module of chunkGraph.getOrderedChunkModulesIterable(\n\t\t\t\tasyncChunk,\n\t\t\t\tcompareModulesById(chunkGraph)\n\t\t\t)) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tchunkModuleIdMap[asyncChunk.id] = array;\n\t\t\t\t\t}\n\t\t\t\t\tconst moduleId = chunkGraph.getModuleId(module);\n\t\t\t\t\tarray.push(moduleId);\n\t\t\t\t\tchunkModuleHashMap[moduleId] = chunkGraph.getRenderedModuleHash(\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tundefined\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tid: chunkModuleIdMap,\n\t\t\thash: chunkModuleHashMap\n\t\t};\n\t}\n\n\t/**\n\t * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n\t * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n\t * @returns {boolean} return true if module exists in graph\n\t */\n\thasModuleInGraph(filterFn, filterChunkFn) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.hasModuleInGraph\",\n\t\t\t\"DEP_WEBPACK_CHUNK_HAS_MODULE_IN_GRAPH\"\n\t\t);\n\t\treturn chunkGraph.hasModuleInGraph(this, filterFn, filterChunkFn);\n\t}\n\n\t/**\n\t * @deprecated\n\t * @param {boolean} realHash whether the full hash or the rendered hash is to be used\n\t * @returns {ChunkMaps} the chunk map information\n\t */\n\tgetChunkMaps(realHash) {\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkHashMap = Object.create(null);\n\t\t/** @type {Record<string|number, Record<string, string>>} */\n\t\tconst chunkContentHashMap = Object.create(null);\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkNameMap = Object.create(null);\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\tchunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n\t\t\tfor (const key of Object.keys(chunk.contentHash)) {\n\t\t\t\tif (!chunkContentHashMap[key]) {\n\t\t\t\t\tchunkContentHashMap[key] = Object.create(null);\n\t\t\t\t}\n\t\t\t\tchunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n\t\t\t}\n\t\t\tif (chunk.name) {\n\t\t\t\tchunkNameMap[chunk.id] = chunk.name;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\thash: chunkHashMap,\n\t\t\tcontentHash: chunkContentHashMap,\n\t\t\tname: chunkNameMap\n\t\t};\n\t}\n\t// BACKWARD-COMPAT END\n\n\t/**\n\t * @returns {boolean} whether or not the Chunk will have a runtime\n\t */\n\thasRuntime() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (\n\t\t\t\tchunkGroup instanceof Entrypoint &&\n\t\t\t\tchunkGroup.getRuntimeChunk() === this\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} whether or not this chunk can be an initial chunk\n\t */\n\tcanBeInitial() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (chunkGroup.isInitial()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} whether this chunk can only be an initial chunk\n\t */\n\tisOnlyInitial() {\n\t\tif (this._groups.size <= 0) return false;\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (!chunkGroup.isInitial()) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @returns {EntryOptions | undefined} the entry options for this chunk\n\t */\n\tgetEntryOptions() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (chunkGroup instanceof Entrypoint) {\n\t\t\t\treturn chunkGroup.options;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\n\t * @returns {void}\n\t */\n\taddGroup(chunkGroup) {\n\t\tthis._groups.add(chunkGroup);\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\n\t * @returns {void}\n\t */\n\tremoveGroup(chunkGroup) {\n\t\tthis._groups.delete(chunkGroup);\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to check\n\t * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\n\t */\n\tisInGroup(chunkGroup) {\n\t\treturn this._groups.has(chunkGroup);\n\t}\n\n\t/**\n\t * @returns {number} the amount of groups that the said chunk is in\n\t */\n\tgetNumberOfGroups() {\n\t\treturn this._groups.size;\n\t}\n\n\t/**\n\t * @returns {Iterable<ChunkGroup>} the chunkGroups that the said chunk is referenced in\n\t */\n\tget groupsIterable() {\n\t\tthis._groups.sort();\n\t\treturn this._groups;\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tdisconnectFromGroups() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tchunkGroup.removeChunk(this);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} newChunk the new chunk that will be split out of\n\t * @returns {void}\n\t */\n\tsplit(newChunk) {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tchunkGroup.insertChunk(newChunk, this);\n\t\t\tnewChunk.addGroup(chunkGroup);\n\t\t}\n\t\tfor (const idHint of this.idNameHints) {\n\t\t\tnewChunk.idNameHints.add(idHint);\n\t\t}\n\t\tnewChunk.runtime = mergeRuntime(newChunk.runtime, this.runtime);\n\t}\n\n\t/**\n\t * @param {Hash} hash hash (will be modified)\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {void}\n\t */\n\tupdateHash(hash, chunkGraph) {\n\t\thash.update(\n\t\t\t`${this.id} ${this.ids ? this.ids.join() : \"\"} ${this.name || \"\"} `\n\t\t);\n\t\tconst xor = new StringXor();\n\t\tfor (const m of chunkGraph.getChunkModulesIterable(this)) {\n\t\t\txor.add(chunkGraph.getModuleHash(m, this.runtime));\n\t\t}\n\t\txor.updateHash(hash);\n\t\tconst entryModules =\n\t\t\tchunkGraph.getChunkEntryModulesWithChunkGroupIterable(this);\n\t\tfor (const [m, chunkGroup] of entryModules) {\n\t\t\thash.update(`entry${chunkGraph.getModuleId(m)}${chunkGroup.id}`);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {Set<Chunk>} a set of all the async chunks\n\t */\n\tgetAllAsyncChunks() {\n\t\tconst queue = new Set();\n\t\tconst chunks = new Set();\n\n\t\tconst initialChunks = intersect(\n\t\t\tArray.from(this.groupsIterable, g => new Set(g.chunks))\n\t\t);\n\n\t\tconst initialQueue = new Set(this.groupsIterable);\n\n\t\tfor (const chunkGroup of initialQueue) {\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tif (child instanceof Entrypoint) {\n\t\t\t\t\tinitialQueue.add(child);\n\t\t\t\t} else {\n\t\t\t\t\tqueue.add(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tif (!initialChunks.has(chunk)) {\n\t\t\t\t\tchunks.add(chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * @returns {Set<Chunk>} a set of all the initial chunks (including itself)\n\t */\n\tgetAllInitialChunks() {\n\t\tconst chunks = new Set();\n\t\tconst queue = new Set(this.groupsIterable);\n\t\tfor (const group of queue) {\n\t\t\tif (group.isInitial()) {\n\t\t\t\tfor (const c of group.chunks) chunks.add(c);\n\t\t\t\tfor (const g of group.childrenIterable) queue.add(g);\n\t\t\t}\n\t\t}\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * @returns {Set<Chunk>} a set of all the referenced chunks (including itself)\n\t */\n\tgetAllReferencedChunks() {\n\t\tconst queue = new Set(this.groupsIterable);\n\t\tconst chunks = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tchunks.add(chunk);\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * @returns {Set<Entrypoint>} a set of all the referenced entrypoints\n\t */\n\tgetAllReferencedAsyncEntrypoints() {\n\t\tconst queue = new Set(this.groupsIterable);\n\t\tconst entrypoints = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const entrypoint of chunkGroup.asyncEntrypointsIterable) {\n\t\t\t\tentrypoints.add(entrypoint);\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn entrypoints;\n\t}\n\n\t/**\n\t * @returns {boolean} true, if the chunk references async chunks\n\t */\n\thasAsyncChunks() {\n\t\tconst queue = new Set();\n\n\t\tconst initialChunks = intersect(\n\t\t\tArray.from(this.groupsIterable, g => new Set(g.chunks))\n\t\t);\n\n\t\tfor (const chunkGroup of this.groupsIterable) {\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tif (!initialChunks.has(chunk)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n\t * @returns {Record<string, (string | number)[]>} a record object of names to lists of child ids(?)\n\t */\n\tgetChildIdsByOrders(chunkGraph, filterFn) {\n\t\t/** @type {Map<string, {order: number, group: ChunkGroup}[]>} */\n\t\tconst lists = new Map();\n\t\tfor (const group of this.groupsIterable) {\n\t\t\tif (group.chunks[group.chunks.length - 1] === this) {\n\t\t\t\tfor (const childGroup of group.childrenIterable) {\n\t\t\t\t\tfor (const key of Object.keys(childGroup.options)) {\n\t\t\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\t\t\tconst name = key.slice(0, key.length - \"Order\".length);\n\t\t\t\t\t\t\tlet list = lists.get(name);\n\t\t\t\t\t\t\tif (list === undefined) {\n\t\t\t\t\t\t\t\tlist = [];\n\t\t\t\t\t\t\t\tlists.set(name, list);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlist.push({\n\t\t\t\t\t\t\t\torder: childGroup.options[key],\n\t\t\t\t\t\t\t\tgroup: childGroup\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/** @type {Record<string, (string | number)[]>} */\n\t\tconst result = Object.create(null);\n\t\tfor (const [name, list] of lists) {\n\t\t\tlist.sort((a, b) => {\n\t\t\t\tconst cmp = b.order - a.order;\n\t\t\t\tif (cmp !== 0) return cmp;\n\t\t\t\treturn a.group.compareTo(chunkGraph, b.group);\n\t\t\t});\n\t\t\t/** @type {Set<string | number>} */\n\t\t\tconst chunkIdSet = new Set();\n\t\t\tfor (const item of list) {\n\t\t\t\tfor (const chunk of item.group.chunks) {\n\t\t\t\t\tif (filterFn && !filterFn(chunk, chunkGraph)) continue;\n\t\t\t\t\tchunkIdSet.add(chunk.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chunkIdSet.size > 0) {\n\t\t\t\tresult[name] = Array.from(chunkIdSet);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {string} type option name\n\t * @returns {{ onChunks: Chunk[], chunks: Set<Chunk> }[]} referenced chunks for a specific type\n\t */\n\tgetChildrenOfTypeInOrder(chunkGraph, type) {\n\t\tconst list = [];\n\t\tfor (const group of this.groupsIterable) {\n\t\t\tfor (const childGroup of group.childrenIterable) {\n\t\t\t\tconst order = childGroup.options[type];\n\t\t\t\tif (order === undefined) continue;\n\t\t\t\tlist.push({\n\t\t\t\t\torder,\n\t\t\t\t\tgroup,\n\t\t\t\t\tchildGroup\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (list.length === 0) return undefined;\n\t\tlist.sort((a, b) => {\n\t\t\tconst cmp = b.order - a.order;\n\t\t\tif (cmp !== 0) return cmp;\n\t\t\treturn a.group.compareTo(chunkGraph, b.group);\n\t\t});\n\t\tconst result = [];\n\t\tlet lastEntry;\n\t\tfor (const { group, childGroup } of list) {\n\t\t\tif (lastEntry && lastEntry.onChunks === group.chunks) {\n\t\t\t\tfor (const chunk of childGroup.chunks) {\n\t\t\t\t\tlastEntry.chunks.add(chunk);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult.push(\n\t\t\t\t\t(lastEntry = {\n\t\t\t\t\t\tonChunks: group.chunks,\n\t\t\t\t\t\tchunks: new Set(childGroup.chunks)\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {boolean=} includeDirectChildren include direct children (by default only children of async children are included)\n\t * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n\t * @returns {Record<string|number, Record<string, (string | number)[]>>} a record object of names to lists of child ids(?) by chunk id\n\t */\n\tgetChildIdsByOrdersMap(chunkGraph, includeDirectChildren, filterFn) {\n\t\t/** @type {Record<string|number, Record<string, (string | number)[]>>} */\n\t\tconst chunkMaps = Object.create(null);\n\n\t\t/**\n\t\t * @param {Chunk} chunk a chunk\n\t\t * @returns {void}\n\t\t */\n\t\tconst addChildIdsByOrdersToMap = chunk => {\n\t\t\tconst data = chunk.getChildIdsByOrders(chunkGraph, filterFn);\n\t\t\tfor (const key of Object.keys(data)) {\n\t\t\t\tlet chunkMap = chunkMaps[key];\n\t\t\t\tif (chunkMap === undefined) {\n\t\t\t\t\tchunkMaps[key] = chunkMap = Object.create(null);\n\t\t\t\t}\n\t\t\t\tchunkMap[chunk.id] = data[key];\n\t\t\t}\n\t\t};\n\n\t\tif (includeDirectChildren) {\n\t\t\t/** @type {Set<Chunk>} */\n\t\t\tconst chunks = new Set();\n\t\t\tfor (const chunkGroup of this.groupsIterable) {\n\t\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\t\tchunks.add(chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const chunk of chunks) {\n\t\t\t\taddChildIdsByOrdersToMap(chunk);\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\taddChildIdsByOrdersToMap(chunk);\n\t\t}\n\n\t\treturn chunkMaps;\n\t}\n}\n\nmodule.exports = Chunk;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}