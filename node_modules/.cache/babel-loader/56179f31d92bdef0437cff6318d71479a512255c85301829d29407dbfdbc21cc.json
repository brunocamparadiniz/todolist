{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _require = require(\"enhanced-resolve\"),\n  forEachBail = _require.forEachBail;\nvar asyncLib = require(\"neo-async\");\nvar _getLazyHashedEtag = require(\"./cache/getLazyHashedEtag\");\nvar _mergeEtags = require(\"./cache/mergeEtags\");\n\n/** @typedef {import(\"./Cache\")} Cache */\n/** @typedef {import(\"./Cache\").Etag} Etag */\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n/** @typedef {import(\"./cache/getLazyHashedEtag\").HashableObject} HashableObject */\n/** @typedef {typeof import(\"./util/Hash\")} HashConstructor */\n\n/**\n * @template T\n * @callback CallbackCache\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\n/**\n * @template T\n * @callback CallbackNormalErrorCache\n * @param {(Error | null)=} err\n * @param {T=} result\n * @returns {void}\n */\nvar MultiItemCache = /*#__PURE__*/function () {\n  /**\n   * @param {ItemCacheFacade[]} items item caches\n   */\n  function MultiItemCache(items) {\n    _classCallCheck(this, MultiItemCache);\n    this._items = items;\n    if (items.length === 1) return (/** @type {any} */items[0]\n    );\n  }\n\n  /**\n   * @template T\n   * @param {CallbackCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n  _createClass(MultiItemCache, [{\n    key: \"get\",\n    value: function get(callback) {\n      forEachBail(this._items, function (item, callback) {\n        return item.get(callback);\n      }, callback);\n    }\n\n    /**\n     * @template T\n     * @returns {Promise<T>} promise with the data\n     */\n  }, {\n    key: \"getPromise\",\n    value: function getPromise() {\n      var _this = this;\n      var next = function next(i) {\n        return _this._items[i].getPromise().then(function (result) {\n          if (result !== undefined) return result;\n          if (++i < _this._items.length) return next(i);\n        });\n      };\n      return next(0);\n    }\n\n    /**\n     * @template T\n     * @param {T} data the value to store\n     * @param {CallbackCache<void>} callback signals when the value is stored\n     * @returns {void}\n     */\n  }, {\n    key: \"store\",\n    value: function store(data, callback) {\n      asyncLib.each(this._items, function (item, callback) {\n        return item.store(data, callback);\n      }, callback);\n    }\n\n    /**\n     * @template T\n     * @param {T} data the value to store\n     * @returns {Promise<void>} promise signals when the value is stored\n     */\n  }, {\n    key: \"storePromise\",\n    value: function storePromise(data) {\n      return Promise.all(this._items.map(function (item) {\n        return item.storePromise(data);\n      })).then(function () {});\n    }\n  }]);\n  return MultiItemCache;\n}();\nvar ItemCacheFacade = /*#__PURE__*/function () {\n  /**\n   * @param {Cache} cache the root cache\n   * @param {string} name the child cache item name\n   * @param {Etag | null} etag the etag\n   */\n  function ItemCacheFacade(cache, name, etag) {\n    _classCallCheck(this, ItemCacheFacade);\n    this._cache = cache;\n    this._name = name;\n    this._etag = etag;\n  }\n\n  /**\n   * @template T\n   * @param {CallbackCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n  _createClass(ItemCacheFacade, [{\n    key: \"get\",\n    value: function get(callback) {\n      this._cache.get(this._name, this._etag, callback);\n    }\n\n    /**\n     * @template T\n     * @returns {Promise<T>} promise with the data\n     */\n  }, {\n    key: \"getPromise\",\n    value: function getPromise() {\n      var _this2 = this;\n      return new Promise(function (resolve, reject) {\n        _this2._cache.get(_this2._name, _this2._etag, function (err, data) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(data);\n          }\n        });\n      });\n    }\n\n    /**\n     * @template T\n     * @param {T} data the value to store\n     * @param {CallbackCache<void>} callback signals when the value is stored\n     * @returns {void}\n     */\n  }, {\n    key: \"store\",\n    value: function store(data, callback) {\n      this._cache.store(this._name, this._etag, data, callback);\n    }\n\n    /**\n     * @template T\n     * @param {T} data the value to store\n     * @returns {Promise<void>} promise signals when the value is stored\n     */\n  }, {\n    key: \"storePromise\",\n    value: function storePromise(data) {\n      var _this3 = this;\n      return new Promise(function (resolve, reject) {\n        _this3._cache.store(_this3._name, _this3._etag, data, function (err) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n      });\n    }\n\n    /**\n     * @template T\n     * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n     * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n     * @returns {void}\n     */\n  }, {\n    key: \"provide\",\n    value: function provide(computer, callback) {\n      var _this4 = this;\n      this.get(function (err, cacheEntry) {\n        if (err) return callback(err);\n        if (cacheEntry !== undefined) return cacheEntry;\n        computer(function (err, result) {\n          if (err) return callback(err);\n          _this4.store(result, function (err) {\n            if (err) return callback(err);\n            callback(null, result);\n          });\n        });\n      });\n    }\n\n    /**\n     * @template T\n     * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n     * @returns {Promise<T>} promise with the data\n     */\n  }, {\n    key: \"providePromise\",\n    value: function () {\n      var _providePromise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(computer) {\n        var cacheEntry, result;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return this.getPromise();\n            case 2:\n              cacheEntry = _context.sent;\n              if (!(cacheEntry !== undefined)) {\n                _context.next = 5;\n                break;\n              }\n              return _context.abrupt(\"return\", cacheEntry);\n            case 5:\n              _context.next = 7;\n              return computer();\n            case 7:\n              result = _context.sent;\n              _context.next = 10;\n              return this.storePromise(result);\n            case 10:\n              return _context.abrupt(\"return\", result);\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function providePromise(_x) {\n        return _providePromise.apply(this, arguments);\n      }\n      return providePromise;\n    }()\n  }]);\n  return ItemCacheFacade;\n}();\nvar CacheFacade = /*#__PURE__*/function () {\n  /**\n   * @param {Cache} cache the root cache\n   * @param {string} name the child cache name\n   * @param {string | HashConstructor} hashFunction the hash function to use\n   */\n  function CacheFacade(cache, name, hashFunction) {\n    _classCallCheck(this, CacheFacade);\n    this._cache = cache;\n    this._name = name;\n    this._hashFunction = hashFunction;\n  }\n\n  /**\n   * @param {string} name the child cache name#\n   * @returns {CacheFacade} child cache\n   */\n  _createClass(CacheFacade, [{\n    key: \"getChildCache\",\n    value: function getChildCache(name) {\n      return new CacheFacade(this._cache, \"\".concat(this._name, \"|\").concat(name), this._hashFunction);\n    }\n\n    /**\n     * @param {string} identifier the cache identifier\n     * @param {Etag | null} etag the etag\n     * @returns {ItemCacheFacade} item cache\n     */\n  }, {\n    key: \"getItemCache\",\n    value: function getItemCache(identifier, etag) {\n      return new ItemCacheFacade(this._cache, \"\".concat(this._name, \"|\").concat(identifier), etag);\n    }\n\n    /**\n     * @param {HashableObject} obj an hashable object\n     * @returns {Etag} an etag that is lazy hashed\n     */\n  }, {\n    key: \"getLazyHashedEtag\",\n    value: function getLazyHashedEtag(obj) {\n      return _getLazyHashedEtag(obj, this._hashFunction);\n    }\n\n    /**\n     * @param {Etag} a an etag\n     * @param {Etag} b another etag\n     * @returns {Etag} an etag that represents both\n     */\n  }, {\n    key: \"mergeEtags\",\n    value: function mergeEtags(a, b) {\n      return _mergeEtags(a, b);\n    }\n\n    /**\n     * @template T\n     * @param {string} identifier the cache identifier\n     * @param {Etag | null} etag the etag\n     * @param {CallbackCache<T>} callback signals when the value is retrieved\n     * @returns {void}\n     */\n  }, {\n    key: \"get\",\n    value: function get(identifier, etag, callback) {\n      this._cache.get(\"\".concat(this._name, \"|\").concat(identifier), etag, callback);\n    }\n\n    /**\n     * @template T\n     * @param {string} identifier the cache identifier\n     * @param {Etag | null} etag the etag\n     * @returns {Promise<T>} promise with the data\n     */\n  }, {\n    key: \"getPromise\",\n    value: function getPromise(identifier, etag) {\n      var _this5 = this;\n      return new Promise(function (resolve, reject) {\n        _this5._cache.get(\"\".concat(_this5._name, \"|\").concat(identifier), etag, function (err, data) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(data);\n          }\n        });\n      });\n    }\n\n    /**\n     * @template T\n     * @param {string} identifier the cache identifier\n     * @param {Etag | null} etag the etag\n     * @param {T} data the value to store\n     * @param {CallbackCache<void>} callback signals when the value is stored\n     * @returns {void}\n     */\n  }, {\n    key: \"store\",\n    value: function store(identifier, etag, data, callback) {\n      this._cache.store(\"\".concat(this._name, \"|\").concat(identifier), etag, data, callback);\n    }\n\n    /**\n     * @template T\n     * @param {string} identifier the cache identifier\n     * @param {Etag | null} etag the etag\n     * @param {T} data the value to store\n     * @returns {Promise<void>} promise signals when the value is stored\n     */\n  }, {\n    key: \"storePromise\",\n    value: function storePromise(identifier, etag, data) {\n      var _this6 = this;\n      return new Promise(function (resolve, reject) {\n        _this6._cache.store(\"\".concat(_this6._name, \"|\").concat(identifier), etag, data, function (err) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n      });\n    }\n\n    /**\n     * @template T\n     * @param {string} identifier the cache identifier\n     * @param {Etag | null} etag the etag\n     * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n     * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n     * @returns {void}\n     */\n  }, {\n    key: \"provide\",\n    value: function provide(identifier, etag, computer, callback) {\n      var _this7 = this;\n      this.get(identifier, etag, function (err, cacheEntry) {\n        if (err) return callback(err);\n        if (cacheEntry !== undefined) return cacheEntry;\n        computer(function (err, result) {\n          if (err) return callback(err);\n          _this7.store(identifier, etag, result, function (err) {\n            if (err) return callback(err);\n            callback(null, result);\n          });\n        });\n      });\n    }\n\n    /**\n     * @template T\n     * @param {string} identifier the cache identifier\n     * @param {Etag | null} etag the etag\n     * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n     * @returns {Promise<T>} promise with the data\n     */\n  }, {\n    key: \"providePromise\",\n    value: function () {\n      var _providePromise2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(identifier, etag, computer) {\n        var cacheEntry, result;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.getPromise(identifier, etag);\n            case 2:\n              cacheEntry = _context2.sent;\n              if (!(cacheEntry !== undefined)) {\n                _context2.next = 5;\n                break;\n              }\n              return _context2.abrupt(\"return\", cacheEntry);\n            case 5:\n              _context2.next = 7;\n              return computer();\n            case 7:\n              result = _context2.sent;\n              _context2.next = 10;\n              return this.storePromise(identifier, etag, result);\n            case 10:\n              return _context2.abrupt(\"return\", result);\n            case 11:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function providePromise(_x2, _x3, _x4) {\n        return _providePromise2.apply(this, arguments);\n      }\n      return providePromise;\n    }()\n  }]);\n  return CacheFacade;\n}();\nmodule.exports = CacheFacade;\nmodule.exports.ItemCacheFacade = ItemCacheFacade;\nmodule.exports.MultiItemCache = MultiItemCache;","map":{"version":3,"names":["require","forEachBail","asyncLib","getLazyHashedEtag","mergeEtags","MultiItemCache","items","_items","length","callback","item","get","next","i","getPromise","then","result","undefined","data","each","store","Promise","all","map","storePromise","ItemCacheFacade","cache","name","etag","_cache","_name","_etag","resolve","reject","err","computer","cacheEntry","CacheFacade","hashFunction","_hashFunction","identifier","obj","a","b","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/CacheFacade.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { forEachBail } = require(\"enhanced-resolve\");\nconst asyncLib = require(\"neo-async\");\nconst getLazyHashedEtag = require(\"./cache/getLazyHashedEtag\");\nconst mergeEtags = require(\"./cache/mergeEtags\");\n\n/** @typedef {import(\"./Cache\")} Cache */\n/** @typedef {import(\"./Cache\").Etag} Etag */\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n/** @typedef {import(\"./cache/getLazyHashedEtag\").HashableObject} HashableObject */\n/** @typedef {typeof import(\"./util/Hash\")} HashConstructor */\n\n/**\n * @template T\n * @callback CallbackCache\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\n/**\n * @template T\n * @callback CallbackNormalErrorCache\n * @param {(Error | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\nclass MultiItemCache {\n\t/**\n\t * @param {ItemCacheFacade[]} items item caches\n\t */\n\tconstructor(items) {\n\t\tthis._items = items;\n\t\tif (items.length === 1) return /** @type {any} */ (items[0]);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {CallbackCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tget(callback) {\n\t\tforEachBail(this._items, (item, callback) => item.get(callback), callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tgetPromise() {\n\t\tconst next = i => {\n\t\t\treturn this._items[i].getPromise().then(result => {\n\t\t\t\tif (result !== undefined) return result;\n\t\t\t\tif (++i < this._items.length) return next(i);\n\t\t\t});\n\t\t};\n\t\treturn next(0);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @param {CallbackCache<void>} callback signals when the value is stored\n\t * @returns {void}\n\t */\n\tstore(data, callback) {\n\t\tasyncLib.each(\n\t\t\tthis._items,\n\t\t\t(item, callback) => item.store(data, callback),\n\t\t\tcallback\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @returns {Promise<void>} promise signals when the value is stored\n\t */\n\tstorePromise(data) {\n\t\treturn Promise.all(this._items.map(item => item.storePromise(data))).then(\n\t\t\t() => {}\n\t\t);\n\t}\n}\n\nclass ItemCacheFacade {\n\t/**\n\t * @param {Cache} cache the root cache\n\t * @param {string} name the child cache item name\n\t * @param {Etag | null} etag the etag\n\t */\n\tconstructor(cache, name, etag) {\n\t\tthis._cache = cache;\n\t\tthis._name = name;\n\t\tthis._etag = etag;\n\t}\n\n\t/**\n\t * @template T\n\t * @param {CallbackCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tget(callback) {\n\t\tthis._cache.get(this._name, this._etag, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tgetPromise() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.get(this._name, this._etag, (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(data);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @param {CallbackCache<void>} callback signals when the value is stored\n\t * @returns {void}\n\t */\n\tstore(data, callback) {\n\t\tthis._cache.store(this._name, this._etag, data, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @returns {Promise<void>} promise signals when the value is stored\n\t */\n\tstorePromise(data) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.store(this._name, this._etag, data, err => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n\t * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tprovide(computer, callback) {\n\t\tthis.get((err, cacheEntry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tcomputer((err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tthis.store(result, err => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tcallback(null, result);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tasync providePromise(computer) {\n\t\tconst cacheEntry = await this.getPromise();\n\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\tconst result = await computer();\n\t\tawait this.storePromise(result);\n\t\treturn result;\n\t}\n}\n\nclass CacheFacade {\n\t/**\n\t * @param {Cache} cache the root cache\n\t * @param {string} name the child cache name\n\t * @param {string | HashConstructor} hashFunction the hash function to use\n\t */\n\tconstructor(cache, name, hashFunction) {\n\t\tthis._cache = cache;\n\t\tthis._name = name;\n\t\tthis._hashFunction = hashFunction;\n\t}\n\n\t/**\n\t * @param {string} name the child cache name#\n\t * @returns {CacheFacade} child cache\n\t */\n\tgetChildCache(name) {\n\t\treturn new CacheFacade(\n\t\t\tthis._cache,\n\t\t\t`${this._name}|${name}`,\n\t\t\tthis._hashFunction\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @returns {ItemCacheFacade} item cache\n\t */\n\tgetItemCache(identifier, etag) {\n\t\treturn new ItemCacheFacade(\n\t\t\tthis._cache,\n\t\t\t`${this._name}|${identifier}`,\n\t\t\tetag\n\t\t);\n\t}\n\n\t/**\n\t * @param {HashableObject} obj an hashable object\n\t * @returns {Etag} an etag that is lazy hashed\n\t */\n\tgetLazyHashedEtag(obj) {\n\t\treturn getLazyHashedEtag(obj, this._hashFunction);\n\t}\n\n\t/**\n\t * @param {Etag} a an etag\n\t * @param {Etag} b another etag\n\t * @returns {Etag} an etag that represents both\n\t */\n\tmergeEtags(a, b) {\n\t\treturn mergeEtags(a, b);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {CallbackCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tget(identifier, etag, callback) {\n\t\tthis._cache.get(`${this._name}|${identifier}`, etag, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tgetPromise(identifier, etag) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.get(`${this._name}|${identifier}`, etag, (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(data);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {T} data the value to store\n\t * @param {CallbackCache<void>} callback signals when the value is stored\n\t * @returns {void}\n\t */\n\tstore(identifier, etag, data, callback) {\n\t\tthis._cache.store(`${this._name}|${identifier}`, etag, data, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {T} data the value to store\n\t * @returns {Promise<void>} promise signals when the value is stored\n\t */\n\tstorePromise(identifier, etag, data) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.store(`${this._name}|${identifier}`, etag, data, err => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n\t * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tprovide(identifier, etag, computer, callback) {\n\t\tthis.get(identifier, etag, (err, cacheEntry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tcomputer((err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tthis.store(identifier, etag, result, err => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tcallback(null, result);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tasync providePromise(identifier, etag, computer) {\n\t\tconst cacheEntry = await this.getPromise(identifier, etag);\n\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\tconst result = await computer();\n\t\tawait this.storePromise(identifier, etag, result);\n\t\treturn result;\n\t}\n}\n\nmodule.exports = CacheFacade;\nmodule.exports.ItemCacheFacade = ItemCacheFacade;\nmodule.exports.MultiItemCache = MultiItemCache;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}