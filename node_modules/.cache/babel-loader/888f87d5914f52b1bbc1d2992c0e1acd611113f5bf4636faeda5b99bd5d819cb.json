{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar Source = require(\"./Source\");\nvar RawSource = require(\"./RawSource\");\nvar _streamChunks = require(\"./helpers/streamChunks\");\nvar _require = require(\"./helpers/getFromStreamChunks\"),\n  getMap = _require.getMap,\n  getSourceAndMap = _require.getSourceAndMap;\nvar REPLACE_REGEX = /\\n(?=.|\\s)/g;\nvar PrefixSource = /*#__PURE__*/function (_Source) {\n  _inherits(PrefixSource, _Source);\n  var _super = _createSuper(PrefixSource);\n  function PrefixSource(prefix, source) {\n    var _this;\n    _classCallCheck(this, PrefixSource);\n    _this = _super.call(this);\n    _this._source = typeof source === \"string\" || Buffer.isBuffer(source) ? new RawSource(source, true) : source;\n    _this._prefix = prefix;\n    return _this;\n  }\n  _createClass(PrefixSource, [{\n    key: \"getPrefix\",\n    value: function getPrefix() {\n      return this._prefix;\n    }\n  }, {\n    key: \"original\",\n    value: function original() {\n      return this._source;\n    }\n  }, {\n    key: \"source\",\n    value: function source() {\n      var node = this._source.source();\n      var prefix = this._prefix;\n      return prefix + node.replace(REPLACE_REGEX, \"\\n\" + prefix);\n    }\n\n    // TODO efficient buffer() implementation\n  }, {\n    key: \"map\",\n    value: function map(options) {\n      return getMap(this, options);\n    }\n  }, {\n    key: \"sourceAndMap\",\n    value: function sourceAndMap(options) {\n      return getSourceAndMap(this, options);\n    }\n  }, {\n    key: \"streamChunks\",\n    value: function streamChunks(options, onChunk, onSource, onName) {\n      var prefix = this._prefix;\n      var prefixOffset = prefix.length;\n      var linesOnly = !!(options && options.columns === false);\n      var _streamChunks2 = _streamChunks(this._source, options, function (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) {\n          if (generatedColumn !== 0) {\n            // In the middle of the line, we just adject the column\n            generatedColumn += prefixOffset;\n          } else if (chunk !== undefined) {\n            // At the start of the line, when we have source content\n            // add the prefix as generated mapping\n            // (in lines only mode we just add it to the original mapping\n            // for performance reasons)\n            if (linesOnly || sourceIndex < 0) {\n              chunk = prefix + chunk;\n            } else if (prefixOffset > 0) {\n              onChunk(prefix, generatedLine, generatedColumn, -1, -1, -1, -1);\n              generatedColumn += prefixOffset;\n            }\n          } else if (!linesOnly) {\n            // Without source content, we only need to adject the column info\n            // expect in lines only mode where prefix is added to original mapping\n            generatedColumn += prefixOffset;\n          }\n          onChunk(chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex);\n        }, onSource, onName),\n        generatedLine = _streamChunks2.generatedLine,\n        generatedColumn = _streamChunks2.generatedColumn,\n        source = _streamChunks2.source;\n      return {\n        generatedLine: generatedLine,\n        generatedColumn: generatedColumn === 0 ? 0 : prefixOffset + generatedColumn,\n        source: source !== undefined ? prefix + source.replace(REPLACE_REGEX, \"\\n\" + prefix) : undefined\n      };\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      hash.update(\"PrefixSource\");\n      this._source.updateHash(hash);\n      hash.update(this._prefix);\n    }\n  }]);\n  return PrefixSource;\n}(Source);\nmodule.exports = PrefixSource;","map":{"version":3,"names":["Source","require","RawSource","streamChunks","getMap","getSourceAndMap","REPLACE_REGEX","PrefixSource","prefix","source","_source","Buffer","isBuffer","_prefix","node","replace","options","onChunk","onSource","onName","prefixOffset","length","linesOnly","columns","chunk","generatedLine","generatedColumn","sourceIndex","originalLine","originalColumn","nameIndex","undefined","hash","update","updateHash","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack-sources/lib/PrefixSource.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\nconst RawSource = require(\"./RawSource\");\nconst streamChunks = require(\"./helpers/streamChunks\");\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\n\nconst REPLACE_REGEX = /\\n(?=.|\\s)/g;\n\nclass PrefixSource extends Source {\n\tconstructor(prefix, source) {\n\t\tsuper();\n\t\tthis._source =\n\t\t\ttypeof source === \"string\" || Buffer.isBuffer(source)\n\t\t\t\t? new RawSource(source, true)\n\t\t\t\t: source;\n\t\tthis._prefix = prefix;\n\t}\n\n\tgetPrefix() {\n\t\treturn this._prefix;\n\t}\n\n\toriginal() {\n\t\treturn this._source;\n\t}\n\n\tsource() {\n\t\tconst node = this._source.source();\n\t\tconst prefix = this._prefix;\n\t\treturn prefix + node.replace(REPLACE_REGEX, \"\\n\" + prefix);\n\t}\n\n\t// TODO efficient buffer() implementation\n\n\tmap(options) {\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tconst prefix = this._prefix;\n\t\tconst prefixOffset = prefix.length;\n\t\tconst linesOnly = !!(options && options.columns === false);\n\t\tconst { generatedLine, generatedColumn, source } = streamChunks(\n\t\t\tthis._source,\n\t\t\toptions,\n\t\t\t(\n\t\t\t\tchunk,\n\t\t\t\tgeneratedLine,\n\t\t\t\tgeneratedColumn,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\tnameIndex\n\t\t\t) => {\n\t\t\t\tif (generatedColumn !== 0) {\n\t\t\t\t\t// In the middle of the line, we just adject the column\n\t\t\t\t\tgeneratedColumn += prefixOffset;\n\t\t\t\t} else if (chunk !== undefined) {\n\t\t\t\t\t// At the start of the line, when we have source content\n\t\t\t\t\t// add the prefix as generated mapping\n\t\t\t\t\t// (in lines only mode we just add it to the original mapping\n\t\t\t\t\t// for performance reasons)\n\t\t\t\t\tif (linesOnly || sourceIndex < 0) {\n\t\t\t\t\t\tchunk = prefix + chunk;\n\t\t\t\t\t} else if (prefixOffset > 0) {\n\t\t\t\t\t\tonChunk(prefix, generatedLine, generatedColumn, -1, -1, -1, -1);\n\t\t\t\t\t\tgeneratedColumn += prefixOffset;\n\t\t\t\t\t}\n\t\t\t\t} else if (!linesOnly) {\n\t\t\t\t\t// Without source content, we only need to adject the column info\n\t\t\t\t\t// expect in lines only mode where prefix is added to original mapping\n\t\t\t\t\tgeneratedColumn += prefixOffset;\n\t\t\t\t}\n\t\t\t\tonChunk(\n\t\t\t\t\tchunk,\n\t\t\t\t\tgeneratedLine,\n\t\t\t\t\tgeneratedColumn,\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\toriginalLine,\n\t\t\t\t\toriginalColumn,\n\t\t\t\t\tnameIndex\n\t\t\t\t);\n\t\t\t},\n\t\t\tonSource,\n\t\t\tonName\n\t\t);\n\t\treturn {\n\t\t\tgeneratedLine,\n\t\t\tgeneratedColumn:\n\t\t\t\tgeneratedColumn === 0 ? 0 : prefixOffset + generatedColumn,\n\t\t\tsource:\n\t\t\t\tsource !== undefined\n\t\t\t\t\t? prefix + source.replace(REPLACE_REGEX, \"\\n\" + prefix)\n\t\t\t\t\t: undefined\n\t\t};\n\t}\n\n\tupdateHash(hash) {\n\t\thash.update(\"PrefixSource\");\n\t\tthis._source.updateHash(hash);\n\t\thash.update(this._prefix);\n\t}\n}\n\nmodule.exports = PrefixSource;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}