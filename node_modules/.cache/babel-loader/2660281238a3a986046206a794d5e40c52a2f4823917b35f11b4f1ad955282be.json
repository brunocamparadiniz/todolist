{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _objectSpread = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar Chunk = require(\"../Chunk\");\nvar _require = require(\"../OptimizationStages\"),\n  STAGE_ADVANCED = _require.STAGE_ADVANCED;\nvar WebpackError = require(\"../WebpackError\");\nvar _require2 = require(\"../ids/IdHelpers\"),\n  requestToId = _require2.requestToId;\nvar _require3 = require(\"../util/SetHelpers\"),\n  isSubset = _require3.isSubset;\nvar SortableSet = require(\"../util/SortableSet\");\nvar _require4 = require(\"../util/comparators\"),\n  compareModulesByIdentifier = _require4.compareModulesByIdentifier,\n  compareIterables = _require4.compareIterables;\nvar createHash = require(\"../util/createHash\");\nvar deterministicGrouping = require(\"../util/deterministicGrouping\");\nvar _require5 = require(\"../util/identifier\"),\n  makePathsRelative = _require5.makePathsRelative;\nvar memoize = require(\"../util/memoize\");\nvar MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksCacheGroup} OptimizationSplitChunksCacheGroup */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksGetCacheGroups} OptimizationSplitChunksGetCacheGroups */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksOptions} OptimizationSplitChunksOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksSizes} OptimizationSplitChunksSizes */\n/** @typedef {import(\"../../declarations/WebpackOptions\").Output} OutputOptions */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n\n/** @typedef {Record<string, number>} SplitChunksSizes */\n\n/**\n * @callback ChunkFilterFunction\n * @param {Chunk} chunk\n * @returns {boolean}\n */\n\n/**\n * @callback CombineSizeFunction\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\n\n/**\n * @typedef {Object} CacheGroupSource\n * @property {string=} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {boolean=} enforce\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean=} reuseExistingChunk\n * @property {boolean=} usedExports\n */\n\n/**\n * @typedef {Object} CacheGroup\n * @property {string} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean} reuseExistingChunk\n * @property {boolean} usedExports\n * @property {boolean} _validateSize\n * @property {boolean} _validateRemainingSize\n * @property {SplitChunksSizes} _minSizeForMaxSize\n * @property {boolean} _conditionalEnforce\n */\n\n/**\n * @typedef {Object} FallbackCacheGroup\n * @property {ChunkFilterFunction} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {string} automaticNameDelimiter\n */\n\n/**\n * @typedef {Object} CacheGroupsContext\n * @property {ModuleGraph} moduleGraph\n * @property {ChunkGraph} chunkGraph\n */\n\n/**\n * @callback GetCacheGroups\n * @param {Module} module\n * @param {CacheGroupsContext} context\n * @returns {CacheGroupSource[]}\n */\n\n/**\n * @callback GetName\n * @param {Module=} module\n * @param {Chunk[]=} chunks\n * @param {string=} key\n * @returns {string=}\n */\n\n/**\n * @typedef {Object} SplitChunksOptions\n * @property {ChunkFilterFunction} chunksFilter\n * @property {string[]} defaultSizeTypes\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxInitialSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {number} minChunks\n * @property {number} maxAsyncRequests\n * @property {number} maxInitialRequests\n * @property {boolean} hidePathInfo\n * @property {string | function(PathData, AssetInfo=): string} filename\n * @property {string} automaticNameDelimiter\n * @property {GetCacheGroups} getCacheGroups\n * @property {GetName} getName\n * @property {boolean} usedExports\n * @property {FallbackCacheGroup} fallbackCacheGroup\n */\n\n/**\n * @typedef {Object} ChunksInfoItem\n * @property {SortableSet<Module>} modules\n * @property {CacheGroup} cacheGroup\n * @property {number} cacheGroupIndex\n * @property {string} name\n * @property {Record<string, number>} sizes\n * @property {Set<Chunk>} chunks\n * @property {Set<Chunk>} reuseableChunks\n * @property {Set<bigint | Chunk>} chunksKeys\n */\n\nvar defaultGetName = /** @type {GetName} */function defaultGetName() {};\nvar deterministicGroupingForModules = /** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */\ndeterministicGrouping;\n\n/** @type {WeakMap<Module, string>} */\nvar getKeyCache = new WeakMap();\n\n/**\n * @param {string} name a filename to hash\n * @param {OutputOptions} outputOptions hash function used\n * @returns {string} hashed filename\n */\nvar hashFilename = function hashFilename(name, outputOptions) {\n  var digest = /** @type {string} */\n  createHash(outputOptions.hashFunction).update(name).digest(outputOptions.hashDigest);\n  return digest.slice(0, 8);\n};\n\n/**\n * @param {Chunk} chunk the chunk\n * @returns {number} the number of requests\n */\nvar getRequests = function getRequests(chunk) {\n  var requests = 0;\n  var _iterator = _createForOfIteratorHelper(chunk.groupsIterable),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var chunkGroup = _step.value;\n      requests = Math.max(requests, chunkGroup.chunks.length);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return requests;\n};\nvar mapObject = function mapObject(obj, fn) {\n  var newObj = Object.create(null);\n  for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    newObj[key] = fn(obj[key], key);\n  }\n  return newObj;\n};\n\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\nvar isOverlap = function isOverlap(a, b) {\n  var _iterator2 = _createForOfIteratorHelper(a),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var item = _step2.value;\n      if (b.has(item)) return true;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return false;\n};\nvar compareModuleIterables = compareIterables(compareModulesByIdentifier);\n\n/**\n * @param {ChunksInfoItem} a item\n * @param {ChunksInfoItem} b item\n * @returns {number} compare result\n */\nvar compareEntries = function compareEntries(a, b) {\n  // 1. by priority\n  var diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n  if (diffPriority) return diffPriority;\n  // 2. by number of chunks\n  var diffCount = a.chunks.size - b.chunks.size;\n  if (diffCount) return diffCount;\n  // 3. by size reduction\n  var aSizeReduce = totalSize(a.sizes) * (a.chunks.size - 1);\n  var bSizeReduce = totalSize(b.sizes) * (b.chunks.size - 1);\n  var diffSizeReduce = aSizeReduce - bSizeReduce;\n  if (diffSizeReduce) return diffSizeReduce;\n  // 4. by cache group index\n  var indexDiff = b.cacheGroupIndex - a.cacheGroupIndex;\n  if (indexDiff) return indexDiff;\n  // 5. by number of modules (to be able to compare by identifier)\n  var modulesA = a.modules;\n  var modulesB = b.modules;\n  var diff = modulesA.size - modulesB.size;\n  if (diff) return diff;\n  // 6. by module identifiers\n  modulesA.sort();\n  modulesB.sort();\n  return compareModuleIterables(modulesA, modulesB);\n};\nvar INITIAL_CHUNK_FILTER = function INITIAL_CHUNK_FILTER(chunk) {\n  return chunk.canBeInitial();\n};\nvar ASYNC_CHUNK_FILTER = function ASYNC_CHUNK_FILTER(chunk) {\n  return !chunk.canBeInitial();\n};\nvar ALL_CHUNK_FILTER = function ALL_CHUNK_FILTER(chunk) {\n  return true;\n};\n\n/**\n * @param {OptimizationSplitChunksSizes} value the sizes\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {SplitChunksSizes} normalized representation\n */\nvar normalizeSizes = function normalizeSizes(value, defaultSizeTypes) {\n  if (typeof value === \"number\") {\n    /** @type {Record<string, number>} */\n    var o = {};\n    var _iterator3 = _createForOfIteratorHelper(defaultSizeTypes),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var sizeType = _step3.value;\n        o[sizeType] = value;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return o;\n  } else if (typeof value === \"object\" && value !== null) {\n    return _objectSpread({}, value);\n  } else {\n    return {};\n  }\n};\n\n/**\n * @param {...SplitChunksSizes} sizes the sizes\n * @returns {SplitChunksSizes} the merged sizes\n */\nvar mergeSizes = function mergeSizes() {\n  /** @type {SplitChunksSizes} */\n  var merged = {};\n  for (var i = arguments.length - 1; i >= 0; i--) {\n    merged = Object.assign(merged, i < 0 || arguments.length <= i ? undefined : arguments[i]);\n  }\n  return merged;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {boolean} true, if there are sizes > 0\n */\nvar hasNonZeroSizes = function hasNonZeroSizes(sizes) {\n  for (var _i2 = 0, _Object$keys2 = Object.keys(sizes); _i2 < _Object$keys2.length; _i2++) {\n    var key = _Object$keys2[_i2];\n    if (sizes[key] > 0) return true;\n  }\n  return false;\n};\n\n/**\n * @param {SplitChunksSizes} a first sizes\n * @param {SplitChunksSizes} b second sizes\n * @param {CombineSizeFunction} combine a function to combine sizes\n * @returns {SplitChunksSizes} the combine sizes\n */\nvar combineSizes = function combineSizes(a, b, combine) {\n  var aKeys = new Set(Object.keys(a));\n  var bKeys = new Set(Object.keys(b));\n  /** @type {SplitChunksSizes} */\n  var result = {};\n  var _iterator4 = _createForOfIteratorHelper(aKeys),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var key = _step4.value;\n      if (bKeys.has(key)) {\n        result[key] = combine(a[key], b[key]);\n      } else {\n        result[key] = a[key];\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  var _iterator5 = _createForOfIteratorHelper(bKeys),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var _key = _step5.value;\n      if (!aKeys.has(_key)) {\n        result[_key] = b[_key];\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  return result;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSize`\n */\nvar checkMinSize = function checkMinSize(sizes, minSize) {\n  for (var _i3 = 0, _Object$keys3 = Object.keys(minSize); _i3 < _Object$keys3.length; _i3++) {\n    var key = _Object$keys3[_i3];\n    var size = sizes[key];\n    if (size === undefined || size === 0) continue;\n    if (size < minSize[key]) return false;\n  }\n  return true;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSizeReduction the min sizes\n * @param {number} chunkCount number of chunks\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSizeReduction`\n */\nvar checkMinSizeReduction = function checkMinSizeReduction(sizes, minSizeReduction, chunkCount) {\n  for (var _i4 = 0, _Object$keys4 = Object.keys(minSizeReduction); _i4 < _Object$keys4.length; _i4++) {\n    var key = _Object$keys4[_i4];\n    var size = sizes[key];\n    if (size === undefined || size === 0) continue;\n    if (size * chunkCount < minSizeReduction[key]) return false;\n  }\n  return true;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {undefined | string[]} list of size types that are below min size\n */\nvar getViolatingMinSizes = function getViolatingMinSizes(sizes, minSize) {\n  var list;\n  for (var _i5 = 0, _Object$keys5 = Object.keys(minSize); _i5 < _Object$keys5.length; _i5++) {\n    var key = _Object$keys5[_i5];\n    var size = sizes[key];\n    if (size === undefined || size === 0) continue;\n    if (size < minSize[key]) {\n      if (list === undefined) list = [key];else list.push(key);\n    }\n  }\n  return list;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {number} the total size\n */\nvar totalSize = function totalSize(sizes) {\n  var size = 0;\n  for (var _i6 = 0, _Object$keys6 = Object.keys(sizes); _i6 < _Object$keys6.length; _i6++) {\n    var key = _Object$keys6[_i6];\n    size += sizes[key];\n  }\n  return size;\n};\n\n/**\n * @param {false|string|Function} name the chunk name\n * @returns {GetName} a function to get the name of the chunk\n */\nvar normalizeName = function normalizeName(name) {\n  if (typeof name === \"string\") {\n    return function () {\n      return name;\n    };\n  }\n  if (typeof name === \"function\") {\n    return (/** @type {GetName} */name\n    );\n  }\n};\n\n/**\n * @param {OptimizationSplitChunksCacheGroup[\"chunks\"]} chunks the chunk filter option\n * @returns {ChunkFilterFunction} the chunk filter function\n */\nvar normalizeChunksFilter = function normalizeChunksFilter(chunks) {\n  if (chunks === \"initial\") {\n    return INITIAL_CHUNK_FILTER;\n  }\n  if (chunks === \"async\") {\n    return ASYNC_CHUNK_FILTER;\n  }\n  if (chunks === \"all\") {\n    return ALL_CHUNK_FILTER;\n  }\n  if (typeof chunks === \"function\") {\n    return chunks;\n  }\n};\n\n/**\n * @param {GetCacheGroups | Record<string, false|string|RegExp|OptimizationSplitChunksGetCacheGroups|OptimizationSplitChunksCacheGroup>} cacheGroups the cache group options\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {GetCacheGroups} a function to get the cache groups\n */\nvar normalizeCacheGroups = function normalizeCacheGroups(cacheGroups, defaultSizeTypes) {\n  if (typeof cacheGroups === \"function\") {\n    return cacheGroups;\n  }\n  if (typeof cacheGroups === \"object\" && cacheGroups !== null) {\n    /** @type {(function(Module, CacheGroupsContext, CacheGroupSource[]): void)[]} */\n    var handlers = [];\n    var _loop = function _loop() {\n      var key = _Object$keys7[_i7];\n      var option = cacheGroups[key];\n      if (option === false) {\n        return \"continue\";\n      }\n      if (typeof option === \"string\" || option instanceof RegExp) {\n        var source = createCacheGroupSource({}, key, defaultSizeTypes);\n        handlers.push(function (module, context, results) {\n          if (checkTest(option, module, context)) {\n            results.push(source);\n          }\n        });\n      } else if (typeof option === \"function\") {\n        var cache = new WeakMap();\n        handlers.push(function (module, context, results) {\n          var result = option(module);\n          if (result) {\n            var groups = Array.isArray(result) ? result : [result];\n            var _iterator6 = _createForOfIteratorHelper(groups),\n              _step6;\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var group = _step6.value;\n                var cachedSource = cache.get(group);\n                if (cachedSource !== undefined) {\n                  results.push(cachedSource);\n                } else {\n                  var _source = createCacheGroupSource(group, key, defaultSizeTypes);\n                  cache.set(group, _source);\n                  results.push(_source);\n                }\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n          }\n        });\n      } else {\n        var _source2 = createCacheGroupSource(option, key, defaultSizeTypes);\n        handlers.push(function (module, context, results) {\n          if (checkTest(option.test, module, context) && checkModuleType(option.type, module) && checkModuleLayer(option.layer, module)) {\n            results.push(_source2);\n          }\n        });\n      }\n    };\n    for (var _i7 = 0, _Object$keys7 = Object.keys(cacheGroups); _i7 < _Object$keys7.length; _i7++) {\n      var _ret = _loop();\n      if (_ret === \"continue\") continue;\n    }\n    /**\n     * @param {Module} module the current module\n     * @param {CacheGroupsContext} context the current context\n     * @returns {CacheGroupSource[]} the matching cache groups\n     */\n    var fn = function fn(module, context) {\n      /** @type {CacheGroupSource[]} */\n      var results = [];\n      for (var _i8 = 0, _handlers = handlers; _i8 < _handlers.length; _i8++) {\n        var _fn = _handlers[_i8];\n        _fn(module, context, results);\n      }\n      return results;\n    };\n    return fn;\n  }\n  return function () {\n    return null;\n  };\n};\n\n/**\n * @param {undefined|boolean|string|RegExp|Function} test test option\n * @param {Module} module the module\n * @param {CacheGroupsContext} context context object\n * @returns {boolean} true, if the module should be selected\n */\nvar checkTest = function checkTest(test, module, context) {\n  if (test === undefined) return true;\n  if (typeof test === \"function\") {\n    return test(module, context);\n  }\n  if (typeof test === \"boolean\") return test;\n  if (typeof test === \"string\") {\n    var name = module.nameForCondition();\n    return name && name.startsWith(test);\n  }\n  if (test instanceof RegExp) {\n    var _name = module.nameForCondition();\n    return _name && test.test(_name);\n  }\n  return false;\n};\n\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\nvar checkModuleType = function checkModuleType(test, module) {\n  if (test === undefined) return true;\n  if (typeof test === \"function\") {\n    return test(module.type);\n  }\n  if (typeof test === \"string\") {\n    var type = module.type;\n    return test === type;\n  }\n  if (test instanceof RegExp) {\n    var _type = module.type;\n    return test.test(_type);\n  }\n  return false;\n};\n\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\nvar checkModuleLayer = function checkModuleLayer(test, module) {\n  if (test === undefined) return true;\n  if (typeof test === \"function\") {\n    return test(module.layer);\n  }\n  if (typeof test === \"string\") {\n    var layer = module.layer;\n    return test === \"\" ? !layer : layer && layer.startsWith(test);\n  }\n  if (test instanceof RegExp) {\n    var _layer = module.layer;\n    return test.test(_layer);\n  }\n  return false;\n};\n\n/**\n * @param {OptimizationSplitChunksCacheGroup} options the group options\n * @param {string} key key of cache group\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {CacheGroupSource} the normalized cached group\n */\nvar createCacheGroupSource = function createCacheGroupSource(options, key, defaultSizeTypes) {\n  var minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n  var minSizeReduction = normalizeSizes(options.minSizeReduction, defaultSizeTypes);\n  var maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n  return {\n    key: key,\n    priority: options.priority,\n    getName: normalizeName(options.name),\n    chunksFilter: normalizeChunksFilter(options.chunks),\n    enforce: options.enforce,\n    minSize: minSize,\n    minSizeReduction: minSizeReduction,\n    minRemainingSize: mergeSizes(normalizeSizes(options.minRemainingSize, defaultSizeTypes), minSize),\n    enforceSizeThreshold: normalizeSizes(options.enforceSizeThreshold, defaultSizeTypes),\n    maxAsyncSize: mergeSizes(normalizeSizes(options.maxAsyncSize, defaultSizeTypes), maxSize),\n    maxInitialSize: mergeSizes(normalizeSizes(options.maxInitialSize, defaultSizeTypes), maxSize),\n    minChunks: options.minChunks,\n    maxAsyncRequests: options.maxAsyncRequests,\n    maxInitialRequests: options.maxInitialRequests,\n    filename: options.filename,\n    idHint: options.idHint,\n    automaticNameDelimiter: options.automaticNameDelimiter,\n    reuseExistingChunk: options.reuseExistingChunk,\n    usedExports: options.usedExports\n  };\n};\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   * @param {OptimizationSplitChunksOptions=} options plugin options\n   */\n  function SplitChunksPlugin() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, SplitChunksPlugin);\n    var defaultSizeTypes = options.defaultSizeTypes || [\"javascript\", \"unknown\"];\n    var fallbackCacheGroup = options.fallbackCacheGroup || {};\n    var minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n    var minSizeReduction = normalizeSizes(options.minSizeReduction, defaultSizeTypes);\n    var maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n\n    /** @type {SplitChunksOptions} */\n    this.options = {\n      chunksFilter: normalizeChunksFilter(options.chunks || \"all\"),\n      defaultSizeTypes: defaultSizeTypes,\n      minSize: minSize,\n      minSizeReduction: minSizeReduction,\n      minRemainingSize: mergeSizes(normalizeSizes(options.minRemainingSize, defaultSizeTypes), minSize),\n      enforceSizeThreshold: normalizeSizes(options.enforceSizeThreshold, defaultSizeTypes),\n      maxAsyncSize: mergeSizes(normalizeSizes(options.maxAsyncSize, defaultSizeTypes), maxSize),\n      maxInitialSize: mergeSizes(normalizeSizes(options.maxInitialSize, defaultSizeTypes), maxSize),\n      minChunks: options.minChunks || 1,\n      maxAsyncRequests: options.maxAsyncRequests || 1,\n      maxInitialRequests: options.maxInitialRequests || 1,\n      hidePathInfo: options.hidePathInfo || false,\n      filename: options.filename || undefined,\n      getCacheGroups: normalizeCacheGroups(options.cacheGroups, defaultSizeTypes),\n      getName: options.name ? normalizeName(options.name) : defaultGetName,\n      automaticNameDelimiter: options.automaticNameDelimiter,\n      usedExports: options.usedExports,\n      fallbackCacheGroup: {\n        chunksFilter: normalizeChunksFilter(fallbackCacheGroup.chunks || options.chunks || \"all\"),\n        minSize: mergeSizes(normalizeSizes(fallbackCacheGroup.minSize, defaultSizeTypes), minSize),\n        maxAsyncSize: mergeSizes(normalizeSizes(fallbackCacheGroup.maxAsyncSize, defaultSizeTypes), normalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes), normalizeSizes(options.maxAsyncSize, defaultSizeTypes), normalizeSizes(options.maxSize, defaultSizeTypes)),\n        maxInitialSize: mergeSizes(normalizeSizes(fallbackCacheGroup.maxInitialSize, defaultSizeTypes), normalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes), normalizeSizes(options.maxInitialSize, defaultSizeTypes), normalizeSizes(options.maxSize, defaultSizeTypes)),\n        automaticNameDelimiter: fallbackCacheGroup.automaticNameDelimiter || options.automaticNameDelimiter || \"~\"\n      }\n    };\n\n    /** @type {WeakMap<CacheGroupSource, CacheGroup>} */\n    this._cacheGroupCache = new WeakMap();\n  }\n\n  /**\n   * @param {CacheGroupSource} cacheGroupSource source\n   * @returns {CacheGroup} the cache group (cached)\n   */\n  _createClass(SplitChunksPlugin, [{\n    key: \"_getCacheGroup\",\n    value: function _getCacheGroup(cacheGroupSource) {\n      var cacheEntry = this._cacheGroupCache.get(cacheGroupSource);\n      if (cacheEntry !== undefined) return cacheEntry;\n      var minSize = mergeSizes(cacheGroupSource.minSize, cacheGroupSource.enforce ? undefined : this.options.minSize);\n      var minSizeReduction = mergeSizes(cacheGroupSource.minSizeReduction, cacheGroupSource.enforce ? undefined : this.options.minSizeReduction);\n      var minRemainingSize = mergeSizes(cacheGroupSource.minRemainingSize, cacheGroupSource.enforce ? undefined : this.options.minRemainingSize);\n      var enforceSizeThreshold = mergeSizes(cacheGroupSource.enforceSizeThreshold, cacheGroupSource.enforce ? undefined : this.options.enforceSizeThreshold);\n      var cacheGroup = {\n        key: cacheGroupSource.key,\n        priority: cacheGroupSource.priority || 0,\n        chunksFilter: cacheGroupSource.chunksFilter || this.options.chunksFilter,\n        minSize: minSize,\n        minSizeReduction: minSizeReduction,\n        minRemainingSize: minRemainingSize,\n        enforceSizeThreshold: enforceSizeThreshold,\n        maxAsyncSize: mergeSizes(cacheGroupSource.maxAsyncSize, cacheGroupSource.enforce ? undefined : this.options.maxAsyncSize),\n        maxInitialSize: mergeSizes(cacheGroupSource.maxInitialSize, cacheGroupSource.enforce ? undefined : this.options.maxInitialSize),\n        minChunks: cacheGroupSource.minChunks !== undefined ? cacheGroupSource.minChunks : cacheGroupSource.enforce ? 1 : this.options.minChunks,\n        maxAsyncRequests: cacheGroupSource.maxAsyncRequests !== undefined ? cacheGroupSource.maxAsyncRequests : cacheGroupSource.enforce ? Infinity : this.options.maxAsyncRequests,\n        maxInitialRequests: cacheGroupSource.maxInitialRequests !== undefined ? cacheGroupSource.maxInitialRequests : cacheGroupSource.enforce ? Infinity : this.options.maxInitialRequests,\n        getName: cacheGroupSource.getName !== undefined ? cacheGroupSource.getName : this.options.getName,\n        usedExports: cacheGroupSource.usedExports !== undefined ? cacheGroupSource.usedExports : this.options.usedExports,\n        filename: cacheGroupSource.filename !== undefined ? cacheGroupSource.filename : this.options.filename,\n        automaticNameDelimiter: cacheGroupSource.automaticNameDelimiter !== undefined ? cacheGroupSource.automaticNameDelimiter : this.options.automaticNameDelimiter,\n        idHint: cacheGroupSource.idHint !== undefined ? cacheGroupSource.idHint : cacheGroupSource.key,\n        reuseExistingChunk: cacheGroupSource.reuseExistingChunk || false,\n        _validateSize: hasNonZeroSizes(minSize),\n        _validateRemainingSize: hasNonZeroSizes(minRemainingSize),\n        _minSizeForMaxSize: mergeSizes(cacheGroupSource.minSize, this.options.minSize),\n        _conditionalEnforce: hasNonZeroSizes(enforceSizeThreshold)\n      };\n      this._cacheGroupCache.set(cacheGroupSource, cacheGroup);\n      return cacheGroup;\n    }\n\n    /**\n     * Apply the plugin\n     * @param {Compiler} compiler the compiler instance\n     * @returns {void}\n     */\n  }, {\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this = this;\n      var cachedMakePathsRelative = makePathsRelative.bindContextCache(compiler.context, compiler.root);\n      compiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", function (compilation) {\n        var logger = compilation.getLogger(\"webpack.SplitChunksPlugin\");\n        var alreadyOptimized = false;\n        compilation.hooks.unseal.tap(\"SplitChunksPlugin\", function () {\n          alreadyOptimized = false;\n        });\n        compilation.hooks.optimizeChunks.tap({\n          name: \"SplitChunksPlugin\",\n          stage: STAGE_ADVANCED\n        }, function (chunks) {\n          if (alreadyOptimized) return;\n          alreadyOptimized = true;\n          logger.time(\"prepare\");\n          var chunkGraph = compilation.chunkGraph;\n          var moduleGraph = compilation.moduleGraph;\n          // Give each selected chunk an index (to create strings from chunks)\n          /** @type {Map<Chunk, bigint>} */\n          var chunkIndexMap = new Map();\n          var ZERO = BigInt(\"0\");\n          var ONE = BigInt(\"1\");\n          var START = ONE << BigInt(\"31\");\n          var index = START;\n          var _iterator7 = _createForOfIteratorHelper(chunks),\n            _step7;\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var _chunk8 = _step7.value;\n              chunkIndexMap.set(_chunk8, index | BigInt(Math.random() * 0x7fffffff | 0));\n              index = index << ONE;\n            }\n            /**\n             * @param {Iterable<Chunk>} chunks list of chunks\n             * @returns {bigint | Chunk} key of the chunks\n             */\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n          var getKey = function getKey(chunks) {\n            var iterator = chunks[Symbol.iterator]();\n            var result = iterator.next();\n            if (result.done) return ZERO;\n            var first = result.value;\n            result = iterator.next();\n            if (result.done) return first;\n            var key = chunkIndexMap.get(first) | chunkIndexMap.get(result.value);\n            while (!(result = iterator.next()).done) {\n              var raw = chunkIndexMap.get(result.value);\n              key = key ^ raw;\n            }\n            return key;\n          };\n          var keyToString = function keyToString(key) {\n            if (typeof key === \"bigint\") return key.toString(16);\n            return chunkIndexMap.get(key).toString(16);\n          };\n          var getChunkSetsInGraph = memoize(function () {\n            /** @type {Map<bigint, Set<Chunk>>} */\n            var chunkSetsInGraph = new Map();\n            /** @type {Set<Chunk>} */\n            var singleChunkSets = new Set();\n            var _iterator8 = _createForOfIteratorHelper(compilation.modules),\n              _step8;\n            try {\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                var _module = _step8.value;\n                var _chunks = chunkGraph.getModuleChunksIterable(_module);\n                var chunksKey = getKey(_chunks);\n                if (typeof chunksKey === \"bigint\") {\n                  if (!chunkSetsInGraph.has(chunksKey)) {\n                    chunkSetsInGraph.set(chunksKey, new Set(_chunks));\n                  }\n                } else {\n                  singleChunkSets.add(chunksKey);\n                }\n              }\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n            return {\n              chunkSetsInGraph: chunkSetsInGraph,\n              singleChunkSets: singleChunkSets\n            };\n          });\n\n          /**\n           * @param {Module} module the module\n           * @returns {Iterable<Chunk[]>} groups of chunks with equal exports\n           */\n          var groupChunksByExports = function groupChunksByExports(module) {\n            var exportsInfo = moduleGraph.getExportsInfo(module);\n            var groupedByUsedExports = new Map();\n            var _iterator9 = _createForOfIteratorHelper(chunkGraph.getModuleChunksIterable(module)),\n              _step9;\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var chunk = _step9.value;\n                var key = exportsInfo.getUsageKey(chunk.runtime);\n                var list = groupedByUsedExports.get(key);\n                if (list !== undefined) {\n                  list.push(chunk);\n                } else {\n                  groupedByUsedExports.set(key, [chunk]);\n                }\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n            return groupedByUsedExports.values();\n          };\n\n          /** @type {Map<Module, Iterable<Chunk[]>>} */\n          var groupedByExportsMap = new Map();\n          var getExportsChunkSetsInGraph = memoize(function () {\n            /** @type {Map<bigint, Set<Chunk>>} */\n            var chunkSetsInGraph = new Map();\n            /** @type {Set<Chunk>} */\n            var singleChunkSets = new Set();\n            var _iterator10 = _createForOfIteratorHelper(compilation.modules),\n              _step10;\n            try {\n              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                var _module2 = _step10.value;\n                var groupedChunks = Array.from(groupChunksByExports(_module2));\n                groupedByExportsMap.set(_module2, groupedChunks);\n                for (var _i9 = 0, _groupedChunks = groupedChunks; _i9 < _groupedChunks.length; _i9++) {\n                  var _chunks2 = _groupedChunks[_i9];\n                  if (_chunks2.length === 1) {\n                    singleChunkSets.add(_chunks2[0]);\n                  } else {\n                    var chunksKey = /** @type {bigint} */getKey(_chunks2);\n                    if (!chunkSetsInGraph.has(chunksKey)) {\n                      chunkSetsInGraph.set(chunksKey, new Set(_chunks2));\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator10.e(err);\n            } finally {\n              _iterator10.f();\n            }\n            return {\n              chunkSetsInGraph: chunkSetsInGraph,\n              singleChunkSets: singleChunkSets\n            };\n          });\n\n          // group these set of chunks by count\n          // to allow to check less sets via isSubset\n          // (only smaller sets can be subset)\n          var groupChunkSetsByCount = function groupChunkSetsByCount(chunkSets) {\n            /** @type {Map<number, Array<Set<Chunk>>>} */\n            var chunkSetsByCount = new Map();\n            var _iterator11 = _createForOfIteratorHelper(chunkSets),\n              _step11;\n            try {\n              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                var chunksSet = _step11.value;\n                var count = chunksSet.size;\n                var array = chunkSetsByCount.get(count);\n                if (array === undefined) {\n                  array = [];\n                  chunkSetsByCount.set(count, array);\n                }\n                array.push(chunksSet);\n              }\n            } catch (err) {\n              _iterator11.e(err);\n            } finally {\n              _iterator11.f();\n            }\n            return chunkSetsByCount;\n          };\n          var getChunkSetsByCount = memoize(function () {\n            return groupChunkSetsByCount(getChunkSetsInGraph().chunkSetsInGraph.values());\n          });\n          var getExportsChunkSetsByCount = memoize(function () {\n            return groupChunkSetsByCount(getExportsChunkSetsInGraph().chunkSetsInGraph.values());\n          });\n\n          // Create a list of possible combinations\n          var createGetCombinations = function createGetCombinations(chunkSets, singleChunkSets, chunkSetsByCount) {\n            /** @type {Map<bigint | Chunk, (Set<Chunk> | Chunk)[]>} */\n            var combinationsCache = new Map();\n            return function (key) {\n              var cacheEntry = combinationsCache.get(key);\n              if (cacheEntry !== undefined) return cacheEntry;\n              if (key instanceof Chunk) {\n                var result = [key];\n                combinationsCache.set(key, result);\n                return result;\n              }\n              var chunksSet = chunkSets.get(key);\n              /** @type {(Set<Chunk> | Chunk)[]} */\n              var array = [chunksSet];\n              var _iterator12 = _createForOfIteratorHelper(chunkSetsByCount),\n                _step12;\n              try {\n                for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                  var _step12$value = _slicedToArray(_step12.value, 2),\n                    count = _step12$value[0],\n                    setArray = _step12$value[1];\n                  // \"equal\" is not needed because they would have been merge in the first step\n                  if (count < chunksSet.size) {\n                    var _iterator14 = _createForOfIteratorHelper(setArray),\n                      _step14;\n                    try {\n                      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                        var set = _step14.value;\n                        if (isSubset(chunksSet, set)) {\n                          array.push(set);\n                        }\n                      }\n                    } catch (err) {\n                      _iterator14.e(err);\n                    } finally {\n                      _iterator14.f();\n                    }\n                  }\n                }\n              } catch (err) {\n                _iterator12.e(err);\n              } finally {\n                _iterator12.f();\n              }\n              var _iterator13 = _createForOfIteratorHelper(singleChunkSets),\n                _step13;\n              try {\n                for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                  var chunk = _step13.value;\n                  if (chunksSet.has(chunk)) {\n                    array.push(chunk);\n                  }\n                }\n              } catch (err) {\n                _iterator13.e(err);\n              } finally {\n                _iterator13.f();\n              }\n              combinationsCache.set(key, array);\n              return array;\n            };\n          };\n          var getCombinationsFactory = memoize(function () {\n            var _getChunkSetsInGraph = getChunkSetsInGraph(),\n              chunkSetsInGraph = _getChunkSetsInGraph.chunkSetsInGraph,\n              singleChunkSets = _getChunkSetsInGraph.singleChunkSets;\n            return createGetCombinations(chunkSetsInGraph, singleChunkSets, getChunkSetsByCount());\n          });\n          var getCombinations = function getCombinations(key) {\n            return getCombinationsFactory()(key);\n          };\n          var getExportsCombinationsFactory = memoize(function () {\n            var _getExportsChunkSetsI = getExportsChunkSetsInGraph(),\n              chunkSetsInGraph = _getExportsChunkSetsI.chunkSetsInGraph,\n              singleChunkSets = _getExportsChunkSetsI.singleChunkSets;\n            return createGetCombinations(chunkSetsInGraph, singleChunkSets, getExportsChunkSetsByCount());\n          });\n          var getExportsCombinations = function getExportsCombinations(key) {\n            return getExportsCombinationsFactory()(key);\n          };\n\n          /**\n           * @typedef {Object} SelectedChunksResult\n           * @property {Chunk[]} chunks the list of chunks\n           * @property {bigint | Chunk} key a key of the list\n           */\n\n          /** @type {WeakMap<Set<Chunk> | Chunk, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n          var selectedChunksCacheByChunksSet = new WeakMap();\n\n          /**\n           * get list and key by applying the filter function to the list\n           * It is cached for performance reasons\n           * @param {Set<Chunk> | Chunk} chunks list of chunks\n           * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n           * @returns {SelectedChunksResult} list and key\n           */\n          var getSelectedChunks = function getSelectedChunks(chunks, chunkFilter) {\n            var entry = selectedChunksCacheByChunksSet.get(chunks);\n            if (entry === undefined) {\n              entry = new WeakMap();\n              selectedChunksCacheByChunksSet.set(chunks, entry);\n            }\n            /** @type {SelectedChunksResult} */\n            var entry2 = entry.get(chunkFilter);\n            if (entry2 === undefined) {\n              /** @type {Chunk[]} */\n              var selectedChunks = [];\n              if (chunks instanceof Chunk) {\n                if (chunkFilter(chunks)) selectedChunks.push(chunks);\n              } else {\n                var _iterator15 = _createForOfIteratorHelper(chunks),\n                  _step15;\n                try {\n                  for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                    var chunk = _step15.value;\n                    if (chunkFilter(chunk)) selectedChunks.push(chunk);\n                  }\n                } catch (err) {\n                  _iterator15.e(err);\n                } finally {\n                  _iterator15.f();\n                }\n              }\n              entry2 = {\n                chunks: selectedChunks,\n                key: getKey(selectedChunks)\n              };\n              entry.set(chunkFilter, entry2);\n            }\n            return entry2;\n          };\n\n          /** @type {Map<string, boolean>} */\n          var alreadyValidatedParents = new Map();\n          /** @type {Set<string>} */\n          var alreadyReportedErrors = new Set();\n\n          // Map a list of chunks to a list of modules\n          // For the key the chunk \"index\" is used, the value is a SortableSet of modules\n          /** @type {Map<string, ChunksInfoItem>} */\n          var chunksInfoMap = new Map();\n\n          /**\n           * @param {CacheGroup} cacheGroup the current cache group\n           * @param {number} cacheGroupIndex the index of the cache group of ordering\n           * @param {Chunk[]} selectedChunks chunks selected for this module\n           * @param {bigint | Chunk} selectedChunksKey a key of selectedChunks\n           * @param {Module} module the current module\n           * @returns {void}\n           */\n          var addModuleToChunksInfoMap = function addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module) {\n            // Break if minimum number of chunks is not reached\n            if (selectedChunks.length < cacheGroup.minChunks) return;\n            // Determine name for split chunk\n            var name = cacheGroup.getName(module, selectedChunks, cacheGroup.key);\n            // Check if the name is ok\n            var existingChunk = compilation.namedChunks.get(name);\n            if (existingChunk) {\n              var parentValidationKey = \"\".concat(name, \"|\").concat(typeof selectedChunksKey === \"bigint\" ? selectedChunksKey : selectedChunksKey.debugId);\n              var valid = alreadyValidatedParents.get(parentValidationKey);\n              if (valid === false) return;\n              if (valid === undefined) {\n                // Module can only be moved into the existing chunk if the existing chunk\n                // is a parent of all selected chunks\n                var isInAllParents = true;\n                /** @type {Set<ChunkGroup>} */\n                var queue = new Set();\n                var _iterator16 = _createForOfIteratorHelper(selectedChunks),\n                  _step16;\n                try {\n                  for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                    var chunk = _step16.value;\n                    var _iterator18 = _createForOfIteratorHelper(chunk.groupsIterable),\n                      _step18;\n                    try {\n                      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n                        var group = _step18.value;\n                        queue.add(group);\n                      }\n                    } catch (err) {\n                      _iterator18.e(err);\n                    } finally {\n                      _iterator18.f();\n                    }\n                  }\n                } catch (err) {\n                  _iterator16.e(err);\n                } finally {\n                  _iterator16.f();\n                }\n                var _iterator17 = _createForOfIteratorHelper(queue),\n                  _step17;\n                try {\n                  for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n                    var _group = _step17.value;\n                    if (existingChunk.isInGroup(_group)) continue;\n                    var hasParent = false;\n                    var _iterator19 = _createForOfIteratorHelper(_group.parentsIterable),\n                      _step19;\n                    try {\n                      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                        var parent = _step19.value;\n                        hasParent = true;\n                        queue.add(parent);\n                      }\n                    } catch (err) {\n                      _iterator19.e(err);\n                    } finally {\n                      _iterator19.f();\n                    }\n                    if (!hasParent) {\n                      isInAllParents = false;\n                    }\n                  }\n                } catch (err) {\n                  _iterator17.e(err);\n                } finally {\n                  _iterator17.f();\n                }\n                var _valid = isInAllParents;\n                alreadyValidatedParents.set(parentValidationKey, _valid);\n                if (!_valid) {\n                  if (!alreadyReportedErrors.has(name)) {\n                    alreadyReportedErrors.add(name);\n                    compilation.errors.push(new WebpackError(\"SplitChunksPlugin\\n\" + \"Cache group \\\"\".concat(cacheGroup.key, \"\\\" conflicts with existing chunk.\\n\") + \"Both have the same name \\\"\".concat(name, \"\\\" and existing chunk is not a parent of the selected modules.\\n\") + \"Use a different name for the cache group or make sure that the existing chunk is a parent (e. g. via dependOn).\\n\" + 'HINT: You can omit \"name\" to automatically create a name.\\n' + \"BREAKING CHANGE: webpack < 5 used to allow to use an entrypoint as splitChunk. \" + \"This is no longer allowed when the entrypoint is not a parent of the selected modules.\\n\" + \"Remove this entrypoint and add modules to cache group's 'test' instead. \" + \"If you need modules to be evaluated on startup, add them to the existing entrypoints (make them arrays). \" + \"See migration guide of more info.\"));\n                  }\n                  return;\n                }\n              }\n            }\n            // Create key for maps\n            // When it has a name we use the name as key\n            // Otherwise we create the key from chunks and cache group key\n            // This automatically merges equal names\n            var key = cacheGroup.key + (name ? \" name:\".concat(name) : \" chunks:\".concat(keyToString(selectedChunksKey)));\n            // Add module to maps\n            var info = chunksInfoMap.get(key);\n            if (info === undefined) {\n              chunksInfoMap.set(key, info = {\n                modules: new SortableSet(undefined, compareModulesByIdentifier),\n                cacheGroup: cacheGroup,\n                cacheGroupIndex: cacheGroupIndex,\n                name: name,\n                sizes: {},\n                chunks: new Set(),\n                reuseableChunks: new Set(),\n                chunksKeys: new Set()\n              });\n            }\n            var oldSize = info.modules.size;\n            info.modules.add(module);\n            if (info.modules.size !== oldSize) {\n              var _iterator20 = _createForOfIteratorHelper(module.getSourceTypes()),\n                _step20;\n              try {\n                for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                  var type = _step20.value;\n                  info.sizes[type] = (info.sizes[type] || 0) + module.size(type);\n                }\n              } catch (err) {\n                _iterator20.e(err);\n              } finally {\n                _iterator20.f();\n              }\n            }\n            var oldChunksKeysSize = info.chunksKeys.size;\n            info.chunksKeys.add(selectedChunksKey);\n            if (oldChunksKeysSize !== info.chunksKeys.size) {\n              var _iterator21 = _createForOfIteratorHelper(selectedChunks),\n                _step21;\n              try {\n                for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n                  var _chunk = _step21.value;\n                  info.chunks.add(_chunk);\n                }\n              } catch (err) {\n                _iterator21.e(err);\n              } finally {\n                _iterator21.f();\n              }\n            }\n          };\n          var context = {\n            moduleGraph: moduleGraph,\n            chunkGraph: chunkGraph\n          };\n          logger.timeEnd(\"prepare\");\n          logger.time(\"modules\");\n\n          // Walk through all modules\n          var _iterator22 = _createForOfIteratorHelper(compilation.modules),\n            _step22;\n          try {\n            var _loop4 = function _loop4() {\n              var module = _step22.value;\n              // Get cache group\n              var cacheGroups = _this.options.getCacheGroups(module, context);\n              if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n                return \"continue\";\n              }\n\n              // Prepare some values (usedExports = false)\n              var getCombs = memoize(function () {\n                var chunks = chunkGraph.getModuleChunksIterable(module);\n                var chunksKey = getKey(chunks);\n                return getCombinations(chunksKey);\n              });\n\n              // Prepare some values (usedExports = true)\n              var getCombsByUsedExports = memoize(function () {\n                // fill the groupedByExportsMap\n                getExportsChunkSetsInGraph();\n                /** @type {Set<Set<Chunk> | Chunk>} */\n                var set = new Set();\n                var groupedByUsedExports = groupedByExportsMap.get(module);\n                var _iterator45 = _createForOfIteratorHelper(groupedByUsedExports),\n                  _step45;\n                try {\n                  for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {\n                    var _chunks3 = _step45.value;\n                    var chunksKey = getKey(_chunks3);\n                    var _iterator46 = _createForOfIteratorHelper(getExportsCombinations(chunksKey)),\n                      _step46;\n                    try {\n                      for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {\n                        var comb = _step46.value;\n                        set.add(comb);\n                      }\n                    } catch (err) {\n                      _iterator46.e(err);\n                    } finally {\n                      _iterator46.f();\n                    }\n                  }\n                } catch (err) {\n                  _iterator45.e(err);\n                } finally {\n                  _iterator45.f();\n                }\n                return set;\n              });\n              var cacheGroupIndex = 0;\n              var _iterator47 = _createForOfIteratorHelper(cacheGroups),\n                _step47;\n              try {\n                for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {\n                  var cacheGroupSource = _step47.value;\n                  var cacheGroup = _this._getCacheGroup(cacheGroupSource);\n                  var combs = cacheGroup.usedExports ? getCombsByUsedExports() : getCombs();\n                  // For all combination of chunk selection\n                  var _iterator48 = _createForOfIteratorHelper(combs),\n                    _step48;\n                  try {\n                    for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {\n                      var chunkCombination = _step48.value;\n                      // Break if minimum number of chunks is not reached\n                      var count = chunkCombination instanceof Chunk ? 1 : chunkCombination.size;\n                      if (count < cacheGroup.minChunks) continue;\n                      // Select chunks by configuration\n                      var _getSelectedChunks = getSelectedChunks(chunkCombination, cacheGroup.chunksFilter),\n                        selectedChunks = _getSelectedChunks.chunks,\n                        selectedChunksKey = _getSelectedChunks.key;\n                      addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module);\n                    }\n                  } catch (err) {\n                    _iterator48.e(err);\n                  } finally {\n                    _iterator48.f();\n                  }\n                  cacheGroupIndex++;\n                }\n              } catch (err) {\n                _iterator47.e(err);\n              } finally {\n                _iterator47.f();\n              }\n            };\n            for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n              var _ret3 = _loop4();\n              if (_ret3 === \"continue\") continue;\n            }\n          } catch (err) {\n            _iterator22.e(err);\n          } finally {\n            _iterator22.f();\n          }\n          logger.timeEnd(\"modules\");\n          logger.time(\"queue\");\n\n          /**\n           * @param {ChunksInfoItem} info entry\n           * @param {string[]} sourceTypes source types to be removed\n           */\n          var removeModulesWithSourceType = function removeModulesWithSourceType(info, sourceTypes) {\n            var _iterator23 = _createForOfIteratorHelper(info.modules),\n              _step23;\n            try {\n              var _loop2 = function _loop2() {\n                var module = _step23.value;\n                var types = module.getSourceTypes();\n                if (sourceTypes.some(function (type) {\n                  return types.has(type);\n                })) {\n                  info.modules.delete(module);\n                  var _iterator24 = _createForOfIteratorHelper(types),\n                    _step24;\n                  try {\n                    for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n                      var type = _step24.value;\n                      info.sizes[type] -= module.size(type);\n                    }\n                  } catch (err) {\n                    _iterator24.e(err);\n                  } finally {\n                    _iterator24.f();\n                  }\n                }\n              };\n              for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n                _loop2();\n              }\n            } catch (err) {\n              _iterator23.e(err);\n            } finally {\n              _iterator23.f();\n            }\n          };\n\n          /**\n           * @param {ChunksInfoItem} info entry\n           * @returns {boolean} true, if entry become empty\n           */\n          var removeMinSizeViolatingModules = function removeMinSizeViolatingModules(info) {\n            if (!info.cacheGroup._validateSize) return false;\n            var violatingSizes = getViolatingMinSizes(info.sizes, info.cacheGroup.minSize);\n            if (violatingSizes === undefined) return false;\n            removeModulesWithSourceType(info, violatingSizes);\n            return info.modules.size === 0;\n          };\n\n          // Filter items were size < minSize\n          var _iterator25 = _createForOfIteratorHelper(chunksInfoMap),\n            _step25;\n          try {\n            for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n              var _step25$value = _slicedToArray(_step25.value, 2),\n                _key7 = _step25$value[0],\n                _info2 = _step25$value[1];\n              if (removeMinSizeViolatingModules(_info2)) {\n                chunksInfoMap.delete(_key7);\n              } else if (!checkMinSizeReduction(_info2.sizes, _info2.cacheGroup.minSizeReduction, _info2.chunks.size)) {\n                chunksInfoMap.delete(_key7);\n              }\n            }\n\n            /**\n             * @typedef {Object} MaxSizeQueueItem\n             * @property {SplitChunksSizes} minSize\n             * @property {SplitChunksSizes} maxAsyncSize\n             * @property {SplitChunksSizes} maxInitialSize\n             * @property {string} automaticNameDelimiter\n             * @property {string[]} keys\n             */\n\n            /** @type {Map<Chunk, MaxSizeQueueItem>} */\n          } catch (err) {\n            _iterator25.e(err);\n          } finally {\n            _iterator25.f();\n          }\n          var maxSizeQueueMap = new Map();\n          while (chunksInfoMap.size > 0) {\n            // Find best matching entry\n            var bestEntryKey = void 0;\n            var bestEntry = void 0;\n            var _iterator26 = _createForOfIteratorHelper(chunksInfoMap),\n              _step26;\n            try {\n              for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n                var pair = _step26.value;\n                var key = pair[0];\n                var info = pair[1];\n                if (bestEntry === undefined || compareEntries(bestEntry, info) < 0) {\n                  bestEntry = info;\n                  bestEntryKey = key;\n                }\n              }\n            } catch (err) {\n              _iterator26.e(err);\n            } finally {\n              _iterator26.f();\n            }\n            var item = bestEntry;\n            chunksInfoMap.delete(bestEntryKey);\n            var chunkName = item.name;\n            // Variable for the new chunk (lazy created)\n            /** @type {Chunk} */\n            var newChunk = void 0;\n            // When no chunk name, check if we can reuse a chunk instead of creating a new one\n            var isExistingChunk = false;\n            var isReusedWithAllModules = false;\n            if (chunkName) {\n              var chunkByName = compilation.namedChunks.get(chunkName);\n              if (chunkByName !== undefined) {\n                newChunk = chunkByName;\n                var oldSize = item.chunks.size;\n                item.chunks.delete(newChunk);\n                isExistingChunk = item.chunks.size !== oldSize;\n              }\n            } else if (item.cacheGroup.reuseExistingChunk) {\n              var _iterator27 = _createForOfIteratorHelper(item.chunks),\n                _step27;\n              try {\n                outer: for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n                  var chunk = _step27.value;\n                  if (chunkGraph.getNumberOfChunkModules(chunk) !== item.modules.size) {\n                    continue;\n                  }\n                  if (item.chunks.size > 1 && chunkGraph.getNumberOfEntryModules(chunk) > 0) {\n                    continue;\n                  }\n                  var _iterator28 = _createForOfIteratorHelper(item.modules),\n                    _step28;\n                  try {\n                    for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n                      var _module3 = _step28.value;\n                      if (!chunkGraph.isModuleInChunk(_module3, chunk)) {\n                        continue outer;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator28.e(err);\n                  } finally {\n                    _iterator28.f();\n                  }\n                  if (!newChunk || !newChunk.name) {\n                    newChunk = chunk;\n                  } else if (chunk.name && chunk.name.length < newChunk.name.length) {\n                    newChunk = chunk;\n                  } else if (chunk.name && chunk.name.length === newChunk.name.length && chunk.name < newChunk.name) {\n                    newChunk = chunk;\n                  }\n                }\n              } catch (err) {\n                _iterator27.e(err);\n              } finally {\n                _iterator27.f();\n              }\n              if (newChunk) {\n                item.chunks.delete(newChunk);\n                chunkName = undefined;\n                isExistingChunk = true;\n                isReusedWithAllModules = true;\n              }\n            }\n            var enforced = item.cacheGroup._conditionalEnforce && checkMinSize(item.sizes, item.cacheGroup.enforceSizeThreshold);\n            var usedChunks = new Set(item.chunks);\n\n            // Check if maxRequests condition can be fulfilled\n            if (!enforced && (Number.isFinite(item.cacheGroup.maxInitialRequests) || Number.isFinite(item.cacheGroup.maxAsyncRequests))) {\n              var _iterator29 = _createForOfIteratorHelper(usedChunks),\n                _step29;\n              try {\n                for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n                  var _chunk2 = _step29.value;\n                  // respect max requests\n                  var maxRequests = _chunk2.isOnlyInitial() ? item.cacheGroup.maxInitialRequests : _chunk2.canBeInitial() ? Math.min(item.cacheGroup.maxInitialRequests, item.cacheGroup.maxAsyncRequests) : item.cacheGroup.maxAsyncRequests;\n                  if (isFinite(maxRequests) && getRequests(_chunk2) >= maxRequests) {\n                    usedChunks.delete(_chunk2);\n                  }\n                }\n              } catch (err) {\n                _iterator29.e(err);\n              } finally {\n                _iterator29.f();\n              }\n            }\n            var _iterator30 = _createForOfIteratorHelper(usedChunks),\n              _step30;\n            try {\n              outer: for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n                var _chunk6 = _step30.value;\n                var _iterator40 = _createForOfIteratorHelper(item.modules),\n                  _step40;\n                try {\n                  for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {\n                    var _module8 = _step40.value;\n                    if (chunkGraph.isModuleInChunk(_module8, _chunk6)) continue outer;\n                  }\n                } catch (err) {\n                  _iterator40.e(err);\n                } finally {\n                  _iterator40.f();\n                }\n                usedChunks.delete(_chunk6);\n              }\n            } catch (err) {\n              _iterator30.e(err);\n            } finally {\n              _iterator30.f();\n            } // Were some (invalid) chunks removed from usedChunks?\n            // => readd all modules to the queue, as things could have been changed\n            if (usedChunks.size < item.chunks.size) {\n              if (isExistingChunk) usedChunks.add(newChunk);\n              if (usedChunks.size >= item.cacheGroup.minChunks) {\n                var chunksArr = Array.from(usedChunks);\n                var _iterator31 = _createForOfIteratorHelper(item.modules),\n                  _step31;\n                try {\n                  for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n                    var _module4 = _step31.value;\n                    addModuleToChunksInfoMap(item.cacheGroup, item.cacheGroupIndex, chunksArr, getKey(usedChunks), _module4);\n                  }\n                } catch (err) {\n                  _iterator31.e(err);\n                } finally {\n                  _iterator31.f();\n                }\n              }\n              continue;\n            }\n\n            // Validate minRemainingSize constraint when a single chunk is left over\n            if (!enforced && item.cacheGroup._validateRemainingSize && usedChunks.size === 1) {\n              var _usedChunks = _slicedToArray(usedChunks, 1),\n                _chunk3 = _usedChunks[0];\n              var chunkSizes = Object.create(null);\n              var _iterator32 = _createForOfIteratorHelper(chunkGraph.getChunkModulesIterable(_chunk3)),\n                _step32;\n              try {\n                for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n                  var _module5 = _step32.value;\n                  if (!item.modules.has(_module5)) {\n                    var _iterator33 = _createForOfIteratorHelper(_module5.getSourceTypes()),\n                      _step33;\n                    try {\n                      for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n                        var type = _step33.value;\n                        chunkSizes[type] = (chunkSizes[type] || 0) + _module5.size(type);\n                      }\n                    } catch (err) {\n                      _iterator33.e(err);\n                    } finally {\n                      _iterator33.f();\n                    }\n                  }\n                }\n              } catch (err) {\n                _iterator32.e(err);\n              } finally {\n                _iterator32.f();\n              }\n              var violatingSizes = getViolatingMinSizes(chunkSizes, item.cacheGroup.minRemainingSize);\n              if (violatingSizes !== undefined) {\n                var oldModulesSize = item.modules.size;\n                removeModulesWithSourceType(item, violatingSizes);\n                if (item.modules.size > 0 && item.modules.size !== oldModulesSize) {\n                  // queue this item again to be processed again\n                  // without violating modules\n                  chunksInfoMap.set(bestEntryKey, item);\n                }\n                continue;\n              }\n            }\n\n            // Create the new chunk if not reusing one\n            if (newChunk === undefined) {\n              newChunk = compilation.addChunk(chunkName);\n            }\n            // Walk through all chunks\n            var _iterator34 = _createForOfIteratorHelper(usedChunks),\n              _step34;\n            try {\n              for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n                var _chunk7 = _step34.value;\n                // Add graph connections for splitted chunk\n                _chunk7.split(newChunk);\n              }\n\n              // Add a note to the chunk\n            } catch (err) {\n              _iterator34.e(err);\n            } finally {\n              _iterator34.f();\n            }\n            newChunk.chunkReason = (newChunk.chunkReason ? newChunk.chunkReason + \", \" : \"\") + (isReusedWithAllModules ? \"reused as split chunk\" : \"split chunk\");\n            if (item.cacheGroup.key) {\n              newChunk.chunkReason += \" (cache group: \".concat(item.cacheGroup.key, \")\");\n            }\n            if (chunkName) {\n              newChunk.chunkReason += \" (name: \".concat(chunkName, \")\");\n            }\n            if (item.cacheGroup.filename) {\n              newChunk.filenameTemplate = item.cacheGroup.filename;\n            }\n            if (item.cacheGroup.idHint) {\n              newChunk.idNameHints.add(item.cacheGroup.idHint);\n            }\n            if (!isReusedWithAllModules) {\n              // Add all modules to the new chunk\n              var _iterator35 = _createForOfIteratorHelper(item.modules),\n                _step35;\n              try {\n                for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n                  var _module6 = _step35.value;\n                  if (!_module6.chunkCondition(newChunk, compilation)) continue;\n                  // Add module to new chunk\n                  chunkGraph.connectChunkAndModule(newChunk, _module6);\n                  // Remove module from used chunks\n                  var _iterator36 = _createForOfIteratorHelper(usedChunks),\n                    _step36;\n                  try {\n                    for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n                      var _chunk4 = _step36.value;\n                      chunkGraph.disconnectChunkAndModule(_chunk4, _module6);\n                    }\n                  } catch (err) {\n                    _iterator36.e(err);\n                  } finally {\n                    _iterator36.f();\n                  }\n                }\n              } catch (err) {\n                _iterator35.e(err);\n              } finally {\n                _iterator35.f();\n              }\n            } else {\n              // Remove all modules from used chunks\n              var _iterator37 = _createForOfIteratorHelper(item.modules),\n                _step37;\n              try {\n                for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {\n                  var _module7 = _step37.value;\n                  var _iterator38 = _createForOfIteratorHelper(usedChunks),\n                    _step38;\n                  try {\n                    for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {\n                      var _chunk5 = _step38.value;\n                      chunkGraph.disconnectChunkAndModule(_chunk5, _module7);\n                    }\n                  } catch (err) {\n                    _iterator38.e(err);\n                  } finally {\n                    _iterator38.f();\n                  }\n                }\n              } catch (err) {\n                _iterator37.e(err);\n              } finally {\n                _iterator37.f();\n              }\n            }\n            if (Object.keys(item.cacheGroup.maxAsyncSize).length > 0 || Object.keys(item.cacheGroup.maxInitialSize).length > 0) {\n              var oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n              maxSizeQueueMap.set(newChunk, {\n                minSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.minSize, item.cacheGroup._minSizeForMaxSize, Math.max) : item.cacheGroup.minSize,\n                maxAsyncSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.maxAsyncSize, item.cacheGroup.maxAsyncSize, Math.min) : item.cacheGroup.maxAsyncSize,\n                maxInitialSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.maxInitialSize, item.cacheGroup.maxInitialSize, Math.min) : item.cacheGroup.maxInitialSize,\n                automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n                keys: oldMaxSizeSettings ? oldMaxSizeSettings.keys.concat(item.cacheGroup.key) : [item.cacheGroup.key]\n              });\n            }\n\n            // remove all modules from other entries and update size\n            var _iterator39 = _createForOfIteratorHelper(chunksInfoMap),\n              _step39;\n            try {\n              for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {\n                var _step39$value = _slicedToArray(_step39.value, 2),\n                  _key2 = _step39$value[0],\n                  _info = _step39$value[1];\n                if (isOverlap(_info.chunks, usedChunks)) {\n                  // update modules and total size\n                  // may remove it from the map when < minSize\n                  var updated = false;\n                  var _iterator41 = _createForOfIteratorHelper(item.modules),\n                    _step41;\n                  try {\n                    for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {\n                      var _module9 = _step41.value;\n                      if (_info.modules.has(_module9)) {\n                        // remove module\n                        _info.modules.delete(_module9);\n                        // update size\n                        var _iterator42 = _createForOfIteratorHelper(_module9.getSourceTypes()),\n                          _step42;\n                        try {\n                          for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {\n                            var _key3 = _step42.value;\n                            _info.sizes[_key3] -= _module9.size(_key3);\n                          }\n                        } catch (err) {\n                          _iterator42.e(err);\n                        } finally {\n                          _iterator42.f();\n                        }\n                        updated = true;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator41.e(err);\n                  } finally {\n                    _iterator41.f();\n                  }\n                  if (updated) {\n                    if (_info.modules.size === 0) {\n                      chunksInfoMap.delete(_key2);\n                      continue;\n                    }\n                    if (removeMinSizeViolatingModules(_info) || !checkMinSizeReduction(_info.sizes, _info.cacheGroup.minSizeReduction, _info.chunks.size)) {\n                      chunksInfoMap.delete(_key2);\n                      continue;\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator39.e(err);\n            } finally {\n              _iterator39.f();\n            }\n          }\n          logger.timeEnd(\"queue\");\n          logger.time(\"maxSize\");\n\n          /** @type {Set<string>} */\n          var incorrectMinMaxSizeSet = new Set();\n          var outputOptions = compilation.outputOptions;\n\n          // Make sure that maxSize is fulfilled\n          var fallbackCacheGroup = _this.options.fallbackCacheGroup;\n          var _loop3 = function _loop3() {\n            var chunk = _Array$from[_i10];\n            var chunkConfig = maxSizeQueueMap.get(chunk);\n            var _ref = chunkConfig || fallbackCacheGroup,\n              minSize = _ref.minSize,\n              maxAsyncSize = _ref.maxAsyncSize,\n              maxInitialSize = _ref.maxInitialSize,\n              automaticNameDelimiter = _ref.automaticNameDelimiter;\n            if (!chunkConfig && !fallbackCacheGroup.chunksFilter(chunk)) return \"continue\";\n            /** @type {SplitChunksSizes} */\n            var maxSize;\n            if (chunk.isOnlyInitial()) {\n              maxSize = maxInitialSize;\n            } else if (chunk.canBeInitial()) {\n              maxSize = combineSizes(maxAsyncSize, maxInitialSize, Math.min);\n            } else {\n              maxSize = maxAsyncSize;\n            }\n            if (Object.keys(maxSize).length === 0) {\n              return \"continue\";\n            }\n            for (var _i11 = 0, _Object$keys8 = Object.keys(maxSize); _i11 < _Object$keys8.length; _i11++) {\n              var _key4 = _Object$keys8[_i11];\n              var maxSizeValue = maxSize[_key4];\n              var minSizeValue = minSize[_key4];\n              if (typeof minSizeValue === \"number\" && minSizeValue > maxSizeValue) {\n                var keys = chunkConfig && chunkConfig.keys;\n                var warningKey = \"\".concat(keys && keys.join(), \" \").concat(minSizeValue, \" \").concat(maxSizeValue);\n                if (!incorrectMinMaxSizeSet.has(warningKey)) {\n                  incorrectMinMaxSizeSet.add(warningKey);\n                  compilation.warnings.push(new MinMaxSizeWarning(keys, minSizeValue, maxSizeValue));\n                }\n              }\n            }\n            var results = deterministicGroupingForModules({\n              minSize: minSize,\n              maxSize: mapObject(maxSize, function (value, key) {\n                var minSizeValue = minSize[key];\n                return typeof minSizeValue === \"number\" ? Math.max(value, minSizeValue) : value;\n              }),\n              items: chunkGraph.getChunkModulesIterable(chunk),\n              getKey: function getKey(module) {\n                var cache = getKeyCache.get(module);\n                if (cache !== undefined) return cache;\n                var ident = cachedMakePathsRelative(module.identifier());\n                var nameForCondition = module.nameForCondition && module.nameForCondition();\n                var name = nameForCondition ? cachedMakePathsRelative(nameForCondition) : ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n                var fullKey = name + automaticNameDelimiter + hashFilename(ident, outputOptions);\n                var key = requestToId(fullKey);\n                getKeyCache.set(module, key);\n                return key;\n              },\n              getSize: function getSize(module) {\n                var size = Object.create(null);\n                var _iterator43 = _createForOfIteratorHelper(module.getSourceTypes()),\n                  _step43;\n                try {\n                  for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {\n                    var _key5 = _step43.value;\n                    size[_key5] = module.size(_key5);\n                  }\n                } catch (err) {\n                  _iterator43.e(err);\n                } finally {\n                  _iterator43.f();\n                }\n                return size;\n              }\n            });\n            if (results.length <= 1) {\n              return \"continue\";\n            }\n            for (var i = 0; i < results.length; i++) {\n              var group = results[i];\n              var _key6 = _this.options.hidePathInfo ? hashFilename(group.key, outputOptions) : group.key;\n              var name = chunk.name ? chunk.name + automaticNameDelimiter + _key6 : null;\n              if (name && name.length > 100) {\n                name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name, outputOptions);\n              }\n              if (i !== results.length - 1) {\n                var newPart = compilation.addChunk(name);\n                chunk.split(newPart);\n                newPart.chunkReason = chunk.chunkReason;\n                // Add all modules to the new chunk\n                var _iterator44 = _createForOfIteratorHelper(group.items),\n                  _step44;\n                try {\n                  for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {\n                    var _module10 = _step44.value;\n                    if (!_module10.chunkCondition(newPart, compilation)) {\n                      continue;\n                    }\n                    // Add module to new chunk\n                    chunkGraph.connectChunkAndModule(newPart, _module10);\n                    // Remove module from used chunks\n                    chunkGraph.disconnectChunkAndModule(chunk, _module10);\n                  }\n                } catch (err) {\n                  _iterator44.e(err);\n                } finally {\n                  _iterator44.f();\n                }\n              } else {\n                // change the chunk to be a part\n                chunk.name = name;\n              }\n            }\n          };\n          for (var _i10 = 0, _Array$from = Array.from(compilation.chunks); _i10 < _Array$from.length; _i10++) {\n            var _ret2 = _loop3();\n            if (_ret2 === \"continue\") continue;\n          }\n          logger.timeEnd(\"maxSize\");\n        });\n      });\n    }\n  }]);\n  return SplitChunksPlugin;\n}();","map":{"version":3,"names":["Chunk","require","STAGE_ADVANCED","WebpackError","requestToId","isSubset","SortableSet","compareModulesByIdentifier","compareIterables","createHash","deterministicGrouping","makePathsRelative","memoize","MinMaxSizeWarning","defaultGetName","deterministicGroupingForModules","getKeyCache","WeakMap","hashFilename","name","outputOptions","digest","hashFunction","update","hashDigest","slice","getRequests","chunk","requests","groupsIterable","chunkGroup","Math","max","chunks","length","mapObject","obj","fn","newObj","Object","create","keys","key","isOverlap","a","b","item","has","compareModuleIterables","compareEntries","diffPriority","cacheGroup","priority","diffCount","size","aSizeReduce","totalSize","sizes","bSizeReduce","diffSizeReduce","indexDiff","cacheGroupIndex","modulesA","modules","modulesB","diff","sort","INITIAL_CHUNK_FILTER","canBeInitial","ASYNC_CHUNK_FILTER","ALL_CHUNK_FILTER","normalizeSizes","value","defaultSizeTypes","o","sizeType","mergeSizes","merged","i","assign","hasNonZeroSizes","combineSizes","combine","aKeys","Set","bKeys","result","checkMinSize","minSize","undefined","checkMinSizeReduction","minSizeReduction","chunkCount","getViolatingMinSizes","list","push","normalizeName","normalizeChunksFilter","normalizeCacheGroups","cacheGroups","handlers","option","RegExp","source","createCacheGroupSource","module","context","results","checkTest","cache","groups","Array","isArray","group","cachedSource","get","set","test","checkModuleType","type","checkModuleLayer","layer","nameForCondition","startsWith","options","maxSize","getName","chunksFilter","enforce","minRemainingSize","enforceSizeThreshold","maxAsyncSize","maxInitialSize","minChunks","maxAsyncRequests","maxInitialRequests","filename","idHint","automaticNameDelimiter","reuseExistingChunk","usedExports","exports","fallbackCacheGroup","hidePathInfo","getCacheGroups","_cacheGroupCache","cacheGroupSource","cacheEntry","Infinity","_validateSize","_validateRemainingSize","_minSizeForMaxSize","_conditionalEnforce","compiler","cachedMakePathsRelative","bindContextCache","root","hooks","thisCompilation","tap","compilation","logger","getLogger","alreadyOptimized","unseal","optimizeChunks","stage","time","chunkGraph","moduleGraph","chunkIndexMap","Map","ZERO","BigInt","ONE","START","index","random","getKey","iterator","Symbol","next","done","first","raw","keyToString","toString","getChunkSetsInGraph","chunkSetsInGraph","singleChunkSets","getModuleChunksIterable","chunksKey","add","groupChunksByExports","exportsInfo","getExportsInfo","groupedByUsedExports","getUsageKey","runtime","values","groupedByExportsMap","getExportsChunkSetsInGraph","groupedChunks","from","groupChunkSetsByCount","chunkSets","chunkSetsByCount","chunksSet","count","array","getChunkSetsByCount","getExportsChunkSetsByCount","createGetCombinations","combinationsCache","setArray","getCombinationsFactory","getCombinations","getExportsCombinationsFactory","getExportsCombinations","selectedChunksCacheByChunksSet","getSelectedChunks","chunkFilter","entry","entry2","selectedChunks","alreadyValidatedParents","alreadyReportedErrors","chunksInfoMap","addModuleToChunksInfoMap","selectedChunksKey","existingChunk","namedChunks","parentValidationKey","debugId","valid","isInAllParents","queue","isInGroup","hasParent","parentsIterable","parent","errors","info","reuseableChunks","chunksKeys","oldSize","getSourceTypes","oldChunksKeysSize","timeEnd","getCombs","getCombsByUsedExports","comb","_getCacheGroup","combs","chunkCombination","removeModulesWithSourceType","sourceTypes","types","some","delete","removeMinSizeViolatingModules","violatingSizes","maxSizeQueueMap","bestEntryKey","bestEntry","pair","chunkName","newChunk","isExistingChunk","isReusedWithAllModules","chunkByName","outer","getNumberOfChunkModules","getNumberOfEntryModules","isModuleInChunk","enforced","usedChunks","Number","isFinite","maxRequests","isOnlyInitial","min","chunksArr","chunkSizes","getChunkModulesIterable","oldModulesSize","addChunk","split","chunkReason","filenameTemplate","idNameHints","chunkCondition","connectChunkAndModule","disconnectChunkAndModule","oldMaxSizeSettings","concat","updated","incorrectMinMaxSizeSet","chunkConfig","maxSizeValue","minSizeValue","warningKey","join","warnings","items","ident","identifier","replace","fullKey","getSize","newPart"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/optimize/SplitChunksPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Chunk = require(\"../Chunk\");\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\nconst WebpackError = require(\"../WebpackError\");\nconst { requestToId } = require(\"../ids/IdHelpers\");\nconst { isSubset } = require(\"../util/SetHelpers\");\nconst SortableSet = require(\"../util/SortableSet\");\nconst {\n\tcompareModulesByIdentifier,\n\tcompareIterables\n} = require(\"../util/comparators\");\nconst createHash = require(\"../util/createHash\");\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\nconst { makePathsRelative } = require(\"../util/identifier\");\nconst memoize = require(\"../util/memoize\");\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksCacheGroup} OptimizationSplitChunksCacheGroup */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksGetCacheGroups} OptimizationSplitChunksGetCacheGroups */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksOptions} OptimizationSplitChunksOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksSizes} OptimizationSplitChunksSizes */\n/** @typedef {import(\"../../declarations/WebpackOptions\").Output} OutputOptions */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n\n/** @typedef {Record<string, number>} SplitChunksSizes */\n\n/**\n * @callback ChunkFilterFunction\n * @param {Chunk} chunk\n * @returns {boolean}\n */\n\n/**\n * @callback CombineSizeFunction\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\n\n/**\n * @typedef {Object} CacheGroupSource\n * @property {string=} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {boolean=} enforce\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean=} reuseExistingChunk\n * @property {boolean=} usedExports\n */\n\n/**\n * @typedef {Object} CacheGroup\n * @property {string} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean} reuseExistingChunk\n * @property {boolean} usedExports\n * @property {boolean} _validateSize\n * @property {boolean} _validateRemainingSize\n * @property {SplitChunksSizes} _minSizeForMaxSize\n * @property {boolean} _conditionalEnforce\n */\n\n/**\n * @typedef {Object} FallbackCacheGroup\n * @property {ChunkFilterFunction} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {string} automaticNameDelimiter\n */\n\n/**\n * @typedef {Object} CacheGroupsContext\n * @property {ModuleGraph} moduleGraph\n * @property {ChunkGraph} chunkGraph\n */\n\n/**\n * @callback GetCacheGroups\n * @param {Module} module\n * @param {CacheGroupsContext} context\n * @returns {CacheGroupSource[]}\n */\n\n/**\n * @callback GetName\n * @param {Module=} module\n * @param {Chunk[]=} chunks\n * @param {string=} key\n * @returns {string=}\n */\n\n/**\n * @typedef {Object} SplitChunksOptions\n * @property {ChunkFilterFunction} chunksFilter\n * @property {string[]} defaultSizeTypes\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxInitialSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {number} minChunks\n * @property {number} maxAsyncRequests\n * @property {number} maxInitialRequests\n * @property {boolean} hidePathInfo\n * @property {string | function(PathData, AssetInfo=): string} filename\n * @property {string} automaticNameDelimiter\n * @property {GetCacheGroups} getCacheGroups\n * @property {GetName} getName\n * @property {boolean} usedExports\n * @property {FallbackCacheGroup} fallbackCacheGroup\n */\n\n/**\n * @typedef {Object} ChunksInfoItem\n * @property {SortableSet<Module>} modules\n * @property {CacheGroup} cacheGroup\n * @property {number} cacheGroupIndex\n * @property {string} name\n * @property {Record<string, number>} sizes\n * @property {Set<Chunk>} chunks\n * @property {Set<Chunk>} reuseableChunks\n * @property {Set<bigint | Chunk>} chunksKeys\n */\n\nconst defaultGetName = /** @type {GetName} */ (() => {});\n\nconst deterministicGroupingForModules =\n\t/** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */ (\n\t\tdeterministicGrouping\n\t);\n\n/** @type {WeakMap<Module, string>} */\nconst getKeyCache = new WeakMap();\n\n/**\n * @param {string} name a filename to hash\n * @param {OutputOptions} outputOptions hash function used\n * @returns {string} hashed filename\n */\nconst hashFilename = (name, outputOptions) => {\n\tconst digest = /** @type {string} */ (\n\t\tcreateHash(outputOptions.hashFunction)\n\t\t\t.update(name)\n\t\t\t.digest(outputOptions.hashDigest)\n\t);\n\treturn digest.slice(0, 8);\n};\n\n/**\n * @param {Chunk} chunk the chunk\n * @returns {number} the number of requests\n */\nconst getRequests = chunk => {\n\tlet requests = 0;\n\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\trequests = Math.max(requests, chunkGroup.chunks.length);\n\t}\n\treturn requests;\n};\n\nconst mapObject = (obj, fn) => {\n\tconst newObj = Object.create(null);\n\tfor (const key of Object.keys(obj)) {\n\t\tnewObj[key] = fn(obj[key], key);\n\t}\n\treturn newObj;\n};\n\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\nconst isOverlap = (a, b) => {\n\tfor (const item of a) {\n\t\tif (b.has(item)) return true;\n\t}\n\treturn false;\n};\n\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n\n/**\n * @param {ChunksInfoItem} a item\n * @param {ChunksInfoItem} b item\n * @returns {number} compare result\n */\nconst compareEntries = (a, b) => {\n\t// 1. by priority\n\tconst diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n\tif (diffPriority) return diffPriority;\n\t// 2. by number of chunks\n\tconst diffCount = a.chunks.size - b.chunks.size;\n\tif (diffCount) return diffCount;\n\t// 3. by size reduction\n\tconst aSizeReduce = totalSize(a.sizes) * (a.chunks.size - 1);\n\tconst bSizeReduce = totalSize(b.sizes) * (b.chunks.size - 1);\n\tconst diffSizeReduce = aSizeReduce - bSizeReduce;\n\tif (diffSizeReduce) return diffSizeReduce;\n\t// 4. by cache group index\n\tconst indexDiff = b.cacheGroupIndex - a.cacheGroupIndex;\n\tif (indexDiff) return indexDiff;\n\t// 5. by number of modules (to be able to compare by identifier)\n\tconst modulesA = a.modules;\n\tconst modulesB = b.modules;\n\tconst diff = modulesA.size - modulesB.size;\n\tif (diff) return diff;\n\t// 6. by module identifiers\n\tmodulesA.sort();\n\tmodulesB.sort();\n\treturn compareModuleIterables(modulesA, modulesB);\n};\n\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\nconst ALL_CHUNK_FILTER = chunk => true;\n\n/**\n * @param {OptimizationSplitChunksSizes} value the sizes\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {SplitChunksSizes} normalized representation\n */\nconst normalizeSizes = (value, defaultSizeTypes) => {\n\tif (typeof value === \"number\") {\n\t\t/** @type {Record<string, number>} */\n\t\tconst o = {};\n\t\tfor (const sizeType of defaultSizeTypes) o[sizeType] = value;\n\t\treturn o;\n\t} else if (typeof value === \"object\" && value !== null) {\n\t\treturn { ...value };\n\t} else {\n\t\treturn {};\n\t}\n};\n\n/**\n * @param {...SplitChunksSizes} sizes the sizes\n * @returns {SplitChunksSizes} the merged sizes\n */\nconst mergeSizes = (...sizes) => {\n\t/** @type {SplitChunksSizes} */\n\tlet merged = {};\n\tfor (let i = sizes.length - 1; i >= 0; i--) {\n\t\tmerged = Object.assign(merged, sizes[i]);\n\t}\n\treturn merged;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {boolean} true, if there are sizes > 0\n */\nconst hasNonZeroSizes = sizes => {\n\tfor (const key of Object.keys(sizes)) {\n\t\tif (sizes[key] > 0) return true;\n\t}\n\treturn false;\n};\n\n/**\n * @param {SplitChunksSizes} a first sizes\n * @param {SplitChunksSizes} b second sizes\n * @param {CombineSizeFunction} combine a function to combine sizes\n * @returns {SplitChunksSizes} the combine sizes\n */\nconst combineSizes = (a, b, combine) => {\n\tconst aKeys = new Set(Object.keys(a));\n\tconst bKeys = new Set(Object.keys(b));\n\t/** @type {SplitChunksSizes} */\n\tconst result = {};\n\tfor (const key of aKeys) {\n\t\tif (bKeys.has(key)) {\n\t\t\tresult[key] = combine(a[key], b[key]);\n\t\t} else {\n\t\t\tresult[key] = a[key];\n\t\t}\n\t}\n\tfor (const key of bKeys) {\n\t\tif (!aKeys.has(key)) {\n\t\t\tresult[key] = b[key];\n\t\t}\n\t}\n\treturn result;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSize`\n */\nconst checkMinSize = (sizes, minSize) => {\n\tfor (const key of Object.keys(minSize)) {\n\t\tconst size = sizes[key];\n\t\tif (size === undefined || size === 0) continue;\n\t\tif (size < minSize[key]) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSizeReduction the min sizes\n * @param {number} chunkCount number of chunks\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSizeReduction`\n */\nconst checkMinSizeReduction = (sizes, minSizeReduction, chunkCount) => {\n\tfor (const key of Object.keys(minSizeReduction)) {\n\t\tconst size = sizes[key];\n\t\tif (size === undefined || size === 0) continue;\n\t\tif (size * chunkCount < minSizeReduction[key]) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {undefined | string[]} list of size types that are below min size\n */\nconst getViolatingMinSizes = (sizes, minSize) => {\n\tlet list;\n\tfor (const key of Object.keys(minSize)) {\n\t\tconst size = sizes[key];\n\t\tif (size === undefined || size === 0) continue;\n\t\tif (size < minSize[key]) {\n\t\t\tif (list === undefined) list = [key];\n\t\t\telse list.push(key);\n\t\t}\n\t}\n\treturn list;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {number} the total size\n */\nconst totalSize = sizes => {\n\tlet size = 0;\n\tfor (const key of Object.keys(sizes)) {\n\t\tsize += sizes[key];\n\t}\n\treturn size;\n};\n\n/**\n * @param {false|string|Function} name the chunk name\n * @returns {GetName} a function to get the name of the chunk\n */\nconst normalizeName = name => {\n\tif (typeof name === \"string\") {\n\t\treturn () => name;\n\t}\n\tif (typeof name === \"function\") {\n\t\treturn /** @type {GetName} */ (name);\n\t}\n};\n\n/**\n * @param {OptimizationSplitChunksCacheGroup[\"chunks\"]} chunks the chunk filter option\n * @returns {ChunkFilterFunction} the chunk filter function\n */\nconst normalizeChunksFilter = chunks => {\n\tif (chunks === \"initial\") {\n\t\treturn INITIAL_CHUNK_FILTER;\n\t}\n\tif (chunks === \"async\") {\n\t\treturn ASYNC_CHUNK_FILTER;\n\t}\n\tif (chunks === \"all\") {\n\t\treturn ALL_CHUNK_FILTER;\n\t}\n\tif (typeof chunks === \"function\") {\n\t\treturn chunks;\n\t}\n};\n\n/**\n * @param {GetCacheGroups | Record<string, false|string|RegExp|OptimizationSplitChunksGetCacheGroups|OptimizationSplitChunksCacheGroup>} cacheGroups the cache group options\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {GetCacheGroups} a function to get the cache groups\n */\nconst normalizeCacheGroups = (cacheGroups, defaultSizeTypes) => {\n\tif (typeof cacheGroups === \"function\") {\n\t\treturn cacheGroups;\n\t}\n\tif (typeof cacheGroups === \"object\" && cacheGroups !== null) {\n\t\t/** @type {(function(Module, CacheGroupsContext, CacheGroupSource[]): void)[]} */\n\t\tconst handlers = [];\n\t\tfor (const key of Object.keys(cacheGroups)) {\n\t\t\tconst option = cacheGroups[key];\n\t\t\tif (option === false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (typeof option === \"string\" || option instanceof RegExp) {\n\t\t\t\tconst source = createCacheGroupSource({}, key, defaultSizeTypes);\n\t\t\t\thandlers.push((module, context, results) => {\n\t\t\t\t\tif (checkTest(option, module, context)) {\n\t\t\t\t\t\tresults.push(source);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (typeof option === \"function\") {\n\t\t\t\tconst cache = new WeakMap();\n\t\t\t\thandlers.push((module, context, results) => {\n\t\t\t\t\tconst result = option(module);\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tconst groups = Array.isArray(result) ? result : [result];\n\t\t\t\t\t\tfor (const group of groups) {\n\t\t\t\t\t\t\tconst cachedSource = cache.get(group);\n\t\t\t\t\t\t\tif (cachedSource !== undefined) {\n\t\t\t\t\t\t\t\tresults.push(cachedSource);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst source = createCacheGroupSource(\n\t\t\t\t\t\t\t\t\tgroup,\n\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\tdefaultSizeTypes\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcache.set(group, source);\n\t\t\t\t\t\t\t\tresults.push(source);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst source = createCacheGroupSource(option, key, defaultSizeTypes);\n\t\t\t\thandlers.push((module, context, results) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tcheckTest(option.test, module, context) &&\n\t\t\t\t\t\tcheckModuleType(option.type, module) &&\n\t\t\t\t\t\tcheckModuleLayer(option.layer, module)\n\t\t\t\t\t) {\n\t\t\t\t\t\tresults.push(source);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * @param {Module} module the current module\n\t\t * @param {CacheGroupsContext} context the current context\n\t\t * @returns {CacheGroupSource[]} the matching cache groups\n\t\t */\n\t\tconst fn = (module, context) => {\n\t\t\t/** @type {CacheGroupSource[]} */\n\t\t\tlet results = [];\n\t\t\tfor (const fn of handlers) {\n\t\t\t\tfn(module, context, results);\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\t\treturn fn;\n\t}\n\treturn () => null;\n};\n\n/**\n * @param {undefined|boolean|string|RegExp|Function} test test option\n * @param {Module} module the module\n * @param {CacheGroupsContext} context context object\n * @returns {boolean} true, if the module should be selected\n */\nconst checkTest = (test, module, context) => {\n\tif (test === undefined) return true;\n\tif (typeof test === \"function\") {\n\t\treturn test(module, context);\n\t}\n\tif (typeof test === \"boolean\") return test;\n\tif (typeof test === \"string\") {\n\t\tconst name = module.nameForCondition();\n\t\treturn name && name.startsWith(test);\n\t}\n\tif (test instanceof RegExp) {\n\t\tconst name = module.nameForCondition();\n\t\treturn name && test.test(name);\n\t}\n\treturn false;\n};\n\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\nconst checkModuleType = (test, module) => {\n\tif (test === undefined) return true;\n\tif (typeof test === \"function\") {\n\t\treturn test(module.type);\n\t}\n\tif (typeof test === \"string\") {\n\t\tconst type = module.type;\n\t\treturn test === type;\n\t}\n\tif (test instanceof RegExp) {\n\t\tconst type = module.type;\n\t\treturn test.test(type);\n\t}\n\treturn false;\n};\n\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\nconst checkModuleLayer = (test, module) => {\n\tif (test === undefined) return true;\n\tif (typeof test === \"function\") {\n\t\treturn test(module.layer);\n\t}\n\tif (typeof test === \"string\") {\n\t\tconst layer = module.layer;\n\t\treturn test === \"\" ? !layer : layer && layer.startsWith(test);\n\t}\n\tif (test instanceof RegExp) {\n\t\tconst layer = module.layer;\n\t\treturn test.test(layer);\n\t}\n\treturn false;\n};\n\n/**\n * @param {OptimizationSplitChunksCacheGroup} options the group options\n * @param {string} key key of cache group\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {CacheGroupSource} the normalized cached group\n */\nconst createCacheGroupSource = (options, key, defaultSizeTypes) => {\n\tconst minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n\tconst minSizeReduction = normalizeSizes(\n\t\toptions.minSizeReduction,\n\t\tdefaultSizeTypes\n\t);\n\tconst maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n\treturn {\n\t\tkey,\n\t\tpriority: options.priority,\n\t\tgetName: normalizeName(options.name),\n\t\tchunksFilter: normalizeChunksFilter(options.chunks),\n\t\tenforce: options.enforce,\n\t\tminSize,\n\t\tminSizeReduction,\n\t\tminRemainingSize: mergeSizes(\n\t\t\tnormalizeSizes(options.minRemainingSize, defaultSizeTypes),\n\t\t\tminSize\n\t\t),\n\t\tenforceSizeThreshold: normalizeSizes(\n\t\t\toptions.enforceSizeThreshold,\n\t\t\tdefaultSizeTypes\n\t\t),\n\t\tmaxAsyncSize: mergeSizes(\n\t\t\tnormalizeSizes(options.maxAsyncSize, defaultSizeTypes),\n\t\t\tmaxSize\n\t\t),\n\t\tmaxInitialSize: mergeSizes(\n\t\t\tnormalizeSizes(options.maxInitialSize, defaultSizeTypes),\n\t\t\tmaxSize\n\t\t),\n\t\tminChunks: options.minChunks,\n\t\tmaxAsyncRequests: options.maxAsyncRequests,\n\t\tmaxInitialRequests: options.maxInitialRequests,\n\t\tfilename: options.filename,\n\t\tidHint: options.idHint,\n\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\treuseExistingChunk: options.reuseExistingChunk,\n\t\tusedExports: options.usedExports\n\t};\n};\n\nmodule.exports = class SplitChunksPlugin {\n\t/**\n\t * @param {OptimizationSplitChunksOptions=} options plugin options\n\t */\n\tconstructor(options = {}) {\n\t\tconst defaultSizeTypes = options.defaultSizeTypes || [\n\t\t\t\"javascript\",\n\t\t\t\"unknown\"\n\t\t];\n\t\tconst fallbackCacheGroup = options.fallbackCacheGroup || {};\n\t\tconst minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n\t\tconst minSizeReduction = normalizeSizes(\n\t\t\toptions.minSizeReduction,\n\t\t\tdefaultSizeTypes\n\t\t);\n\t\tconst maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n\n\t\t/** @type {SplitChunksOptions} */\n\t\tthis.options = {\n\t\t\tchunksFilter: normalizeChunksFilter(options.chunks || \"all\"),\n\t\t\tdefaultSizeTypes,\n\t\t\tminSize,\n\t\t\tminSizeReduction,\n\t\t\tminRemainingSize: mergeSizes(\n\t\t\t\tnormalizeSizes(options.minRemainingSize, defaultSizeTypes),\n\t\t\t\tminSize\n\t\t\t),\n\t\t\tenforceSizeThreshold: normalizeSizes(\n\t\t\t\toptions.enforceSizeThreshold,\n\t\t\t\tdefaultSizeTypes\n\t\t\t),\n\t\t\tmaxAsyncSize: mergeSizes(\n\t\t\t\tnormalizeSizes(options.maxAsyncSize, defaultSizeTypes),\n\t\t\t\tmaxSize\n\t\t\t),\n\t\t\tmaxInitialSize: mergeSizes(\n\t\t\t\tnormalizeSizes(options.maxInitialSize, defaultSizeTypes),\n\t\t\t\tmaxSize\n\t\t\t),\n\t\t\tminChunks: options.minChunks || 1,\n\t\t\tmaxAsyncRequests: options.maxAsyncRequests || 1,\n\t\t\tmaxInitialRequests: options.maxInitialRequests || 1,\n\t\t\thidePathInfo: options.hidePathInfo || false,\n\t\t\tfilename: options.filename || undefined,\n\t\t\tgetCacheGroups: normalizeCacheGroups(\n\t\t\t\toptions.cacheGroups,\n\t\t\t\tdefaultSizeTypes\n\t\t\t),\n\t\t\tgetName: options.name ? normalizeName(options.name) : defaultGetName,\n\t\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\t\tusedExports: options.usedExports,\n\t\t\tfallbackCacheGroup: {\n\t\t\t\tchunksFilter: normalizeChunksFilter(\n\t\t\t\t\tfallbackCacheGroup.chunks || options.chunks || \"all\"\n\t\t\t\t),\n\t\t\t\tminSize: mergeSizes(\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.minSize, defaultSizeTypes),\n\t\t\t\t\tminSize\n\t\t\t\t),\n\t\t\t\tmaxAsyncSize: mergeSizes(\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxAsyncSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxAsyncSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxSize, defaultSizeTypes)\n\t\t\t\t),\n\t\t\t\tmaxInitialSize: mergeSizes(\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxInitialSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxInitialSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxSize, defaultSizeTypes)\n\t\t\t\t),\n\t\t\t\tautomaticNameDelimiter:\n\t\t\t\t\tfallbackCacheGroup.automaticNameDelimiter ||\n\t\t\t\t\toptions.automaticNameDelimiter ||\n\t\t\t\t\t\"~\"\n\t\t\t}\n\t\t};\n\n\t\t/** @type {WeakMap<CacheGroupSource, CacheGroup>} */\n\t\tthis._cacheGroupCache = new WeakMap();\n\t}\n\n\t/**\n\t * @param {CacheGroupSource} cacheGroupSource source\n\t * @returns {CacheGroup} the cache group (cached)\n\t */\n\t_getCacheGroup(cacheGroupSource) {\n\t\tconst cacheEntry = this._cacheGroupCache.get(cacheGroupSource);\n\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\tconst minSize = mergeSizes(\n\t\t\tcacheGroupSource.minSize,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.minSize\n\t\t);\n\t\tconst minSizeReduction = mergeSizes(\n\t\t\tcacheGroupSource.minSizeReduction,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.minSizeReduction\n\t\t);\n\t\tconst minRemainingSize = mergeSizes(\n\t\t\tcacheGroupSource.minRemainingSize,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.minRemainingSize\n\t\t);\n\t\tconst enforceSizeThreshold = mergeSizes(\n\t\t\tcacheGroupSource.enforceSizeThreshold,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.enforceSizeThreshold\n\t\t);\n\t\tconst cacheGroup = {\n\t\t\tkey: cacheGroupSource.key,\n\t\t\tpriority: cacheGroupSource.priority || 0,\n\t\t\tchunksFilter: cacheGroupSource.chunksFilter || this.options.chunksFilter,\n\t\t\tminSize,\n\t\t\tminSizeReduction,\n\t\t\tminRemainingSize,\n\t\t\tenforceSizeThreshold,\n\t\t\tmaxAsyncSize: mergeSizes(\n\t\t\t\tcacheGroupSource.maxAsyncSize,\n\t\t\t\tcacheGroupSource.enforce ? undefined : this.options.maxAsyncSize\n\t\t\t),\n\t\t\tmaxInitialSize: mergeSizes(\n\t\t\t\tcacheGroupSource.maxInitialSize,\n\t\t\t\tcacheGroupSource.enforce ? undefined : this.options.maxInitialSize\n\t\t\t),\n\t\t\tminChunks:\n\t\t\t\tcacheGroupSource.minChunks !== undefined\n\t\t\t\t\t? cacheGroupSource.minChunks\n\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t? 1\n\t\t\t\t\t: this.options.minChunks,\n\t\t\tmaxAsyncRequests:\n\t\t\t\tcacheGroupSource.maxAsyncRequests !== undefined\n\t\t\t\t\t? cacheGroupSource.maxAsyncRequests\n\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t? Infinity\n\t\t\t\t\t: this.options.maxAsyncRequests,\n\t\t\tmaxInitialRequests:\n\t\t\t\tcacheGroupSource.maxInitialRequests !== undefined\n\t\t\t\t\t? cacheGroupSource.maxInitialRequests\n\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t? Infinity\n\t\t\t\t\t: this.options.maxInitialRequests,\n\t\t\tgetName:\n\t\t\t\tcacheGroupSource.getName !== undefined\n\t\t\t\t\t? cacheGroupSource.getName\n\t\t\t\t\t: this.options.getName,\n\t\t\tusedExports:\n\t\t\t\tcacheGroupSource.usedExports !== undefined\n\t\t\t\t\t? cacheGroupSource.usedExports\n\t\t\t\t\t: this.options.usedExports,\n\t\t\tfilename:\n\t\t\t\tcacheGroupSource.filename !== undefined\n\t\t\t\t\t? cacheGroupSource.filename\n\t\t\t\t\t: this.options.filename,\n\t\t\tautomaticNameDelimiter:\n\t\t\t\tcacheGroupSource.automaticNameDelimiter !== undefined\n\t\t\t\t\t? cacheGroupSource.automaticNameDelimiter\n\t\t\t\t\t: this.options.automaticNameDelimiter,\n\t\t\tidHint:\n\t\t\t\tcacheGroupSource.idHint !== undefined\n\t\t\t\t\t? cacheGroupSource.idHint\n\t\t\t\t\t: cacheGroupSource.key,\n\t\t\treuseExistingChunk: cacheGroupSource.reuseExistingChunk || false,\n\t\t\t_validateSize: hasNonZeroSizes(minSize),\n\t\t\t_validateRemainingSize: hasNonZeroSizes(minRemainingSize),\n\t\t\t_minSizeForMaxSize: mergeSizes(\n\t\t\t\tcacheGroupSource.minSize,\n\t\t\t\tthis.options.minSize\n\t\t\t),\n\t\t\t_conditionalEnforce: hasNonZeroSizes(enforceSizeThreshold)\n\t\t};\n\t\tthis._cacheGroupCache.set(cacheGroupSource, cacheGroup);\n\t\treturn cacheGroup;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst cachedMakePathsRelative = makePathsRelative.bindContextCache(\n\t\t\tcompiler.context,\n\t\t\tcompiler.root\n\t\t);\n\t\tcompiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n\t\t\tconst logger = compilation.getLogger(\"webpack.SplitChunksPlugin\");\n\t\t\tlet alreadyOptimized = false;\n\t\t\tcompilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n\t\t\t\talreadyOptimized = false;\n\t\t\t});\n\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"SplitChunksPlugin\",\n\t\t\t\t\tstage: STAGE_ADVANCED\n\t\t\t\t},\n\t\t\t\tchunks => {\n\t\t\t\t\tif (alreadyOptimized) return;\n\t\t\t\t\talreadyOptimized = true;\n\t\t\t\t\tlogger.time(\"prepare\");\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\t\t\t// Give each selected chunk an index (to create strings from chunks)\n\t\t\t\t\t/** @type {Map<Chunk, bigint>} */\n\t\t\t\t\tconst chunkIndexMap = new Map();\n\t\t\t\t\tconst ZERO = BigInt(\"0\");\n\t\t\t\t\tconst ONE = BigInt(\"1\");\n\t\t\t\t\tconst START = ONE << BigInt(\"31\");\n\t\t\t\t\tlet index = START;\n\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\tchunkIndexMap.set(\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tindex | BigInt((Math.random() * 0x7fffffff) | 0)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tindex = index << ONE;\n\t\t\t\t\t}\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Iterable<Chunk>} chunks list of chunks\n\t\t\t\t\t * @returns {bigint | Chunk} key of the chunks\n\t\t\t\t\t */\n\t\t\t\t\tconst getKey = chunks => {\n\t\t\t\t\t\tconst iterator = chunks[Symbol.iterator]();\n\t\t\t\t\t\tlet result = iterator.next();\n\t\t\t\t\t\tif (result.done) return ZERO;\n\t\t\t\t\t\tconst first = result.value;\n\t\t\t\t\t\tresult = iterator.next();\n\t\t\t\t\t\tif (result.done) return first;\n\t\t\t\t\t\tlet key =\n\t\t\t\t\t\t\tchunkIndexMap.get(first) | chunkIndexMap.get(result.value);\n\t\t\t\t\t\twhile (!(result = iterator.next()).done) {\n\t\t\t\t\t\t\tconst raw = chunkIndexMap.get(result.value);\n\t\t\t\t\t\t\tkey = key ^ raw;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn key;\n\t\t\t\t\t};\n\t\t\t\t\tconst keyToString = key => {\n\t\t\t\t\t\tif (typeof key === \"bigint\") return key.toString(16);\n\t\t\t\t\t\treturn chunkIndexMap.get(key).toString(16);\n\t\t\t\t\t};\n\n\t\t\t\t\tconst getChunkSetsInGraph = memoize(() => {\n\t\t\t\t\t\t/** @type {Map<bigint, Set<Chunk>>} */\n\t\t\t\t\t\tconst chunkSetsInGraph = new Map();\n\t\t\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\t\t\tconst singleChunkSets = new Set();\n\t\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t\tconst chunks = chunkGraph.getModuleChunksIterable(module);\n\t\t\t\t\t\t\tconst chunksKey = getKey(chunks);\n\t\t\t\t\t\t\tif (typeof chunksKey === \"bigint\") {\n\t\t\t\t\t\t\t\tif (!chunkSetsInGraph.has(chunksKey)) {\n\t\t\t\t\t\t\t\t\tchunkSetsInGraph.set(chunksKey, new Set(chunks));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsingleChunkSets.add(chunksKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn { chunkSetsInGraph, singleChunkSets };\n\t\t\t\t\t});\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Module} module the module\n\t\t\t\t\t * @returns {Iterable<Chunk[]>} groups of chunks with equal exports\n\t\t\t\t\t */\n\t\t\t\t\tconst groupChunksByExports = module => {\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\tconst groupedByUsedExports = new Map();\n\t\t\t\t\t\tfor (const chunk of chunkGraph.getModuleChunksIterable(module)) {\n\t\t\t\t\t\t\tconst key = exportsInfo.getUsageKey(chunk.runtime);\n\t\t\t\t\t\t\tconst list = groupedByUsedExports.get(key);\n\t\t\t\t\t\t\tif (list !== undefined) {\n\t\t\t\t\t\t\t\tlist.push(chunk);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgroupedByUsedExports.set(key, [chunk]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn groupedByUsedExports.values();\n\t\t\t\t\t};\n\n\t\t\t\t\t/** @type {Map<Module, Iterable<Chunk[]>>} */\n\t\t\t\t\tconst groupedByExportsMap = new Map();\n\n\t\t\t\t\tconst getExportsChunkSetsInGraph = memoize(() => {\n\t\t\t\t\t\t/** @type {Map<bigint, Set<Chunk>>} */\n\t\t\t\t\t\tconst chunkSetsInGraph = new Map();\n\t\t\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\t\t\tconst singleChunkSets = new Set();\n\t\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t\tconst groupedChunks = Array.from(groupChunksByExports(module));\n\t\t\t\t\t\t\tgroupedByExportsMap.set(module, groupedChunks);\n\t\t\t\t\t\t\tfor (const chunks of groupedChunks) {\n\t\t\t\t\t\t\t\tif (chunks.length === 1) {\n\t\t\t\t\t\t\t\t\tsingleChunkSets.add(chunks[0]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst chunksKey = /** @type {bigint} */ (getKey(chunks));\n\t\t\t\t\t\t\t\t\tif (!chunkSetsInGraph.has(chunksKey)) {\n\t\t\t\t\t\t\t\t\t\tchunkSetsInGraph.set(chunksKey, new Set(chunks));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn { chunkSetsInGraph, singleChunkSets };\n\t\t\t\t\t});\n\n\t\t\t\t\t// group these set of chunks by count\n\t\t\t\t\t// to allow to check less sets via isSubset\n\t\t\t\t\t// (only smaller sets can be subset)\n\t\t\t\t\tconst groupChunkSetsByCount = chunkSets => {\n\t\t\t\t\t\t/** @type {Map<number, Array<Set<Chunk>>>} */\n\t\t\t\t\t\tconst chunkSetsByCount = new Map();\n\t\t\t\t\t\tfor (const chunksSet of chunkSets) {\n\t\t\t\t\t\t\tconst count = chunksSet.size;\n\t\t\t\t\t\t\tlet array = chunkSetsByCount.get(count);\n\t\t\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\t\t\tchunkSetsByCount.set(count, array);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tarray.push(chunksSet);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn chunkSetsByCount;\n\t\t\t\t\t};\n\t\t\t\t\tconst getChunkSetsByCount = memoize(() =>\n\t\t\t\t\t\tgroupChunkSetsByCount(\n\t\t\t\t\t\t\tgetChunkSetsInGraph().chunkSetsInGraph.values()\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tconst getExportsChunkSetsByCount = memoize(() =>\n\t\t\t\t\t\tgroupChunkSetsByCount(\n\t\t\t\t\t\t\tgetExportsChunkSetsInGraph().chunkSetsInGraph.values()\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\t// Create a list of possible combinations\n\t\t\t\t\tconst createGetCombinations = (\n\t\t\t\t\t\tchunkSets,\n\t\t\t\t\t\tsingleChunkSets,\n\t\t\t\t\t\tchunkSetsByCount\n\t\t\t\t\t) => {\n\t\t\t\t\t\t/** @type {Map<bigint | Chunk, (Set<Chunk> | Chunk)[]>} */\n\t\t\t\t\t\tconst combinationsCache = new Map();\n\n\t\t\t\t\t\treturn key => {\n\t\t\t\t\t\t\tconst cacheEntry = combinationsCache.get(key);\n\t\t\t\t\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\t\t\t\t\tif (key instanceof Chunk) {\n\t\t\t\t\t\t\t\tconst result = [key];\n\t\t\t\t\t\t\t\tcombinationsCache.set(key, result);\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst chunksSet = chunkSets.get(key);\n\t\t\t\t\t\t\t/** @type {(Set<Chunk> | Chunk)[]} */\n\t\t\t\t\t\t\tconst array = [chunksSet];\n\t\t\t\t\t\t\tfor (const [count, setArray] of chunkSetsByCount) {\n\t\t\t\t\t\t\t\t// \"equal\" is not needed because they would have been merge in the first step\n\t\t\t\t\t\t\t\tif (count < chunksSet.size) {\n\t\t\t\t\t\t\t\t\tfor (const set of setArray) {\n\t\t\t\t\t\t\t\t\t\tif (isSubset(chunksSet, set)) {\n\t\t\t\t\t\t\t\t\t\t\tarray.push(set);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const chunk of singleChunkSets) {\n\t\t\t\t\t\t\t\tif (chunksSet.has(chunk)) {\n\t\t\t\t\t\t\t\t\tarray.push(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcombinationsCache.set(key, array);\n\t\t\t\t\t\t\treturn array;\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\tconst getCombinationsFactory = memoize(() => {\n\t\t\t\t\t\tconst { chunkSetsInGraph, singleChunkSets } = getChunkSetsInGraph();\n\t\t\t\t\t\treturn createGetCombinations(\n\t\t\t\t\t\t\tchunkSetsInGraph,\n\t\t\t\t\t\t\tsingleChunkSets,\n\t\t\t\t\t\t\tgetChunkSetsByCount()\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\tconst getCombinations = key => getCombinationsFactory()(key);\n\n\t\t\t\t\tconst getExportsCombinationsFactory = memoize(() => {\n\t\t\t\t\t\tconst { chunkSetsInGraph, singleChunkSets } =\n\t\t\t\t\t\t\tgetExportsChunkSetsInGraph();\n\t\t\t\t\t\treturn createGetCombinations(\n\t\t\t\t\t\t\tchunkSetsInGraph,\n\t\t\t\t\t\t\tsingleChunkSets,\n\t\t\t\t\t\t\tgetExportsChunkSetsByCount()\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\tconst getExportsCombinations = key =>\n\t\t\t\t\t\tgetExportsCombinationsFactory()(key);\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} SelectedChunksResult\n\t\t\t\t\t * @property {Chunk[]} chunks the list of chunks\n\t\t\t\t\t * @property {bigint | Chunk} key a key of the list\n\t\t\t\t\t */\n\n\t\t\t\t\t/** @type {WeakMap<Set<Chunk> | Chunk, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\t\t\t\t\tconst selectedChunksCacheByChunksSet = new WeakMap();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * get list and key by applying the filter function to the list\n\t\t\t\t\t * It is cached for performance reasons\n\t\t\t\t\t * @param {Set<Chunk> | Chunk} chunks list of chunks\n\t\t\t\t\t * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n\t\t\t\t\t * @returns {SelectedChunksResult} list and key\n\t\t\t\t\t */\n\t\t\t\t\tconst getSelectedChunks = (chunks, chunkFilter) => {\n\t\t\t\t\t\tlet entry = selectedChunksCacheByChunksSet.get(chunks);\n\t\t\t\t\t\tif (entry === undefined) {\n\t\t\t\t\t\t\tentry = new WeakMap();\n\t\t\t\t\t\t\tselectedChunksCacheByChunksSet.set(chunks, entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/** @type {SelectedChunksResult} */\n\t\t\t\t\t\tlet entry2 = entry.get(chunkFilter);\n\t\t\t\t\t\tif (entry2 === undefined) {\n\t\t\t\t\t\t\t/** @type {Chunk[]} */\n\t\t\t\t\t\t\tconst selectedChunks = [];\n\t\t\t\t\t\t\tif (chunks instanceof Chunk) {\n\t\t\t\t\t\t\t\tif (chunkFilter(chunks)) selectedChunks.push(chunks);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\t\t\tif (chunkFilter(chunk)) selectedChunks.push(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry2 = {\n\t\t\t\t\t\t\t\tchunks: selectedChunks,\n\t\t\t\t\t\t\t\tkey: getKey(selectedChunks)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tentry.set(chunkFilter, entry2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn entry2;\n\t\t\t\t\t};\n\n\t\t\t\t\t/** @type {Map<string, boolean>} */\n\t\t\t\t\tconst alreadyValidatedParents = new Map();\n\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\tconst alreadyReportedErrors = new Set();\n\n\t\t\t\t\t// Map a list of chunks to a list of modules\n\t\t\t\t\t// For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\t\t\t\t\t/** @type {Map<string, ChunksInfoItem>} */\n\t\t\t\t\tconst chunksInfoMap = new Map();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {CacheGroup} cacheGroup the current cache group\n\t\t\t\t\t * @param {number} cacheGroupIndex the index of the cache group of ordering\n\t\t\t\t\t * @param {Chunk[]} selectedChunks chunks selected for this module\n\t\t\t\t\t * @param {bigint | Chunk} selectedChunksKey a key of selectedChunks\n\t\t\t\t\t * @param {Module} module the current module\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst addModuleToChunksInfoMap = (\n\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\tmodule\n\t\t\t\t\t) => {\n\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\tif (selectedChunks.length < cacheGroup.minChunks) return;\n\t\t\t\t\t\t// Determine name for split chunk\n\t\t\t\t\t\tconst name = cacheGroup.getName(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\tcacheGroup.key\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Check if the name is ok\n\t\t\t\t\t\tconst existingChunk = compilation.namedChunks.get(name);\n\t\t\t\t\t\tif (existingChunk) {\n\t\t\t\t\t\t\tconst parentValidationKey = `${name}|${\n\t\t\t\t\t\t\t\ttypeof selectedChunksKey === \"bigint\"\n\t\t\t\t\t\t\t\t\t? selectedChunksKey\n\t\t\t\t\t\t\t\t\t: selectedChunksKey.debugId\n\t\t\t\t\t\t\t}`;\n\t\t\t\t\t\t\tconst valid = alreadyValidatedParents.get(parentValidationKey);\n\t\t\t\t\t\t\tif (valid === false) return;\n\t\t\t\t\t\t\tif (valid === undefined) {\n\t\t\t\t\t\t\t\t// Module can only be moved into the existing chunk if the existing chunk\n\t\t\t\t\t\t\t\t// is a parent of all selected chunks\n\t\t\t\t\t\t\t\tlet isInAllParents = true;\n\t\t\t\t\t\t\t\t/** @type {Set<ChunkGroup>} */\n\t\t\t\t\t\t\t\tconst queue = new Set();\n\t\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\t\tfor (const group of chunk.groupsIterable) {\n\t\t\t\t\t\t\t\t\t\tqueue.add(group);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const group of queue) {\n\t\t\t\t\t\t\t\t\tif (existingChunk.isInGroup(group)) continue;\n\t\t\t\t\t\t\t\t\tlet hasParent = false;\n\t\t\t\t\t\t\t\t\tfor (const parent of group.parentsIterable) {\n\t\t\t\t\t\t\t\t\t\thasParent = true;\n\t\t\t\t\t\t\t\t\t\tqueue.add(parent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!hasParent) {\n\t\t\t\t\t\t\t\t\t\tisInAllParents = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst valid = isInAllParents;\n\t\t\t\t\t\t\t\talreadyValidatedParents.set(parentValidationKey, valid);\n\t\t\t\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\t\t\t\tif (!alreadyReportedErrors.has(name)) {\n\t\t\t\t\t\t\t\t\t\talreadyReportedErrors.add(name);\n\t\t\t\t\t\t\t\t\t\tcompilation.errors.push(\n\t\t\t\t\t\t\t\t\t\t\tnew WebpackError(\n\t\t\t\t\t\t\t\t\t\t\t\t\"SplitChunksPlugin\\n\" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t`Cache group \"${cacheGroup.key}\" conflicts with existing chunk.\\n` +\n\t\t\t\t\t\t\t\t\t\t\t\t\t`Both have the same name \"${name}\" and existing chunk is not a parent of the selected modules.\\n` +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Use a different name for the cache group or make sure that the existing chunk is a parent (e. g. via dependOn).\\n\" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t'HINT: You can omit \"name\" to automatically create a name.\\n' +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"BREAKING CHANGE: webpack < 5 used to allow to use an entrypoint as splitChunk. \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"This is no longer allowed when the entrypoint is not a parent of the selected modules.\\n\" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Remove this entrypoint and add modules to cache group's 'test' instead. \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"If you need modules to be evaluated on startup, add them to the existing entrypoints (make them arrays). \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"See migration guide of more info.\"\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Create key for maps\n\t\t\t\t\t\t// When it has a name we use the name as key\n\t\t\t\t\t\t// Otherwise we create the key from chunks and cache group key\n\t\t\t\t\t\t// This automatically merges equal names\n\t\t\t\t\t\tconst key =\n\t\t\t\t\t\t\tcacheGroup.key +\n\t\t\t\t\t\t\t(name\n\t\t\t\t\t\t\t\t? ` name:${name}`\n\t\t\t\t\t\t\t\t: ` chunks:${keyToString(selectedChunksKey)}`);\n\t\t\t\t\t\t// Add module to maps\n\t\t\t\t\t\tlet info = chunksInfoMap.get(key);\n\t\t\t\t\t\tif (info === undefined) {\n\t\t\t\t\t\t\tchunksInfoMap.set(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t(info = {\n\t\t\t\t\t\t\t\t\tmodules: new SortableSet(\n\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\tcompareModulesByIdentifier\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\tsizes: {},\n\t\t\t\t\t\t\t\t\tchunks: new Set(),\n\t\t\t\t\t\t\t\t\treuseableChunks: new Set(),\n\t\t\t\t\t\t\t\t\tchunksKeys: new Set()\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst oldSize = info.modules.size;\n\t\t\t\t\t\tinfo.modules.add(module);\n\t\t\t\t\t\tif (info.modules.size !== oldSize) {\n\t\t\t\t\t\t\tfor (const type of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\tinfo.sizes[type] = (info.sizes[type] || 0) + module.size(type);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst oldChunksKeysSize = info.chunksKeys.size;\n\t\t\t\t\t\tinfo.chunksKeys.add(selectedChunksKey);\n\t\t\t\t\t\tif (oldChunksKeysSize !== info.chunksKeys.size) {\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tinfo.chunks.add(chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tconst context = {\n\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\tchunkGraph\n\t\t\t\t\t};\n\n\t\t\t\t\tlogger.timeEnd(\"prepare\");\n\n\t\t\t\t\tlogger.time(\"modules\");\n\n\t\t\t\t\t// Walk through all modules\n\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t// Get cache group\n\t\t\t\t\t\tlet cacheGroups = this.options.getCacheGroups(module, context);\n\t\t\t\t\t\tif (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prepare some values (usedExports = false)\n\t\t\t\t\t\tconst getCombs = memoize(() => {\n\t\t\t\t\t\t\tconst chunks = chunkGraph.getModuleChunksIterable(module);\n\t\t\t\t\t\t\tconst chunksKey = getKey(chunks);\n\t\t\t\t\t\t\treturn getCombinations(chunksKey);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Prepare some values (usedExports = true)\n\t\t\t\t\t\tconst getCombsByUsedExports = memoize(() => {\n\t\t\t\t\t\t\t// fill the groupedByExportsMap\n\t\t\t\t\t\t\tgetExportsChunkSetsInGraph();\n\t\t\t\t\t\t\t/** @type {Set<Set<Chunk> | Chunk>} */\n\t\t\t\t\t\t\tconst set = new Set();\n\t\t\t\t\t\t\tconst groupedByUsedExports = groupedByExportsMap.get(module);\n\t\t\t\t\t\t\tfor (const chunks of groupedByUsedExports) {\n\t\t\t\t\t\t\t\tconst chunksKey = getKey(chunks);\n\t\t\t\t\t\t\t\tfor (const comb of getExportsCombinations(chunksKey))\n\t\t\t\t\t\t\t\t\tset.add(comb);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn set;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tlet cacheGroupIndex = 0;\n\t\t\t\t\t\tfor (const cacheGroupSource of cacheGroups) {\n\t\t\t\t\t\t\tconst cacheGroup = this._getCacheGroup(cacheGroupSource);\n\n\t\t\t\t\t\t\tconst combs = cacheGroup.usedExports\n\t\t\t\t\t\t\t\t? getCombsByUsedExports()\n\t\t\t\t\t\t\t\t: getCombs();\n\t\t\t\t\t\t\t// For all combination of chunk selection\n\t\t\t\t\t\t\tfor (const chunkCombination of combs) {\n\t\t\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\t\t\tconst count =\n\t\t\t\t\t\t\t\t\tchunkCombination instanceof Chunk ? 1 : chunkCombination.size;\n\t\t\t\t\t\t\t\tif (count < cacheGroup.minChunks) continue;\n\t\t\t\t\t\t\t\t// Select chunks by configuration\n\t\t\t\t\t\t\t\tconst { chunks: selectedChunks, key: selectedChunksKey } =\n\t\t\t\t\t\t\t\t\tgetSelectedChunks(chunkCombination, cacheGroup.chunksFilter);\n\n\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcacheGroupIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.timeEnd(\"modules\");\n\n\t\t\t\t\tlogger.time(\"queue\");\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {ChunksInfoItem} info entry\n\t\t\t\t\t * @param {string[]} sourceTypes source types to be removed\n\t\t\t\t\t */\n\t\t\t\t\tconst removeModulesWithSourceType = (info, sourceTypes) => {\n\t\t\t\t\t\tfor (const module of info.modules) {\n\t\t\t\t\t\t\tconst types = module.getSourceTypes();\n\t\t\t\t\t\t\tif (sourceTypes.some(type => types.has(type))) {\n\t\t\t\t\t\t\t\tinfo.modules.delete(module);\n\t\t\t\t\t\t\t\tfor (const type of types) {\n\t\t\t\t\t\t\t\t\tinfo.sizes[type] -= module.size(type);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {ChunksInfoItem} info entry\n\t\t\t\t\t * @returns {boolean} true, if entry become empty\n\t\t\t\t\t */\n\t\t\t\t\tconst removeMinSizeViolatingModules = info => {\n\t\t\t\t\t\tif (!info.cacheGroup._validateSize) return false;\n\t\t\t\t\t\tconst violatingSizes = getViolatingMinSizes(\n\t\t\t\t\t\t\tinfo.sizes,\n\t\t\t\t\t\t\tinfo.cacheGroup.minSize\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (violatingSizes === undefined) return false;\n\t\t\t\t\t\tremoveModulesWithSourceType(info, violatingSizes);\n\t\t\t\t\t\treturn info.modules.size === 0;\n\t\t\t\t\t};\n\n\t\t\t\t\t// Filter items were size < minSize\n\t\t\t\t\tfor (const [key, info] of chunksInfoMap) {\n\t\t\t\t\t\tif (removeMinSizeViolatingModules(info)) {\n\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t!checkMinSizeReduction(\n\t\t\t\t\t\t\t\tinfo.sizes,\n\t\t\t\t\t\t\t\tinfo.cacheGroup.minSizeReduction,\n\t\t\t\t\t\t\t\tinfo.chunks.size\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} MaxSizeQueueItem\n\t\t\t\t\t * @property {SplitChunksSizes} minSize\n\t\t\t\t\t * @property {SplitChunksSizes} maxAsyncSize\n\t\t\t\t\t * @property {SplitChunksSizes} maxInitialSize\n\t\t\t\t\t * @property {string} automaticNameDelimiter\n\t\t\t\t\t * @property {string[]} keys\n\t\t\t\t\t */\n\n\t\t\t\t\t/** @type {Map<Chunk, MaxSizeQueueItem>} */\n\t\t\t\t\tconst maxSizeQueueMap = new Map();\n\n\t\t\t\t\twhile (chunksInfoMap.size > 0) {\n\t\t\t\t\t\t// Find best matching entry\n\t\t\t\t\t\tlet bestEntryKey;\n\t\t\t\t\t\tlet bestEntry;\n\t\t\t\t\t\tfor (const pair of chunksInfoMap) {\n\t\t\t\t\t\t\tconst key = pair[0];\n\t\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tbestEntry === undefined ||\n\t\t\t\t\t\t\t\tcompareEntries(bestEntry, info) < 0\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tbestEntry = info;\n\t\t\t\t\t\t\t\tbestEntryKey = key;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst item = bestEntry;\n\t\t\t\t\t\tchunksInfoMap.delete(bestEntryKey);\n\n\t\t\t\t\t\tlet chunkName = item.name;\n\t\t\t\t\t\t// Variable for the new chunk (lazy created)\n\t\t\t\t\t\t/** @type {Chunk} */\n\t\t\t\t\t\tlet newChunk;\n\t\t\t\t\t\t// When no chunk name, check if we can reuse a chunk instead of creating a new one\n\t\t\t\t\t\tlet isExistingChunk = false;\n\t\t\t\t\t\tlet isReusedWithAllModules = false;\n\t\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\t\tconst chunkByName = compilation.namedChunks.get(chunkName);\n\t\t\t\t\t\t\tif (chunkByName !== undefined) {\n\t\t\t\t\t\t\t\tnewChunk = chunkByName;\n\t\t\t\t\t\t\t\tconst oldSize = item.chunks.size;\n\t\t\t\t\t\t\t\titem.chunks.delete(newChunk);\n\t\t\t\t\t\t\t\tisExistingChunk = item.chunks.size !== oldSize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (item.cacheGroup.reuseExistingChunk) {\n\t\t\t\t\t\t\touter: for (const chunk of item.chunks) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(chunk) !==\n\t\t\t\t\t\t\t\t\titem.modules.size\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\titem.chunks.size > 1 &&\n\t\t\t\t\t\t\t\t\tchunkGraph.getNumberOfEntryModules(chunk) > 0\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tif (!chunkGraph.isModuleInChunk(module, chunk)) {\n\t\t\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!newChunk || !newChunk.name) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length < newChunk.name.length\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length === newChunk.name.length &&\n\t\t\t\t\t\t\t\t\tchunk.name < newChunk.name\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (newChunk) {\n\t\t\t\t\t\t\t\titem.chunks.delete(newChunk);\n\t\t\t\t\t\t\t\tchunkName = undefined;\n\t\t\t\t\t\t\t\tisExistingChunk = true;\n\t\t\t\t\t\t\t\tisReusedWithAllModules = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst enforced =\n\t\t\t\t\t\t\titem.cacheGroup._conditionalEnforce &&\n\t\t\t\t\t\t\tcheckMinSize(item.sizes, item.cacheGroup.enforceSizeThreshold);\n\n\t\t\t\t\t\tconst usedChunks = new Set(item.chunks);\n\n\t\t\t\t\t\t// Check if maxRequests condition can be fulfilled\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!enforced &&\n\t\t\t\t\t\t\t(Number.isFinite(item.cacheGroup.maxInitialRequests) ||\n\t\t\t\t\t\t\t\tNumber.isFinite(item.cacheGroup.maxAsyncRequests))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t// respect max requests\n\t\t\t\t\t\t\t\tconst maxRequests = chunk.isOnlyInitial()\n\t\t\t\t\t\t\t\t\t? item.cacheGroup.maxInitialRequests\n\t\t\t\t\t\t\t\t\t: chunk.canBeInitial()\n\t\t\t\t\t\t\t\t\t? Math.min(\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxInitialRequests,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxAsyncRequests\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxAsyncRequests;\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tisFinite(maxRequests) &&\n\t\t\t\t\t\t\t\t\tgetRequests(chunk) >= maxRequests\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tusedChunks.delete(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\touter: for (const chunk of usedChunks) {\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (chunkGraph.isModuleInChunk(module, chunk)) continue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tusedChunks.delete(chunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Were some (invalid) chunks removed from usedChunks?\n\t\t\t\t\t\t// => readd all modules to the queue, as things could have been changed\n\t\t\t\t\t\tif (usedChunks.size < item.chunks.size) {\n\t\t\t\t\t\t\tif (isExistingChunk) usedChunks.add(newChunk);\n\t\t\t\t\t\t\tif (usedChunks.size >= item.cacheGroup.minChunks) {\n\t\t\t\t\t\t\t\tconst chunksArr = Array.from(usedChunks);\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\t\titem.cacheGroup,\n\t\t\t\t\t\t\t\t\t\titem.cacheGroupIndex,\n\t\t\t\t\t\t\t\t\t\tchunksArr,\n\t\t\t\t\t\t\t\t\t\tgetKey(usedChunks),\n\t\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Validate minRemainingSize constraint when a single chunk is left over\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!enforced &&\n\t\t\t\t\t\t\titem.cacheGroup._validateRemainingSize &&\n\t\t\t\t\t\t\tusedChunks.size === 1\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst [chunk] = usedChunks;\n\t\t\t\t\t\t\tlet chunkSizes = Object.create(null);\n\t\t\t\t\t\t\tfor (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\t\t\t\t\tif (!item.modules.has(module)) {\n\t\t\t\t\t\t\t\t\tfor (const type of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\t\t\tchunkSizes[type] =\n\t\t\t\t\t\t\t\t\t\t\t(chunkSizes[type] || 0) + module.size(type);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst violatingSizes = getViolatingMinSizes(\n\t\t\t\t\t\t\t\tchunkSizes,\n\t\t\t\t\t\t\t\titem.cacheGroup.minRemainingSize\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (violatingSizes !== undefined) {\n\t\t\t\t\t\t\t\tconst oldModulesSize = item.modules.size;\n\t\t\t\t\t\t\t\tremoveModulesWithSourceType(item, violatingSizes);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\titem.modules.size > 0 &&\n\t\t\t\t\t\t\t\t\titem.modules.size !== oldModulesSize\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t// queue this item again to be processed again\n\t\t\t\t\t\t\t\t\t// without violating modules\n\t\t\t\t\t\t\t\t\tchunksInfoMap.set(bestEntryKey, item);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Create the new chunk if not reusing one\n\t\t\t\t\t\tif (newChunk === undefined) {\n\t\t\t\t\t\t\tnewChunk = compilation.addChunk(chunkName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Walk through all chunks\n\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t// Add graph connections for splitted chunk\n\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add a note to the chunk\n\t\t\t\t\t\tnewChunk.chunkReason =\n\t\t\t\t\t\t\t(newChunk.chunkReason ? newChunk.chunkReason + \", \" : \"\") +\n\t\t\t\t\t\t\t(isReusedWithAllModules\n\t\t\t\t\t\t\t\t? \"reused as split chunk\"\n\t\t\t\t\t\t\t\t: \"split chunk\");\n\t\t\t\t\t\tif (item.cacheGroup.key) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (name: ${chunkName})`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (item.cacheGroup.filename) {\n\t\t\t\t\t\t\tnewChunk.filenameTemplate = item.cacheGroup.filename;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (item.cacheGroup.idHint) {\n\t\t\t\t\t\t\tnewChunk.idNameHints.add(item.cacheGroup.idHint);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!isReusedWithAllModules) {\n\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (!module.chunkCondition(newChunk, compilation)) continue;\n\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\tchunkGraph.connectChunkAndModule(newChunk, module);\n\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Remove all modules from used chunks\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tObject.keys(item.cacheGroup.maxAsyncSize).length > 0 ||\n\t\t\t\t\t\t\tObject.keys(item.cacheGroup.maxInitialSize).length > 0\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n\t\t\t\t\t\t\tmaxSizeQueueMap.set(newChunk, {\n\t\t\t\t\t\t\t\tminSize: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? combineSizes(\n\t\t\t\t\t\t\t\t\t\t\toldMaxSizeSettings.minSize,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup._minSizeForMaxSize,\n\t\t\t\t\t\t\t\t\t\t\tMath.max\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.minSize,\n\t\t\t\t\t\t\t\tmaxAsyncSize: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? combineSizes(\n\t\t\t\t\t\t\t\t\t\t\toldMaxSizeSettings.maxAsyncSize,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxAsyncSize,\n\t\t\t\t\t\t\t\t\t\t\tMath.min\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxAsyncSize,\n\t\t\t\t\t\t\t\tmaxInitialSize: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? combineSizes(\n\t\t\t\t\t\t\t\t\t\t\toldMaxSizeSettings.maxInitialSize,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxInitialSize,\n\t\t\t\t\t\t\t\t\t\t\tMath.min\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxInitialSize,\n\t\t\t\t\t\t\t\tautomaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n\t\t\t\t\t\t\t\tkeys: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? oldMaxSizeSettings.keys.concat(item.cacheGroup.key)\n\t\t\t\t\t\t\t\t\t: [item.cacheGroup.key]\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// remove all modules from other entries and update size\n\t\t\t\t\t\tfor (const [key, info] of chunksInfoMap) {\n\t\t\t\t\t\t\tif (isOverlap(info.chunks, usedChunks)) {\n\t\t\t\t\t\t\t\t// update modules and total size\n\t\t\t\t\t\t\t\t// may remove it from the map when < minSize\n\t\t\t\t\t\t\t\tlet updated = false;\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tif (info.modules.has(module)) {\n\t\t\t\t\t\t\t\t\t\t// remove module\n\t\t\t\t\t\t\t\t\t\tinfo.modules.delete(module);\n\t\t\t\t\t\t\t\t\t\t// update size\n\t\t\t\t\t\t\t\t\t\tfor (const key of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\t\t\t\tinfo.sizes[key] -= module.size(key);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (updated) {\n\t\t\t\t\t\t\t\t\tif (info.modules.size === 0) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tremoveMinSizeViolatingModules(info) ||\n\t\t\t\t\t\t\t\t\t\t!checkMinSizeReduction(\n\t\t\t\t\t\t\t\t\t\t\tinfo.sizes,\n\t\t\t\t\t\t\t\t\t\t\tinfo.cacheGroup.minSizeReduction,\n\t\t\t\t\t\t\t\t\t\t\tinfo.chunks.size\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.timeEnd(\"queue\");\n\n\t\t\t\t\tlogger.time(\"maxSize\");\n\n\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\tconst incorrectMinMaxSizeSet = new Set();\n\n\t\t\t\t\tconst { outputOptions } = compilation;\n\n\t\t\t\t\t// Make sure that maxSize is fulfilled\n\t\t\t\t\tconst { fallbackCacheGroup } = this.options;\n\t\t\t\t\tfor (const chunk of Array.from(compilation.chunks)) {\n\t\t\t\t\t\tconst chunkConfig = maxSizeQueueMap.get(chunk);\n\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\tmaxAsyncSize,\n\t\t\t\t\t\t\tmaxInitialSize,\n\t\t\t\t\t\t\tautomaticNameDelimiter\n\t\t\t\t\t\t} = chunkConfig || fallbackCacheGroup;\n\t\t\t\t\t\tif (!chunkConfig && !fallbackCacheGroup.chunksFilter(chunk))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t/** @type {SplitChunksSizes} */\n\t\t\t\t\t\tlet maxSize;\n\t\t\t\t\t\tif (chunk.isOnlyInitial()) {\n\t\t\t\t\t\t\tmaxSize = maxInitialSize;\n\t\t\t\t\t\t} else if (chunk.canBeInitial()) {\n\t\t\t\t\t\t\tmaxSize = combineSizes(maxAsyncSize, maxInitialSize, Math.min);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmaxSize = maxAsyncSize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (Object.keys(maxSize).length === 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const key of Object.keys(maxSize)) {\n\t\t\t\t\t\t\tconst maxSizeValue = maxSize[key];\n\t\t\t\t\t\t\tconst minSizeValue = minSize[key];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\ttypeof minSizeValue === \"number\" &&\n\t\t\t\t\t\t\t\tminSizeValue > maxSizeValue\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst keys = chunkConfig && chunkConfig.keys;\n\t\t\t\t\t\t\t\tconst warningKey = `${\n\t\t\t\t\t\t\t\t\tkeys && keys.join()\n\t\t\t\t\t\t\t\t} ${minSizeValue} ${maxSizeValue}`;\n\t\t\t\t\t\t\t\tif (!incorrectMinMaxSizeSet.has(warningKey)) {\n\t\t\t\t\t\t\t\t\tincorrectMinMaxSizeSet.add(warningKey);\n\t\t\t\t\t\t\t\t\tcompilation.warnings.push(\n\t\t\t\t\t\t\t\t\t\tnew MinMaxSizeWarning(keys, minSizeValue, maxSizeValue)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst results = deterministicGroupingForModules({\n\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\tmaxSize: mapObject(maxSize, (value, key) => {\n\t\t\t\t\t\t\t\tconst minSizeValue = minSize[key];\n\t\t\t\t\t\t\t\treturn typeof minSizeValue === \"number\"\n\t\t\t\t\t\t\t\t\t? Math.max(value, minSizeValue)\n\t\t\t\t\t\t\t\t\t: value;\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\titems: chunkGraph.getChunkModulesIterable(chunk),\n\t\t\t\t\t\t\tgetKey(module) {\n\t\t\t\t\t\t\t\tconst cache = getKeyCache.get(module);\n\t\t\t\t\t\t\t\tif (cache !== undefined) return cache;\n\t\t\t\t\t\t\t\tconst ident = cachedMakePathsRelative(module.identifier());\n\t\t\t\t\t\t\t\tconst nameForCondition =\n\t\t\t\t\t\t\t\t\tmodule.nameForCondition && module.nameForCondition();\n\t\t\t\t\t\t\t\tconst name = nameForCondition\n\t\t\t\t\t\t\t\t\t? cachedMakePathsRelative(nameForCondition)\n\t\t\t\t\t\t\t\t\t: ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n\t\t\t\t\t\t\t\tconst fullKey =\n\t\t\t\t\t\t\t\t\tname +\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\t\t\t\thashFilename(ident, outputOptions);\n\t\t\t\t\t\t\t\tconst key = requestToId(fullKey);\n\t\t\t\t\t\t\t\tgetKeyCache.set(module, key);\n\t\t\t\t\t\t\t\treturn key;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgetSize(module) {\n\t\t\t\t\t\t\t\tconst size = Object.create(null);\n\t\t\t\t\t\t\t\tfor (const key of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\t\tsize[key] = module.size(key);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn size;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (results.length <= 1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\t\t\t\t\tconst group = results[i];\n\t\t\t\t\t\t\tconst key = this.options.hidePathInfo\n\t\t\t\t\t\t\t\t? hashFilename(group.key, outputOptions)\n\t\t\t\t\t\t\t\t: group.key;\n\t\t\t\t\t\t\tlet name = chunk.name\n\t\t\t\t\t\t\t\t? chunk.name + automaticNameDelimiter + key\n\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\tif (name && name.length > 100) {\n\t\t\t\t\t\t\t\tname =\n\t\t\t\t\t\t\t\t\tname.slice(0, 100) +\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\t\t\t\thashFilename(name, outputOptions);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i !== results.length - 1) {\n\t\t\t\t\t\t\t\tconst newPart = compilation.addChunk(name);\n\t\t\t\t\t\t\t\tchunk.split(newPart);\n\t\t\t\t\t\t\t\tnewPart.chunkReason = chunk.chunkReason;\n\t\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\t\tfor (const module of group.items) {\n\t\t\t\t\t\t\t\t\tif (!module.chunkCondition(newPart, compilation)) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\t\tchunkGraph.connectChunkAndModule(newPart, module);\n\t\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// change the chunk to be a part\n\t\t\t\t\t\t\t\tchunk.name = name;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"maxSize\");\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}