{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _require = require(\"./util/comparators\"),\n  compareNumbers = _require.compareNumbers;\nvar identifierUtils = require(\"./util/identifier\");\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} RecordsChunks\n * @property {Record<string, number>=} byName\n * @property {Record<string, number>=} bySource\n * @property {number[]=} usedIds\n */\n\n/**\n * @typedef {Object} RecordsModules\n * @property {Record<string, number>=} byIdentifier\n * @property {Record<string, number>=} bySource\n * @property {number[]=} usedIds\n */\n\n/**\n * @typedef {Object} Records\n * @property {RecordsChunks=} chunks\n * @property {RecordsModules=} modules\n */\nvar RecordIdsPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {Object} options Options object\n   * @param {boolean=} options.portableIds true, when ids need to be portable\n   */\n  function RecordIdsPlugin(options) {\n    _classCallCheck(this, RecordIdsPlugin);\n    this.options = options || {};\n  }\n\n  /**\n   * @param {Compiler} compiler the Compiler\n   * @returns {void}\n   */\n  _createClass(RecordIdsPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var portableIds = this.options.portableIds;\n      var makePathsRelative = identifierUtils.makePathsRelative.bindContextCache(compiler.context, compiler.root);\n\n      /**\n       * @param {Module} module the module\n       * @returns {string} the (portable) identifier\n       */\n      var getModuleIdentifier = function getModuleIdentifier(module) {\n        if (portableIds) {\n          return makePathsRelative(module.identifier());\n        }\n        return module.identifier();\n      };\n      compiler.hooks.compilation.tap(\"RecordIdsPlugin\", function (compilation) {\n        compilation.hooks.recordModules.tap(\"RecordIdsPlugin\",\n        /**\n         * @param {Module[]} modules the modules array\n         * @param {Records} records the records object\n         * @returns {void}\n         */\n        function (modules, records) {\n          var chunkGraph = compilation.chunkGraph;\n          if (!records.modules) records.modules = {};\n          if (!records.modules.byIdentifier) records.modules.byIdentifier = {};\n          /** @type {Set<number>} */\n          var usedIds = new Set();\n          var _iterator = _createForOfIteratorHelper(modules),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _module = _step.value;\n              var moduleId = chunkGraph.getModuleId(_module);\n              if (typeof moduleId !== \"number\") continue;\n              var identifier = getModuleIdentifier(_module);\n              records.modules.byIdentifier[identifier] = moduleId;\n              usedIds.add(moduleId);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          records.modules.usedIds = Array.from(usedIds).sort(compareNumbers);\n        });\n        compilation.hooks.reviveModules.tap(\"RecordIdsPlugin\",\n        /**\n         * @param {Module[]} modules the modules array\n         * @param {Records} records the records object\n         * @returns {void}\n         */\n        function (modules, records) {\n          if (!records.modules) return;\n          if (records.modules.byIdentifier) {\n            var chunkGraph = compilation.chunkGraph;\n            /** @type {Set<number>} */\n            var usedIds = new Set();\n            var _iterator2 = _createForOfIteratorHelper(modules),\n              _step2;\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var _module2 = _step2.value;\n                var moduleId = chunkGraph.getModuleId(_module2);\n                if (moduleId !== null) continue;\n                var identifier = getModuleIdentifier(_module2);\n                var id = records.modules.byIdentifier[identifier];\n                if (id === undefined) continue;\n                if (usedIds.has(id)) continue;\n                usedIds.add(id);\n                chunkGraph.setModuleId(_module2, id);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          }\n          if (Array.isArray(records.modules.usedIds)) {\n            compilation.usedModuleIds = new Set(records.modules.usedIds);\n          }\n        });\n\n        /**\n         * @param {Chunk} chunk the chunk\n         * @returns {string[]} sources of the chunk\n         */\n        var getChunkSources = function getChunkSources(chunk) {\n          /** @type {string[]} */\n          var sources = [];\n          var _iterator3 = _createForOfIteratorHelper(chunk.groupsIterable),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var chunkGroup = _step3.value;\n              var index = chunkGroup.chunks.indexOf(chunk);\n              if (chunkGroup.name) {\n                sources.push(\"\".concat(index, \" \").concat(chunkGroup.name));\n              } else {\n                var _iterator4 = _createForOfIteratorHelper(chunkGroup.origins),\n                  _step4;\n                try {\n                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                    var origin = _step4.value;\n                    if (origin.module) {\n                      if (origin.request) {\n                        sources.push(\"\".concat(index, \" \").concat(getModuleIdentifier(origin.module), \" \").concat(origin.request));\n                      } else if (typeof origin.loc === \"string\") {\n                        sources.push(\"\".concat(index, \" \").concat(getModuleIdentifier(origin.module), \" \").concat(origin.loc));\n                      } else if (origin.loc && typeof origin.loc === \"object\" && \"start\" in origin.loc) {\n                        sources.push(\"\".concat(index, \" \").concat(getModuleIdentifier(origin.module), \" \").concat(JSON.stringify(origin.loc.start)));\n                      }\n                    }\n                  }\n                } catch (err) {\n                  _iterator4.e(err);\n                } finally {\n                  _iterator4.f();\n                }\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          return sources;\n        };\n        compilation.hooks.recordChunks.tap(\"RecordIdsPlugin\",\n        /**\n         * @param {Chunk[]} chunks the chunks array\n         * @param {Records} records the records object\n         * @returns {void}\n         */\n        function (chunks, records) {\n          if (!records.chunks) records.chunks = {};\n          if (!records.chunks.byName) records.chunks.byName = {};\n          if (!records.chunks.bySource) records.chunks.bySource = {};\n          /** @type {Set<number>} */\n          var usedIds = new Set();\n          var _iterator5 = _createForOfIteratorHelper(chunks),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var chunk = _step5.value;\n              if (typeof chunk.id !== \"number\") continue;\n              var name = chunk.name;\n              if (name) records.chunks.byName[name] = chunk.id;\n              var sources = getChunkSources(chunk);\n              var _iterator6 = _createForOfIteratorHelper(sources),\n                _step6;\n              try {\n                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                  var source = _step6.value;\n                  records.chunks.bySource[source] = chunk.id;\n                }\n              } catch (err) {\n                _iterator6.e(err);\n              } finally {\n                _iterator6.f();\n              }\n              usedIds.add(chunk.id);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n          records.chunks.usedIds = Array.from(usedIds).sort(compareNumbers);\n        });\n        compilation.hooks.reviveChunks.tap(\"RecordIdsPlugin\",\n        /**\n         * @param {Chunk[]} chunks the chunks array\n         * @param {Records} records the records object\n         * @returns {void}\n         */\n        function (chunks, records) {\n          if (!records.chunks) return;\n          /** @type {Set<number>} */\n          var usedIds = new Set();\n          if (records.chunks.byName) {\n            var _iterator7 = _createForOfIteratorHelper(chunks),\n              _step7;\n            try {\n              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                var chunk = _step7.value;\n                if (chunk.id !== null) continue;\n                if (!chunk.name) continue;\n                var id = records.chunks.byName[chunk.name];\n                if (id === undefined) continue;\n                if (usedIds.has(id)) continue;\n                usedIds.add(id);\n                chunk.id = id;\n                chunk.ids = [id];\n              }\n            } catch (err) {\n              _iterator7.e(err);\n            } finally {\n              _iterator7.f();\n            }\n          }\n          if (records.chunks.bySource) {\n            var _iterator8 = _createForOfIteratorHelper(chunks),\n              _step8;\n            try {\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                var _chunk = _step8.value;\n                if (_chunk.id !== null) continue;\n                var sources = getChunkSources(_chunk);\n                var _iterator9 = _createForOfIteratorHelper(sources),\n                  _step9;\n                try {\n                  for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                    var source = _step9.value;\n                    var _id = records.chunks.bySource[source];\n                    if (_id === undefined) continue;\n                    if (usedIds.has(_id)) continue;\n                    usedIds.add(_id);\n                    _chunk.id = _id;\n                    _chunk.ids = [_id];\n                    break;\n                  }\n                } catch (err) {\n                  _iterator9.e(err);\n                } finally {\n                  _iterator9.f();\n                }\n              }\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n          }\n          if (Array.isArray(records.chunks.usedIds)) {\n            compilation.usedChunkIds = new Set(records.chunks.usedIds);\n          }\n        });\n      });\n    }\n  }]);\n  return RecordIdsPlugin;\n}();\nmodule.exports = RecordIdsPlugin;","map":{"version":3,"names":["require","compareNumbers","identifierUtils","RecordIdsPlugin","options","compiler","portableIds","makePathsRelative","bindContextCache","context","root","getModuleIdentifier","module","identifier","hooks","compilation","tap","recordModules","modules","records","chunkGraph","byIdentifier","usedIds","Set","moduleId","getModuleId","add","Array","from","sort","reviveModules","id","undefined","has","setModuleId","isArray","usedModuleIds","getChunkSources","chunk","sources","groupsIterable","chunkGroup","index","chunks","indexOf","name","push","origins","origin","request","loc","JSON","stringify","start","recordChunks","byName","bySource","source","reviveChunks","ids","usedChunkIds","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/RecordIdsPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { compareNumbers } = require(\"./util/comparators\");\nconst identifierUtils = require(\"./util/identifier\");\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} RecordsChunks\n * @property {Record<string, number>=} byName\n * @property {Record<string, number>=} bySource\n * @property {number[]=} usedIds\n */\n\n/**\n * @typedef {Object} RecordsModules\n * @property {Record<string, number>=} byIdentifier\n * @property {Record<string, number>=} bySource\n * @property {number[]=} usedIds\n */\n\n/**\n * @typedef {Object} Records\n * @property {RecordsChunks=} chunks\n * @property {RecordsModules=} modules\n */\n\nclass RecordIdsPlugin {\n\t/**\n\t * @param {Object} options Options object\n\t * @param {boolean=} options.portableIds true, when ids need to be portable\n\t */\n\tconstructor(options) {\n\t\tthis.options = options || {};\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the Compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst portableIds = this.options.portableIds;\n\n\t\tconst makePathsRelative =\n\t\t\tidentifierUtils.makePathsRelative.bindContextCache(\n\t\t\t\tcompiler.context,\n\t\t\t\tcompiler.root\n\t\t\t);\n\n\t\t/**\n\t\t * @param {Module} module the module\n\t\t * @returns {string} the (portable) identifier\n\t\t */\n\t\tconst getModuleIdentifier = module => {\n\t\t\tif (portableIds) {\n\t\t\t\treturn makePathsRelative(module.identifier());\n\t\t\t}\n\t\t\treturn module.identifier();\n\t\t};\n\n\t\tcompiler.hooks.compilation.tap(\"RecordIdsPlugin\", compilation => {\n\t\t\tcompilation.hooks.recordModules.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Module[]} modules the modules array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(modules, records) => {\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tif (!records.modules) records.modules = {};\n\t\t\t\t\tif (!records.modules.byIdentifier) records.modules.byIdentifier = {};\n\t\t\t\t\t/** @type {Set<number>} */\n\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tconst moduleId = chunkGraph.getModuleId(module);\n\t\t\t\t\t\tif (typeof moduleId !== \"number\") continue;\n\t\t\t\t\t\tconst identifier = getModuleIdentifier(module);\n\t\t\t\t\t\trecords.modules.byIdentifier[identifier] = moduleId;\n\t\t\t\t\t\tusedIds.add(moduleId);\n\t\t\t\t\t}\n\t\t\t\t\trecords.modules.usedIds = Array.from(usedIds).sort(compareNumbers);\n\t\t\t\t}\n\t\t\t);\n\t\t\tcompilation.hooks.reviveModules.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Module[]} modules the modules array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(modules, records) => {\n\t\t\t\t\tif (!records.modules) return;\n\t\t\t\t\tif (records.modules.byIdentifier) {\n\t\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\t\t/** @type {Set<number>} */\n\t\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\tconst moduleId = chunkGraph.getModuleId(module);\n\t\t\t\t\t\t\tif (moduleId !== null) continue;\n\t\t\t\t\t\t\tconst identifier = getModuleIdentifier(module);\n\t\t\t\t\t\t\tconst id = records.modules.byIdentifier[identifier];\n\t\t\t\t\t\t\tif (id === undefined) continue;\n\t\t\t\t\t\t\tif (usedIds.has(id)) continue;\n\t\t\t\t\t\t\tusedIds.add(id);\n\t\t\t\t\t\t\tchunkGraph.setModuleId(module, id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Array.isArray(records.modules.usedIds)) {\n\t\t\t\t\t\tcompilation.usedModuleIds = new Set(records.modules.usedIds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t/**\n\t\t\t * @param {Chunk} chunk the chunk\n\t\t\t * @returns {string[]} sources of the chunk\n\t\t\t */\n\t\t\tconst getChunkSources = chunk => {\n\t\t\t\t/** @type {string[]} */\n\t\t\t\tconst sources = [];\n\t\t\t\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\t\t\t\tconst index = chunkGroup.chunks.indexOf(chunk);\n\t\t\t\t\tif (chunkGroup.name) {\n\t\t\t\t\t\tsources.push(`${index} ${chunkGroup.name}`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const origin of chunkGroup.origins) {\n\t\t\t\t\t\t\tif (origin.module) {\n\t\t\t\t\t\t\t\tif (origin.request) {\n\t\t\t\t\t\t\t\t\tsources.push(\n\t\t\t\t\t\t\t\t\t\t`${index} ${getModuleIdentifier(origin.module)} ${\n\t\t\t\t\t\t\t\t\t\t\torigin.request\n\t\t\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else if (typeof origin.loc === \"string\") {\n\t\t\t\t\t\t\t\t\tsources.push(\n\t\t\t\t\t\t\t\t\t\t`${index} ${getModuleIdentifier(origin.module)} ${\n\t\t\t\t\t\t\t\t\t\t\torigin.loc\n\t\t\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\torigin.loc &&\n\t\t\t\t\t\t\t\t\ttypeof origin.loc === \"object\" &&\n\t\t\t\t\t\t\t\t\t\"start\" in origin.loc\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tsources.push(\n\t\t\t\t\t\t\t\t\t\t`${index} ${getModuleIdentifier(\n\t\t\t\t\t\t\t\t\t\t\torigin.module\n\t\t\t\t\t\t\t\t\t\t)} ${JSON.stringify(origin.loc.start)}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sources;\n\t\t\t};\n\n\t\t\tcompilation.hooks.recordChunks.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Chunk[]} chunks the chunks array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(chunks, records) => {\n\t\t\t\t\tif (!records.chunks) records.chunks = {};\n\t\t\t\t\tif (!records.chunks.byName) records.chunks.byName = {};\n\t\t\t\t\tif (!records.chunks.bySource) records.chunks.bySource = {};\n\t\t\t\t\t/** @type {Set<number>} */\n\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\tif (typeof chunk.id !== \"number\") continue;\n\t\t\t\t\t\tconst name = chunk.name;\n\t\t\t\t\t\tif (name) records.chunks.byName[name] = chunk.id;\n\t\t\t\t\t\tconst sources = getChunkSources(chunk);\n\t\t\t\t\t\tfor (const source of sources) {\n\t\t\t\t\t\t\trecords.chunks.bySource[source] = chunk.id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tusedIds.add(chunk.id);\n\t\t\t\t\t}\n\t\t\t\t\trecords.chunks.usedIds = Array.from(usedIds).sort(compareNumbers);\n\t\t\t\t}\n\t\t\t);\n\t\t\tcompilation.hooks.reviveChunks.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Chunk[]} chunks the chunks array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(chunks, records) => {\n\t\t\t\t\tif (!records.chunks) return;\n\t\t\t\t\t/** @type {Set<number>} */\n\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\tif (records.chunks.byName) {\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tif (chunk.id !== null) continue;\n\t\t\t\t\t\t\tif (!chunk.name) continue;\n\t\t\t\t\t\t\tconst id = records.chunks.byName[chunk.name];\n\t\t\t\t\t\t\tif (id === undefined) continue;\n\t\t\t\t\t\t\tif (usedIds.has(id)) continue;\n\t\t\t\t\t\t\tusedIds.add(id);\n\t\t\t\t\t\t\tchunk.id = id;\n\t\t\t\t\t\t\tchunk.ids = [id];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (records.chunks.bySource) {\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tif (chunk.id !== null) continue;\n\t\t\t\t\t\t\tconst sources = getChunkSources(chunk);\n\t\t\t\t\t\t\tfor (const source of sources) {\n\t\t\t\t\t\t\t\tconst id = records.chunks.bySource[source];\n\t\t\t\t\t\t\t\tif (id === undefined) continue;\n\t\t\t\t\t\t\t\tif (usedIds.has(id)) continue;\n\t\t\t\t\t\t\t\tusedIds.add(id);\n\t\t\t\t\t\t\t\tchunk.id = id;\n\t\t\t\t\t\t\t\tchunk.ids = [id];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Array.isArray(records.chunks.usedIds)) {\n\t\t\t\t\t\tcompilation.usedChunkIds = new Set(records.chunks.usedIds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = RecordIdsPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}