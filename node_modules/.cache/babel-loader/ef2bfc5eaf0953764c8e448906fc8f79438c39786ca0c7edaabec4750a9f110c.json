{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _require = require(\"../ExportsInfo\"),\n  UsageState = _require.UsageState;\nvar _require2 = require(\"../Template\"),\n  numberToIdentifier = _require2.numberToIdentifier,\n  NUMBER_OF_IDENTIFIER_START_CHARS = _require2.NUMBER_OF_IDENTIFIER_START_CHARS,\n  NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS = _require2.NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS;\nvar _require3 = require(\"../ids/IdHelpers\"),\n  assignDeterministicIds = _require3.assignDeterministicIds;\nvar _require4 = require(\"../util/comparators\"),\n  compareSelect = _require4.compareSelect,\n  compareStringsNumeric = _require4.compareStringsNumeric;\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"../ExportsInfo\").ExportInfo} ExportInfo */\n\n/**\n * @param {ExportsInfo} exportsInfo exports info\n * @returns {boolean} mangle is possible\n */\nvar canMangle = function canMangle(exportsInfo) {\n  if (exportsInfo.otherExportsInfo.getUsed(undefined) !== UsageState.Unused) return false;\n  var hasSomethingToMangle = false;\n  var _iterator = _createForOfIteratorHelper(exportsInfo.exports),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var exportInfo = _step.value;\n      if (exportInfo.canMangle === true) {\n        hasSomethingToMangle = true;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return hasSomethingToMangle;\n};\n\n// Sort by name\nvar comparator = compareSelect(function (e) {\n  return e.name;\n}, compareStringsNumeric);\n/**\n * @param {boolean} deterministic use deterministic names\n * @param {ExportsInfo} exportsInfo exports info\n * @param {boolean} isNamespace is namespace object\n * @returns {void}\n */\nvar mangleExportsInfo = function mangleExportsInfo(deterministic, exportsInfo, isNamespace) {\n  if (!canMangle(exportsInfo)) return;\n  var usedNames = new Set();\n  /** @type {ExportInfo[]} */\n  var mangleableExports = [];\n\n  // Avoid to renamed exports that are not provided when\n  // 1. it's not a namespace export: non-provided exports can be found in prototype chain\n  // 2. there are other provided exports and deterministic mode is chosen:\n  //    non-provided exports would break the determinism\n  var avoidMangleNonProvided = !isNamespace;\n  if (!avoidMangleNonProvided && deterministic) {\n    var _iterator2 = _createForOfIteratorHelper(exportsInfo.ownedExports),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var exportInfo = _step2.value;\n        if (exportInfo.provided !== false) {\n          avoidMangleNonProvided = true;\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n  var _iterator3 = _createForOfIteratorHelper(exportsInfo.ownedExports),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _exportInfo3 = _step3.value;\n      var _name = _exportInfo3.name;\n      if (!_exportInfo3.hasUsedName()) {\n        if (\n        // Can the export be mangled?\n        _exportInfo3.canMangle !== true ||\n        // Never rename 1 char exports\n        _name.length === 1 && /^[a-zA-Z0-9_$]/.test(_name) ||\n        // Don't rename 2 char exports in deterministic mode\n        deterministic && _name.length === 2 && /^[a-zA-Z_$][a-zA-Z0-9_$]|^[1-9][0-9]/.test(_name) ||\n        // Don't rename exports that are not provided\n        avoidMangleNonProvided && _exportInfo3.provided !== true) {\n          _exportInfo3.setUsedName(_name);\n          usedNames.add(_name);\n        } else {\n          mangleableExports.push(_exportInfo3);\n        }\n      }\n      if (_exportInfo3.exportsInfoOwned) {\n        var used = _exportInfo3.getUsed(undefined);\n        if (used === UsageState.OnlyPropertiesUsed || used === UsageState.Unused) {\n          mangleExportsInfo(deterministic, _exportInfo3.exportsInfo, false);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  if (deterministic) {\n    assignDeterministicIds(mangleableExports, function (e) {\n      return e.name;\n    }, comparator, function (e, id) {\n      var name = numberToIdentifier(id);\n      var size = usedNames.size;\n      usedNames.add(name);\n      if (size === usedNames.size) return false;\n      e.setUsedName(name);\n      return true;\n    }, [NUMBER_OF_IDENTIFIER_START_CHARS, NUMBER_OF_IDENTIFIER_START_CHARS * NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS], NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS, usedNames.size);\n  } else {\n    var usedExports = [];\n    var unusedExports = [];\n    var _iterator4 = _createForOfIteratorHelper(mangleableExports),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _exportInfo2 = _step4.value;\n        if (_exportInfo2.getUsed(undefined) === UsageState.Unused) {\n          unusedExports.push(_exportInfo2);\n        } else {\n          usedExports.push(_exportInfo2);\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    usedExports.sort(comparator);\n    unusedExports.sort(comparator);\n    var i = 0;\n    for (var _i = 0, _arr = [usedExports, unusedExports]; _i < _arr.length; _i++) {\n      var list = _arr[_i];\n      var _iterator5 = _createForOfIteratorHelper(list),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _exportInfo = _step5.value;\n          var name = void 0;\n          do {\n            name = numberToIdentifier(i++);\n          } while (usedNames.has(name));\n          _exportInfo.setUsedName(name);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  }\n};\nvar MangleExportsPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {boolean} deterministic use deterministic names\n   */\n  function MangleExportsPlugin(deterministic) {\n    _classCallCheck(this, MangleExportsPlugin);\n    this._deterministic = deterministic;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  _createClass(MangleExportsPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var deterministic = this._deterministic;\n      compiler.hooks.compilation.tap(\"MangleExportsPlugin\", function (compilation) {\n        var moduleGraph = compilation.moduleGraph;\n        compilation.hooks.optimizeCodeGeneration.tap(\"MangleExportsPlugin\", function (modules) {\n          if (compilation.moduleMemCaches) {\n            throw new Error(\"optimization.mangleExports can't be used with cacheUnaffected as export mangling is a global effect\");\n          }\n          var _iterator6 = _createForOfIteratorHelper(modules),\n            _step6;\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var _module = _step6.value;\n              var isNamespace = _module.buildMeta && _module.buildMeta.exportsType === \"namespace\";\n              var exportsInfo = moduleGraph.getExportsInfo(_module);\n              mangleExportsInfo(deterministic, exportsInfo, isNamespace);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        });\n      });\n    }\n  }]);\n  return MangleExportsPlugin;\n}();\nmodule.exports = MangleExportsPlugin;","map":{"version":3,"names":["require","UsageState","numberToIdentifier","NUMBER_OF_IDENTIFIER_START_CHARS","NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS","assignDeterministicIds","compareSelect","compareStringsNumeric","canMangle","exportsInfo","otherExportsInfo","getUsed","undefined","Unused","hasSomethingToMangle","exports","exportInfo","comparator","e","name","mangleExportsInfo","deterministic","isNamespace","usedNames","Set","mangleableExports","avoidMangleNonProvided","ownedExports","provided","hasUsedName","length","test","setUsedName","add","push","exportsInfoOwned","used","OnlyPropertiesUsed","id","size","usedExports","unusedExports","sort","i","list","has","MangleExportsPlugin","_deterministic","compiler","hooks","compilation","tap","moduleGraph","optimizeCodeGeneration","modules","moduleMemCaches","Error","module","buildMeta","exportsType","getExportsInfo"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/optimize/MangleExportsPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { UsageState } = require(\"../ExportsInfo\");\nconst {\n\tnumberToIdentifier,\n\tNUMBER_OF_IDENTIFIER_START_CHARS,\n\tNUMBER_OF_IDENTIFIER_CONTINUATION_CHARS\n} = require(\"../Template\");\nconst { assignDeterministicIds } = require(\"../ids/IdHelpers\");\nconst { compareSelect, compareStringsNumeric } = require(\"../util/comparators\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"../ExportsInfo\").ExportInfo} ExportInfo */\n\n/**\n * @param {ExportsInfo} exportsInfo exports info\n * @returns {boolean} mangle is possible\n */\nconst canMangle = exportsInfo => {\n\tif (exportsInfo.otherExportsInfo.getUsed(undefined) !== UsageState.Unused)\n\t\treturn false;\n\tlet hasSomethingToMangle = false;\n\tfor (const exportInfo of exportsInfo.exports) {\n\t\tif (exportInfo.canMangle === true) {\n\t\t\thasSomethingToMangle = true;\n\t\t}\n\t}\n\treturn hasSomethingToMangle;\n};\n\n// Sort by name\nconst comparator = compareSelect(e => e.name, compareStringsNumeric);\n/**\n * @param {boolean} deterministic use deterministic names\n * @param {ExportsInfo} exportsInfo exports info\n * @param {boolean} isNamespace is namespace object\n * @returns {void}\n */\nconst mangleExportsInfo = (deterministic, exportsInfo, isNamespace) => {\n\tif (!canMangle(exportsInfo)) return;\n\tconst usedNames = new Set();\n\t/** @type {ExportInfo[]} */\n\tconst mangleableExports = [];\n\n\t// Avoid to renamed exports that are not provided when\n\t// 1. it's not a namespace export: non-provided exports can be found in prototype chain\n\t// 2. there are other provided exports and deterministic mode is chosen:\n\t//    non-provided exports would break the determinism\n\tlet avoidMangleNonProvided = !isNamespace;\n\tif (!avoidMangleNonProvided && deterministic) {\n\t\tfor (const exportInfo of exportsInfo.ownedExports) {\n\t\t\tif (exportInfo.provided !== false) {\n\t\t\t\tavoidMangleNonProvided = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (const exportInfo of exportsInfo.ownedExports) {\n\t\tconst name = exportInfo.name;\n\t\tif (!exportInfo.hasUsedName()) {\n\t\t\tif (\n\t\t\t\t// Can the export be mangled?\n\t\t\t\texportInfo.canMangle !== true ||\n\t\t\t\t// Never rename 1 char exports\n\t\t\t\t(name.length === 1 && /^[a-zA-Z0-9_$]/.test(name)) ||\n\t\t\t\t// Don't rename 2 char exports in deterministic mode\n\t\t\t\t(deterministic &&\n\t\t\t\t\tname.length === 2 &&\n\t\t\t\t\t/^[a-zA-Z_$][a-zA-Z0-9_$]|^[1-9][0-9]/.test(name)) ||\n\t\t\t\t// Don't rename exports that are not provided\n\t\t\t\t(avoidMangleNonProvided && exportInfo.provided !== true)\n\t\t\t) {\n\t\t\t\texportInfo.setUsedName(name);\n\t\t\t\tusedNames.add(name);\n\t\t\t} else {\n\t\t\t\tmangleableExports.push(exportInfo);\n\t\t\t}\n\t\t}\n\t\tif (exportInfo.exportsInfoOwned) {\n\t\t\tconst used = exportInfo.getUsed(undefined);\n\t\t\tif (\n\t\t\t\tused === UsageState.OnlyPropertiesUsed ||\n\t\t\t\tused === UsageState.Unused\n\t\t\t) {\n\t\t\t\tmangleExportsInfo(deterministic, exportInfo.exportsInfo, false);\n\t\t\t}\n\t\t}\n\t}\n\tif (deterministic) {\n\t\tassignDeterministicIds(\n\t\t\tmangleableExports,\n\t\t\te => e.name,\n\t\t\tcomparator,\n\t\t\t(e, id) => {\n\t\t\t\tconst name = numberToIdentifier(id);\n\t\t\t\tconst size = usedNames.size;\n\t\t\t\tusedNames.add(name);\n\t\t\t\tif (size === usedNames.size) return false;\n\t\t\t\te.setUsedName(name);\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\t[\n\t\t\t\tNUMBER_OF_IDENTIFIER_START_CHARS,\n\t\t\t\tNUMBER_OF_IDENTIFIER_START_CHARS *\n\t\t\t\t\tNUMBER_OF_IDENTIFIER_CONTINUATION_CHARS\n\t\t\t],\n\t\t\tNUMBER_OF_IDENTIFIER_CONTINUATION_CHARS,\n\t\t\tusedNames.size\n\t\t);\n\t} else {\n\t\tconst usedExports = [];\n\t\tconst unusedExports = [];\n\t\tfor (const exportInfo of mangleableExports) {\n\t\t\tif (exportInfo.getUsed(undefined) === UsageState.Unused) {\n\t\t\t\tunusedExports.push(exportInfo);\n\t\t\t} else {\n\t\t\t\tusedExports.push(exportInfo);\n\t\t\t}\n\t\t}\n\t\tusedExports.sort(comparator);\n\t\tunusedExports.sort(comparator);\n\t\tlet i = 0;\n\t\tfor (const list of [usedExports, unusedExports]) {\n\t\t\tfor (const exportInfo of list) {\n\t\t\t\tlet name;\n\t\t\t\tdo {\n\t\t\t\t\tname = numberToIdentifier(i++);\n\t\t\t\t} while (usedNames.has(name));\n\t\t\t\texportInfo.setUsedName(name);\n\t\t\t}\n\t\t}\n\t}\n};\n\nclass MangleExportsPlugin {\n\t/**\n\t * @param {boolean} deterministic use deterministic names\n\t */\n\tconstructor(deterministic) {\n\t\tthis._deterministic = deterministic;\n\t}\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst { _deterministic: deterministic } = this;\n\t\tcompiler.hooks.compilation.tap(\"MangleExportsPlugin\", compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\tcompilation.hooks.optimizeCodeGeneration.tap(\n\t\t\t\t\"MangleExportsPlugin\",\n\t\t\t\tmodules => {\n\t\t\t\t\tif (compilation.moduleMemCaches) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"optimization.mangleExports can't be used with cacheUnaffected as export mangling is a global effect\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tconst isNamespace =\n\t\t\t\t\t\t\tmodule.buildMeta && module.buildMeta.exportsType === \"namespace\";\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\tmangleExportsInfo(deterministic, exportsInfo, isNamespace);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = MangleExportsPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}