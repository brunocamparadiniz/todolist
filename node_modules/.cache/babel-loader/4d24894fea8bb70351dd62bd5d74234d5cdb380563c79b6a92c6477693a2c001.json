{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _require = require(\"tapable\"),\n  AsyncParallelHook = _require.AsyncParallelHook,\n  AsyncSeriesBailHook = _require.AsyncSeriesBailHook,\n  SyncHook = _require.SyncHook;\nvar _require2 = require(\"./HookWebpackError\"),\n  makeWebpackError = _require2.makeWebpackError,\n  makeWebpackErrorCallback = _require2.makeWebpackErrorCallback;\n\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n\n/**\n * @typedef {Object} Etag\n * @property {function(): string} toString\n */\n\n/**\n * @template T\n * @callback CallbackCache\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\n/**\n * @callback GotHandler\n * @param {any} result\n * @param {function(Error=): void} callback\n * @returns {void}\n */\n\nvar needCalls = function needCalls(times, callback) {\n  return function (err) {\n    if (--times === 0) {\n      return callback(err);\n    }\n    if (err && times > 0) {\n      times = 0;\n      return callback(err);\n    }\n  };\n};\nvar Cache = /*#__PURE__*/function () {\n  function Cache() {\n    _classCallCheck(this, Cache);\n    this.hooks = {\n      /** @type {AsyncSeriesBailHook<[string, Etag | null, GotHandler[]], any>} */\n      get: new AsyncSeriesBailHook([\"identifier\", \"etag\", \"gotHandlers\"]),\n      /** @type {AsyncParallelHook<[string, Etag | null, any]>} */\n      store: new AsyncParallelHook([\"identifier\", \"etag\", \"data\"]),\n      /** @type {AsyncParallelHook<[Iterable<string>]>} */\n      storeBuildDependencies: new AsyncParallelHook([\"dependencies\"]),\n      /** @type {SyncHook<[]>} */\n      beginIdle: new SyncHook([]),\n      /** @type {AsyncParallelHook<[]>} */\n      endIdle: new AsyncParallelHook([]),\n      /** @type {AsyncParallelHook<[]>} */\n      shutdown: new AsyncParallelHook([])\n    };\n  }\n\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {CallbackCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n  _createClass(Cache, [{\n    key: \"get\",\n    value: function get(identifier, etag, callback) {\n      var gotHandlers = [];\n      this.hooks.get.callAsync(identifier, etag, gotHandlers, function (err, result) {\n        if (err) {\n          callback(makeWebpackError(err, \"Cache.hooks.get\"));\n          return;\n        }\n        if (result === null) {\n          result = undefined;\n        }\n        if (gotHandlers.length > 1) {\n          var innerCallback = needCalls(gotHandlers.length, function () {\n            return callback(null, result);\n          });\n          for (var _i = 0, _gotHandlers = gotHandlers; _i < _gotHandlers.length; _i++) {\n            var gotHandler = _gotHandlers[_i];\n            gotHandler(result, innerCallback);\n          }\n        } else if (gotHandlers.length === 1) {\n          gotHandlers[0](result, function () {\n            return callback(null, result);\n          });\n        } else {\n          callback(null, result);\n        }\n      });\n    }\n\n    /**\n     * @template T\n     * @param {string} identifier the cache identifier\n     * @param {Etag | null} etag the etag\n     * @param {T} data the value to store\n     * @param {CallbackCache<void>} callback signals when the value is stored\n     * @returns {void}\n     */\n  }, {\n    key: \"store\",\n    value: function store(identifier, etag, data, callback) {\n      this.hooks.store.callAsync(identifier, etag, data, makeWebpackErrorCallback(callback, \"Cache.hooks.store\"));\n    }\n\n    /**\n     * After this method has succeeded the cache can only be restored when build dependencies are\n     * @param {Iterable<string>} dependencies list of all build dependencies\n     * @param {CallbackCache<void>} callback signals when the dependencies are stored\n     * @returns {void}\n     */\n  }, {\n    key: \"storeBuildDependencies\",\n    value: function storeBuildDependencies(dependencies, callback) {\n      this.hooks.storeBuildDependencies.callAsync(dependencies, makeWebpackErrorCallback(callback, \"Cache.hooks.storeBuildDependencies\"));\n    }\n\n    /**\n     * @returns {void}\n     */\n  }, {\n    key: \"beginIdle\",\n    value: function beginIdle() {\n      this.hooks.beginIdle.call();\n    }\n\n    /**\n     * @param {CallbackCache<void>} callback signals when the call finishes\n     * @returns {void}\n     */\n  }, {\n    key: \"endIdle\",\n    value: function endIdle(callback) {\n      this.hooks.endIdle.callAsync(makeWebpackErrorCallback(callback, \"Cache.hooks.endIdle\"));\n    }\n\n    /**\n     * @param {CallbackCache<void>} callback signals when the call finishes\n     * @returns {void}\n     */\n  }, {\n    key: \"shutdown\",\n    value: function shutdown(callback) {\n      this.hooks.shutdown.callAsync(makeWebpackErrorCallback(callback, \"Cache.hooks.shutdown\"));\n    }\n  }]);\n  return Cache;\n}();\nCache.STAGE_MEMORY = -10;\nCache.STAGE_DEFAULT = 0;\nCache.STAGE_DISK = 10;\nCache.STAGE_NETWORK = 20;\nmodule.exports = Cache;","map":{"version":3,"names":["require","AsyncParallelHook","AsyncSeriesBailHook","SyncHook","makeWebpackError","makeWebpackErrorCallback","needCalls","times","callback","err","Cache","hooks","get","store","storeBuildDependencies","beginIdle","endIdle","shutdown","identifier","etag","gotHandlers","callAsync","result","undefined","length","innerCallback","gotHandler","data","dependencies","call","STAGE_MEMORY","STAGE_DEFAULT","STAGE_DISK","STAGE_NETWORK","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/Cache.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { AsyncParallelHook, AsyncSeriesBailHook, SyncHook } = require(\"tapable\");\nconst {\n\tmakeWebpackError,\n\tmakeWebpackErrorCallback\n} = require(\"./HookWebpackError\");\n\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n\n/**\n * @typedef {Object} Etag\n * @property {function(): string} toString\n */\n\n/**\n * @template T\n * @callback CallbackCache\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\n/**\n * @callback GotHandler\n * @param {any} result\n * @param {function(Error=): void} callback\n * @returns {void}\n */\n\nconst needCalls = (times, callback) => {\n\treturn err => {\n\t\tif (--times === 0) {\n\t\t\treturn callback(err);\n\t\t}\n\t\tif (err && times > 0) {\n\t\t\ttimes = 0;\n\t\t\treturn callback(err);\n\t\t}\n\t};\n};\n\nclass Cache {\n\tconstructor() {\n\t\tthis.hooks = {\n\t\t\t/** @type {AsyncSeriesBailHook<[string, Etag | null, GotHandler[]], any>} */\n\t\t\tget: new AsyncSeriesBailHook([\"identifier\", \"etag\", \"gotHandlers\"]),\n\t\t\t/** @type {AsyncParallelHook<[string, Etag | null, any]>} */\n\t\t\tstore: new AsyncParallelHook([\"identifier\", \"etag\", \"data\"]),\n\t\t\t/** @type {AsyncParallelHook<[Iterable<string>]>} */\n\t\t\tstoreBuildDependencies: new AsyncParallelHook([\"dependencies\"]),\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\tbeginIdle: new SyncHook([]),\n\t\t\t/** @type {AsyncParallelHook<[]>} */\n\t\t\tendIdle: new AsyncParallelHook([]),\n\t\t\t/** @type {AsyncParallelHook<[]>} */\n\t\t\tshutdown: new AsyncParallelHook([])\n\t\t};\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {CallbackCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tget(identifier, etag, callback) {\n\t\tconst gotHandlers = [];\n\t\tthis.hooks.get.callAsync(identifier, etag, gotHandlers, (err, result) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(makeWebpackError(err, \"Cache.hooks.get\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (result === null) {\n\t\t\t\tresult = undefined;\n\t\t\t}\n\t\t\tif (gotHandlers.length > 1) {\n\t\t\t\tconst innerCallback = needCalls(gotHandlers.length, () =>\n\t\t\t\t\tcallback(null, result)\n\t\t\t\t);\n\t\t\t\tfor (const gotHandler of gotHandlers) {\n\t\t\t\t\tgotHandler(result, innerCallback);\n\t\t\t\t}\n\t\t\t} else if (gotHandlers.length === 1) {\n\t\t\t\tgotHandlers[0](result, () => callback(null, result));\n\t\t\t} else {\n\t\t\t\tcallback(null, result);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {T} data the value to store\n\t * @param {CallbackCache<void>} callback signals when the value is stored\n\t * @returns {void}\n\t */\n\tstore(identifier, etag, data, callback) {\n\t\tthis.hooks.store.callAsync(\n\t\t\tidentifier,\n\t\t\tetag,\n\t\t\tdata,\n\t\t\tmakeWebpackErrorCallback(callback, \"Cache.hooks.store\")\n\t\t);\n\t}\n\n\t/**\n\t * After this method has succeeded the cache can only be restored when build dependencies are\n\t * @param {Iterable<string>} dependencies list of all build dependencies\n\t * @param {CallbackCache<void>} callback signals when the dependencies are stored\n\t * @returns {void}\n\t */\n\tstoreBuildDependencies(dependencies, callback) {\n\t\tthis.hooks.storeBuildDependencies.callAsync(\n\t\t\tdependencies,\n\t\t\tmakeWebpackErrorCallback(callback, \"Cache.hooks.storeBuildDependencies\")\n\t\t);\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tbeginIdle() {\n\t\tthis.hooks.beginIdle.call();\n\t}\n\n\t/**\n\t * @param {CallbackCache<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\tendIdle(callback) {\n\t\tthis.hooks.endIdle.callAsync(\n\t\t\tmakeWebpackErrorCallback(callback, \"Cache.hooks.endIdle\")\n\t\t);\n\t}\n\n\t/**\n\t * @param {CallbackCache<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\tshutdown(callback) {\n\t\tthis.hooks.shutdown.callAsync(\n\t\t\tmakeWebpackErrorCallback(callback, \"Cache.hooks.shutdown\")\n\t\t);\n\t}\n}\n\nCache.STAGE_MEMORY = -10;\nCache.STAGE_DEFAULT = 0;\nCache.STAGE_DISK = 10;\nCache.STAGE_NETWORK = 20;\n\nmodule.exports = Cache;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}