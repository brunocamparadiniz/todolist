{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _require = require(\"../OptimizationStages\"),\n  STAGE_BASIC = _require.STAGE_BASIC;\nvar Queue = require(\"../util/Queue\");\nvar _require2 = require(\"../util/SetHelpers\"),\n  intersect = _require2.intersect;\n\n/** @typedef {import(\"../Compiler\")} Compiler */\nvar RemoveParentModulesPlugin = /*#__PURE__*/function () {\n  function RemoveParentModulesPlugin() {\n    _classCallCheck(this, RemoveParentModulesPlugin);\n  }\n  _createClass(RemoveParentModulesPlugin, [{\n    key: \"apply\",\n    value:\n    /**\n     * @param {Compiler} compiler the compiler\n     * @returns {void}\n     */\n    function apply(compiler) {\n      compiler.hooks.compilation.tap(\"RemoveParentModulesPlugin\", function (compilation) {\n        var handler = function handler(chunks, chunkGroups) {\n          var chunkGraph = compilation.chunkGraph;\n          var queue = new Queue();\n          var availableModulesMap = new WeakMap();\n          var _iterator = _createForOfIteratorHelper(compilation.entrypoints.values()),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _chunkGroup = _step.value;\n              // initialize available modules for chunks without parents\n              availableModulesMap.set(_chunkGroup, new Set());\n              var _iterator9 = _createForOfIteratorHelper(_chunkGroup.childrenIterable),\n                _step9;\n              try {\n                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                  var _child = _step9.value;\n                  queue.enqueue(_child);\n                }\n              } catch (err) {\n                _iterator9.e(err);\n              } finally {\n                _iterator9.f();\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          var _iterator2 = _createForOfIteratorHelper(compilation.asyncEntrypoints),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _chunkGroup2 = _step2.value;\n              // initialize available modules for chunks without parents\n              availableModulesMap.set(_chunkGroup2, new Set());\n              var _iterator10 = _createForOfIteratorHelper(_chunkGroup2.childrenIterable),\n                _step10;\n              try {\n                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                  var _child2 = _step10.value;\n                  queue.enqueue(_child2);\n                }\n              } catch (err) {\n                _iterator10.e(err);\n              } finally {\n                _iterator10.f();\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          while (queue.length > 0) {\n            var chunkGroup = queue.dequeue();\n            var availableModules = availableModulesMap.get(chunkGroup);\n            var changed = false;\n            var _iterator3 = _createForOfIteratorHelper(chunkGroup.parentsIterable),\n              _step3;\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var parent = _step3.value;\n                var availableModulesInParent = availableModulesMap.get(parent);\n                if (availableModulesInParent !== undefined) {\n                  // If we know the available modules in parent: process these\n                  if (availableModules === undefined) {\n                    // if we have not own info yet: create new entry\n                    availableModules = new Set(availableModulesInParent);\n                    var _iterator5 = _createForOfIteratorHelper(parent.chunks),\n                      _step5;\n                    try {\n                      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                        var chunk = _step5.value;\n                        var _iterator6 = _createForOfIteratorHelper(chunkGraph.getChunkModulesIterable(chunk)),\n                          _step6;\n                        try {\n                          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                            var m = _step6.value;\n                            availableModules.add(m);\n                          }\n                        } catch (err) {\n                          _iterator6.e(err);\n                        } finally {\n                          _iterator6.f();\n                        }\n                      }\n                    } catch (err) {\n                      _iterator5.e(err);\n                    } finally {\n                      _iterator5.f();\n                    }\n                    availableModulesMap.set(chunkGroup, availableModules);\n                    changed = true;\n                  } else {\n                    var _iterator7 = _createForOfIteratorHelper(availableModules),\n                      _step7;\n                    try {\n                      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                        var _m = _step7.value;\n                        if (!chunkGraph.isModuleInChunkGroup(_m, parent) && !availableModulesInParent.has(_m)) {\n                          availableModules.delete(_m);\n                          changed = true;\n                        }\n                      }\n                    } catch (err) {\n                      _iterator7.e(err);\n                    } finally {\n                      _iterator7.f();\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n            if (changed) {\n              // if something changed: enqueue our children\n              var _iterator4 = _createForOfIteratorHelper(chunkGroup.childrenIterable),\n                _step4;\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  var child = _step4.value;\n                  queue.enqueue(child);\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n            }\n          }\n\n          // now we have available modules for every chunk\n          var _iterator8 = _createForOfIteratorHelper(chunks),\n            _step8;\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var _chunk = _step8.value;\n              var availableModulesSets = Array.from(_chunk.groupsIterable, function (chunkGroup) {\n                return availableModulesMap.get(chunkGroup);\n              });\n              if (availableModulesSets.some(function (s) {\n                return s === undefined;\n              })) continue; // No info about this chunk group\n              var _availableModules = availableModulesSets.length === 1 ? availableModulesSets[0] : intersect(availableModulesSets);\n              var numberOfModules = chunkGraph.getNumberOfChunkModules(_chunk);\n              var toRemove = new Set();\n              if (numberOfModules < _availableModules.size) {\n                var _iterator11 = _createForOfIteratorHelper(chunkGraph.getChunkModulesIterable(_chunk)),\n                  _step11;\n                try {\n                  for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                    var _m2 = _step11.value;\n                    if (_availableModules.has(_m2)) {\n                      toRemove.add(_m2);\n                    }\n                  }\n                } catch (err) {\n                  _iterator11.e(err);\n                } finally {\n                  _iterator11.f();\n                }\n              } else {\n                var _iterator12 = _createForOfIteratorHelper(_availableModules),\n                  _step12;\n                try {\n                  for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                    var _m3 = _step12.value;\n                    if (chunkGraph.isModuleInChunk(_m3, _chunk)) {\n                      toRemove.add(_m3);\n                    }\n                  }\n                } catch (err) {\n                  _iterator12.e(err);\n                } finally {\n                  _iterator12.f();\n                }\n              }\n              var _iterator13 = _createForOfIteratorHelper(toRemove),\n                _step13;\n              try {\n                for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                  var _module = _step13.value;\n                  chunkGraph.disconnectChunkAndModule(_chunk, _module);\n                }\n              } catch (err) {\n                _iterator13.e(err);\n              } finally {\n                _iterator13.f();\n              }\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n        };\n        compilation.hooks.optimizeChunks.tap({\n          name: \"RemoveParentModulesPlugin\",\n          stage: STAGE_BASIC\n        }, handler);\n      });\n    }\n  }]);\n  return RemoveParentModulesPlugin;\n}();\nmodule.exports = RemoveParentModulesPlugin;","map":{"version":3,"names":["require","STAGE_BASIC","Queue","intersect","RemoveParentModulesPlugin","compiler","hooks","compilation","tap","handler","chunks","chunkGroups","chunkGraph","queue","availableModulesMap","WeakMap","entrypoints","values","chunkGroup","set","Set","childrenIterable","child","enqueue","asyncEntrypoints","length","dequeue","availableModules","get","changed","parentsIterable","parent","availableModulesInParent","undefined","chunk","getChunkModulesIterable","m","add","isModuleInChunkGroup","has","delete","availableModulesSets","Array","from","groupsIterable","some","s","numberOfModules","getNumberOfChunkModules","toRemove","size","isModuleInChunk","module","disconnectChunkAndModule","optimizeChunks","name","stage","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/optimize/RemoveParentModulesPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_BASIC } = require(\"../OptimizationStages\");\nconst Queue = require(\"../util/Queue\");\nconst { intersect } = require(\"../util/SetHelpers\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nclass RemoveParentModulesPlugin {\n\t/**\n\t * @param {Compiler} compiler the compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"RemoveParentModulesPlugin\", compilation => {\n\t\t\tconst handler = (chunks, chunkGroups) => {\n\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\tconst queue = new Queue();\n\t\t\t\tconst availableModulesMap = new WeakMap();\n\n\t\t\t\tfor (const chunkGroup of compilation.entrypoints.values()) {\n\t\t\t\t\t// initialize available modules for chunks without parents\n\t\t\t\t\tavailableModulesMap.set(chunkGroup, new Set());\n\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\tqueue.enqueue(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const chunkGroup of compilation.asyncEntrypoints) {\n\t\t\t\t\t// initialize available modules for chunks without parents\n\t\t\t\t\tavailableModulesMap.set(chunkGroup, new Set());\n\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\tqueue.enqueue(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst chunkGroup = queue.dequeue();\n\t\t\t\t\tlet availableModules = availableModulesMap.get(chunkGroup);\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\t\t\t\tconst availableModulesInParent = availableModulesMap.get(parent);\n\t\t\t\t\t\tif (availableModulesInParent !== undefined) {\n\t\t\t\t\t\t\t// If we know the available modules in parent: process these\n\t\t\t\t\t\t\tif (availableModules === undefined) {\n\t\t\t\t\t\t\t\t// if we have not own info yet: create new entry\n\t\t\t\t\t\t\t\tavailableModules = new Set(availableModulesInParent);\n\t\t\t\t\t\t\t\tfor (const chunk of parent.chunks) {\n\t\t\t\t\t\t\t\t\tfor (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\t\t\t\t\t\t\tavailableModules.add(m);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tavailableModulesMap.set(chunkGroup, availableModules);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const m of availableModules) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!chunkGraph.isModuleInChunkGroup(m, parent) &&\n\t\t\t\t\t\t\t\t\t\t!availableModulesInParent.has(m)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tavailableModules.delete(m);\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t// if something changed: enqueue our children\n\t\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\t\tqueue.enqueue(child);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// now we have available modules for every chunk\n\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\tconst availableModulesSets = Array.from(\n\t\t\t\t\t\tchunk.groupsIterable,\n\t\t\t\t\t\tchunkGroup => availableModulesMap.get(chunkGroup)\n\t\t\t\t\t);\n\t\t\t\t\tif (availableModulesSets.some(s => s === undefined)) continue; // No info about this chunk group\n\t\t\t\t\tconst availableModules =\n\t\t\t\t\t\tavailableModulesSets.length === 1\n\t\t\t\t\t\t\t? availableModulesSets[0]\n\t\t\t\t\t\t\t: intersect(availableModulesSets);\n\t\t\t\t\tconst numberOfModules = chunkGraph.getNumberOfChunkModules(chunk);\n\t\t\t\t\tconst toRemove = new Set();\n\t\t\t\t\tif (numberOfModules < availableModules.size) {\n\t\t\t\t\t\tfor (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\t\t\t\tif (availableModules.has(m)) {\n\t\t\t\t\t\t\t\ttoRemove.add(m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const m of availableModules) {\n\t\t\t\t\t\t\tif (chunkGraph.isModuleInChunk(m, chunk)) {\n\t\t\t\t\t\t\t\ttoRemove.add(m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const module of toRemove) {\n\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"RemoveParentModulesPlugin\",\n\t\t\t\t\tstage: STAGE_BASIC\n\t\t\t\t},\n\t\t\t\thandler\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = RemoveParentModulesPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}