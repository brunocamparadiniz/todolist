{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar util = require(\"util\");\nvar Entrypoint = require(\"./Entrypoint\");\nvar ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nvar _require = require(\"./util/SetHelpers\"),\n  first = _require.first;\nvar SortableSet = require(\"./util/SortableSet\");\nvar _require2 = require(\"./util/comparators\"),\n  compareModulesById = _require2.compareModulesById,\n  compareIterables = _require2.compareIterables,\n  compareModulesByIdentifier = _require2.compareModulesByIdentifier,\n  concatComparators = _require2.concatComparators,\n  compareSelect = _require2.compareSelect,\n  compareIds = _require2.compareIds;\nvar createHash = require(\"./util/createHash\");\nvar findGraphRoots = require(\"./util/findGraphRoots\");\nvar _require3 = require(\"./util/runtime\"),\n  RuntimeSpecMap = _require3.RuntimeSpecMap,\n  RuntimeSpecSet = _require3.RuntimeSpecSet,\n  runtimeToString = _require3.runtimeToString,\n  mergeRuntime = _require3.mergeRuntime,\n  forEachRuntime = _require3.forEachRuntime;\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @type {ReadonlySet<string>} */\nvar EMPTY_SET = new Set();\nvar ZERO_BIG_INT = BigInt(0);\nvar compareModuleIterables = compareIterables(compareModulesByIdentifier);\n\n/** @typedef {(c: Chunk, chunkGraph: ChunkGraph) => boolean} ChunkFilterPredicate */\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n/** @typedef {[Module, Entrypoint | undefined]} EntryModuleWithChunkGroup */\n\n/**\n * @typedef {Object} ChunkSizeOptions\n * @property {number=} chunkOverhead constant overhead for a chunk\n * @property {number=} entryChunkMultiplicator multiplicator for initial chunks\n */\nvar ModuleHashInfo = /*#__PURE__*/_createClass(function ModuleHashInfo(hash, renderedHash) {\n  _classCallCheck(this, ModuleHashInfo);\n  this.hash = hash;\n  this.renderedHash = renderedHash;\n});\n/** @template T @typedef {(set: SortableSet<T>) => T[]} SetToArrayFunction<T> */\n/**\n * @template T\n * @param {SortableSet<T>} set the set\n * @returns {T[]} set as array\n */\nvar getArray = function getArray(set) {\n  return Array.from(set);\n};\n\n/**\n * @param {SortableSet<Chunk>} chunks the chunks\n * @returns {RuntimeSpecSet} runtimes\n */\nvar _getModuleRuntimes = function getModuleRuntimes(chunks) {\n  var runtimes = new RuntimeSpecSet();\n  var _iterator = _createForOfIteratorHelper(chunks),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var chunk = _step.value;\n      runtimes.add(chunk.runtime);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return runtimes;\n};\n\n/**\n * @param {WeakMap<Module, Set<string>> | undefined} sourceTypesByModule sourceTypesByModule\n * @returns {function (SortableSet<Module>): Map<string, SortableSet<Module>>} modules by source type\n */\nvar modulesBySourceType = function modulesBySourceType(sourceTypesByModule) {\n  return function (set) {\n    /** @type {Map<string, SortableSet<Module>>} */\n    var map = new Map();\n    var _iterator2 = _createForOfIteratorHelper(set),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _module = _step2.value;\n        var sourceTypes = sourceTypesByModule && sourceTypesByModule.get(_module) || _module.getSourceTypes();\n        var _iterator4 = _createForOfIteratorHelper(sourceTypes),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var sourceType = _step4.value;\n            var innerSet = map.get(sourceType);\n            if (innerSet === undefined) {\n              innerSet = new SortableSet();\n              map.set(sourceType, innerSet);\n            }\n            innerSet.add(_module);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    var _iterator3 = _createForOfIteratorHelper(map),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _step3$value = _slicedToArray(_step3.value, 2),\n          key = _step3$value[0],\n          _innerSet = _step3$value[1];\n        // When all modules have the source type, we reuse the original SortableSet\n        // to benefit from the shared cache (especially for sorting)\n        if (_innerSet.size === set.size) {\n          map.set(key, set);\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    return map;\n  };\n};\nvar defaultModulesBySourceType = modulesBySourceType(undefined);\n\n/** @type {WeakMap<Function, any>} */\nvar createOrderedArrayFunctionMap = new WeakMap();\n\n/**\n * @template T\n * @param {function(T, T): -1|0|1} comparator comparator function\n * @returns {SetToArrayFunction<T>} set as ordered array\n */\nvar createOrderedArrayFunction = function createOrderedArrayFunction(comparator) {\n  /** @type {SetToArrayFunction<T>} */\n  var fn = createOrderedArrayFunctionMap.get(comparator);\n  if (fn !== undefined) return fn;\n  fn = function fn(set) {\n    set.sortWith(comparator);\n    return Array.from(set);\n  };\n  createOrderedArrayFunctionMap.set(comparator, fn);\n  return fn;\n};\n\n/**\n * @param {Iterable<Module>} modules the modules to get the count/size of\n * @returns {number} the size of the modules\n */\nvar getModulesSize = function getModulesSize(modules) {\n  var size = 0;\n  var _iterator5 = _createForOfIteratorHelper(modules),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var _module2 = _step5.value;\n      var _iterator6 = _createForOfIteratorHelper(_module2.getSourceTypes()),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var type = _step6.value;\n          size += _module2.size(type);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  return size;\n};\n\n/**\n * @param {Iterable<Module>} modules the sortable Set to get the size of\n * @returns {Record<string, number>} the sizes of the modules\n */\nvar getModulesSizes = function getModulesSizes(modules) {\n  var sizes = Object.create(null);\n  var _iterator7 = _createForOfIteratorHelper(modules),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var _module3 = _step7.value;\n      var _iterator8 = _createForOfIteratorHelper(_module3.getSourceTypes()),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var type = _step8.value;\n          sizes[type] = (sizes[type] || 0) + _module3.size(type);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  return sizes;\n};\n\n/**\n * @param {Chunk} a chunk\n * @param {Chunk} b chunk\n * @returns {boolean} true, if a is always a parent of b\n */\nvar isAvailableChunk = function isAvailableChunk(a, b) {\n  var queue = new Set(b.groupsIterable);\n  var _iterator9 = _createForOfIteratorHelper(queue),\n    _step9;\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var chunkGroup = _step9.value;\n      if (a.isInGroup(chunkGroup)) continue;\n      if (chunkGroup.isInitial()) return false;\n      var _iterator10 = _createForOfIteratorHelper(chunkGroup.parentsIterable),\n        _step10;\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var parent = _step10.value;\n          queue.add(parent);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n  return true;\n};\nvar ChunkGraphModule = /*#__PURE__*/_createClass(function ChunkGraphModule() {\n  _classCallCheck(this, ChunkGraphModule);\n  /** @type {SortableSet<Chunk>} */\n  this.chunks = new SortableSet();\n  /** @type {Set<Chunk> | undefined} */\n  this.entryInChunks = undefined;\n  /** @type {Set<Chunk> | undefined} */\n  this.runtimeInChunks = undefined;\n  /** @type {RuntimeSpecMap<ModuleHashInfo>} */\n  this.hashes = undefined;\n  /** @type {string | number} */\n  this.id = null;\n  /** @type {RuntimeSpecMap<Set<string>> | undefined} */\n  this.runtimeRequirements = undefined;\n  /** @type {RuntimeSpecMap<string>} */\n  this.graphHashes = undefined;\n  /** @type {RuntimeSpecMap<string>} */\n  this.graphHashesWithConnections = undefined;\n});\nvar ChunkGraphChunk = /*#__PURE__*/_createClass(function ChunkGraphChunk() {\n  _classCallCheck(this, ChunkGraphChunk);\n  /** @type {SortableSet<Module>} */\n  this.modules = new SortableSet();\n  /** @type {WeakMap<Module, Set<string>> | undefined} */\n  this.sourceTypesByModule = undefined;\n  /** @type {Map<Module, Entrypoint>} */\n  this.entryModules = new Map();\n  /** @type {SortableSet<RuntimeModule>} */\n  this.runtimeModules = new SortableSet();\n  /** @type {Set<RuntimeModule> | undefined} */\n  this.fullHashModules = undefined;\n  /** @type {Set<RuntimeModule> | undefined} */\n  this.dependentHashModules = undefined;\n  /** @type {Set<string> | undefined} */\n  this.runtimeRequirements = undefined;\n  /** @type {Set<string>} */\n  this.runtimeRequirementsInTree = new Set();\n  this._modulesBySourceType = defaultModulesBySourceType;\n});\nvar ChunkGraph = /*#__PURE__*/function () {\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @param {string | Hash} hashFunction the hash function to use\n   */\n  function ChunkGraph(moduleGraph) {\n    var hashFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"md4\";\n    _classCallCheck(this, ChunkGraph);\n    /** @private @type {WeakMap<Module, ChunkGraphModule>} */\n    this._modules = new WeakMap();\n    /** @private @type {WeakMap<Chunk, ChunkGraphChunk>} */\n    this._chunks = new WeakMap();\n    /** @private @type {WeakMap<AsyncDependenciesBlock, ChunkGroup>} */\n    this._blockChunkGroups = new WeakMap();\n    /** @private @type {Map<string, string | number>} */\n    this._runtimeIds = new Map();\n    /** @type {ModuleGraph} */\n    this.moduleGraph = moduleGraph;\n    this._hashFunction = hashFunction;\n    this._getGraphRoots = this._getGraphRoots.bind(this);\n  }\n\n  /**\n   * @private\n   * @param {Module} module the module\n   * @returns {ChunkGraphModule} internal module\n   */\n  _createClass(ChunkGraph, [{\n    key: \"_getChunkGraphModule\",\n    value: function _getChunkGraphModule(module) {\n      var cgm = this._modules.get(module);\n      if (cgm === undefined) {\n        cgm = new ChunkGraphModule();\n        this._modules.set(module, cgm);\n      }\n      return cgm;\n    }\n\n    /**\n     * @private\n     * @param {Chunk} chunk the chunk\n     * @returns {ChunkGraphChunk} internal chunk\n     */\n  }, {\n    key: \"_getChunkGraphChunk\",\n    value: function _getChunkGraphChunk(chunk) {\n      var cgc = this._chunks.get(chunk);\n      if (cgc === undefined) {\n        cgc = new ChunkGraphChunk();\n        this._chunks.set(chunk, cgc);\n      }\n      return cgc;\n    }\n\n    /**\n     * @param {SortableSet<Module>} set the sortable Set to get the roots of\n     * @returns {Module[]} the graph roots\n     */\n  }, {\n    key: \"_getGraphRoots\",\n    value: function _getGraphRoots(set) {\n      var moduleGraph = this.moduleGraph;\n      return Array.from(findGraphRoots(set, function (module) {\n        /** @type {Set<Module>} */\n        var set = new Set();\n        var addDependencies = function addDependencies(module) {\n          var _iterator11 = _createForOfIteratorHelper(moduleGraph.getOutgoingConnections(module)),\n            _step11;\n          try {\n            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n              var connection = _step11.value;\n              if (!connection.module) continue;\n              var activeState = connection.getActiveState(undefined);\n              if (activeState === false) continue;\n              if (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n                addDependencies(connection.module);\n                continue;\n              }\n              set.add(connection.module);\n            }\n          } catch (err) {\n            _iterator11.e(err);\n          } finally {\n            _iterator11.f();\n          }\n        };\n        addDependencies(module);\n        return set;\n      })).sort(compareModulesByIdentifier);\n    }\n\n    /**\n     * @param {Chunk} chunk the new chunk\n     * @param {Module} module the module\n     * @returns {void}\n     */\n  }, {\n    key: \"connectChunkAndModule\",\n    value: function connectChunkAndModule(chunk, module) {\n      var cgm = this._getChunkGraphModule(module);\n      var cgc = this._getChunkGraphChunk(chunk);\n      cgm.chunks.add(chunk);\n      cgc.modules.add(module);\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {Module} module the module\n     * @returns {void}\n     */\n  }, {\n    key: \"disconnectChunkAndModule\",\n    value: function disconnectChunkAndModule(chunk, module) {\n      var cgm = this._getChunkGraphModule(module);\n      var cgc = this._getChunkGraphChunk(chunk);\n      cgc.modules.delete(module);\n      // No need to invalidate cgc._modulesBySourceType because we modified cgc.modules anyway\n      if (cgc.sourceTypesByModule) cgc.sourceTypesByModule.delete(module);\n      cgm.chunks.delete(chunk);\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk which will be disconnected\n     * @returns {void}\n     */\n  }, {\n    key: \"disconnectChunk\",\n    value: function disconnectChunk(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      var _iterator12 = _createForOfIteratorHelper(cgc.modules),\n        _step12;\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var _module4 = _step12.value;\n          var cgm = this._getChunkGraphModule(_module4);\n          cgm.chunks.delete(chunk);\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n      cgc.modules.clear();\n      chunk.disconnectFromGroups();\n      ChunkGraph.clearChunkGraphForChunk(chunk);\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {Iterable<Module>} modules the modules\n     * @returns {void}\n     */\n  }, {\n    key: \"attachModules\",\n    value: function attachModules(chunk, modules) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      var _iterator13 = _createForOfIteratorHelper(modules),\n        _step13;\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var _module5 = _step13.value;\n          cgc.modules.add(_module5);\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {Iterable<RuntimeModule>} modules the runtime modules\n     * @returns {void}\n     */\n  }, {\n    key: \"attachRuntimeModules\",\n    value: function attachRuntimeModules(chunk, modules) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      var _iterator14 = _createForOfIteratorHelper(modules),\n        _step14;\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var _module6 = _step14.value;\n          cgc.runtimeModules.add(_module6);\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n     * @returns {void}\n     */\n  }, {\n    key: \"attachFullHashModules\",\n    value: function attachFullHashModules(chunk, modules) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      if (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n      var _iterator15 = _createForOfIteratorHelper(modules),\n        _step15;\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var _module7 = _step15.value;\n          cgc.fullHashModules.add(_module7);\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n     * @returns {void}\n     */\n  }, {\n    key: \"attachDependentHashModules\",\n    value: function attachDependentHashModules(chunk, modules) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      if (cgc.dependentHashModules === undefined) cgc.dependentHashModules = new Set();\n      var _iterator16 = _createForOfIteratorHelper(modules),\n        _step16;\n      try {\n        for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n          var _module8 = _step16.value;\n          cgc.dependentHashModules.add(_module8);\n        }\n      } catch (err) {\n        _iterator16.e(err);\n      } finally {\n        _iterator16.f();\n      }\n    }\n\n    /**\n     * @param {Module} oldModule the replaced module\n     * @param {Module} newModule the replacing module\n     * @returns {void}\n     */\n  }, {\n    key: \"replaceModule\",\n    value: function replaceModule(oldModule, newModule) {\n      var oldCgm = this._getChunkGraphModule(oldModule);\n      var newCgm = this._getChunkGraphModule(newModule);\n      var _iterator17 = _createForOfIteratorHelper(oldCgm.chunks),\n        _step17;\n      try {\n        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n          var _chunk2 = _step17.value;\n          var _cgc2 = this._getChunkGraphChunk(_chunk2);\n          _cgc2.modules.delete(oldModule);\n          _cgc2.modules.add(newModule);\n          newCgm.chunks.add(_chunk2);\n        }\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n      oldCgm.chunks.clear();\n      if (oldCgm.entryInChunks !== undefined) {\n        if (newCgm.entryInChunks === undefined) {\n          newCgm.entryInChunks = new Set();\n        }\n        var _iterator18 = _createForOfIteratorHelper(oldCgm.entryInChunks),\n          _step18;\n        try {\n          for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n            var chunk = _step18.value;\n            var cgc = this._getChunkGraphChunk(chunk);\n            var old = cgc.entryModules.get(oldModule);\n            /** @type {Map<Module, Entrypoint>} */\n            var newEntryModules = new Map();\n            var _iterator19 = _createForOfIteratorHelper(cgc.entryModules),\n              _step19;\n            try {\n              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                var _step19$value = _slicedToArray(_step19.value, 2),\n                  m = _step19$value[0],\n                  cg = _step19$value[1];\n                if (m === oldModule) {\n                  newEntryModules.set(newModule, old);\n                } else {\n                  newEntryModules.set(m, cg);\n                }\n              }\n            } catch (err) {\n              _iterator19.e(err);\n            } finally {\n              _iterator19.f();\n            }\n            cgc.entryModules = newEntryModules;\n            newCgm.entryInChunks.add(chunk);\n          }\n        } catch (err) {\n          _iterator18.e(err);\n        } finally {\n          _iterator18.f();\n        }\n        oldCgm.entryInChunks = undefined;\n      }\n      if (oldCgm.runtimeInChunks !== undefined) {\n        if (newCgm.runtimeInChunks === undefined) {\n          newCgm.runtimeInChunks = new Set();\n        }\n        var _iterator20 = _createForOfIteratorHelper(oldCgm.runtimeInChunks),\n          _step20;\n        try {\n          for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n            var _chunk = _step20.value;\n            var _cgc = this._getChunkGraphChunk(_chunk);\n            _cgc.runtimeModules.delete( /** @type {RuntimeModule} */oldModule);\n            _cgc.runtimeModules.add( /** @type {RuntimeModule} */newModule);\n            newCgm.runtimeInChunks.add(_chunk);\n            if (_cgc.fullHashModules !== undefined && _cgc.fullHashModules.has( /** @type {RuntimeModule} */oldModule)) {\n              _cgc.fullHashModules.delete( /** @type {RuntimeModule} */oldModule);\n              _cgc.fullHashModules.add( /** @type {RuntimeModule} */newModule);\n            }\n            if (_cgc.dependentHashModules !== undefined && _cgc.dependentHashModules.has( /** @type {RuntimeModule} */oldModule)) {\n              _cgc.dependentHashModules.delete( /** @type {RuntimeModule} */oldModule);\n              _cgc.dependentHashModules.add( /** @type {RuntimeModule} */newModule);\n            }\n          }\n        } catch (err) {\n          _iterator20.e(err);\n        } finally {\n          _iterator20.f();\n        }\n        oldCgm.runtimeInChunks = undefined;\n      }\n    }\n\n    /**\n     * @param {Module} module the checked module\n     * @param {Chunk} chunk the checked chunk\n     * @returns {boolean} true, if the chunk contains the module\n     */\n  }, {\n    key: \"isModuleInChunk\",\n    value: function isModuleInChunk(module, chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      return cgc.modules.has(module);\n    }\n\n    /**\n     * @param {Module} module the checked module\n     * @param {ChunkGroup} chunkGroup the checked chunk group\n     * @returns {boolean} true, if the chunk contains the module\n     */\n  }, {\n    key: \"isModuleInChunkGroup\",\n    value: function isModuleInChunkGroup(module, chunkGroup) {\n      var _iterator21 = _createForOfIteratorHelper(chunkGroup.chunks),\n        _step21;\n      try {\n        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n          var chunk = _step21.value;\n          if (this.isModuleInChunk(module, chunk)) return true;\n        }\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n      return false;\n    }\n\n    /**\n     * @param {Module} module the checked module\n     * @returns {boolean} true, if the module is entry of any chunk\n     */\n  }, {\n    key: \"isEntryModule\",\n    value: function isEntryModule(module) {\n      var cgm = this._getChunkGraphModule(module);\n      return cgm.entryInChunks !== undefined;\n    }\n\n    /**\n     * @param {Module} module the module\n     * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n     */\n  }, {\n    key: \"getModuleChunksIterable\",\n    value: function getModuleChunksIterable(module) {\n      var cgm = this._getChunkGraphModule(module);\n      return cgm.chunks;\n    }\n\n    /**\n     * @param {Module} module the module\n     * @param {function(Chunk, Chunk): -1|0|1} sortFn sort function\n     * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n     */\n  }, {\n    key: \"getOrderedModuleChunksIterable\",\n    value: function getOrderedModuleChunksIterable(module, sortFn) {\n      var cgm = this._getChunkGraphModule(module);\n      cgm.chunks.sortWith(sortFn);\n      return cgm.chunks;\n    }\n\n    /**\n     * @param {Module} module the module\n     * @returns {Chunk[]} array of chunks (cached, do not modify)\n     */\n  }, {\n    key: \"getModuleChunks\",\n    value: function getModuleChunks(module) {\n      var cgm = this._getChunkGraphModule(module);\n      return cgm.chunks.getFromCache(getArray);\n    }\n\n    /**\n     * @param {Module} module the module\n     * @returns {number} the number of chunk which contain the module\n     */\n  }, {\n    key: \"getNumberOfModuleChunks\",\n    value: function getNumberOfModuleChunks(module) {\n      var cgm = this._getChunkGraphModule(module);\n      return cgm.chunks.size;\n    }\n\n    /**\n     * @param {Module} module the module\n     * @returns {RuntimeSpecSet} runtimes\n     */\n  }, {\n    key: \"getModuleRuntimes\",\n    value: function getModuleRuntimes(module) {\n      var cgm = this._getChunkGraphModule(module);\n      return cgm.chunks.getFromUnorderedCache(_getModuleRuntimes);\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {number} the number of modules which are contained in this chunk\n     */\n  }, {\n    key: \"getNumberOfChunkModules\",\n    value: function getNumberOfChunkModules(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      return cgc.modules.size;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {number} the number of full hash modules which are contained in this chunk\n     */\n  }, {\n    key: \"getNumberOfChunkFullHashModules\",\n    value: function getNumberOfChunkFullHashModules(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      return cgc.fullHashModules === undefined ? 0 : cgc.fullHashModules.size;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Iterable<Module>} return the modules for this chunk\n     */\n  }, {\n    key: \"getChunkModulesIterable\",\n    value: function getChunkModulesIterable(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      return cgc.modules;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {string} sourceType source type\n     * @returns {Iterable<Module> | undefined} return the modules for this chunk\n     */\n  }, {\n    key: \"getChunkModulesIterableBySourceType\",\n    value: function getChunkModulesIterableBySourceType(chunk, sourceType) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      var modulesWithSourceType = cgc.modules.getFromUnorderedCache(cgc._modulesBySourceType).get(sourceType);\n      return modulesWithSourceType;\n    }\n\n    /**\n     * @param {Chunk} chunk chunk\n     * @param {Module} module chunk module\n     * @param {Set<string>} sourceTypes source types\n     */\n  }, {\n    key: \"setChunkModuleSourceTypes\",\n    value: function setChunkModuleSourceTypes(chunk, module, sourceTypes) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      if (cgc.sourceTypesByModule === undefined) {\n        cgc.sourceTypesByModule = new WeakMap();\n      }\n      cgc.sourceTypesByModule.set(module, sourceTypes);\n      // Update cgc._modulesBySourceType to invalidate the cache\n      cgc._modulesBySourceType = modulesBySourceType(cgc.sourceTypesByModule);\n    }\n\n    /**\n     * @param {Chunk} chunk chunk\n     * @param {Module} module chunk module\n     * @returns {Set<string>} source types\n     */\n  }, {\n    key: \"getChunkModuleSourceTypes\",\n    value: function getChunkModuleSourceTypes(chunk, module) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      if (cgc.sourceTypesByModule === undefined) {\n        return module.getSourceTypes();\n      }\n      return cgc.sourceTypesByModule.get(module) || module.getSourceTypes();\n    }\n\n    /**\n     * @param {Module} module module\n     * @returns {Set<string>} source types\n     */\n  }, {\n    key: \"getModuleSourceTypes\",\n    value: function getModuleSourceTypes(module) {\n      return this._getOverwrittenModuleSourceTypes(module) || module.getSourceTypes();\n    }\n\n    /**\n     * @param {Module} module module\n     * @returns {Set<string> | undefined} source types\n     */\n  }, {\n    key: \"_getOverwrittenModuleSourceTypes\",\n    value: function _getOverwrittenModuleSourceTypes(module) {\n      var newSet = false;\n      var sourceTypes;\n      var _iterator22 = _createForOfIteratorHelper(this.getModuleChunksIterable(module)),\n        _step22;\n      try {\n        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n          var chunk = _step22.value;\n          var cgc = this._getChunkGraphChunk(chunk);\n          if (cgc.sourceTypesByModule === undefined) return;\n          var st = cgc.sourceTypesByModule.get(module);\n          if (st === undefined) return;\n          if (!sourceTypes) {\n            sourceTypes = st;\n            continue;\n          } else if (!newSet) {\n            var _iterator23 = _createForOfIteratorHelper(st),\n              _step23;\n            try {\n              for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n                var type = _step23.value;\n                if (!newSet) {\n                  if (!sourceTypes.has(type)) {\n                    newSet = true;\n                    sourceTypes = new Set(sourceTypes);\n                    sourceTypes.add(type);\n                  }\n                } else {\n                  sourceTypes.add(type);\n                }\n              }\n            } catch (err) {\n              _iterator23.e(err);\n            } finally {\n              _iterator23.f();\n            }\n          } else {\n            var _iterator24 = _createForOfIteratorHelper(st),\n              _step24;\n            try {\n              for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n                var _type = _step24.value;\n                sourceTypes.add(_type);\n              }\n            } catch (err) {\n              _iterator24.e(err);\n            } finally {\n              _iterator24.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator22.e(err);\n      } finally {\n        _iterator22.f();\n      }\n      return sourceTypes;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {function(Module, Module): -1|0|1} comparator comparator function\n     * @returns {Iterable<Module>} return the modules for this chunk\n     */\n  }, {\n    key: \"getOrderedChunkModulesIterable\",\n    value: function getOrderedChunkModulesIterable(chunk, comparator) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      cgc.modules.sortWith(comparator);\n      return cgc.modules;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {string} sourceType source type\n     * @param {function(Module, Module): -1|0|1} comparator comparator function\n     * @returns {Iterable<Module> | undefined} return the modules for this chunk\n     */\n  }, {\n    key: \"getOrderedChunkModulesIterableBySourceType\",\n    value: function getOrderedChunkModulesIterableBySourceType(chunk, sourceType, comparator) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      var modulesWithSourceType = cgc.modules.getFromUnorderedCache(cgc._modulesBySourceType).get(sourceType);\n      if (modulesWithSourceType === undefined) return undefined;\n      modulesWithSourceType.sortWith(comparator);\n      return modulesWithSourceType;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n     */\n  }, {\n    key: \"getChunkModules\",\n    value: function getChunkModules(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      return cgc.modules.getFromUnorderedCache(getArray);\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {function(Module, Module): -1|0|1} comparator comparator function\n     * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n     */\n  }, {\n    key: \"getOrderedChunkModules\",\n    value: function getOrderedChunkModules(chunk, comparator) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      var arrayFunction = createOrderedArrayFunction(comparator);\n      return cgc.modules.getFromUnorderedCache(arrayFunction);\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {ModuleFilterPredicate} filterFn function used to filter modules\n     * @param {boolean} includeAllChunks all chunks or only async chunks\n     * @returns {Record<string|number, (string|number)[]>} chunk to module ids object\n     */\n  }, {\n    key: \"getChunkModuleIdMap\",\n    value: function getChunkModuleIdMap(chunk, filterFn) {\n      var includeAllChunks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      /** @type {Record<string|number, (string|number)[]>} */\n      var chunkModuleIdMap = Object.create(null);\n      var _iterator25 = _createForOfIteratorHelper(includeAllChunks ? chunk.getAllReferencedChunks() : chunk.getAllAsyncChunks()),\n        _step25;\n      try {\n        for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n          var asyncChunk = _step25.value;\n          /** @type {(string|number)[]} */\n          var array = void 0;\n          var _iterator26 = _createForOfIteratorHelper(this.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(this))),\n            _step26;\n          try {\n            for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n              var _module9 = _step26.value;\n              if (filterFn(_module9)) {\n                if (array === undefined) {\n                  array = [];\n                  chunkModuleIdMap[asyncChunk.id] = array;\n                }\n                var moduleId = this.getModuleId(_module9);\n                array.push(moduleId);\n              }\n            }\n          } catch (err) {\n            _iterator26.e(err);\n          } finally {\n            _iterator26.f();\n          }\n        }\n      } catch (err) {\n        _iterator25.e(err);\n      } finally {\n        _iterator25.f();\n      }\n      return chunkModuleIdMap;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {ModuleFilterPredicate} filterFn function used to filter modules\n     * @param {number} hashLength length of the hash\n     * @param {boolean} includeAllChunks all chunks or only async chunks\n     * @returns {Record<string|number, Record<string|number, string>>} chunk to module id to module hash object\n     */\n  }, {\n    key: \"getChunkModuleRenderedHashMap\",\n    value: function getChunkModuleRenderedHashMap(chunk, filterFn) {\n      var hashLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var includeAllChunks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      /** @type {Record<string|number, Record<string|number, string>>} */\n      var chunkModuleHashMap = Object.create(null);\n      var _iterator27 = _createForOfIteratorHelper(includeAllChunks ? chunk.getAllReferencedChunks() : chunk.getAllAsyncChunks()),\n        _step27;\n      try {\n        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n          var asyncChunk = _step27.value;\n          /** @type {Record<string|number, string>} */\n          var idToHashMap = void 0;\n          var _iterator28 = _createForOfIteratorHelper(this.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(this))),\n            _step28;\n          try {\n            for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n              var _module10 = _step28.value;\n              if (filterFn(_module10)) {\n                if (idToHashMap === undefined) {\n                  idToHashMap = Object.create(null);\n                  chunkModuleHashMap[asyncChunk.id] = idToHashMap;\n                }\n                var moduleId = this.getModuleId(_module10);\n                var hash = this.getRenderedModuleHash(_module10, asyncChunk.runtime);\n                idToHashMap[moduleId] = hashLength ? hash.slice(0, hashLength) : hash;\n              }\n            }\n          } catch (err) {\n            _iterator28.e(err);\n          } finally {\n            _iterator28.f();\n          }\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n      return chunkModuleHashMap;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {ChunkFilterPredicate} filterFn function used to filter chunks\n     * @returns {Record<string|number, boolean>} chunk map\n     */\n  }, {\n    key: \"getChunkConditionMap\",\n    value: function getChunkConditionMap(chunk, filterFn) {\n      var map = Object.create(null);\n      var _iterator29 = _createForOfIteratorHelper(chunk.getAllReferencedChunks()),\n        _step29;\n      try {\n        for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n          var c = _step29.value;\n          map[c.id] = filterFn(c, this);\n        }\n      } catch (err) {\n        _iterator29.e(err);\n      } finally {\n        _iterator29.f();\n      }\n      return map;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n     * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n     * @returns {boolean} return true if module exists in graph\n     */\n  }, {\n    key: \"hasModuleInGraph\",\n    value: function hasModuleInGraph(chunk, filterFn, filterChunkFn) {\n      var queue = new Set(chunk.groupsIterable);\n      var chunksProcessed = new Set();\n      var _iterator30 = _createForOfIteratorHelper(queue),\n        _step30;\n      try {\n        for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n          var chunkGroup = _step30.value;\n          var _iterator31 = _createForOfIteratorHelper(chunkGroup.chunks),\n            _step31;\n          try {\n            for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n              var innerChunk = _step31.value;\n              if (!chunksProcessed.has(innerChunk)) {\n                chunksProcessed.add(innerChunk);\n                if (!filterChunkFn || filterChunkFn(innerChunk, this)) {\n                  var _iterator33 = _createForOfIteratorHelper(this.getChunkModulesIterable(innerChunk)),\n                    _step33;\n                  try {\n                    for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n                      var _module11 = _step33.value;\n                      if (filterFn(_module11)) {\n                        return true;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator33.e(err);\n                  } finally {\n                    _iterator33.f();\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _iterator31.e(err);\n          } finally {\n            _iterator31.f();\n          }\n          var _iterator32 = _createForOfIteratorHelper(chunkGroup.childrenIterable),\n            _step32;\n          try {\n            for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n              var child = _step32.value;\n              queue.add(child);\n            }\n          } catch (err) {\n            _iterator32.e(err);\n          } finally {\n            _iterator32.f();\n          }\n        }\n      } catch (err) {\n        _iterator30.e(err);\n      } finally {\n        _iterator30.f();\n      }\n      return false;\n    }\n\n    /**\n     * @param {Chunk} chunkA first chunk\n     * @param {Chunk} chunkB second chunk\n     * @returns {-1|0|1} this is a comparator function like sort and returns -1, 0, or 1 based on sort order\n     */\n  }, {\n    key: \"compareChunks\",\n    value: function compareChunks(chunkA, chunkB) {\n      var cgcA = this._getChunkGraphChunk(chunkA);\n      var cgcB = this._getChunkGraphChunk(chunkB);\n      if (cgcA.modules.size > cgcB.modules.size) return -1;\n      if (cgcA.modules.size < cgcB.modules.size) return 1;\n      cgcA.modules.sortWith(compareModulesByIdentifier);\n      cgcB.modules.sortWith(compareModulesByIdentifier);\n      return compareModuleIterables(cgcA.modules, cgcB.modules);\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {number} total size of all modules in the chunk\n     */\n  }, {\n    key: \"getChunkModulesSize\",\n    value: function getChunkModulesSize(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      return cgc.modules.getFromUnorderedCache(getModulesSize);\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Record<string, number>} total sizes of all modules in the chunk by source type\n     */\n  }, {\n    key: \"getChunkModulesSizes\",\n    value: function getChunkModulesSizes(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      return cgc.modules.getFromUnorderedCache(getModulesSizes);\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Module[]} root modules of the chunks (ordered by identifier)\n     */\n  }, {\n    key: \"getChunkRootModules\",\n    value: function getChunkRootModules(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      return cgc.modules.getFromUnorderedCache(this._getGraphRoots);\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {ChunkSizeOptions} options options object\n     * @returns {number} total size of the chunk\n     */\n  }, {\n    key: \"getChunkSize\",\n    value: function getChunkSize(chunk) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var cgc = this._getChunkGraphChunk(chunk);\n      var modulesSize = cgc.modules.getFromUnorderedCache(getModulesSize);\n      var chunkOverhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n      var entryChunkMultiplicator = typeof options.entryChunkMultiplicator === \"number\" ? options.entryChunkMultiplicator : 10;\n      return chunkOverhead + modulesSize * (chunk.canBeInitial() ? entryChunkMultiplicator : 1);\n    }\n\n    /**\n     * @param {Chunk} chunkA chunk\n     * @param {Chunk} chunkB chunk\n     * @param {ChunkSizeOptions} options options object\n     * @returns {number} total size of the chunk or false if chunks can't be integrated\n     */\n  }, {\n    key: \"getIntegratedChunksSize\",\n    value: function getIntegratedChunksSize(chunkA, chunkB) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var cgcA = this._getChunkGraphChunk(chunkA);\n      var cgcB = this._getChunkGraphChunk(chunkB);\n      var allModules = new Set(cgcA.modules);\n      var _iterator34 = _createForOfIteratorHelper(cgcB.modules),\n        _step34;\n      try {\n        for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n          var m = _step34.value;\n          allModules.add(m);\n        }\n      } catch (err) {\n        _iterator34.e(err);\n      } finally {\n        _iterator34.f();\n      }\n      var modulesSize = getModulesSize(allModules);\n      var chunkOverhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n      var entryChunkMultiplicator = typeof options.entryChunkMultiplicator === \"number\" ? options.entryChunkMultiplicator : 10;\n      return chunkOverhead + modulesSize * (chunkA.canBeInitial() || chunkB.canBeInitial() ? entryChunkMultiplicator : 1);\n    }\n\n    /**\n     * @param {Chunk} chunkA chunk\n     * @param {Chunk} chunkB chunk\n     * @returns {boolean} true, if chunks could be integrated\n     */\n  }, {\n    key: \"canChunksBeIntegrated\",\n    value: function canChunksBeIntegrated(chunkA, chunkB) {\n      if (chunkA.preventIntegration || chunkB.preventIntegration) {\n        return false;\n      }\n      var hasRuntimeA = chunkA.hasRuntime();\n      var hasRuntimeB = chunkB.hasRuntime();\n      if (hasRuntimeA !== hasRuntimeB) {\n        if (hasRuntimeA) {\n          return isAvailableChunk(chunkA, chunkB);\n        } else if (hasRuntimeB) {\n          return isAvailableChunk(chunkB, chunkA);\n        } else {\n          return false;\n        }\n      }\n      if (this.getNumberOfEntryModules(chunkA) > 0 || this.getNumberOfEntryModules(chunkB) > 0) {\n        return false;\n      }\n      return true;\n    }\n\n    /**\n     * @param {Chunk} chunkA the target chunk\n     * @param {Chunk} chunkB the chunk to integrate\n     * @returns {void}\n     */\n  }, {\n    key: \"integrateChunks\",\n    value: function integrateChunks(chunkA, chunkB) {\n      // Decide for one name (deterministic)\n      if (chunkA.name && chunkB.name) {\n        if (this.getNumberOfEntryModules(chunkA) > 0 === this.getNumberOfEntryModules(chunkB) > 0) {\n          // When both chunks have entry modules or none have one, use\n          // shortest name\n          if (chunkA.name.length !== chunkB.name.length) {\n            chunkA.name = chunkA.name.length < chunkB.name.length ? chunkA.name : chunkB.name;\n          } else {\n            chunkA.name = chunkA.name < chunkB.name ? chunkA.name : chunkB.name;\n          }\n        } else if (this.getNumberOfEntryModules(chunkB) > 0) {\n          // Pick the name of the chunk with the entry module\n          chunkA.name = chunkB.name;\n        }\n      } else if (chunkB.name) {\n        chunkA.name = chunkB.name;\n      }\n\n      // Merge id name hints\n      var _iterator35 = _createForOfIteratorHelper(chunkB.idNameHints),\n        _step35;\n      try {\n        for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n          var hint = _step35.value;\n          chunkA.idNameHints.add(hint);\n        }\n\n        // Merge runtime\n      } catch (err) {\n        _iterator35.e(err);\n      } finally {\n        _iterator35.f();\n      }\n      chunkA.runtime = mergeRuntime(chunkA.runtime, chunkB.runtime);\n\n      // getChunkModules is used here to create a clone, because disconnectChunkAndModule modifies\n      var _iterator36 = _createForOfIteratorHelper(this.getChunkModules(chunkB)),\n        _step36;\n      try {\n        for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n          var _module13 = _step36.value;\n          this.disconnectChunkAndModule(chunkB, _module13);\n          this.connectChunkAndModule(chunkA, _module13);\n        }\n      } catch (err) {\n        _iterator36.e(err);\n      } finally {\n        _iterator36.f();\n      }\n      for (var _i = 0, _Array$from = Array.from(this.getChunkEntryModulesWithChunkGroupIterable(chunkB)); _i < _Array$from.length; _i++) {\n        var _Array$from$_i = _slicedToArray(_Array$from[_i], 2),\n          _module12 = _Array$from$_i[0],\n          chunkGroup = _Array$from$_i[1];\n        this.disconnectChunkAndEntryModule(chunkB, _module12);\n        this.connectChunkAndEntryModule(chunkA, _module12, chunkGroup);\n      }\n      var _iterator37 = _createForOfIteratorHelper(chunkB.groupsIterable),\n        _step37;\n      try {\n        for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {\n          var _chunkGroup = _step37.value;\n          _chunkGroup.replaceChunk(chunkB, chunkA);\n          chunkA.addGroup(_chunkGroup);\n          chunkB.removeGroup(_chunkGroup);\n        }\n      } catch (err) {\n        _iterator37.e(err);\n      } finally {\n        _iterator37.f();\n      }\n      ChunkGraph.clearChunkGraphForChunk(chunkB);\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk to upgrade\n     * @returns {void}\n     */\n  }, {\n    key: \"upgradeDependentToFullHashModules\",\n    value: function upgradeDependentToFullHashModules(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      if (cgc.dependentHashModules === undefined) return;\n      if (cgc.fullHashModules === undefined) {\n        cgc.fullHashModules = cgc.dependentHashModules;\n      } else {\n        var _iterator38 = _createForOfIteratorHelper(cgc.dependentHashModules),\n          _step38;\n        try {\n          for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {\n            var m = _step38.value;\n            cgc.fullHashModules.add(m);\n          }\n        } catch (err) {\n          _iterator38.e(err);\n        } finally {\n          _iterator38.f();\n        }\n        cgc.dependentHashModules = undefined;\n      }\n    }\n\n    /**\n     * @param {Module} module the checked module\n     * @param {Chunk} chunk the checked chunk\n     * @returns {boolean} true, if the chunk contains the module as entry\n     */\n  }, {\n    key: \"isEntryModuleInChunk\",\n    value: function isEntryModuleInChunk(module, chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      return cgc.entryModules.has(module);\n    }\n\n    /**\n     * @param {Chunk} chunk the new chunk\n     * @param {Module} module the entry module\n     * @param {Entrypoint=} entrypoint the chunk group which must be loaded before the module is executed\n     * @returns {void}\n     */\n  }, {\n    key: \"connectChunkAndEntryModule\",\n    value: function connectChunkAndEntryModule(chunk, module, entrypoint) {\n      var cgm = this._getChunkGraphModule(module);\n      var cgc = this._getChunkGraphChunk(chunk);\n      if (cgm.entryInChunks === undefined) {\n        cgm.entryInChunks = new Set();\n      }\n      cgm.entryInChunks.add(chunk);\n      cgc.entryModules.set(module, entrypoint);\n    }\n\n    /**\n     * @param {Chunk} chunk the new chunk\n     * @param {RuntimeModule} module the runtime module\n     * @returns {void}\n     */\n  }, {\n    key: \"connectChunkAndRuntimeModule\",\n    value: function connectChunkAndRuntimeModule(chunk, module) {\n      var cgm = this._getChunkGraphModule(module);\n      var cgc = this._getChunkGraphChunk(chunk);\n      if (cgm.runtimeInChunks === undefined) {\n        cgm.runtimeInChunks = new Set();\n      }\n      cgm.runtimeInChunks.add(chunk);\n      cgc.runtimeModules.add(module);\n    }\n\n    /**\n     * @param {Chunk} chunk the new chunk\n     * @param {RuntimeModule} module the module that require a full hash\n     * @returns {void}\n     */\n  }, {\n    key: \"addFullHashModuleToChunk\",\n    value: function addFullHashModuleToChunk(chunk, module) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      if (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n      cgc.fullHashModules.add(module);\n    }\n\n    /**\n     * @param {Chunk} chunk the new chunk\n     * @param {RuntimeModule} module the module that require a full hash\n     * @returns {void}\n     */\n  }, {\n    key: \"addDependentHashModuleToChunk\",\n    value: function addDependentHashModuleToChunk(chunk, module) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      if (cgc.dependentHashModules === undefined) cgc.dependentHashModules = new Set();\n      cgc.dependentHashModules.add(module);\n    }\n\n    /**\n     * @param {Chunk} chunk the new chunk\n     * @param {Module} module the entry module\n     * @returns {void}\n     */\n  }, {\n    key: \"disconnectChunkAndEntryModule\",\n    value: function disconnectChunkAndEntryModule(chunk, module) {\n      var cgm = this._getChunkGraphModule(module);\n      var cgc = this._getChunkGraphChunk(chunk);\n      cgm.entryInChunks.delete(chunk);\n      if (cgm.entryInChunks.size === 0) {\n        cgm.entryInChunks = undefined;\n      }\n      cgc.entryModules.delete(module);\n    }\n\n    /**\n     * @param {Chunk} chunk the new chunk\n     * @param {RuntimeModule} module the runtime module\n     * @returns {void}\n     */\n  }, {\n    key: \"disconnectChunkAndRuntimeModule\",\n    value: function disconnectChunkAndRuntimeModule(chunk, module) {\n      var cgm = this._getChunkGraphModule(module);\n      var cgc = this._getChunkGraphChunk(chunk);\n      cgm.runtimeInChunks.delete(chunk);\n      if (cgm.runtimeInChunks.size === 0) {\n        cgm.runtimeInChunks = undefined;\n      }\n      cgc.runtimeModules.delete(module);\n    }\n\n    /**\n     * @param {Module} module the entry module, it will no longer be entry\n     * @returns {void}\n     */\n  }, {\n    key: \"disconnectEntryModule\",\n    value: function disconnectEntryModule(module) {\n      var cgm = this._getChunkGraphModule(module);\n      var _iterator39 = _createForOfIteratorHelper(cgm.entryInChunks),\n        _step39;\n      try {\n        for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {\n          var chunk = _step39.value;\n          var cgc = this._getChunkGraphChunk(chunk);\n          cgc.entryModules.delete(module);\n        }\n      } catch (err) {\n        _iterator39.e(err);\n      } finally {\n        _iterator39.f();\n      }\n      cgm.entryInChunks = undefined;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk, for which all entries will be removed\n     * @returns {void}\n     */\n  }, {\n    key: \"disconnectEntries\",\n    value: function disconnectEntries(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      var _iterator40 = _createForOfIteratorHelper(cgc.entryModules.keys()),\n        _step40;\n      try {\n        for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {\n          var _module14 = _step40.value;\n          var cgm = this._getChunkGraphModule(_module14);\n          cgm.entryInChunks.delete(chunk);\n          if (cgm.entryInChunks.size === 0) {\n            cgm.entryInChunks = undefined;\n          }\n        }\n      } catch (err) {\n        _iterator40.e(err);\n      } finally {\n        _iterator40.f();\n      }\n      cgc.entryModules.clear();\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {number} the amount of entry modules in chunk\n     */\n  }, {\n    key: \"getNumberOfEntryModules\",\n    value: function getNumberOfEntryModules(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      return cgc.entryModules.size;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {number} the amount of entry modules in chunk\n     */\n  }, {\n    key: \"getNumberOfRuntimeModules\",\n    value: function getNumberOfRuntimeModules(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      return cgc.runtimeModules.size;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Iterable<Module>} iterable of modules (do not modify)\n     */\n  }, {\n    key: \"getChunkEntryModulesIterable\",\n    value: function getChunkEntryModulesIterable(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      return cgc.entryModules.keys();\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Iterable<Chunk>} iterable of chunks\n     */\n  }, {\n    key: \"getChunkEntryDependentChunksIterable\",\n    value: function getChunkEntryDependentChunksIterable(chunk) {\n      /** @type {Set<Chunk>} */\n      var set = new Set();\n      var _iterator41 = _createForOfIteratorHelper(chunk.groupsIterable),\n        _step41;\n      try {\n        for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {\n          var chunkGroup = _step41.value;\n          if (chunkGroup instanceof Entrypoint) {\n            var entrypointChunk = chunkGroup.getEntrypointChunk();\n            var cgc = this._getChunkGraphChunk(entrypointChunk);\n            var _iterator42 = _createForOfIteratorHelper(cgc.entryModules.values()),\n              _step42;\n            try {\n              for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {\n                var _chunkGroup2 = _step42.value;\n                var _iterator43 = _createForOfIteratorHelper(_chunkGroup2.chunks),\n                  _step43;\n                try {\n                  for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {\n                    var c = _step43.value;\n                    if (c !== chunk && c !== entrypointChunk && !c.hasRuntime()) {\n                      set.add(c);\n                    }\n                  }\n                } catch (err) {\n                  _iterator43.e(err);\n                } finally {\n                  _iterator43.f();\n                }\n              }\n            } catch (err) {\n              _iterator42.e(err);\n            } finally {\n              _iterator42.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator41.e(err);\n      } finally {\n        _iterator41.f();\n      }\n      return set;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {boolean} true, when it has dependent chunks\n     */\n  }, {\n    key: \"hasChunkEntryDependentChunks\",\n    value: function hasChunkEntryDependentChunks(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      var _iterator44 = _createForOfIteratorHelper(cgc.entryModules.values()),\n        _step44;\n      try {\n        for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {\n          var chunkGroup = _step44.value;\n          var _iterator45 = _createForOfIteratorHelper(chunkGroup.chunks),\n            _step45;\n          try {\n            for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {\n              var c = _step45.value;\n              if (c !== chunk) {\n                return true;\n              }\n            }\n          } catch (err) {\n            _iterator45.e(err);\n          } finally {\n            _iterator45.f();\n          }\n        }\n      } catch (err) {\n        _iterator44.e(err);\n      } finally {\n        _iterator44.f();\n      }\n      return false;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Iterable<RuntimeModule>} iterable of modules (do not modify)\n     */\n  }, {\n    key: \"getChunkRuntimeModulesIterable\",\n    value: function getChunkRuntimeModulesIterable(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      return cgc.runtimeModules;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {RuntimeModule[]} array of modules in order of execution\n     */\n  }, {\n    key: \"getChunkRuntimeModulesInOrder\",\n    value: function getChunkRuntimeModulesInOrder(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      var array = Array.from(cgc.runtimeModules);\n      array.sort(concatComparators(compareSelect(\n      /**\n       * @param {RuntimeModule} r runtime module\n       * @returns {number=} stage\n       */\n      function (r) {\n        return r.stage;\n      }, compareIds), compareModulesByIdentifier));\n      return array;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n     */\n  }, {\n    key: \"getChunkFullHashModulesIterable\",\n    value: function getChunkFullHashModulesIterable(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      return cgc.fullHashModules;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {ReadonlySet<RuntimeModule> | undefined} set of modules (do not modify)\n     */\n  }, {\n    key: \"getChunkFullHashModulesSet\",\n    value: function getChunkFullHashModulesSet(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      return cgc.fullHashModules;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n     */\n  }, {\n    key: \"getChunkDependentHashModulesIterable\",\n    value: function getChunkDependentHashModulesIterable(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      return cgc.dependentHashModules;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {Iterable<EntryModuleWithChunkGroup>} iterable of modules (do not modify)\n     */\n  }, {\n    key: \"getChunkEntryModulesWithChunkGroupIterable\",\n    value: function getChunkEntryModulesWithChunkGroupIterable(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      return cgc.entryModules;\n    }\n\n    /**\n     * @param {AsyncDependenciesBlock} depBlock the async block\n     * @returns {ChunkGroup} the chunk group\n     */\n  }, {\n    key: \"getBlockChunkGroup\",\n    value: function getBlockChunkGroup(depBlock) {\n      return this._blockChunkGroups.get(depBlock);\n    }\n\n    /**\n     * @param {AsyncDependenciesBlock} depBlock the async block\n     * @param {ChunkGroup} chunkGroup the chunk group\n     * @returns {void}\n     */\n  }, {\n    key: \"connectBlockAndChunkGroup\",\n    value: function connectBlockAndChunkGroup(depBlock, chunkGroup) {\n      this._blockChunkGroups.set(depBlock, chunkGroup);\n      chunkGroup.addBlock(depBlock);\n    }\n\n    /**\n     * @param {ChunkGroup} chunkGroup the chunk group\n     * @returns {void}\n     */\n  }, {\n    key: \"disconnectChunkGroup\",\n    value: function disconnectChunkGroup(chunkGroup) {\n      var _iterator46 = _createForOfIteratorHelper(chunkGroup.blocksIterable),\n        _step46;\n      try {\n        for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {\n          var block = _step46.value;\n          this._blockChunkGroups.delete(block);\n        }\n        // TODO refactor by moving blocks list into ChunkGraph\n      } catch (err) {\n        _iterator46.e(err);\n      } finally {\n        _iterator46.f();\n      }\n      chunkGroup._blocks.clear();\n    }\n\n    /**\n     * @param {Module} module the module\n     * @returns {string | number} the id of the module\n     */\n  }, {\n    key: \"getModuleId\",\n    value: function getModuleId(module) {\n      var cgm = this._getChunkGraphModule(module);\n      return cgm.id;\n    }\n\n    /**\n     * @param {Module} module the module\n     * @param {string | number} id the id of the module\n     * @returns {void}\n     */\n  }, {\n    key: \"setModuleId\",\n    value: function setModuleId(module, id) {\n      var cgm = this._getChunkGraphModule(module);\n      cgm.id = id;\n    }\n\n    /**\n     * @param {string} runtime runtime\n     * @returns {string | number} the id of the runtime\n     */\n  }, {\n    key: \"getRuntimeId\",\n    value: function getRuntimeId(runtime) {\n      return this._runtimeIds.get(runtime);\n    }\n\n    /**\n     * @param {string} runtime runtime\n     * @param {string | number} id the id of the runtime\n     * @returns {void}\n     */\n  }, {\n    key: \"setRuntimeId\",\n    value: function setRuntimeId(runtime, id) {\n      this._runtimeIds.set(runtime, id);\n    }\n\n    /**\n     * @template T\n     * @param {Module} module the module\n     * @param {RuntimeSpecMap<T>} hashes hashes data\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {T} hash\n     */\n  }, {\n    key: \"_getModuleHashInfo\",\n    value: function _getModuleHashInfo(module, hashes, runtime) {\n      if (!hashes) {\n        throw new Error(\"Module \".concat(module.identifier(), \" has no hash info for runtime \").concat(runtimeToString(runtime), \" (hashes not set at all)\"));\n      } else if (runtime === undefined) {\n        var hashInfoItems = new Set(hashes.values());\n        if (hashInfoItems.size !== 1) {\n          throw new Error(\"No unique hash info entry for unspecified runtime for \".concat(module.identifier(), \" (existing runtimes: \").concat(Array.from(hashes.keys(), function (r) {\n            return runtimeToString(r);\n          }).join(\", \"), \").\\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \\\"global\\\").\"));\n        }\n        return first(hashInfoItems);\n      } else {\n        var hashInfo = hashes.get(runtime);\n        if (!hashInfo) {\n          throw new Error(\"Module \".concat(module.identifier(), \" has no hash info for runtime \").concat(runtimeToString(runtime), \" (available runtimes \").concat(Array.from(hashes.keys(), runtimeToString).join(\", \"), \")\"));\n        }\n        return hashInfo;\n      }\n    }\n\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {boolean} true, if the module has hashes for this runtime\n     */\n  }, {\n    key: \"hasModuleHashes\",\n    value: function hasModuleHashes(module, runtime) {\n      var cgm = this._getChunkGraphModule(module);\n      var hashes = cgm.hashes;\n      return hashes && hashes.has(runtime);\n    }\n\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {string} hash\n     */\n  }, {\n    key: \"getModuleHash\",\n    value: function getModuleHash(module, runtime) {\n      var cgm = this._getChunkGraphModule(module);\n      var hashes = cgm.hashes;\n      return this._getModuleHashInfo(module, hashes, runtime).hash;\n    }\n\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {string} hash\n     */\n  }, {\n    key: \"getRenderedModuleHash\",\n    value: function getRenderedModuleHash(module, runtime) {\n      var cgm = this._getChunkGraphModule(module);\n      var hashes = cgm.hashes;\n      return this._getModuleHashInfo(module, hashes, runtime).renderedHash;\n    }\n\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @param {string} hash the full hash\n     * @param {string} renderedHash the shortened hash for rendering\n     * @returns {void}\n     */\n  }, {\n    key: \"setModuleHashes\",\n    value: function setModuleHashes(module, runtime, hash, renderedHash) {\n      var cgm = this._getChunkGraphModule(module);\n      if (cgm.hashes === undefined) {\n        cgm.hashes = new RuntimeSpecMap();\n      }\n      cgm.hashes.set(runtime, new ModuleHashInfo(hash, renderedHash));\n    }\n\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph when transferOwnership not false)\n     * @param {boolean} transferOwnership true: transfer ownership of the items object, false: items is immutable and shared and won't be modified\n     * @returns {void}\n     */\n  }, {\n    key: \"addModuleRuntimeRequirements\",\n    value: function addModuleRuntimeRequirements(module, runtime, items) {\n      var transferOwnership = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var cgm = this._getChunkGraphModule(module);\n      var runtimeRequirementsMap = cgm.runtimeRequirements;\n      if (runtimeRequirementsMap === undefined) {\n        var map = new RuntimeSpecMap();\n        // TODO avoid cloning item and track ownership instead\n        map.set(runtime, transferOwnership ? items : new Set(items));\n        cgm.runtimeRequirements = map;\n        return;\n      }\n      runtimeRequirementsMap.update(runtime, function (runtimeRequirements) {\n        if (runtimeRequirements === undefined) {\n          return transferOwnership ? items : new Set(items);\n        } else if (!transferOwnership || runtimeRequirements.size >= items.size) {\n          var _iterator47 = _createForOfIteratorHelper(items),\n            _step47;\n          try {\n            for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {\n              var item = _step47.value;\n              runtimeRequirements.add(item);\n            }\n          } catch (err) {\n            _iterator47.e(err);\n          } finally {\n            _iterator47.f();\n          }\n          return runtimeRequirements;\n        } else {\n          var _iterator48 = _createForOfIteratorHelper(runtimeRequirements),\n            _step48;\n          try {\n            for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {\n              var _item = _step48.value;\n              items.add(_item);\n            }\n          } catch (err) {\n            _iterator48.e(err);\n          } finally {\n            _iterator48.f();\n          }\n          return items;\n        }\n      });\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph)\n     * @returns {void}\n     */\n  }, {\n    key: \"addChunkRuntimeRequirements\",\n    value: function addChunkRuntimeRequirements(chunk, items) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      var runtimeRequirements = cgc.runtimeRequirements;\n      if (runtimeRequirements === undefined) {\n        cgc.runtimeRequirements = items;\n      } else if (runtimeRequirements.size >= items.size) {\n        var _iterator49 = _createForOfIteratorHelper(items),\n          _step49;\n        try {\n          for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {\n            var item = _step49.value;\n            runtimeRequirements.add(item);\n          }\n        } catch (err) {\n          _iterator49.e(err);\n        } finally {\n          _iterator49.f();\n        }\n      } else {\n        var _iterator50 = _createForOfIteratorHelper(runtimeRequirements),\n          _step50;\n        try {\n          for (_iterator50.s(); !(_step50 = _iterator50.n()).done;) {\n            var _item2 = _step50.value;\n            items.add(_item2);\n          }\n        } catch (err) {\n          _iterator50.e(err);\n        } finally {\n          _iterator50.f();\n        }\n        cgc.runtimeRequirements = items;\n      }\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {Iterable<string>} items runtime requirements to be added\n     * @returns {void}\n     */\n  }, {\n    key: \"addTreeRuntimeRequirements\",\n    value: function addTreeRuntimeRequirements(chunk, items) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      var runtimeRequirements = cgc.runtimeRequirementsInTree;\n      var _iterator51 = _createForOfIteratorHelper(items),\n        _step51;\n      try {\n        for (_iterator51.s(); !(_step51 = _iterator51.n()).done;) {\n          var item = _step51.value;\n          runtimeRequirements.add(item);\n        }\n      } catch (err) {\n        _iterator51.e(err);\n      } finally {\n        _iterator51.f();\n      }\n    }\n\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {ReadonlySet<string>} runtime requirements\n     */\n  }, {\n    key: \"getModuleRuntimeRequirements\",\n    value: function getModuleRuntimeRequirements(module, runtime) {\n      var cgm = this._getChunkGraphModule(module);\n      var runtimeRequirements = cgm.runtimeRequirements && cgm.runtimeRequirements.get(runtime);\n      return runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {ReadonlySet<string>} runtime requirements\n     */\n  }, {\n    key: \"getChunkRuntimeRequirements\",\n    value: function getChunkRuntimeRequirements(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      var runtimeRequirements = cgc.runtimeRequirements;\n      return runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n    }\n\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @param {boolean} withConnections include connections\n     * @returns {string} hash\n     */\n  }, {\n    key: \"getModuleGraphHash\",\n    value: function getModuleGraphHash(module, runtime) {\n      var withConnections = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var cgm = this._getChunkGraphModule(module);\n      return withConnections ? this._getModuleGraphHashWithConnections(cgm, module, runtime) : this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n    }\n\n    /**\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @param {boolean} withConnections include connections\n     * @returns {bigint} hash\n     */\n  }, {\n    key: \"getModuleGraphHashBigInt\",\n    value: function getModuleGraphHashBigInt(module, runtime) {\n      var withConnections = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var cgm = this._getChunkGraphModule(module);\n      return withConnections ? BigInt(\"0x\".concat(this._getModuleGraphHashWithConnections(cgm, module, runtime))) : this._getModuleGraphHashBigInt(cgm, module, runtime);\n    }\n\n    /**\n     * @param {ChunkGraphModule} cgm the ChunkGraphModule\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {bigint} hash as big int\n     */\n  }, {\n    key: \"_getModuleGraphHashBigInt\",\n    value: function _getModuleGraphHashBigInt(cgm, module, runtime) {\n      var _this = this;\n      if (cgm.graphHashes === undefined) {\n        cgm.graphHashes = new RuntimeSpecMap();\n      }\n      var graphHash = cgm.graphHashes.provide(runtime, function () {\n        var hash = createHash(_this._hashFunction);\n        hash.update(\"\".concat(cgm.id).concat(_this.moduleGraph.isAsync(module)));\n        var sourceTypes = _this._getOverwrittenModuleSourceTypes(module);\n        if (sourceTypes !== undefined) {\n          var _iterator52 = _createForOfIteratorHelper(sourceTypes),\n            _step52;\n          try {\n            for (_iterator52.s(); !(_step52 = _iterator52.n()).done;) {\n              var type = _step52.value;\n              hash.update(type);\n            }\n          } catch (err) {\n            _iterator52.e(err);\n          } finally {\n            _iterator52.f();\n          }\n        }\n        _this.moduleGraph.getExportsInfo(module).updateHash(hash, runtime);\n        return BigInt(\"0x\".concat( /** @type {string} */hash.digest(\"hex\")));\n      });\n      return graphHash;\n    }\n\n    /**\n     * @param {ChunkGraphModule} cgm the ChunkGraphModule\n     * @param {Module} module the module\n     * @param {RuntimeSpec} runtime the runtime\n     * @returns {string} hash\n     */\n  }, {\n    key: \"_getModuleGraphHashWithConnections\",\n    value: function _getModuleGraphHashWithConnections(cgm, module, runtime) {\n      var _this2 = this;\n      if (cgm.graphHashesWithConnections === undefined) {\n        cgm.graphHashesWithConnections = new RuntimeSpecMap();\n      }\n      var activeStateToString = function activeStateToString(state) {\n        if (state === false) return \"F\";\n        if (state === true) return \"T\";\n        if (state === ModuleGraphConnection.TRANSITIVE_ONLY) return \"O\";\n        throw new Error(\"Not implemented active state\");\n      };\n      var strict = module.buildMeta && module.buildMeta.strictHarmonyModule;\n      return cgm.graphHashesWithConnections.provide(runtime, function () {\n        var graphHash = _this2._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n        var connections = _this2.moduleGraph.getOutgoingConnections(module);\n        /** @type {Set<Module>} */\n        var activeNamespaceModules = new Set();\n        /** @type {Map<string, Module | Set<Module>>} */\n        var connectedModules = new Map();\n        var processConnection = function processConnection(connection, stateInfo) {\n          var module = connection.module;\n          stateInfo += module.getExportsType(_this2.moduleGraph, strict);\n          // cspell:word Tnamespace\n          if (stateInfo === \"Tnamespace\") activeNamespaceModules.add(module);else {\n            var oldModule = connectedModules.get(stateInfo);\n            if (oldModule === undefined) {\n              connectedModules.set(stateInfo, module);\n            } else if (oldModule instanceof Set) {\n              oldModule.add(module);\n            } else if (oldModule !== module) {\n              connectedModules.set(stateInfo, new Set([oldModule, module]));\n            }\n          }\n        };\n        if (runtime === undefined || typeof runtime === \"string\") {\n          var _iterator53 = _createForOfIteratorHelper(connections),\n            _step53;\n          try {\n            for (_iterator53.s(); !(_step53 = _iterator53.n()).done;) {\n              var connection = _step53.value;\n              var state = connection.getActiveState(runtime);\n              if (state === false) continue;\n              processConnection(connection, state === true ? \"T\" : \"O\");\n            }\n          } catch (err) {\n            _iterator53.e(err);\n          } finally {\n            _iterator53.f();\n          }\n        } else {\n          // cspell:word Tnamespace\n          var _iterator54 = _createForOfIteratorHelper(connections),\n            _step54;\n          try {\n            var _loop = function _loop() {\n              var connection = _step54.value;\n              var states = new Set();\n              var stateInfo = \"\";\n              forEachRuntime(runtime, function (runtime) {\n                var state = connection.getActiveState(runtime);\n                states.add(state);\n                stateInfo += activeStateToString(state) + runtime;\n              }, true);\n              if (states.size === 1) {\n                var _state = first(states);\n                if (_state === false) return \"continue\";\n                stateInfo = activeStateToString(_state);\n              }\n              processConnection(connection, stateInfo);\n            };\n            for (_iterator54.s(); !(_step54 = _iterator54.n()).done;) {\n              var _ret = _loop();\n              if (_ret === \"continue\") continue;\n            }\n          } catch (err) {\n            _iterator54.e(err);\n          } finally {\n            _iterator54.f();\n          }\n        }\n        // cspell:word Tnamespace\n        if (activeNamespaceModules.size === 0 && connectedModules.size === 0) return graphHash;\n        var connectedModulesInOrder = connectedModules.size > 1 ? Array.from(connectedModules).sort(function (_ref, _ref2) {\n          var _ref3 = _slicedToArray(_ref, 1),\n            a = _ref3[0];\n          var _ref4 = _slicedToArray(_ref2, 1),\n            b = _ref4[0];\n          return a < b ? -1 : 1;\n        }) : connectedModules;\n        var hash = createHash(_this2._hashFunction);\n        var addModuleToHash = function addModuleToHash(module) {\n          hash.update(_this2._getModuleGraphHashBigInt(_this2._getChunkGraphModule(module), module, runtime).toString(16));\n        };\n        var addModulesToHash = function addModulesToHash(modules) {\n          var xor = ZERO_BIG_INT;\n          var _iterator55 = _createForOfIteratorHelper(modules),\n            _step55;\n          try {\n            for (_iterator55.s(); !(_step55 = _iterator55.n()).done;) {\n              var m = _step55.value;\n              xor = xor ^ _this2._getModuleGraphHashBigInt(_this2._getChunkGraphModule(m), m, runtime);\n            }\n          } catch (err) {\n            _iterator55.e(err);\n          } finally {\n            _iterator55.f();\n          }\n          hash.update(xor.toString(16));\n        };\n        if (activeNamespaceModules.size === 1) addModuleToHash(activeNamespaceModules.values().next().value);else if (activeNamespaceModules.size > 1) addModulesToHash(activeNamespaceModules);\n        var _iterator56 = _createForOfIteratorHelper(connectedModulesInOrder),\n          _step56;\n        try {\n          for (_iterator56.s(); !(_step56 = _iterator56.n()).done;) {\n            var _step56$value = _slicedToArray(_step56.value, 2),\n              stateInfo = _step56$value[0],\n              modules = _step56$value[1];\n            hash.update(stateInfo);\n            if (modules instanceof Set) {\n              addModulesToHash(modules);\n            } else {\n              addModuleToHash(modules);\n            }\n          }\n        } catch (err) {\n          _iterator56.e(err);\n        } finally {\n          _iterator56.f();\n        }\n        hash.update(graphHash);\n        return (/** @type {string} */hash.digest(\"hex\")\n        );\n      });\n    }\n\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {ReadonlySet<string>} runtime requirements\n     */\n  }, {\n    key: \"getTreeRuntimeRequirements\",\n    value: function getTreeRuntimeRequirements(chunk) {\n      var cgc = this._getChunkGraphChunk(chunk);\n      return cgc.runtimeRequirementsInTree;\n    }\n\n    // TODO remove in webpack 6\n    /**\n     * @param {Module} module the module\n     * @param {string} deprecateMessage message for the deprecation message\n     * @param {string} deprecationCode code for the deprecation\n     * @returns {ChunkGraph} the chunk graph\n     */\n  }], [{\n    key: \"getChunkGraphForModule\",\n    value: function getChunkGraphForModule(module, deprecateMessage, deprecationCode) {\n      var fn = deprecateGetChunkGraphForModuleMap.get(deprecateMessage);\n      if (fn) return fn(module);\n      var newFn = util.deprecate(\n      /**\n       * @param {Module} module the module\n       * @returns {ChunkGraph} the chunk graph\n       */\n      function (module) {\n        var chunkGraph = chunkGraphForModuleMap.get(module);\n        if (!chunkGraph) throw new Error(deprecateMessage + \": There was no ChunkGraph assigned to the Module for backward-compat (Use the new API)\");\n        return chunkGraph;\n      }, deprecateMessage + \": Use new ChunkGraph API\", deprecationCode);\n      deprecateGetChunkGraphForModuleMap.set(deprecateMessage, newFn);\n      return newFn(module);\n    }\n\n    // TODO remove in webpack 6\n    /**\n     * @param {Module} module the module\n     * @param {ChunkGraph} chunkGraph the chunk graph\n     * @returns {void}\n     */\n  }, {\n    key: \"setChunkGraphForModule\",\n    value: function setChunkGraphForModule(module, chunkGraph) {\n      chunkGraphForModuleMap.set(module, chunkGraph);\n    }\n\n    // TODO remove in webpack 6\n    /**\n     * @param {Module} module the module\n     * @returns {void}\n     */\n  }, {\n    key: \"clearChunkGraphForModule\",\n    value: function clearChunkGraphForModule(module) {\n      chunkGraphForModuleMap.delete(module);\n    }\n\n    // TODO remove in webpack 6\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {string} deprecateMessage message for the deprecation message\n     * @param {string} deprecationCode code for the deprecation\n     * @returns {ChunkGraph} the chunk graph\n     */\n  }, {\n    key: \"getChunkGraphForChunk\",\n    value: function getChunkGraphForChunk(chunk, deprecateMessage, deprecationCode) {\n      var fn = deprecateGetChunkGraphForChunkMap.get(deprecateMessage);\n      if (fn) return fn(chunk);\n      var newFn = util.deprecate(\n      /**\n       * @param {Chunk} chunk the chunk\n       * @returns {ChunkGraph} the chunk graph\n       */\n      function (chunk) {\n        var chunkGraph = chunkGraphForChunkMap.get(chunk);\n        if (!chunkGraph) throw new Error(deprecateMessage + \"There was no ChunkGraph assigned to the Chunk for backward-compat (Use the new API)\");\n        return chunkGraph;\n      }, deprecateMessage + \": Use new ChunkGraph API\", deprecationCode);\n      deprecateGetChunkGraphForChunkMap.set(deprecateMessage, newFn);\n      return newFn(chunk);\n    }\n\n    // TODO remove in webpack 6\n    /**\n     * @param {Chunk} chunk the chunk\n     * @param {ChunkGraph} chunkGraph the chunk graph\n     * @returns {void}\n     */\n  }, {\n    key: \"setChunkGraphForChunk\",\n    value: function setChunkGraphForChunk(chunk, chunkGraph) {\n      chunkGraphForChunkMap.set(chunk, chunkGraph);\n    }\n\n    // TODO remove in webpack 6\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {void}\n     */\n  }, {\n    key: \"clearChunkGraphForChunk\",\n    value: function clearChunkGraphForChunk(chunk) {\n      chunkGraphForChunkMap.delete(chunk);\n    }\n  }]);\n  return ChunkGraph;\n}(); // TODO remove in webpack 6\n/** @type {WeakMap<Module, ChunkGraph>} */\nvar chunkGraphForModuleMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Chunk, ChunkGraph>} */\nvar chunkGraphForChunkMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (module: Module) => ChunkGraph>} */\nvar deprecateGetChunkGraphForModuleMap = new Map();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (chunk: Chunk) => ChunkGraph>} */\nvar deprecateGetChunkGraphForChunkMap = new Map();\nmodule.exports = ChunkGraph;","map":{"version":3,"names":["util","require","Entrypoint","ModuleGraphConnection","first","SortableSet","compareModulesById","compareIterables","compareModulesByIdentifier","concatComparators","compareSelect","compareIds","createHash","findGraphRoots","RuntimeSpecMap","RuntimeSpecSet","runtimeToString","mergeRuntime","forEachRuntime","EMPTY_SET","Set","ZERO_BIG_INT","BigInt","compareModuleIterables","ModuleHashInfo","hash","renderedHash","getArray","set","Array","from","getModuleRuntimes","chunks","runtimes","chunk","add","runtime","modulesBySourceType","sourceTypesByModule","map","Map","module","sourceTypes","get","getSourceTypes","sourceType","innerSet","undefined","key","size","defaultModulesBySourceType","createOrderedArrayFunctionMap","WeakMap","createOrderedArrayFunction","comparator","fn","sortWith","getModulesSize","modules","type","getModulesSizes","sizes","Object","create","isAvailableChunk","a","b","queue","groupsIterable","chunkGroup","isInGroup","isInitial","parentsIterable","parent","ChunkGraphModule","entryInChunks","runtimeInChunks","hashes","id","runtimeRequirements","graphHashes","graphHashesWithConnections","ChunkGraphChunk","entryModules","runtimeModules","fullHashModules","dependentHashModules","runtimeRequirementsInTree","_modulesBySourceType","ChunkGraph","moduleGraph","hashFunction","_modules","_chunks","_blockChunkGroups","_runtimeIds","_hashFunction","_getGraphRoots","bind","cgm","cgc","addDependencies","getOutgoingConnections","connection","activeState","getActiveState","TRANSITIVE_ONLY","sort","_getChunkGraphModule","_getChunkGraphChunk","delete","clear","disconnectFromGroups","clearChunkGraphForChunk","oldModule","newModule","oldCgm","newCgm","old","newEntryModules","m","cg","has","isModuleInChunk","sortFn","getFromCache","getFromUnorderedCache","modulesWithSourceType","_getOverwrittenModuleSourceTypes","newSet","getModuleChunksIterable","st","arrayFunction","filterFn","includeAllChunks","chunkModuleIdMap","getAllReferencedChunks","getAllAsyncChunks","asyncChunk","array","getOrderedChunkModulesIterable","moduleId","getModuleId","push","hashLength","chunkModuleHashMap","idToHashMap","getRenderedModuleHash","slice","c","filterChunkFn","chunksProcessed","innerChunk","getChunkModulesIterable","childrenIterable","child","chunkA","chunkB","cgcA","cgcB","options","modulesSize","chunkOverhead","entryChunkMultiplicator","canBeInitial","allModules","preventIntegration","hasRuntimeA","hasRuntime","hasRuntimeB","getNumberOfEntryModules","name","length","idNameHints","hint","getChunkModules","disconnectChunkAndModule","connectChunkAndModule","getChunkEntryModulesWithChunkGroupIterable","disconnectChunkAndEntryModule","connectChunkAndEntryModule","replaceChunk","addGroup","removeGroup","entrypoint","keys","entrypointChunk","getEntrypointChunk","values","r","stage","depBlock","addBlock","blocksIterable","block","_blocks","Error","identifier","hashInfoItems","join","hashInfo","_getModuleHashInfo","items","transferOwnership","runtimeRequirementsMap","update","item","withConnections","_getModuleGraphHashWithConnections","_getModuleGraphHashBigInt","toString","graphHash","provide","isAsync","getExportsInfo","updateHash","digest","activeStateToString","state","strict","buildMeta","strictHarmonyModule","connections","activeNamespaceModules","connectedModules","processConnection","stateInfo","getExportsType","states","connectedModulesInOrder","addModuleToHash","addModulesToHash","xor","next","value","deprecateMessage","deprecationCode","deprecateGetChunkGraphForModuleMap","newFn","deprecate","chunkGraph","chunkGraphForModuleMap","deprecateGetChunkGraphForChunkMap","chunkGraphForChunkMap","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/ChunkGraph.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst util = require(\"util\");\nconst Entrypoint = require(\"./Entrypoint\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst { first } = require(\"./util/SetHelpers\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst {\n\tcompareModulesById,\n\tcompareIterables,\n\tcompareModulesByIdentifier,\n\tconcatComparators,\n\tcompareSelect,\n\tcompareIds\n} = require(\"./util/comparators\");\nconst createHash = require(\"./util/createHash\");\nconst findGraphRoots = require(\"./util/findGraphRoots\");\nconst {\n\tRuntimeSpecMap,\n\tRuntimeSpecSet,\n\truntimeToString,\n\tmergeRuntime,\n\tforEachRuntime\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @type {ReadonlySet<string>} */\nconst EMPTY_SET = new Set();\n\nconst ZERO_BIG_INT = BigInt(0);\n\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n\n/** @typedef {(c: Chunk, chunkGraph: ChunkGraph) => boolean} ChunkFilterPredicate */\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n/** @typedef {[Module, Entrypoint | undefined]} EntryModuleWithChunkGroup */\n\n/**\n * @typedef {Object} ChunkSizeOptions\n * @property {number=} chunkOverhead constant overhead for a chunk\n * @property {number=} entryChunkMultiplicator multiplicator for initial chunks\n */\n\nclass ModuleHashInfo {\n\tconstructor(hash, renderedHash) {\n\t\tthis.hash = hash;\n\t\tthis.renderedHash = renderedHash;\n\t}\n}\n\n/** @template T @typedef {(set: SortableSet<T>) => T[]} SetToArrayFunction<T> */\n\n/**\n * @template T\n * @param {SortableSet<T>} set the set\n * @returns {T[]} set as array\n */\nconst getArray = set => {\n\treturn Array.from(set);\n};\n\n/**\n * @param {SortableSet<Chunk>} chunks the chunks\n * @returns {RuntimeSpecSet} runtimes\n */\nconst getModuleRuntimes = chunks => {\n\tconst runtimes = new RuntimeSpecSet();\n\tfor (const chunk of chunks) {\n\t\truntimes.add(chunk.runtime);\n\t}\n\treturn runtimes;\n};\n\n/**\n * @param {WeakMap<Module, Set<string>> | undefined} sourceTypesByModule sourceTypesByModule\n * @returns {function (SortableSet<Module>): Map<string, SortableSet<Module>>} modules by source type\n */\nconst modulesBySourceType = sourceTypesByModule => set => {\n\t/** @type {Map<string, SortableSet<Module>>} */\n\tconst map = new Map();\n\tfor (const module of set) {\n\t\tconst sourceTypes =\n\t\t\t(sourceTypesByModule && sourceTypesByModule.get(module)) ||\n\t\t\tmodule.getSourceTypes();\n\t\tfor (const sourceType of sourceTypes) {\n\t\t\tlet innerSet = map.get(sourceType);\n\t\t\tif (innerSet === undefined) {\n\t\t\t\tinnerSet = new SortableSet();\n\t\t\t\tmap.set(sourceType, innerSet);\n\t\t\t}\n\t\t\tinnerSet.add(module);\n\t\t}\n\t}\n\tfor (const [key, innerSet] of map) {\n\t\t// When all modules have the source type, we reuse the original SortableSet\n\t\t// to benefit from the shared cache (especially for sorting)\n\t\tif (innerSet.size === set.size) {\n\t\t\tmap.set(key, set);\n\t\t}\n\t}\n\treturn map;\n};\nconst defaultModulesBySourceType = modulesBySourceType(undefined);\n\n/** @type {WeakMap<Function, any>} */\nconst createOrderedArrayFunctionMap = new WeakMap();\n\n/**\n * @template T\n * @param {function(T, T): -1|0|1} comparator comparator function\n * @returns {SetToArrayFunction<T>} set as ordered array\n */\nconst createOrderedArrayFunction = comparator => {\n\t/** @type {SetToArrayFunction<T>} */\n\tlet fn = createOrderedArrayFunctionMap.get(comparator);\n\tif (fn !== undefined) return fn;\n\tfn = set => {\n\t\tset.sortWith(comparator);\n\t\treturn Array.from(set);\n\t};\n\tcreateOrderedArrayFunctionMap.set(comparator, fn);\n\treturn fn;\n};\n\n/**\n * @param {Iterable<Module>} modules the modules to get the count/size of\n * @returns {number} the size of the modules\n */\nconst getModulesSize = modules => {\n\tlet size = 0;\n\tfor (const module of modules) {\n\t\tfor (const type of module.getSourceTypes()) {\n\t\t\tsize += module.size(type);\n\t\t}\n\t}\n\treturn size;\n};\n\n/**\n * @param {Iterable<Module>} modules the sortable Set to get the size of\n * @returns {Record<string, number>} the sizes of the modules\n */\nconst getModulesSizes = modules => {\n\tlet sizes = Object.create(null);\n\tfor (const module of modules) {\n\t\tfor (const type of module.getSourceTypes()) {\n\t\t\tsizes[type] = (sizes[type] || 0) + module.size(type);\n\t\t}\n\t}\n\treturn sizes;\n};\n\n/**\n * @param {Chunk} a chunk\n * @param {Chunk} b chunk\n * @returns {boolean} true, if a is always a parent of b\n */\nconst isAvailableChunk = (a, b) => {\n\tconst queue = new Set(b.groupsIterable);\n\tfor (const chunkGroup of queue) {\n\t\tif (a.isInGroup(chunkGroup)) continue;\n\t\tif (chunkGroup.isInitial()) return false;\n\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\tqueue.add(parent);\n\t\t}\n\t}\n\treturn true;\n};\n\nclass ChunkGraphModule {\n\tconstructor() {\n\t\t/** @type {SortableSet<Chunk>} */\n\t\tthis.chunks = new SortableSet();\n\t\t/** @type {Set<Chunk> | undefined} */\n\t\tthis.entryInChunks = undefined;\n\t\t/** @type {Set<Chunk> | undefined} */\n\t\tthis.runtimeInChunks = undefined;\n\t\t/** @type {RuntimeSpecMap<ModuleHashInfo>} */\n\t\tthis.hashes = undefined;\n\t\t/** @type {string | number} */\n\t\tthis.id = null;\n\t\t/** @type {RuntimeSpecMap<Set<string>> | undefined} */\n\t\tthis.runtimeRequirements = undefined;\n\t\t/** @type {RuntimeSpecMap<string>} */\n\t\tthis.graphHashes = undefined;\n\t\t/** @type {RuntimeSpecMap<string>} */\n\t\tthis.graphHashesWithConnections = undefined;\n\t}\n}\n\nclass ChunkGraphChunk {\n\tconstructor() {\n\t\t/** @type {SortableSet<Module>} */\n\t\tthis.modules = new SortableSet();\n\t\t/** @type {WeakMap<Module, Set<string>> | undefined} */\n\t\tthis.sourceTypesByModule = undefined;\n\t\t/** @type {Map<Module, Entrypoint>} */\n\t\tthis.entryModules = new Map();\n\t\t/** @type {SortableSet<RuntimeModule>} */\n\t\tthis.runtimeModules = new SortableSet();\n\t\t/** @type {Set<RuntimeModule> | undefined} */\n\t\tthis.fullHashModules = undefined;\n\t\t/** @type {Set<RuntimeModule> | undefined} */\n\t\tthis.dependentHashModules = undefined;\n\t\t/** @type {Set<string> | undefined} */\n\t\tthis.runtimeRequirements = undefined;\n\t\t/** @type {Set<string>} */\n\t\tthis.runtimeRequirementsInTree = new Set();\n\n\t\tthis._modulesBySourceType = defaultModulesBySourceType;\n\t}\n}\n\nclass ChunkGraph {\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {string | Hash} hashFunction the hash function to use\n\t */\n\tconstructor(moduleGraph, hashFunction = \"md4\") {\n\t\t/** @private @type {WeakMap<Module, ChunkGraphModule>} */\n\t\tthis._modules = new WeakMap();\n\t\t/** @private @type {WeakMap<Chunk, ChunkGraphChunk>} */\n\t\tthis._chunks = new WeakMap();\n\t\t/** @private @type {WeakMap<AsyncDependenciesBlock, ChunkGroup>} */\n\t\tthis._blockChunkGroups = new WeakMap();\n\t\t/** @private @type {Map<string, string | number>} */\n\t\tthis._runtimeIds = new Map();\n\t\t/** @type {ModuleGraph} */\n\t\tthis.moduleGraph = moduleGraph;\n\n\t\tthis._hashFunction = hashFunction;\n\n\t\tthis._getGraphRoots = this._getGraphRoots.bind(this);\n\t}\n\n\t/**\n\t * @private\n\t * @param {Module} module the module\n\t * @returns {ChunkGraphModule} internal module\n\t */\n\t_getChunkGraphModule(module) {\n\t\tlet cgm = this._modules.get(module);\n\t\tif (cgm === undefined) {\n\t\t\tcgm = new ChunkGraphModule();\n\t\t\tthis._modules.set(module, cgm);\n\t\t}\n\t\treturn cgm;\n\t}\n\n\t/**\n\t * @private\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ChunkGraphChunk} internal chunk\n\t */\n\t_getChunkGraphChunk(chunk) {\n\t\tlet cgc = this._chunks.get(chunk);\n\t\tif (cgc === undefined) {\n\t\t\tcgc = new ChunkGraphChunk();\n\t\t\tthis._chunks.set(chunk, cgc);\n\t\t}\n\t\treturn cgc;\n\t}\n\n\t/**\n\t * @param {SortableSet<Module>} set the sortable Set to get the roots of\n\t * @returns {Module[]} the graph roots\n\t */\n\t_getGraphRoots(set) {\n\t\tconst { moduleGraph } = this;\n\t\treturn Array.from(\n\t\t\tfindGraphRoots(set, module => {\n\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\tconst set = new Set();\n\t\t\t\tconst addDependencies = module => {\n\t\t\t\t\tfor (const connection of moduleGraph.getOutgoingConnections(module)) {\n\t\t\t\t\t\tif (!connection.module) continue;\n\t\t\t\t\t\tconst activeState = connection.getActiveState(undefined);\n\t\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t\t\tif (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n\t\t\t\t\t\t\taddDependencies(connection.module);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tset.add(connection.module);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\taddDependencies(module);\n\t\t\t\treturn set;\n\t\t\t})\n\t\t).sort(compareModulesByIdentifier);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tconnectChunkAndModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgm.chunks.add(chunk);\n\t\tcgc.modules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tdisconnectChunkAndModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgc.modules.delete(module);\n\t\t// No need to invalidate cgc._modulesBySourceType because we modified cgc.modules anyway\n\t\tif (cgc.sourceTypesByModule) cgc.sourceTypesByModule.delete(module);\n\t\tcgm.chunks.delete(chunk);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk which will be disconnected\n\t * @returns {void}\n\t */\n\tdisconnectChunk(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of cgc.modules) {\n\t\t\tconst cgm = this._getChunkGraphModule(module);\n\t\t\tcgm.chunks.delete(chunk);\n\t\t}\n\t\tcgc.modules.clear();\n\t\tchunk.disconnectFromGroups();\n\t\tChunkGraph.clearChunkGraphForChunk(chunk);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<Module>} modules the modules\n\t * @returns {void}\n\t */\n\tattachModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of modules) {\n\t\t\tcgc.modules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<RuntimeModule>} modules the runtime modules\n\t * @returns {void}\n\t */\n\tattachRuntimeModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of modules) {\n\t\t\tcgc.runtimeModules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n\t * @returns {void}\n\t */\n\tattachFullHashModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n\t\tfor (const module of modules) {\n\t\t\tcgc.fullHashModules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n\t * @returns {void}\n\t */\n\tattachDependentHashModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.dependentHashModules === undefined)\n\t\t\tcgc.dependentHashModules = new Set();\n\t\tfor (const module of modules) {\n\t\t\tcgc.dependentHashModules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} oldModule the replaced module\n\t * @param {Module} newModule the replacing module\n\t * @returns {void}\n\t */\n\treplaceModule(oldModule, newModule) {\n\t\tconst oldCgm = this._getChunkGraphModule(oldModule);\n\t\tconst newCgm = this._getChunkGraphModule(newModule);\n\n\t\tfor (const chunk of oldCgm.chunks) {\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\tcgc.modules.delete(oldModule);\n\t\t\tcgc.modules.add(newModule);\n\t\t\tnewCgm.chunks.add(chunk);\n\t\t}\n\t\toldCgm.chunks.clear();\n\n\t\tif (oldCgm.entryInChunks !== undefined) {\n\t\t\tif (newCgm.entryInChunks === undefined) {\n\t\t\t\tnewCgm.entryInChunks = new Set();\n\t\t\t}\n\t\t\tfor (const chunk of oldCgm.entryInChunks) {\n\t\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\t\tconst old = cgc.entryModules.get(oldModule);\n\t\t\t\t/** @type {Map<Module, Entrypoint>} */\n\t\t\t\tconst newEntryModules = new Map();\n\t\t\t\tfor (const [m, cg] of cgc.entryModules) {\n\t\t\t\t\tif (m === oldModule) {\n\t\t\t\t\t\tnewEntryModules.set(newModule, old);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewEntryModules.set(m, cg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcgc.entryModules = newEntryModules;\n\t\t\t\tnewCgm.entryInChunks.add(chunk);\n\t\t\t}\n\t\t\toldCgm.entryInChunks = undefined;\n\t\t}\n\n\t\tif (oldCgm.runtimeInChunks !== undefined) {\n\t\t\tif (newCgm.runtimeInChunks === undefined) {\n\t\t\t\tnewCgm.runtimeInChunks = new Set();\n\t\t\t}\n\t\t\tfor (const chunk of oldCgm.runtimeInChunks) {\n\t\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\t\tcgc.runtimeModules.delete(/** @type {RuntimeModule} */ (oldModule));\n\t\t\t\tcgc.runtimeModules.add(/** @type {RuntimeModule} */ (newModule));\n\t\t\t\tnewCgm.runtimeInChunks.add(chunk);\n\t\t\t\tif (\n\t\t\t\t\tcgc.fullHashModules !== undefined &&\n\t\t\t\t\tcgc.fullHashModules.has(/** @type {RuntimeModule} */ (oldModule))\n\t\t\t\t) {\n\t\t\t\t\tcgc.fullHashModules.delete(/** @type {RuntimeModule} */ (oldModule));\n\t\t\t\t\tcgc.fullHashModules.add(/** @type {RuntimeModule} */ (newModule));\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tcgc.dependentHashModules !== undefined &&\n\t\t\t\t\tcgc.dependentHashModules.has(/** @type {RuntimeModule} */ (oldModule))\n\t\t\t\t) {\n\t\t\t\t\tcgc.dependentHashModules.delete(\n\t\t\t\t\t\t/** @type {RuntimeModule} */ (oldModule)\n\t\t\t\t\t);\n\t\t\t\t\tcgc.dependentHashModules.add(\n\t\t\t\t\t\t/** @type {RuntimeModule} */ (newModule)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\toldCgm.runtimeInChunks = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @param {Chunk} chunk the checked chunk\n\t * @returns {boolean} true, if the chunk contains the module\n\t */\n\tisModuleInChunk(module, chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.has(module);\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @param {ChunkGroup} chunkGroup the checked chunk group\n\t * @returns {boolean} true, if the chunk contains the module\n\t */\n\tisModuleInChunkGroup(module, chunkGroup) {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tif (this.isModuleInChunk(module, chunk)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @returns {boolean} true, if the module is entry of any chunk\n\t */\n\tisEntryModule(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.entryInChunks !== undefined;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n\t */\n\tgetModuleChunksIterable(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {function(Chunk, Chunk): -1|0|1} sortFn sort function\n\t * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n\t */\n\tgetOrderedModuleChunksIterable(module, sortFn) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tcgm.chunks.sortWith(sortFn);\n\t\treturn cgm.chunks;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {Chunk[]} array of chunks (cached, do not modify)\n\t */\n\tgetModuleChunks(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks.getFromCache(getArray);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {number} the number of chunk which contain the module\n\t */\n\tgetNumberOfModuleChunks(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks.size;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {RuntimeSpecSet} runtimes\n\t */\n\tgetModuleRuntimes(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks.getFromUnorderedCache(getModuleRuntimes);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the number of modules which are contained in this chunk\n\t */\n\tgetNumberOfChunkModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the number of full hash modules which are contained in this chunk\n\t */\n\tgetNumberOfChunkFullHashModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.fullHashModules === undefined ? 0 : cgc.fullHashModules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<Module>} return the modules for this chunk\n\t */\n\tgetChunkModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {string} sourceType source type\n\t * @returns {Iterable<Module> | undefined} return the modules for this chunk\n\t */\n\tgetChunkModulesIterableBySourceType(chunk, sourceType) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst modulesWithSourceType = cgc.modules\n\t\t\t.getFromUnorderedCache(cgc._modulesBySourceType)\n\t\t\t.get(sourceType);\n\t\treturn modulesWithSourceType;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk chunk\n\t * @param {Module} module chunk module\n\t * @param {Set<string>} sourceTypes source types\n\t */\n\tsetChunkModuleSourceTypes(chunk, module, sourceTypes) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.sourceTypesByModule === undefined) {\n\t\t\tcgc.sourceTypesByModule = new WeakMap();\n\t\t}\n\t\tcgc.sourceTypesByModule.set(module, sourceTypes);\n\t\t// Update cgc._modulesBySourceType to invalidate the cache\n\t\tcgc._modulesBySourceType = modulesBySourceType(cgc.sourceTypesByModule);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk chunk\n\t * @param {Module} module chunk module\n\t * @returns {Set<string>} source types\n\t */\n\tgetChunkModuleSourceTypes(chunk, module) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.sourceTypesByModule === undefined) {\n\t\t\treturn module.getSourceTypes();\n\t\t}\n\t\treturn cgc.sourceTypesByModule.get(module) || module.getSourceTypes();\n\t}\n\n\t/**\n\t * @param {Module} module module\n\t * @returns {Set<string>} source types\n\t */\n\tgetModuleSourceTypes(module) {\n\t\treturn (\n\t\t\tthis._getOverwrittenModuleSourceTypes(module) || module.getSourceTypes()\n\t\t);\n\t}\n\n\t/**\n\t * @param {Module} module module\n\t * @returns {Set<string> | undefined} source types\n\t */\n\t_getOverwrittenModuleSourceTypes(module) {\n\t\tlet newSet = false;\n\t\tlet sourceTypes;\n\t\tfor (const chunk of this.getModuleChunksIterable(module)) {\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\tif (cgc.sourceTypesByModule === undefined) return;\n\t\t\tconst st = cgc.sourceTypesByModule.get(module);\n\t\t\tif (st === undefined) return;\n\t\t\tif (!sourceTypes) {\n\t\t\t\tsourceTypes = st;\n\t\t\t\tcontinue;\n\t\t\t} else if (!newSet) {\n\t\t\t\tfor (const type of st) {\n\t\t\t\t\tif (!newSet) {\n\t\t\t\t\t\tif (!sourceTypes.has(type)) {\n\t\t\t\t\t\t\tnewSet = true;\n\t\t\t\t\t\t\tsourceTypes = new Set(sourceTypes);\n\t\t\t\t\t\t\tsourceTypes.add(type);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsourceTypes.add(type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const type of st) sourceTypes.add(type);\n\t\t\t}\n\t\t}\n\n\t\treturn sourceTypes;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\n\t * @returns {Iterable<Module>} return the modules for this chunk\n\t */\n\tgetOrderedChunkModulesIterable(chunk, comparator) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgc.modules.sortWith(comparator);\n\t\treturn cgc.modules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {string} sourceType source type\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\n\t * @returns {Iterable<Module> | undefined} return the modules for this chunk\n\t */\n\tgetOrderedChunkModulesIterableBySourceType(chunk, sourceType, comparator) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst modulesWithSourceType = cgc.modules\n\t\t\t.getFromUnorderedCache(cgc._modulesBySourceType)\n\t\t\t.get(sourceType);\n\t\tif (modulesWithSourceType === undefined) return undefined;\n\t\tmodulesWithSourceType.sortWith(comparator);\n\t\treturn modulesWithSourceType;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n\t */\n\tgetChunkModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(getArray);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\n\t * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n\t */\n\tgetOrderedChunkModules(chunk, comparator) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst arrayFunction = createOrderedArrayFunction(comparator);\n\t\treturn cgc.modules.getFromUnorderedCache(arrayFunction);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @param {boolean} includeAllChunks all chunks or only async chunks\n\t * @returns {Record<string|number, (string|number)[]>} chunk to module ids object\n\t */\n\tgetChunkModuleIdMap(chunk, filterFn, includeAllChunks = false) {\n\t\t/** @type {Record<string|number, (string|number)[]>} */\n\t\tconst chunkModuleIdMap = Object.create(null);\n\n\t\tfor (const asyncChunk of includeAllChunks\n\t\t\t? chunk.getAllReferencedChunks()\n\t\t\t: chunk.getAllAsyncChunks()) {\n\t\t\t/** @type {(string|number)[]} */\n\t\t\tlet array;\n\t\t\tfor (const module of this.getOrderedChunkModulesIterable(\n\t\t\t\tasyncChunk,\n\t\t\t\tcompareModulesById(this)\n\t\t\t)) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tchunkModuleIdMap[asyncChunk.id] = array;\n\t\t\t\t\t}\n\t\t\t\t\tconst moduleId = this.getModuleId(module);\n\t\t\t\t\tarray.push(moduleId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chunkModuleIdMap;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @param {number} hashLength length of the hash\n\t * @param {boolean} includeAllChunks all chunks or only async chunks\n\t * @returns {Record<string|number, Record<string|number, string>>} chunk to module id to module hash object\n\t */\n\tgetChunkModuleRenderedHashMap(\n\t\tchunk,\n\t\tfilterFn,\n\t\thashLength = 0,\n\t\tincludeAllChunks = false\n\t) {\n\t\t/** @type {Record<string|number, Record<string|number, string>>} */\n\t\tconst chunkModuleHashMap = Object.create(null);\n\n\t\tfor (const asyncChunk of includeAllChunks\n\t\t\t? chunk.getAllReferencedChunks()\n\t\t\t: chunk.getAllAsyncChunks()) {\n\t\t\t/** @type {Record<string|number, string>} */\n\t\t\tlet idToHashMap;\n\t\t\tfor (const module of this.getOrderedChunkModulesIterable(\n\t\t\t\tasyncChunk,\n\t\t\t\tcompareModulesById(this)\n\t\t\t)) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (idToHashMap === undefined) {\n\t\t\t\t\t\tidToHashMap = Object.create(null);\n\t\t\t\t\t\tchunkModuleHashMap[asyncChunk.id] = idToHashMap;\n\t\t\t\t\t}\n\t\t\t\t\tconst moduleId = this.getModuleId(module);\n\t\t\t\t\tconst hash = this.getRenderedModuleHash(module, asyncChunk.runtime);\n\t\t\t\t\tidToHashMap[moduleId] = hashLength ? hash.slice(0, hashLength) : hash;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chunkModuleHashMap;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ChunkFilterPredicate} filterFn function used to filter chunks\n\t * @returns {Record<string|number, boolean>} chunk map\n\t */\n\tgetChunkConditionMap(chunk, filterFn) {\n\t\tconst map = Object.create(null);\n\t\tfor (const c of chunk.getAllReferencedChunks()) {\n\t\t\tmap[c.id] = filterFn(c, this);\n\t\t}\n\t\treturn map;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n\t * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n\t * @returns {boolean} return true if module exists in graph\n\t */\n\thasModuleInGraph(chunk, filterFn, filterChunkFn) {\n\t\tconst queue = new Set(chunk.groupsIterable);\n\t\tconst chunksProcessed = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const innerChunk of chunkGroup.chunks) {\n\t\t\t\tif (!chunksProcessed.has(innerChunk)) {\n\t\t\t\t\tchunksProcessed.add(innerChunk);\n\t\t\t\t\tif (!filterChunkFn || filterChunkFn(innerChunk, this)) {\n\t\t\t\t\t\tfor (const module of this.getChunkModulesIterable(innerChunk)) {\n\t\t\t\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA first chunk\n\t * @param {Chunk} chunkB second chunk\n\t * @returns {-1|0|1} this is a comparator function like sort and returns -1, 0, or 1 based on sort order\n\t */\n\tcompareChunks(chunkA, chunkB) {\n\t\tconst cgcA = this._getChunkGraphChunk(chunkA);\n\t\tconst cgcB = this._getChunkGraphChunk(chunkB);\n\t\tif (cgcA.modules.size > cgcB.modules.size) return -1;\n\t\tif (cgcA.modules.size < cgcB.modules.size) return 1;\n\t\tcgcA.modules.sortWith(compareModulesByIdentifier);\n\t\tcgcB.modules.sortWith(compareModulesByIdentifier);\n\t\treturn compareModuleIterables(cgcA.modules, cgcB.modules);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} total size of all modules in the chunk\n\t */\n\tgetChunkModulesSize(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(getModulesSize);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Record<string, number>} total sizes of all modules in the chunk by source type\n\t */\n\tgetChunkModulesSizes(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(getModulesSizes);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Module[]} root modules of the chunks (ordered by identifier)\n\t */\n\tgetChunkRootModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(this._getGraphRoots);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of the chunk\n\t */\n\tgetChunkSize(chunk, options = {}) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst modulesSize = cgc.modules.getFromUnorderedCache(getModulesSize);\n\t\tconst chunkOverhead =\n\t\t\ttypeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n\t\tconst entryChunkMultiplicator =\n\t\t\ttypeof options.entryChunkMultiplicator === \"number\"\n\t\t\t\t? options.entryChunkMultiplicator\n\t\t\t\t: 10;\n\t\treturn (\n\t\t\tchunkOverhead +\n\t\t\tmodulesSize * (chunk.canBeInitial() ? entryChunkMultiplicator : 1)\n\t\t);\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA chunk\n\t * @param {Chunk} chunkB chunk\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of the chunk or false if chunks can't be integrated\n\t */\n\tgetIntegratedChunksSize(chunkA, chunkB, options = {}) {\n\t\tconst cgcA = this._getChunkGraphChunk(chunkA);\n\t\tconst cgcB = this._getChunkGraphChunk(chunkB);\n\t\tconst allModules = new Set(cgcA.modules);\n\t\tfor (const m of cgcB.modules) allModules.add(m);\n\t\tlet modulesSize = getModulesSize(allModules);\n\t\tconst chunkOverhead =\n\t\t\ttypeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n\t\tconst entryChunkMultiplicator =\n\t\t\ttypeof options.entryChunkMultiplicator === \"number\"\n\t\t\t\t? options.entryChunkMultiplicator\n\t\t\t\t: 10;\n\t\treturn (\n\t\t\tchunkOverhead +\n\t\t\tmodulesSize *\n\t\t\t\t(chunkA.canBeInitial() || chunkB.canBeInitial()\n\t\t\t\t\t? entryChunkMultiplicator\n\t\t\t\t\t: 1)\n\t\t);\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA chunk\n\t * @param {Chunk} chunkB chunk\n\t * @returns {boolean} true, if chunks could be integrated\n\t */\n\tcanChunksBeIntegrated(chunkA, chunkB) {\n\t\tif (chunkA.preventIntegration || chunkB.preventIntegration) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst hasRuntimeA = chunkA.hasRuntime();\n\t\tconst hasRuntimeB = chunkB.hasRuntime();\n\n\t\tif (hasRuntimeA !== hasRuntimeB) {\n\t\t\tif (hasRuntimeA) {\n\t\t\t\treturn isAvailableChunk(chunkA, chunkB);\n\t\t\t} else if (hasRuntimeB) {\n\t\t\t\treturn isAvailableChunk(chunkB, chunkA);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tthis.getNumberOfEntryModules(chunkA) > 0 ||\n\t\t\tthis.getNumberOfEntryModules(chunkB) > 0\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA the target chunk\n\t * @param {Chunk} chunkB the chunk to integrate\n\t * @returns {void}\n\t */\n\tintegrateChunks(chunkA, chunkB) {\n\t\t// Decide for one name (deterministic)\n\t\tif (chunkA.name && chunkB.name) {\n\t\t\tif (\n\t\t\t\tthis.getNumberOfEntryModules(chunkA) > 0 ===\n\t\t\t\tthis.getNumberOfEntryModules(chunkB) > 0\n\t\t\t) {\n\t\t\t\t// When both chunks have entry modules or none have one, use\n\t\t\t\t// shortest name\n\t\t\t\tif (chunkA.name.length !== chunkB.name.length) {\n\t\t\t\t\tchunkA.name =\n\t\t\t\t\t\tchunkA.name.length < chunkB.name.length ? chunkA.name : chunkB.name;\n\t\t\t\t} else {\n\t\t\t\t\tchunkA.name = chunkA.name < chunkB.name ? chunkA.name : chunkB.name;\n\t\t\t\t}\n\t\t\t} else if (this.getNumberOfEntryModules(chunkB) > 0) {\n\t\t\t\t// Pick the name of the chunk with the entry module\n\t\t\t\tchunkA.name = chunkB.name;\n\t\t\t}\n\t\t} else if (chunkB.name) {\n\t\t\tchunkA.name = chunkB.name;\n\t\t}\n\n\t\t// Merge id name hints\n\t\tfor (const hint of chunkB.idNameHints) {\n\t\t\tchunkA.idNameHints.add(hint);\n\t\t}\n\n\t\t// Merge runtime\n\t\tchunkA.runtime = mergeRuntime(chunkA.runtime, chunkB.runtime);\n\n\t\t// getChunkModules is used here to create a clone, because disconnectChunkAndModule modifies\n\t\tfor (const module of this.getChunkModules(chunkB)) {\n\t\t\tthis.disconnectChunkAndModule(chunkB, module);\n\t\t\tthis.connectChunkAndModule(chunkA, module);\n\t\t}\n\n\t\tfor (const [module, chunkGroup] of Array.from(\n\t\t\tthis.getChunkEntryModulesWithChunkGroupIterable(chunkB)\n\t\t)) {\n\t\t\tthis.disconnectChunkAndEntryModule(chunkB, module);\n\t\t\tthis.connectChunkAndEntryModule(chunkA, module, chunkGroup);\n\t\t}\n\n\t\tfor (const chunkGroup of chunkB.groupsIterable) {\n\t\t\tchunkGroup.replaceChunk(chunkB, chunkA);\n\t\t\tchunkA.addGroup(chunkGroup);\n\t\t\tchunkB.removeGroup(chunkGroup);\n\t\t}\n\t\tChunkGraph.clearChunkGraphForChunk(chunkB);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk to upgrade\n\t * @returns {void}\n\t */\n\tupgradeDependentToFullHashModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.dependentHashModules === undefined) return;\n\t\tif (cgc.fullHashModules === undefined) {\n\t\t\tcgc.fullHashModules = cgc.dependentHashModules;\n\t\t} else {\n\t\t\tfor (const m of cgc.dependentHashModules) {\n\t\t\t\tcgc.fullHashModules.add(m);\n\t\t\t}\n\t\t\tcgc.dependentHashModules = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @param {Chunk} chunk the checked chunk\n\t * @returns {boolean} true, if the chunk contains the module as entry\n\t */\n\tisEntryModuleInChunk(module, chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules.has(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {Module} module the entry module\n\t * @param {Entrypoint=} entrypoint the chunk group which must be loaded before the module is executed\n\t * @returns {void}\n\t */\n\tconnectChunkAndEntryModule(chunk, module, entrypoint) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgm.entryInChunks === undefined) {\n\t\t\tcgm.entryInChunks = new Set();\n\t\t}\n\t\tcgm.entryInChunks.add(chunk);\n\t\tcgc.entryModules.set(module, entrypoint);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the runtime module\n\t * @returns {void}\n\t */\n\tconnectChunkAndRuntimeModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgm.runtimeInChunks === undefined) {\n\t\t\tcgm.runtimeInChunks = new Set();\n\t\t}\n\t\tcgm.runtimeInChunks.add(chunk);\n\t\tcgc.runtimeModules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the module that require a full hash\n\t * @returns {void}\n\t */\n\taddFullHashModuleToChunk(chunk, module) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n\t\tcgc.fullHashModules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the module that require a full hash\n\t * @returns {void}\n\t */\n\taddDependentHashModuleToChunk(chunk, module) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.dependentHashModules === undefined)\n\t\t\tcgc.dependentHashModules = new Set();\n\t\tcgc.dependentHashModules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {Module} module the entry module\n\t * @returns {void}\n\t */\n\tdisconnectChunkAndEntryModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgm.entryInChunks.delete(chunk);\n\t\tif (cgm.entryInChunks.size === 0) {\n\t\t\tcgm.entryInChunks = undefined;\n\t\t}\n\t\tcgc.entryModules.delete(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the runtime module\n\t * @returns {void}\n\t */\n\tdisconnectChunkAndRuntimeModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgm.runtimeInChunks.delete(chunk);\n\t\tif (cgm.runtimeInChunks.size === 0) {\n\t\t\tcgm.runtimeInChunks = undefined;\n\t\t}\n\t\tcgc.runtimeModules.delete(module);\n\t}\n\n\t/**\n\t * @param {Module} module the entry module, it will no longer be entry\n\t * @returns {void}\n\t */\n\tdisconnectEntryModule(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tfor (const chunk of cgm.entryInChunks) {\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\tcgc.entryModules.delete(module);\n\t\t}\n\t\tcgm.entryInChunks = undefined;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk, for which all entries will be removed\n\t * @returns {void}\n\t */\n\tdisconnectEntries(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of cgc.entryModules.keys()) {\n\t\t\tconst cgm = this._getChunkGraphModule(module);\n\t\t\tcgm.entryInChunks.delete(chunk);\n\t\t\tif (cgm.entryInChunks.size === 0) {\n\t\t\t\tcgm.entryInChunks = undefined;\n\t\t\t}\n\t\t}\n\t\tcgc.entryModules.clear();\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the amount of entry modules in chunk\n\t */\n\tgetNumberOfEntryModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the amount of entry modules in chunk\n\t */\n\tgetNumberOfRuntimeModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.runtimeModules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<Module>} iterable of modules (do not modify)\n\t */\n\tgetChunkEntryModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules.keys();\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<Chunk>} iterable of chunks\n\t */\n\tgetChunkEntryDependentChunksIterable(chunk) {\n\t\t/** @type {Set<Chunk>} */\n\t\tconst set = new Set();\n\t\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\t\tif (chunkGroup instanceof Entrypoint) {\n\t\t\t\tconst entrypointChunk = chunkGroup.getEntrypointChunk();\n\t\t\t\tconst cgc = this._getChunkGraphChunk(entrypointChunk);\n\t\t\t\tfor (const chunkGroup of cgc.entryModules.values()) {\n\t\t\t\t\tfor (const c of chunkGroup.chunks) {\n\t\t\t\t\t\tif (c !== chunk && c !== entrypointChunk && !c.hasRuntime()) {\n\t\t\t\t\t\t\tset.add(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn set;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {boolean} true, when it has dependent chunks\n\t */\n\thasChunkEntryDependentChunks(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const chunkGroup of cgc.entryModules.values()) {\n\t\t\tfor (const c of chunkGroup.chunks) {\n\t\t\t\tif (c !== chunk) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<RuntimeModule>} iterable of modules (do not modify)\n\t */\n\tgetChunkRuntimeModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.runtimeModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {RuntimeModule[]} array of modules in order of execution\n\t */\n\tgetChunkRuntimeModulesInOrder(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst array = Array.from(cgc.runtimeModules);\n\t\tarray.sort(\n\t\t\tconcatComparators(\n\t\t\t\tcompareSelect(\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {RuntimeModule} r runtime module\n\t\t\t\t\t * @returns {number=} stage\n\t\t\t\t\t */\n\t\t\t\t\tr => r.stage,\n\t\t\t\t\tcompareIds\n\t\t\t\t),\n\t\t\t\tcompareModulesByIdentifier\n\t\t\t)\n\t\t);\n\t\treturn array;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n\t */\n\tgetChunkFullHashModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.fullHashModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ReadonlySet<RuntimeModule> | undefined} set of modules (do not modify)\n\t */\n\tgetChunkFullHashModulesSet(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.fullHashModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n\t */\n\tgetChunkDependentHashModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.dependentHashModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<EntryModuleWithChunkGroup>} iterable of modules (do not modify)\n\t */\n\tgetChunkEntryModulesWithChunkGroupIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules;\n\t}\n\n\t/**\n\t * @param {AsyncDependenciesBlock} depBlock the async block\n\t * @returns {ChunkGroup} the chunk group\n\t */\n\tgetBlockChunkGroup(depBlock) {\n\t\treturn this._blockChunkGroups.get(depBlock);\n\t}\n\n\t/**\n\t * @param {AsyncDependenciesBlock} depBlock the async block\n\t * @param {ChunkGroup} chunkGroup the chunk group\n\t * @returns {void}\n\t */\n\tconnectBlockAndChunkGroup(depBlock, chunkGroup) {\n\t\tthis._blockChunkGroups.set(depBlock, chunkGroup);\n\t\tchunkGroup.addBlock(depBlock);\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunk group\n\t * @returns {void}\n\t */\n\tdisconnectChunkGroup(chunkGroup) {\n\t\tfor (const block of chunkGroup.blocksIterable) {\n\t\t\tthis._blockChunkGroups.delete(block);\n\t\t}\n\t\t// TODO refactor by moving blocks list into ChunkGraph\n\t\tchunkGroup._blocks.clear();\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {string | number} the id of the module\n\t */\n\tgetModuleId(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.id;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {string | number} id the id of the module\n\t * @returns {void}\n\t */\n\tsetModuleId(module, id) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tcgm.id = id;\n\t}\n\n\t/**\n\t * @param {string} runtime runtime\n\t * @returns {string | number} the id of the runtime\n\t */\n\tgetRuntimeId(runtime) {\n\t\treturn this._runtimeIds.get(runtime);\n\t}\n\n\t/**\n\t * @param {string} runtime runtime\n\t * @param {string | number} id the id of the runtime\n\t * @returns {void}\n\t */\n\tsetRuntimeId(runtime, id) {\n\t\tthis._runtimeIds.set(runtime, id);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {Module} module the module\n\t * @param {RuntimeSpecMap<T>} hashes hashes data\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {T} hash\n\t */\n\t_getModuleHashInfo(module, hashes, runtime) {\n\t\tif (!hashes) {\n\t\t\tthrow new Error(\n\t\t\t\t`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(\n\t\t\t\t\truntime\n\t\t\t\t)} (hashes not set at all)`\n\t\t\t);\n\t\t} else if (runtime === undefined) {\n\t\t\tconst hashInfoItems = new Set(hashes.values());\n\t\t\tif (hashInfoItems.size !== 1) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`No unique hash info entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(\n\t\t\t\t\t\thashes.keys(),\n\t\t\t\t\t\tr => runtimeToString(r)\n\t\t\t\t\t).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn first(hashInfoItems);\n\t\t} else {\n\t\t\tconst hashInfo = hashes.get(runtime);\n\t\t\tif (!hashInfo) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(\n\t\t\t\t\t\truntime\n\t\t\t\t\t)} (available runtimes ${Array.from(\n\t\t\t\t\t\thashes.keys(),\n\t\t\t\t\t\truntimeToString\n\t\t\t\t\t).join(\", \")})`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn hashInfo;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, if the module has hashes for this runtime\n\t */\n\thasModuleHashes(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst hashes = cgm.hashes;\n\t\treturn hashes && hashes.has(runtime);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {string} hash\n\t */\n\tgetModuleHash(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst hashes = cgm.hashes;\n\t\treturn this._getModuleHashInfo(module, hashes, runtime).hash;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {string} hash\n\t */\n\tgetRenderedModuleHash(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst hashes = cgm.hashes;\n\t\treturn this._getModuleHashInfo(module, hashes, runtime).renderedHash;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {string} hash the full hash\n\t * @param {string} renderedHash the shortened hash for rendering\n\t * @returns {void}\n\t */\n\tsetModuleHashes(module, runtime, hash, renderedHash) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tif (cgm.hashes === undefined) {\n\t\t\tcgm.hashes = new RuntimeSpecMap();\n\t\t}\n\t\tcgm.hashes.set(runtime, new ModuleHashInfo(hash, renderedHash));\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph when transferOwnership not false)\n\t * @param {boolean} transferOwnership true: transfer ownership of the items object, false: items is immutable and shared and won't be modified\n\t * @returns {void}\n\t */\n\taddModuleRuntimeRequirements(\n\t\tmodule,\n\t\truntime,\n\t\titems,\n\t\ttransferOwnership = true\n\t) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst runtimeRequirementsMap = cgm.runtimeRequirements;\n\t\tif (runtimeRequirementsMap === undefined) {\n\t\t\tconst map = new RuntimeSpecMap();\n\t\t\t// TODO avoid cloning item and track ownership instead\n\t\t\tmap.set(runtime, transferOwnership ? items : new Set(items));\n\t\t\tcgm.runtimeRequirements = map;\n\t\t\treturn;\n\t\t}\n\t\truntimeRequirementsMap.update(runtime, runtimeRequirements => {\n\t\t\tif (runtimeRequirements === undefined) {\n\t\t\t\treturn transferOwnership ? items : new Set(items);\n\t\t\t} else if (!transferOwnership || runtimeRequirements.size >= items.size) {\n\t\t\t\tfor (const item of items) runtimeRequirements.add(item);\n\t\t\t\treturn runtimeRequirements;\n\t\t\t} else {\n\t\t\t\tfor (const item of runtimeRequirements) items.add(item);\n\t\t\t\treturn items;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph)\n\t * @returns {void}\n\t */\n\taddChunkRuntimeRequirements(chunk, items) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst runtimeRequirements = cgc.runtimeRequirements;\n\t\tif (runtimeRequirements === undefined) {\n\t\t\tcgc.runtimeRequirements = items;\n\t\t} else if (runtimeRequirements.size >= items.size) {\n\t\t\tfor (const item of items) runtimeRequirements.add(item);\n\t\t} else {\n\t\t\tfor (const item of runtimeRequirements) items.add(item);\n\t\t\tcgc.runtimeRequirements = items;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<string>} items runtime requirements to be added\n\t * @returns {void}\n\t */\n\taddTreeRuntimeRequirements(chunk, items) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst runtimeRequirements = cgc.runtimeRequirementsInTree;\n\t\tfor (const item of items) runtimeRequirements.add(item);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetModuleRuntimeRequirements(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst runtimeRequirements =\n\t\t\tcgm.runtimeRequirements && cgm.runtimeRequirements.get(runtime);\n\t\treturn runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetChunkRuntimeRequirements(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst runtimeRequirements = cgc.runtimeRequirements;\n\t\treturn runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {boolean} withConnections include connections\n\t * @returns {string} hash\n\t */\n\tgetModuleGraphHash(module, runtime, withConnections = true) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn withConnections\n\t\t\t? this._getModuleGraphHashWithConnections(cgm, module, runtime)\n\t\t\t: this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {boolean} withConnections include connections\n\t * @returns {bigint} hash\n\t */\n\tgetModuleGraphHashBigInt(module, runtime, withConnections = true) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn withConnections\n\t\t\t? BigInt(\n\t\t\t\t\t`0x${this._getModuleGraphHashWithConnections(cgm, module, runtime)}`\n\t\t\t  )\n\t\t\t: this._getModuleGraphHashBigInt(cgm, module, runtime);\n\t}\n\n\t/**\n\t * @param {ChunkGraphModule} cgm the ChunkGraphModule\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {bigint} hash as big int\n\t */\n\t_getModuleGraphHashBigInt(cgm, module, runtime) {\n\t\tif (cgm.graphHashes === undefined) {\n\t\t\tcgm.graphHashes = new RuntimeSpecMap();\n\t\t}\n\t\tconst graphHash = cgm.graphHashes.provide(runtime, () => {\n\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\thash.update(`${cgm.id}${this.moduleGraph.isAsync(module)}`);\n\t\t\tconst sourceTypes = this._getOverwrittenModuleSourceTypes(module);\n\t\t\tif (sourceTypes !== undefined) {\n\t\t\t\tfor (const type of sourceTypes) hash.update(type);\n\t\t\t}\n\t\t\tthis.moduleGraph.getExportsInfo(module).updateHash(hash, runtime);\n\t\t\treturn BigInt(`0x${/** @type {string} */ (hash.digest(\"hex\"))}`);\n\t\t});\n\t\treturn graphHash;\n\t}\n\n\t/**\n\t * @param {ChunkGraphModule} cgm the ChunkGraphModule\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {string} hash\n\t */\n\t_getModuleGraphHashWithConnections(cgm, module, runtime) {\n\t\tif (cgm.graphHashesWithConnections === undefined) {\n\t\t\tcgm.graphHashesWithConnections = new RuntimeSpecMap();\n\t\t}\n\t\tconst activeStateToString = state => {\n\t\t\tif (state === false) return \"F\";\n\t\t\tif (state === true) return \"T\";\n\t\t\tif (state === ModuleGraphConnection.TRANSITIVE_ONLY) return \"O\";\n\t\t\tthrow new Error(\"Not implemented active state\");\n\t\t};\n\t\tconst strict = module.buildMeta && module.buildMeta.strictHarmonyModule;\n\t\treturn cgm.graphHashesWithConnections.provide(runtime, () => {\n\t\t\tconst graphHash = this._getModuleGraphHashBigInt(\n\t\t\t\tcgm,\n\t\t\t\tmodule,\n\t\t\t\truntime\n\t\t\t).toString(16);\n\t\t\tconst connections = this.moduleGraph.getOutgoingConnections(module);\n\t\t\t/** @type {Set<Module>} */\n\t\t\tconst activeNamespaceModules = new Set();\n\t\t\t/** @type {Map<string, Module | Set<Module>>} */\n\t\t\tconst connectedModules = new Map();\n\t\t\tconst processConnection = (connection, stateInfo) => {\n\t\t\t\tconst module = connection.module;\n\t\t\t\tstateInfo += module.getExportsType(this.moduleGraph, strict);\n\t\t\t\t// cspell:word Tnamespace\n\t\t\t\tif (stateInfo === \"Tnamespace\") activeNamespaceModules.add(module);\n\t\t\t\telse {\n\t\t\t\t\tconst oldModule = connectedModules.get(stateInfo);\n\t\t\t\t\tif (oldModule === undefined) {\n\t\t\t\t\t\tconnectedModules.set(stateInfo, module);\n\t\t\t\t\t} else if (oldModule instanceof Set) {\n\t\t\t\t\t\toldModule.add(module);\n\t\t\t\t\t} else if (oldModule !== module) {\n\t\t\t\t\t\tconnectedModules.set(stateInfo, new Set([oldModule, module]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (runtime === undefined || typeof runtime === \"string\") {\n\t\t\t\tfor (const connection of connections) {\n\t\t\t\t\tconst state = connection.getActiveState(runtime);\n\t\t\t\t\tif (state === false) continue;\n\t\t\t\t\tprocessConnection(connection, state === true ? \"T\" : \"O\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// cspell:word Tnamespace\n\t\t\t\tfor (const connection of connections) {\n\t\t\t\t\tconst states = new Set();\n\t\t\t\t\tlet stateInfo = \"\";\n\t\t\t\t\tforEachRuntime(\n\t\t\t\t\t\truntime,\n\t\t\t\t\t\truntime => {\n\t\t\t\t\t\t\tconst state = connection.getActiveState(runtime);\n\t\t\t\t\t\t\tstates.add(state);\n\t\t\t\t\t\t\tstateInfo += activeStateToString(state) + runtime;\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttrue\n\t\t\t\t\t);\n\t\t\t\t\tif (states.size === 1) {\n\t\t\t\t\t\tconst state = first(states);\n\t\t\t\t\t\tif (state === false) continue;\n\t\t\t\t\t\tstateInfo = activeStateToString(state);\n\t\t\t\t\t}\n\t\t\t\t\tprocessConnection(connection, stateInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// cspell:word Tnamespace\n\t\t\tif (activeNamespaceModules.size === 0 && connectedModules.size === 0)\n\t\t\t\treturn graphHash;\n\t\t\tconst connectedModulesInOrder =\n\t\t\t\tconnectedModules.size > 1\n\t\t\t\t\t? Array.from(connectedModules).sort(([a], [b]) => (a < b ? -1 : 1))\n\t\t\t\t\t: connectedModules;\n\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\tconst addModuleToHash = module => {\n\t\t\t\thash.update(\n\t\t\t\t\tthis._getModuleGraphHashBigInt(\n\t\t\t\t\t\tthis._getChunkGraphModule(module),\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\truntime\n\t\t\t\t\t).toString(16)\n\t\t\t\t);\n\t\t\t};\n\t\t\tconst addModulesToHash = modules => {\n\t\t\t\tlet xor = ZERO_BIG_INT;\n\t\t\t\tfor (const m of modules) {\n\t\t\t\t\txor =\n\t\t\t\t\t\txor ^\n\t\t\t\t\t\tthis._getModuleGraphHashBigInt(\n\t\t\t\t\t\t\tthis._getChunkGraphModule(m),\n\t\t\t\t\t\t\tm,\n\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\thash.update(xor.toString(16));\n\t\t\t};\n\t\t\tif (activeNamespaceModules.size === 1)\n\t\t\t\taddModuleToHash(activeNamespaceModules.values().next().value);\n\t\t\telse if (activeNamespaceModules.size > 1)\n\t\t\t\taddModulesToHash(activeNamespaceModules);\n\t\t\tfor (const [stateInfo, modules] of connectedModulesInOrder) {\n\t\t\t\thash.update(stateInfo);\n\t\t\t\tif (modules instanceof Set) {\n\t\t\t\t\taddModulesToHash(modules);\n\t\t\t\t} else {\n\t\t\t\t\taddModuleToHash(modules);\n\t\t\t\t}\n\t\t\t}\n\t\t\thash.update(graphHash);\n\t\t\treturn /** @type {string} */ (hash.digest(\"hex\"));\n\t\t});\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetTreeRuntimeRequirements(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.runtimeRequirementsInTree;\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @param {string} deprecateMessage message for the deprecation message\n\t * @param {string} deprecationCode code for the deprecation\n\t * @returns {ChunkGraph} the chunk graph\n\t */\n\tstatic getChunkGraphForModule(module, deprecateMessage, deprecationCode) {\n\t\tconst fn = deprecateGetChunkGraphForModuleMap.get(deprecateMessage);\n\t\tif (fn) return fn(module);\n\t\tconst newFn = util.deprecate(\n\t\t\t/**\n\t\t\t * @param {Module} module the module\n\t\t\t * @returns {ChunkGraph} the chunk graph\n\t\t\t */\n\t\t\tmodule => {\n\t\t\t\tconst chunkGraph = chunkGraphForModuleMap.get(module);\n\t\t\t\tif (!chunkGraph)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\tdeprecateMessage +\n\t\t\t\t\t\t\t\": There was no ChunkGraph assigned to the Module for backward-compat (Use the new API)\"\n\t\t\t\t\t);\n\t\t\t\treturn chunkGraph;\n\t\t\t},\n\t\t\tdeprecateMessage + \": Use new ChunkGraph API\",\n\t\t\tdeprecationCode\n\t\t);\n\t\tdeprecateGetChunkGraphForModuleMap.set(deprecateMessage, newFn);\n\t\treturn newFn(module);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {void}\n\t */\n\tstatic setChunkGraphForModule(module, chunkGraph) {\n\t\tchunkGraphForModuleMap.set(module, chunkGraph);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tstatic clearChunkGraphForModule(module) {\n\t\tchunkGraphForModuleMap.delete(module);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {string} deprecateMessage message for the deprecation message\n\t * @param {string} deprecationCode code for the deprecation\n\t * @returns {ChunkGraph} the chunk graph\n\t */\n\tstatic getChunkGraphForChunk(chunk, deprecateMessage, deprecationCode) {\n\t\tconst fn = deprecateGetChunkGraphForChunkMap.get(deprecateMessage);\n\t\tif (fn) return fn(chunk);\n\t\tconst newFn = util.deprecate(\n\t\t\t/**\n\t\t\t * @param {Chunk} chunk the chunk\n\t\t\t * @returns {ChunkGraph} the chunk graph\n\t\t\t */\n\t\t\tchunk => {\n\t\t\t\tconst chunkGraph = chunkGraphForChunkMap.get(chunk);\n\t\t\t\tif (!chunkGraph)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\tdeprecateMessage +\n\t\t\t\t\t\t\t\"There was no ChunkGraph assigned to the Chunk for backward-compat (Use the new API)\"\n\t\t\t\t\t);\n\t\t\t\treturn chunkGraph;\n\t\t\t},\n\t\t\tdeprecateMessage + \": Use new ChunkGraph API\",\n\t\t\tdeprecationCode\n\t\t);\n\t\tdeprecateGetChunkGraphForChunkMap.set(deprecateMessage, newFn);\n\t\treturn newFn(chunk);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {void}\n\t */\n\tstatic setChunkGraphForChunk(chunk, chunkGraph) {\n\t\tchunkGraphForChunkMap.set(chunk, chunkGraph);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {void}\n\t */\n\tstatic clearChunkGraphForChunk(chunk) {\n\t\tchunkGraphForChunkMap.delete(chunk);\n\t}\n}\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Module, ChunkGraph>} */\nconst chunkGraphForModuleMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Chunk, ChunkGraph>} */\nconst chunkGraphForChunkMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (module: Module) => ChunkGraph>} */\nconst deprecateGetChunkGraphForModuleMap = new Map();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (chunk: Chunk) => ChunkGraph>} */\nconst deprecateGetChunkGraphForChunkMap = new Map();\n\nmodule.exports = ChunkGraph;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}