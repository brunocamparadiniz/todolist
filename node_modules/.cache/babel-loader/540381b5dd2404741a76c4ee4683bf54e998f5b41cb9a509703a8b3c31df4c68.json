{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar RequireEnsureDependenciesBlock = require(\"./RequireEnsureDependenciesBlock\");\nvar RequireEnsureDependency = require(\"./RequireEnsureDependency\");\nvar RequireEnsureItemDependency = require(\"./RequireEnsureItemDependency\");\nvar getFunctionExpression = require(\"./getFunctionExpression\");\nmodule.exports = /*#__PURE__*/function () {\n  function RequireEnsureDependenciesBlockParserPlugin() {\n    _classCallCheck(this, RequireEnsureDependenciesBlockParserPlugin);\n  }\n  _createClass(RequireEnsureDependenciesBlockParserPlugin, [{\n    key: \"apply\",\n    value: function apply(parser) {\n      parser.hooks.call.for(\"require.ensure\").tap(\"RequireEnsureDependenciesBlockParserPlugin\", function (expr) {\n        var chunkName = null;\n        var errorExpressionArg = null;\n        var errorExpression = null;\n        switch (expr.arguments.length) {\n          case 4:\n            {\n              var chunkNameExpr = parser.evaluateExpression(expr.arguments[3]);\n              if (!chunkNameExpr.isString()) return;\n              chunkName = chunkNameExpr.string;\n            }\n          // falls through\n          case 3:\n            {\n              errorExpressionArg = expr.arguments[2];\n              errorExpression = getFunctionExpression(errorExpressionArg);\n              if (!errorExpression && !chunkName) {\n                var _chunkNameExpr = parser.evaluateExpression(expr.arguments[2]);\n                if (!_chunkNameExpr.isString()) return;\n                chunkName = _chunkNameExpr.string;\n              }\n            }\n          // falls through\n          case 2:\n            {\n              var dependenciesExpr = parser.evaluateExpression(expr.arguments[0]);\n              var dependenciesItems = dependenciesExpr.isArray() ? dependenciesExpr.items : [dependenciesExpr];\n              var successExpressionArg = expr.arguments[1];\n              var successExpression = getFunctionExpression(successExpressionArg);\n              if (successExpression) {\n                parser.walkExpressions(successExpression.expressions);\n              }\n              if (errorExpression) {\n                parser.walkExpressions(errorExpression.expressions);\n              }\n              var depBlock = new RequireEnsureDependenciesBlock(chunkName, expr.loc);\n              var errorCallbackExists = expr.arguments.length === 4 || !chunkName && expr.arguments.length === 3;\n              var dep = new RequireEnsureDependency(expr.range, expr.arguments[1].range, errorCallbackExists && expr.arguments[2].range);\n              dep.loc = expr.loc;\n              depBlock.addDependency(dep);\n              var old = parser.state.current;\n              parser.state.current = depBlock;\n              try {\n                var failed = false;\n                parser.inScope([], function () {\n                  var _iterator = _createForOfIteratorHelper(dependenciesItems),\n                    _step;\n                  try {\n                    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                      var ee = _step.value;\n                      if (ee.isString()) {\n                        var ensureDependency = new RequireEnsureItemDependency(ee.string);\n                        ensureDependency.loc = ee.loc || expr.loc;\n                        depBlock.addDependency(ensureDependency);\n                      } else {\n                        failed = true;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator.e(err);\n                  } finally {\n                    _iterator.f();\n                  }\n                });\n                if (failed) {\n                  return;\n                }\n                if (successExpression) {\n                  if (successExpression.fn.body.type === \"BlockStatement\") {\n                    parser.walkStatement(successExpression.fn.body);\n                  } else {\n                    parser.walkExpression(successExpression.fn.body);\n                  }\n                }\n                old.addBlock(depBlock);\n              } finally {\n                parser.state.current = old;\n              }\n              if (!successExpression) {\n                parser.walkExpression(successExpressionArg);\n              }\n              if (errorExpression) {\n                if (errorExpression.fn.body.type === \"BlockStatement\") {\n                  parser.walkStatement(errorExpression.fn.body);\n                } else {\n                  parser.walkExpression(errorExpression.fn.body);\n                }\n              } else if (errorExpressionArg) {\n                parser.walkExpression(errorExpressionArg);\n              }\n              return true;\n            }\n        }\n      });\n    }\n  }]);\n  return RequireEnsureDependenciesBlockParserPlugin;\n}();","map":{"version":3,"names":["RequireEnsureDependenciesBlock","require","RequireEnsureDependency","RequireEnsureItemDependency","getFunctionExpression","module","exports","parser","hooks","call","for","tap","expr","chunkName","errorExpressionArg","errorExpression","arguments","length","chunkNameExpr","evaluateExpression","isString","string","dependenciesExpr","dependenciesItems","isArray","items","successExpressionArg","successExpression","walkExpressions","expressions","depBlock","loc","errorCallbackExists","dep","range","addDependency","old","state","current","failed","inScope","ee","ensureDependency","fn","body","type","walkStatement","walkExpression","addBlock"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/dependencies/RequireEnsureDependenciesBlockParserPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RequireEnsureDependenciesBlock = require(\"./RequireEnsureDependenciesBlock\");\nconst RequireEnsureDependency = require(\"./RequireEnsureDependency\");\nconst RequireEnsureItemDependency = require(\"./RequireEnsureItemDependency\");\nconst getFunctionExpression = require(\"./getFunctionExpression\");\n\nmodule.exports = class RequireEnsureDependenciesBlockParserPlugin {\n\tapply(parser) {\n\t\tparser.hooks.call\n\t\t\t.for(\"require.ensure\")\n\t\t\t.tap(\"RequireEnsureDependenciesBlockParserPlugin\", expr => {\n\t\t\t\tlet chunkName = null;\n\t\t\t\tlet errorExpressionArg = null;\n\t\t\t\tlet errorExpression = null;\n\t\t\t\tswitch (expr.arguments.length) {\n\t\t\t\t\tcase 4: {\n\t\t\t\t\t\tconst chunkNameExpr = parser.evaluateExpression(expr.arguments[3]);\n\t\t\t\t\t\tif (!chunkNameExpr.isString()) return;\n\t\t\t\t\t\tchunkName = chunkNameExpr.string;\n\t\t\t\t\t}\n\t\t\t\t\t// falls through\n\t\t\t\t\tcase 3: {\n\t\t\t\t\t\terrorExpressionArg = expr.arguments[2];\n\t\t\t\t\t\terrorExpression = getFunctionExpression(errorExpressionArg);\n\n\t\t\t\t\t\tif (!errorExpression && !chunkName) {\n\t\t\t\t\t\t\tconst chunkNameExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\texpr.arguments[2]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (!chunkNameExpr.isString()) return;\n\t\t\t\t\t\t\tchunkName = chunkNameExpr.string;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// falls through\n\t\t\t\t\tcase 2: {\n\t\t\t\t\t\tconst dependenciesExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\texpr.arguments[0]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst dependenciesItems = dependenciesExpr.isArray()\n\t\t\t\t\t\t\t? dependenciesExpr.items\n\t\t\t\t\t\t\t: [dependenciesExpr];\n\t\t\t\t\t\tconst successExpressionArg = expr.arguments[1];\n\t\t\t\t\t\tconst successExpression =\n\t\t\t\t\t\t\tgetFunctionExpression(successExpressionArg);\n\n\t\t\t\t\t\tif (successExpression) {\n\t\t\t\t\t\t\tparser.walkExpressions(successExpression.expressions);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (errorExpression) {\n\t\t\t\t\t\t\tparser.walkExpressions(errorExpression.expressions);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst depBlock = new RequireEnsureDependenciesBlock(\n\t\t\t\t\t\t\tchunkName,\n\t\t\t\t\t\t\texpr.loc\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst errorCallbackExists =\n\t\t\t\t\t\t\texpr.arguments.length === 4 ||\n\t\t\t\t\t\t\t(!chunkName && expr.arguments.length === 3);\n\t\t\t\t\t\tconst dep = new RequireEnsureDependency(\n\t\t\t\t\t\t\texpr.range,\n\t\t\t\t\t\t\texpr.arguments[1].range,\n\t\t\t\t\t\t\terrorCallbackExists && expr.arguments[2].range\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\t\tdepBlock.addDependency(dep);\n\t\t\t\t\t\tconst old = parser.state.current;\n\t\t\t\t\t\tparser.state.current = depBlock;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet failed = false;\n\t\t\t\t\t\t\tparser.inScope([], () => {\n\t\t\t\t\t\t\t\tfor (const ee of dependenciesItems) {\n\t\t\t\t\t\t\t\t\tif (ee.isString()) {\n\t\t\t\t\t\t\t\t\t\tconst ensureDependency = new RequireEnsureItemDependency(\n\t\t\t\t\t\t\t\t\t\t\tee.string\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tensureDependency.loc = ee.loc || expr.loc;\n\t\t\t\t\t\t\t\t\t\tdepBlock.addDependency(ensureDependency);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tfailed = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (failed) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (successExpression) {\n\t\t\t\t\t\t\t\tif (successExpression.fn.body.type === \"BlockStatement\") {\n\t\t\t\t\t\t\t\t\tparser.walkStatement(successExpression.fn.body);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tparser.walkExpression(successExpression.fn.body);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\told.addBlock(depBlock);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tparser.state.current = old;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!successExpression) {\n\t\t\t\t\t\t\tparser.walkExpression(successExpressionArg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (errorExpression) {\n\t\t\t\t\t\t\tif (errorExpression.fn.body.type === \"BlockStatement\") {\n\t\t\t\t\t\t\t\tparser.walkStatement(errorExpression.fn.body);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparser.walkExpression(errorExpression.fn.body);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (errorExpressionArg) {\n\t\t\t\t\t\t\tparser.walkExpression(errorExpressionArg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}