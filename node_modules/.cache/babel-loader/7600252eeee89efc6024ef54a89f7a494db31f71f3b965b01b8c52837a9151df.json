{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar Dependency = require(\"./Dependency\");\nvar _require = require(\"./ExportsInfo\"),\n  UsageState = _require.UsageState;\nvar ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nvar _require2 = require(\"./OptimizationStages\"),\n  STAGE_DEFAULT = _require2.STAGE_DEFAULT;\nvar ArrayQueue = require(\"./util/ArrayQueue\");\nvar TupleQueue = require(\"./util/TupleQueue\");\nvar _require3 = require(\"./util/runtime\"),\n  getEntryRuntime = _require3.getEntryRuntime,\n  mergeRuntimeOwned = _require3.mergeRuntimeOwned;\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\").ReferencedExport} ReferencedExport */\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nvar NO_EXPORTS_REFERENCED = Dependency.NO_EXPORTS_REFERENCED,\n  EXPORTS_OBJECT_REFERENCED = Dependency.EXPORTS_OBJECT_REFERENCED;\nvar FlagDependencyUsagePlugin = /*#__PURE__*/function () {\n  /**\n   * @param {boolean} global do a global analysis instead of per runtime\n   */\n  function FlagDependencyUsagePlugin(global) {\n    _classCallCheck(this, FlagDependencyUsagePlugin);\n    this.global = global;\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  _createClass(FlagDependencyUsagePlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this = this;\n      compiler.hooks.compilation.tap(\"FlagDependencyUsagePlugin\", function (compilation) {\n        var moduleGraph = compilation.moduleGraph;\n        compilation.hooks.optimizeDependencies.tap({\n          name: \"FlagDependencyUsagePlugin\",\n          stage: STAGE_DEFAULT\n        }, function (modules) {\n          if (compilation.moduleMemCaches) {\n            throw new Error(\"optimization.usedExports can't be used with cacheUnaffected as export usage is a global effect\");\n          }\n          var logger = compilation.getLogger(\"webpack.FlagDependencyUsagePlugin\");\n          /** @type {Map<ExportsInfo, Module>} */\n          var exportInfoToModuleMap = new Map();\n\n          /** @type {TupleQueue<[Module, RuntimeSpec]>} */\n          var queue = new TupleQueue();\n\n          /**\n           * @param {Module} module module to process\n           * @param {(string[] | ReferencedExport)[]} usedExports list of used exports\n           * @param {RuntimeSpec} runtime part of which runtime\n           * @param {boolean} forceSideEffects always apply side effects\n           * @returns {void}\n           */\n          var processReferencedModule = function processReferencedModule(module, usedExports, runtime, forceSideEffects) {\n            var exportsInfo = moduleGraph.getExportsInfo(module);\n            if (usedExports.length > 0) {\n              if (!module.buildMeta || !module.buildMeta.exportsType) {\n                if (exportsInfo.setUsedWithoutInfo(runtime)) {\n                  queue.enqueue(module, runtime);\n                }\n                return;\n              }\n              var _iterator = _createForOfIteratorHelper(usedExports),\n                _step;\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var usedExportInfo = _step.value;\n                  var usedExport = void 0;\n                  var canMangle = true;\n                  if (Array.isArray(usedExportInfo)) {\n                    usedExport = usedExportInfo;\n                  } else {\n                    usedExport = usedExportInfo.name;\n                    canMangle = usedExportInfo.canMangle !== false;\n                  }\n                  if (usedExport.length === 0) {\n                    if (exportsInfo.setUsedInUnknownWay(runtime)) {\n                      queue.enqueue(module, runtime);\n                    }\n                  } else {\n                    var currentExportsInfo = exportsInfo;\n                    for (var i = 0; i < usedExport.length; i++) {\n                      var exportInfo = currentExportsInfo.getExportInfo(usedExport[i]);\n                      if (canMangle === false) {\n                        exportInfo.canMangleUse = false;\n                      }\n                      var lastOne = i === usedExport.length - 1;\n                      if (!lastOne) {\n                        var nestedInfo = exportInfo.getNestedExportsInfo();\n                        if (nestedInfo) {\n                          if (exportInfo.setUsedConditionally(function (used) {\n                            return used === UsageState.Unused;\n                          }, UsageState.OnlyPropertiesUsed, runtime)) {\n                            var currentModule = currentExportsInfo === exportsInfo ? module : exportInfoToModuleMap.get(currentExportsInfo);\n                            if (currentModule) {\n                              queue.enqueue(currentModule, runtime);\n                            }\n                          }\n                          currentExportsInfo = nestedInfo;\n                          continue;\n                        }\n                      }\n                      if (exportInfo.setUsedConditionally(function (v) {\n                        return v !== UsageState.Used;\n                      }, UsageState.Used, runtime)) {\n                        var _currentModule = currentExportsInfo === exportsInfo ? module : exportInfoToModuleMap.get(currentExportsInfo);\n                        if (_currentModule) {\n                          queue.enqueue(_currentModule, runtime);\n                        }\n                      }\n                      break;\n                    }\n                  }\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n            } else {\n              // for a module without side effects we stop tracking usage here when no export is used\n              // This module won't be evaluated in this case\n              // TODO webpack 6 remove this check\n              if (!forceSideEffects && module.factoryMeta !== undefined && module.factoryMeta.sideEffectFree) {\n                return;\n              }\n              if (exportsInfo.setUsedForSideEffectsOnly(runtime)) {\n                queue.enqueue(module, runtime);\n              }\n            }\n          };\n\n          /**\n           * @param {DependenciesBlock} module the module\n           * @param {RuntimeSpec} runtime part of which runtime\n           * @param {boolean} forceSideEffects always apply side effects\n           * @returns {void}\n           */\n          var processModule = function processModule(module, runtime, forceSideEffects) {\n            /** @type {Map<Module, (string[] | ReferencedExport)[] | Map<string, string[] | ReferencedExport>>} */\n            var map = new Map();\n\n            /** @type {ArrayQueue<DependenciesBlock>} */\n            var queue = new ArrayQueue();\n            queue.enqueue(module);\n            for (;;) {\n              var block = queue.dequeue();\n              if (block === undefined) break;\n              var _iterator2 = _createForOfIteratorHelper(block.blocks),\n                _step2;\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var b = _step2.value;\n                  if (!_this.global && b.groupOptions && b.groupOptions.entryOptions) {\n                    processModule(b, b.groupOptions.entryOptions.runtime || undefined, true);\n                  } else {\n                    queue.enqueue(b);\n                  }\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n              var _iterator3 = _createForOfIteratorHelper(block.dependencies),\n                _step3;\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  var dep = _step3.value;\n                  var connection = moduleGraph.getConnection(dep);\n                  if (!connection || !connection.module) {\n                    continue;\n                  }\n                  var activeState = connection.getActiveState(runtime);\n                  if (activeState === false) continue;\n                  var _module = connection.module;\n                  if (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n                    processModule(_module, runtime, false);\n                    continue;\n                  }\n                  var oldReferencedExports = map.get(_module);\n                  if (oldReferencedExports === EXPORTS_OBJECT_REFERENCED) {\n                    continue;\n                  }\n                  var referencedExports = compilation.getDependencyReferencedExports(dep, runtime);\n                  if (oldReferencedExports === undefined || oldReferencedExports === NO_EXPORTS_REFERENCED || referencedExports === EXPORTS_OBJECT_REFERENCED) {\n                    map.set(_module, referencedExports);\n                  } else if (oldReferencedExports !== undefined && referencedExports === NO_EXPORTS_REFERENCED) {\n                    continue;\n                  } else {\n                    var exportsMap = void 0;\n                    if (Array.isArray(oldReferencedExports)) {\n                      exportsMap = new Map();\n                      var _iterator4 = _createForOfIteratorHelper(oldReferencedExports),\n                        _step4;\n                      try {\n                        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                          var item = _step4.value;\n                          if (Array.isArray(item)) {\n                            exportsMap.set(item.join(\"\\n\"), item);\n                          } else {\n                            exportsMap.set(item.name.join(\"\\n\"), item);\n                          }\n                        }\n                      } catch (err) {\n                        _iterator4.e(err);\n                      } finally {\n                        _iterator4.f();\n                      }\n                      map.set(_module, exportsMap);\n                    } else {\n                      exportsMap = oldReferencedExports;\n                    }\n                    var _iterator5 = _createForOfIteratorHelper(referencedExports),\n                      _step5;\n                    try {\n                      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                        var _item = _step5.value;\n                        if (Array.isArray(_item)) {\n                          var key = _item.join(\"\\n\");\n                          var oldItem = exportsMap.get(key);\n                          if (oldItem === undefined) {\n                            exportsMap.set(key, _item);\n                          }\n                          // if oldItem is already an array we have to do nothing\n                          // if oldItem is an ReferencedExport object, we don't have to do anything\n                          // as canMangle defaults to true for arrays\n                        } else {\n                          var _key = _item.name.join(\"\\n\");\n                          var _oldItem = exportsMap.get(_key);\n                          if (_oldItem === undefined || Array.isArray(_oldItem)) {\n                            exportsMap.set(_key, _item);\n                          } else {\n                            exportsMap.set(_key, {\n                              name: _item.name,\n                              canMangle: _item.canMangle && _oldItem.canMangle\n                            });\n                          }\n                        }\n                      }\n                    } catch (err) {\n                      _iterator5.e(err);\n                    } finally {\n                      _iterator5.f();\n                    }\n                  }\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            }\n            var _iterator6 = _createForOfIteratorHelper(map),\n              _step6;\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var _step6$value = _slicedToArray(_step6.value, 2),\n                  _module2 = _step6$value[0],\n                  _referencedExports = _step6$value[1];\n                if (Array.isArray(_referencedExports)) {\n                  processReferencedModule(_module2, _referencedExports, runtime, forceSideEffects);\n                } else {\n                  processReferencedModule(_module2, Array.from(_referencedExports.values()), runtime, forceSideEffects);\n                }\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n          };\n          logger.time(\"initialize exports usage\");\n          var _iterator7 = _createForOfIteratorHelper(modules),\n            _step7;\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var _module4 = _step7.value;\n              var exportsInfo = moduleGraph.getExportsInfo(_module4);\n              exportInfoToModuleMap.set(exportsInfo, _module4);\n              exportsInfo.setHasUseInfo();\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n          logger.timeEnd(\"initialize exports usage\");\n          logger.time(\"trace exports usage in graph\");\n\n          /**\n           * @param {Dependency} dep dependency\n           * @param {RuntimeSpec} runtime runtime\n           */\n          var processEntryDependency = function processEntryDependency(dep, runtime) {\n            var module = moduleGraph.getModule(dep);\n            if (module) {\n              processReferencedModule(module, NO_EXPORTS_REFERENCED, runtime, true);\n            }\n          };\n          /** @type {RuntimeSpec} */\n          var globalRuntime = undefined;\n          var _iterator8 = _createForOfIteratorHelper(compilation.entries),\n            _step8;\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var _step8$value = _slicedToArray(_step8.value, 2),\n                entryName = _step8$value[0],\n                _step8$value$ = _step8$value[1],\n                deps = _step8$value$.dependencies,\n                includeDeps = _step8$value$.includeDependencies,\n                options = _step8$value$.options;\n              var _runtime = _this.global ? undefined : getEntryRuntime(compilation, entryName, options);\n              var _iterator11 = _createForOfIteratorHelper(deps),\n                _step11;\n              try {\n                for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                  var dep = _step11.value;\n                  processEntryDependency(dep, _runtime);\n                }\n              } catch (err) {\n                _iterator11.e(err);\n              } finally {\n                _iterator11.f();\n              }\n              var _iterator12 = _createForOfIteratorHelper(includeDeps),\n                _step12;\n              try {\n                for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                  var _dep = _step12.value;\n                  processEntryDependency(_dep, _runtime);\n                }\n              } catch (err) {\n                _iterator12.e(err);\n              } finally {\n                _iterator12.f();\n              }\n              globalRuntime = mergeRuntimeOwned(globalRuntime, _runtime);\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n          var _iterator9 = _createForOfIteratorHelper(compilation.globalEntry.dependencies),\n            _step9;\n          try {\n            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n              var _dep2 = _step9.value;\n              processEntryDependency(_dep2, globalRuntime);\n            }\n          } catch (err) {\n            _iterator9.e(err);\n          } finally {\n            _iterator9.f();\n          }\n          var _iterator10 = _createForOfIteratorHelper(compilation.globalEntry.includeDependencies),\n            _step10;\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var _dep3 = _step10.value;\n              processEntryDependency(_dep3, globalRuntime);\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n          while (queue.length) {\n            var _queue$dequeue = queue.dequeue(),\n              _queue$dequeue2 = _slicedToArray(_queue$dequeue, 2),\n              _module3 = _queue$dequeue2[0],\n              runtime = _queue$dequeue2[1];\n            processModule(_module3, runtime, false);\n          }\n          logger.timeEnd(\"trace exports usage in graph\");\n        });\n      });\n    }\n  }]);\n  return FlagDependencyUsagePlugin;\n}();\nmodule.exports = FlagDependencyUsagePlugin;","map":{"version":3,"names":["Dependency","require","UsageState","ModuleGraphConnection","STAGE_DEFAULT","ArrayQueue","TupleQueue","getEntryRuntime","mergeRuntimeOwned","NO_EXPORTS_REFERENCED","EXPORTS_OBJECT_REFERENCED","FlagDependencyUsagePlugin","global","compiler","hooks","compilation","tap","moduleGraph","optimizeDependencies","name","stage","modules","moduleMemCaches","Error","logger","getLogger","exportInfoToModuleMap","Map","queue","processReferencedModule","module","usedExports","runtime","forceSideEffects","exportsInfo","getExportsInfo","length","buildMeta","exportsType","setUsedWithoutInfo","enqueue","usedExportInfo","usedExport","canMangle","Array","isArray","setUsedInUnknownWay","currentExportsInfo","i","exportInfo","getExportInfo","canMangleUse","lastOne","nestedInfo","getNestedExportsInfo","setUsedConditionally","used","Unused","OnlyPropertiesUsed","currentModule","get","v","Used","factoryMeta","undefined","sideEffectFree","setUsedForSideEffectsOnly","processModule","map","block","dequeue","blocks","b","groupOptions","entryOptions","dependencies","dep","connection","getConnection","activeState","getActiveState","TRANSITIVE_ONLY","oldReferencedExports","referencedExports","getDependencyReferencedExports","set","exportsMap","item","join","key","oldItem","from","values","time","setHasUseInfo","timeEnd","processEntryDependency","getModule","globalRuntime","entries","entryName","deps","includeDeps","includeDependencies","options","globalEntry","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/FlagDependencyUsagePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Dependency = require(\"./Dependency\");\nconst { UsageState } = require(\"./ExportsInfo\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst { STAGE_DEFAULT } = require(\"./OptimizationStages\");\nconst ArrayQueue = require(\"./util/ArrayQueue\");\nconst TupleQueue = require(\"./util/TupleQueue\");\nconst { getEntryRuntime, mergeRuntimeOwned } = require(\"./util/runtime\");\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\").ReferencedExport} ReferencedExport */\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nconst { NO_EXPORTS_REFERENCED, EXPORTS_OBJECT_REFERENCED } = Dependency;\n\nclass FlagDependencyUsagePlugin {\n\t/**\n\t * @param {boolean} global do a global analysis instead of per runtime\n\t */\n\tconstructor(global) {\n\t\tthis.global = global;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"FlagDependencyUsagePlugin\", compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\tcompilation.hooks.optimizeDependencies.tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"FlagDependencyUsagePlugin\",\n\t\t\t\t\tstage: STAGE_DEFAULT\n\t\t\t\t},\n\t\t\t\tmodules => {\n\t\t\t\t\tif (compilation.moduleMemCaches) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"optimization.usedExports can't be used with cacheUnaffected as export usage is a global effect\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst logger = compilation.getLogger(\n\t\t\t\t\t\t\"webpack.FlagDependencyUsagePlugin\"\n\t\t\t\t\t);\n\t\t\t\t\t/** @type {Map<ExportsInfo, Module>} */\n\t\t\t\t\tconst exportInfoToModuleMap = new Map();\n\n\t\t\t\t\t/** @type {TupleQueue<[Module, RuntimeSpec]>} */\n\t\t\t\t\tconst queue = new TupleQueue();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Module} module module to process\n\t\t\t\t\t * @param {(string[] | ReferencedExport)[]} usedExports list of used exports\n\t\t\t\t\t * @param {RuntimeSpec} runtime part of which runtime\n\t\t\t\t\t * @param {boolean} forceSideEffects always apply side effects\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst processReferencedModule = (\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tusedExports,\n\t\t\t\t\t\truntime,\n\t\t\t\t\t\tforceSideEffects\n\t\t\t\t\t) => {\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\tif (usedExports.length > 0) {\n\t\t\t\t\t\t\tif (!module.buildMeta || !module.buildMeta.exportsType) {\n\t\t\t\t\t\t\t\tif (exportsInfo.setUsedWithoutInfo(runtime)) {\n\t\t\t\t\t\t\t\t\tqueue.enqueue(module, runtime);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const usedExportInfo of usedExports) {\n\t\t\t\t\t\t\t\tlet usedExport;\n\t\t\t\t\t\t\t\tlet canMangle = true;\n\t\t\t\t\t\t\t\tif (Array.isArray(usedExportInfo)) {\n\t\t\t\t\t\t\t\t\tusedExport = usedExportInfo;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tusedExport = usedExportInfo.name;\n\t\t\t\t\t\t\t\t\tcanMangle = usedExportInfo.canMangle !== false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (usedExport.length === 0) {\n\t\t\t\t\t\t\t\t\tif (exportsInfo.setUsedInUnknownWay(runtime)) {\n\t\t\t\t\t\t\t\t\t\tqueue.enqueue(module, runtime);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlet currentExportsInfo = exportsInfo;\n\t\t\t\t\t\t\t\t\tfor (let i = 0; i < usedExport.length; i++) {\n\t\t\t\t\t\t\t\t\t\tconst exportInfo = currentExportsInfo.getExportInfo(\n\t\t\t\t\t\t\t\t\t\t\tusedExport[i]\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tif (canMangle === false) {\n\t\t\t\t\t\t\t\t\t\t\texportInfo.canMangleUse = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst lastOne = i === usedExport.length - 1;\n\t\t\t\t\t\t\t\t\t\tif (!lastOne) {\n\t\t\t\t\t\t\t\t\t\t\tconst nestedInfo = exportInfo.getNestedExportsInfo();\n\t\t\t\t\t\t\t\t\t\t\tif (nestedInfo) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.setUsedConditionally(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tused => used === UsageState.Unused,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsageState.OnlyPropertiesUsed,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst currentModule =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentExportsInfo === exportsInfo\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? module\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: exportInfoToModuleMap.get(currentExportsInfo);\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (currentModule) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tqueue.enqueue(currentModule, runtime);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentExportsInfo = nestedInfo;\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\texportInfo.setUsedConditionally(\n\t\t\t\t\t\t\t\t\t\t\t\tv => v !== UsageState.Used,\n\t\t\t\t\t\t\t\t\t\t\t\tUsageState.Used,\n\t\t\t\t\t\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tconst currentModule =\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentExportsInfo === exportsInfo\n\t\t\t\t\t\t\t\t\t\t\t\t\t? module\n\t\t\t\t\t\t\t\t\t\t\t\t\t: exportInfoToModuleMap.get(currentExportsInfo);\n\t\t\t\t\t\t\t\t\t\t\tif (currentModule) {\n\t\t\t\t\t\t\t\t\t\t\t\tqueue.enqueue(currentModule, runtime);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// for a module without side effects we stop tracking usage here when no export is used\n\t\t\t\t\t\t\t// This module won't be evaluated in this case\n\t\t\t\t\t\t\t// TODO webpack 6 remove this check\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!forceSideEffects &&\n\t\t\t\t\t\t\t\tmodule.factoryMeta !== undefined &&\n\t\t\t\t\t\t\t\tmodule.factoryMeta.sideEffectFree\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (exportsInfo.setUsedForSideEffectsOnly(runtime)) {\n\t\t\t\t\t\t\t\tqueue.enqueue(module, runtime);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {DependenciesBlock} module the module\n\t\t\t\t\t * @param {RuntimeSpec} runtime part of which runtime\n\t\t\t\t\t * @param {boolean} forceSideEffects always apply side effects\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst processModule = (module, runtime, forceSideEffects) => {\n\t\t\t\t\t\t/** @type {Map<Module, (string[] | ReferencedExport)[] | Map<string, string[] | ReferencedExport>>} */\n\t\t\t\t\t\tconst map = new Map();\n\n\t\t\t\t\t\t/** @type {ArrayQueue<DependenciesBlock>} */\n\t\t\t\t\t\tconst queue = new ArrayQueue();\n\t\t\t\t\t\tqueue.enqueue(module);\n\t\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\t\tconst block = queue.dequeue();\n\t\t\t\t\t\t\tif (block === undefined) break;\n\t\t\t\t\t\t\tfor (const b of block.blocks) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t!this.global &&\n\t\t\t\t\t\t\t\t\tb.groupOptions &&\n\t\t\t\t\t\t\t\t\tb.groupOptions.entryOptions\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tprocessModule(\n\t\t\t\t\t\t\t\t\t\tb,\n\t\t\t\t\t\t\t\t\t\tb.groupOptions.entryOptions.runtime || undefined,\n\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tqueue.enqueue(b);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const dep of block.dependencies) {\n\t\t\t\t\t\t\t\tconst connection = moduleGraph.getConnection(dep);\n\t\t\t\t\t\t\t\tif (!connection || !connection.module) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst activeState = connection.getActiveState(runtime);\n\t\t\t\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t\t\t\t\tconst { module } = connection;\n\t\t\t\t\t\t\t\tif (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n\t\t\t\t\t\t\t\t\tprocessModule(module, runtime, false);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst oldReferencedExports = map.get(module);\n\t\t\t\t\t\t\t\tif (oldReferencedExports === EXPORTS_OBJECT_REFERENCED) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst referencedExports =\n\t\t\t\t\t\t\t\t\tcompilation.getDependencyReferencedExports(dep, runtime);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\toldReferencedExports === undefined ||\n\t\t\t\t\t\t\t\t\toldReferencedExports === NO_EXPORTS_REFERENCED ||\n\t\t\t\t\t\t\t\t\treferencedExports === EXPORTS_OBJECT_REFERENCED\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tmap.set(module, referencedExports);\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\toldReferencedExports !== undefined &&\n\t\t\t\t\t\t\t\t\treferencedExports === NO_EXPORTS_REFERENCED\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlet exportsMap;\n\t\t\t\t\t\t\t\t\tif (Array.isArray(oldReferencedExports)) {\n\t\t\t\t\t\t\t\t\t\texportsMap = new Map();\n\t\t\t\t\t\t\t\t\t\tfor (const item of oldReferencedExports) {\n\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(item)) {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(item.join(\"\\n\"), item);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(item.name.join(\"\\n\"), item);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tmap.set(module, exportsMap);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\texportsMap = oldReferencedExports;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor (const item of referencedExports) {\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(item)) {\n\t\t\t\t\t\t\t\t\t\t\tconst key = item.join(\"\\n\");\n\t\t\t\t\t\t\t\t\t\t\tconst oldItem = exportsMap.get(key);\n\t\t\t\t\t\t\t\t\t\t\tif (oldItem === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(key, item);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// if oldItem is already an array we have to do nothing\n\t\t\t\t\t\t\t\t\t\t\t// if oldItem is an ReferencedExport object, we don't have to do anything\n\t\t\t\t\t\t\t\t\t\t\t// as canMangle defaults to true for arrays\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tconst key = item.name.join(\"\\n\");\n\t\t\t\t\t\t\t\t\t\t\tconst oldItem = exportsMap.get(key);\n\t\t\t\t\t\t\t\t\t\t\tif (oldItem === undefined || Array.isArray(oldItem)) {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(key, item);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(key, {\n\t\t\t\t\t\t\t\t\t\t\t\t\tname: item.name,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcanMangle: item.canMangle && oldItem.canMangle\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const [module, referencedExports] of map) {\n\t\t\t\t\t\t\tif (Array.isArray(referencedExports)) {\n\t\t\t\t\t\t\t\tprocessReferencedModule(\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\treferencedExports,\n\t\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\t\tforceSideEffects\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprocessReferencedModule(\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\tArray.from(referencedExports.values()),\n\t\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\t\tforceSideEffects\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tlogger.time(\"initialize exports usage\");\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\texportInfoToModuleMap.set(exportsInfo, module);\n\t\t\t\t\t\texportsInfo.setHasUseInfo();\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"initialize exports usage\");\n\n\t\t\t\t\tlogger.time(\"trace exports usage in graph\");\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Dependency} dep dependency\n\t\t\t\t\t * @param {RuntimeSpec} runtime runtime\n\t\t\t\t\t */\n\t\t\t\t\tconst processEntryDependency = (dep, runtime) => {\n\t\t\t\t\t\tconst module = moduleGraph.getModule(dep);\n\t\t\t\t\t\tif (module) {\n\t\t\t\t\t\t\tprocessReferencedModule(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\tNO_EXPORTS_REFERENCED,\n\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t/** @type {RuntimeSpec} */\n\t\t\t\t\tlet globalRuntime = undefined;\n\t\t\t\t\tfor (const [\n\t\t\t\t\t\tentryName,\n\t\t\t\t\t\t{ dependencies: deps, includeDependencies: includeDeps, options }\n\t\t\t\t\t] of compilation.entries) {\n\t\t\t\t\t\tconst runtime = this.global\n\t\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t\t: getEntryRuntime(compilation, entryName, options);\n\t\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\t\tprocessEntryDependency(dep, runtime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const dep of includeDeps) {\n\t\t\t\t\t\t\tprocessEntryDependency(dep, runtime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tglobalRuntime = mergeRuntimeOwned(globalRuntime, runtime);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const dep of compilation.globalEntry.dependencies) {\n\t\t\t\t\t\tprocessEntryDependency(dep, globalRuntime);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const dep of compilation.globalEntry.includeDependencies) {\n\t\t\t\t\t\tprocessEntryDependency(dep, globalRuntime);\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (queue.length) {\n\t\t\t\t\t\tconst [module, runtime] = queue.dequeue();\n\t\t\t\t\t\tprocessModule(module, runtime, false);\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"trace exports usage in graph\");\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = FlagDependencyUsagePlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}