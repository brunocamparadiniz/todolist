{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _require = require(\"./helpers/getFromStreamChunks\"),\n  getMap = _require.getMap,\n  getSourceAndMap = _require.getSourceAndMap;\nvar splitIntoLines = require(\"./helpers/splitIntoLines\");\nvar getGeneratedSourceInfo = require(\"./helpers/getGeneratedSourceInfo\");\nvar Source = require(\"./Source\");\nvar splitIntoPotentialTokens = require(\"./helpers/splitIntoPotentialTokens\");\nvar OriginalSource = /*#__PURE__*/function (_Source) {\n  _inherits(OriginalSource, _Source);\n  var _super = _createSuper(OriginalSource);\n  function OriginalSource(value, name) {\n    var _this;\n    _classCallCheck(this, OriginalSource);\n    _this = _super.call(this);\n    var isBuffer = Buffer.isBuffer(value);\n    _this._value = isBuffer ? undefined : value;\n    _this._valueAsBuffer = isBuffer ? value : undefined;\n    _this._name = name;\n    return _this;\n  }\n  _createClass(OriginalSource, [{\n    key: \"getName\",\n    value: function getName() {\n      return this._name;\n    }\n  }, {\n    key: \"source\",\n    value: function source() {\n      if (this._value === undefined) {\n        this._value = this._valueAsBuffer.toString(\"utf-8\");\n      }\n      return this._value;\n    }\n  }, {\n    key: \"buffer\",\n    value: function buffer() {\n      if (this._valueAsBuffer === undefined) {\n        this._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n      }\n      return this._valueAsBuffer;\n    }\n  }, {\n    key: \"map\",\n    value: function map(options) {\n      return getMap(this, options);\n    }\n  }, {\n    key: \"sourceAndMap\",\n    value: function sourceAndMap(options) {\n      return getSourceAndMap(this, options);\n    }\n\n    /**\n     * @param {object} options options\n     * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code\n     * @param {function(number, string, string)} onSource called for each source\n     * @param {function(number, string)} onName called for each name\n     * @returns {void}\n     */\n  }, {\n    key: \"streamChunks\",\n    value: function streamChunks(options, onChunk, onSource, onName) {\n      if (this._value === undefined) {\n        this._value = this._valueAsBuffer.toString(\"utf-8\");\n      }\n      onSource(0, this._name, this._value);\n      var finalSource = !!(options && options.finalSource);\n      if (!options || options.columns !== false) {\n        // With column info we need to read all lines and split them\n        var matches = splitIntoPotentialTokens(this._value);\n        var line = 1;\n        var column = 0;\n        if (matches !== null) {\n          var _iterator = _createForOfIteratorHelper(matches),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var match = _step.value;\n              var isEndOfLine = match.endsWith(\"\\n\");\n              if (isEndOfLine && match.length === 1) {\n                if (!finalSource) onChunk(match, line, column, -1, -1, -1, -1);\n              } else {\n                var chunk = finalSource ? undefined : match;\n                onChunk(chunk, line, column, 0, line, column, -1);\n              }\n              if (isEndOfLine) {\n                line++;\n                column = 0;\n              } else {\n                column += match.length;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n        return {\n          generatedLine: line,\n          generatedColumn: column,\n          source: finalSource ? this._value : undefined\n        };\n      } else if (finalSource) {\n        // Without column info and with final source we only\n        // need meta info to generate mapping\n        var result = getGeneratedSourceInfo(this._value);\n        var generatedLine = result.generatedLine,\n          generatedColumn = result.generatedColumn;\n        if (generatedColumn === 0) {\n          for (var _line = 1; _line < generatedLine; _line++) onChunk(undefined, _line, 0, 0, _line, 0, -1);\n        } else {\n          for (var _line2 = 1; _line2 <= generatedLine; _line2++) onChunk(undefined, _line2, 0, 0, _line2, 0, -1);\n        }\n        return result;\n      } else {\n        // Without column info, but also without final source\n        // we need to split source by lines\n        var _line3 = 1;\n        var _matches = splitIntoLines(this._value);\n        var _match;\n        var _iterator2 = _createForOfIteratorHelper(_matches),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            _match = _step2.value;\n            onChunk(finalSource ? undefined : _match, _line3, 0, 0, _line3, 0, -1);\n            _line3++;\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        return _matches.length === 0 || _match.endsWith(\"\\n\") ? {\n          generatedLine: _matches.length + 1,\n          generatedColumn: 0,\n          source: finalSource ? this._value : undefined\n        } : {\n          generatedLine: _matches.length,\n          generatedColumn: _match.length,\n          source: finalSource ? this._value : undefined\n        };\n      }\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      if (this._valueAsBuffer === undefined) {\n        this._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n      }\n      hash.update(\"OriginalSource\");\n      hash.update(this._valueAsBuffer);\n      hash.update(this._name || \"\");\n    }\n  }]);\n  return OriginalSource;\n}(Source);\nmodule.exports = OriginalSource;","map":{"version":3,"names":["require","getMap","getSourceAndMap","splitIntoLines","getGeneratedSourceInfo","Source","splitIntoPotentialTokens","OriginalSource","value","name","isBuffer","Buffer","_value","undefined","_valueAsBuffer","_name","toString","from","options","onChunk","onSource","onName","finalSource","columns","matches","line","column","match","isEndOfLine","endsWith","length","chunk","generatedLine","generatedColumn","source","result","hash","update","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack-sources/lib/OriginalSource.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\nconst splitIntoLines = require(\"./helpers/splitIntoLines\");\nconst getGeneratedSourceInfo = require(\"./helpers/getGeneratedSourceInfo\");\nconst Source = require(\"./Source\");\nconst splitIntoPotentialTokens = require(\"./helpers/splitIntoPotentialTokens\");\n\nclass OriginalSource extends Source {\n\tconstructor(value, name) {\n\t\tsuper();\n\t\tconst isBuffer = Buffer.isBuffer(value);\n\t\tthis._value = isBuffer ? undefined : value;\n\t\tthis._valueAsBuffer = isBuffer ? value : undefined;\n\t\tthis._name = name;\n\t}\n\n\tgetName() {\n\t\treturn this._name;\n\t}\n\n\tsource() {\n\t\tif (this._value === undefined) {\n\t\t\tthis._value = this._valueAsBuffer.toString(\"utf-8\");\n\t\t}\n\t\treturn this._value;\n\t}\n\n\tbuffer() {\n\t\tif (this._valueAsBuffer === undefined) {\n\t\t\tthis._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n\t\t}\n\t\treturn this._valueAsBuffer;\n\t}\n\n\tmap(options) {\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\t/**\n\t * @param {object} options options\n\t * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code\n\t * @param {function(number, string, string)} onSource called for each source\n\t * @param {function(number, string)} onName called for each name\n\t * @returns {void}\n\t */\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tif (this._value === undefined) {\n\t\t\tthis._value = this._valueAsBuffer.toString(\"utf-8\");\n\t\t}\n\t\tonSource(0, this._name, this._value);\n\t\tconst finalSource = !!(options && options.finalSource);\n\t\tif (!options || options.columns !== false) {\n\t\t\t// With column info we need to read all lines and split them\n\t\t\tconst matches = splitIntoPotentialTokens(this._value);\n\t\t\tlet line = 1;\n\t\t\tlet column = 0;\n\t\t\tif (matches !== null) {\n\t\t\t\tfor (const match of matches) {\n\t\t\t\t\tconst isEndOfLine = match.endsWith(\"\\n\");\n\t\t\t\t\tif (isEndOfLine && match.length === 1) {\n\t\t\t\t\t\tif (!finalSource) onChunk(match, line, column, -1, -1, -1, -1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst chunk = finalSource ? undefined : match;\n\t\t\t\t\t\tonChunk(chunk, line, column, 0, line, column, -1);\n\t\t\t\t\t}\n\t\t\t\t\tif (isEndOfLine) {\n\t\t\t\t\t\tline++;\n\t\t\t\t\t\tcolumn = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumn += match.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tgeneratedLine: line,\n\t\t\t\tgeneratedColumn: column,\n\t\t\t\tsource: finalSource ? this._value : undefined\n\t\t\t};\n\t\t} else if (finalSource) {\n\t\t\t// Without column info and with final source we only\n\t\t\t// need meta info to generate mapping\n\t\t\tconst result = getGeneratedSourceInfo(this._value);\n\t\t\tconst { generatedLine, generatedColumn } = result;\n\t\t\tif (generatedColumn === 0) {\n\t\t\t\tfor (let line = 1; line < generatedLine; line++)\n\t\t\t\t\tonChunk(undefined, line, 0, 0, line, 0, -1);\n\t\t\t} else {\n\t\t\t\tfor (let line = 1; line <= generatedLine; line++)\n\t\t\t\t\tonChunk(undefined, line, 0, 0, line, 0, -1);\n\t\t\t}\n\t\t\treturn result;\n\t\t} else {\n\t\t\t// Without column info, but also without final source\n\t\t\t// we need to split source by lines\n\t\t\tlet line = 1;\n\t\t\tconst matches = splitIntoLines(this._value);\n\t\t\tlet match;\n\t\t\tfor (match of matches) {\n\t\t\t\tonChunk(finalSource ? undefined : match, line, 0, 0, line, 0, -1);\n\t\t\t\tline++;\n\t\t\t}\n\t\t\treturn matches.length === 0 || match.endsWith(\"\\n\")\n\t\t\t\t? {\n\t\t\t\t\t\tgeneratedLine: matches.length + 1,\n\t\t\t\t\t\tgeneratedColumn: 0,\n\t\t\t\t\t\tsource: finalSource ? this._value : undefined\n\t\t\t\t  }\n\t\t\t\t: {\n\t\t\t\t\t\tgeneratedLine: matches.length,\n\t\t\t\t\t\tgeneratedColumn: match.length,\n\t\t\t\t\t\tsource: finalSource ? this._value : undefined\n\t\t\t\t  };\n\t\t}\n\t}\n\n\tupdateHash(hash) {\n\t\tif (this._valueAsBuffer === undefined) {\n\t\t\tthis._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n\t\t}\n\t\thash.update(\"OriginalSource\");\n\t\thash.update(this._valueAsBuffer);\n\t\thash.update(this._name || \"\");\n\t}\n}\n\nmodule.exports = OriginalSource;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}