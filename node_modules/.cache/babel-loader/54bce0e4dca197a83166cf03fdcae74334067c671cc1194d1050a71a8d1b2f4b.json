{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _require = require(\"tapable\"),\n  SyncHook = _require.SyncHook;\n\n/**\n * @typedef {Object} RuleCondition\n * @property {string | string[]} property\n * @property {boolean} matchWhenEmpty\n * @property {function(string): boolean} fn\n */\n\n/**\n * @typedef {Object} Condition\n * @property {boolean} matchWhenEmpty\n * @property {function(string): boolean} fn\n */\n\n/**\n * @typedef {Object} CompiledRule\n * @property {RuleCondition[]} conditions\n * @property {(Effect|function(object): Effect[])[]} effects\n * @property {CompiledRule[]=} rules\n * @property {CompiledRule[]=} oneOf\n */\n\n/**\n * @typedef {Object} Effect\n * @property {string} type\n * @property {any} value\n */\n\n/**\n * @typedef {Object} RuleSet\n * @property {Map<string, any>} references map of references in the rule set (may grow over time)\n * @property {function(object): Effect[]} exec execute the rule set\n */\nvar RuleSetCompiler = /*#__PURE__*/function () {\n  function RuleSetCompiler(plugins) {\n    _classCallCheck(this, RuleSetCompiler);\n    this.hooks = Object.freeze({\n      /** @type {SyncHook<[string, object, Set<string>, CompiledRule, Map<string, any>]>} */\n      rule: new SyncHook([\"path\", \"rule\", \"unhandledProperties\", \"compiledRule\", \"references\"])\n    });\n    if (plugins) {\n      var _iterator = _createForOfIteratorHelper(plugins),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var plugin = _step.value;\n          plugin.apply(this);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }\n\n  /**\n   * @param {object[]} ruleSet raw user provided rules\n   * @returns {RuleSet} compiled RuleSet\n   */\n  _createClass(RuleSetCompiler, [{\n    key: \"compile\",\n    value: function compile(ruleSet) {\n      var refs = new Map();\n      var rules = this.compileRules(\"ruleSet\", ruleSet, refs);\n\n      /**\n       * @param {object} data data passed in\n       * @param {CompiledRule} rule the compiled rule\n       * @param {Effect[]} effects an array where effects are pushed to\n       * @returns {boolean} true, if the rule has matched\n       */\n      var execRule = function execRule(data, rule, effects) {\n        var _iterator2 = _createForOfIteratorHelper(rule.conditions),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var condition = _step2.value;\n            var p = condition.property;\n            if (Array.isArray(p)) {\n              var current = data;\n              var _iterator6 = _createForOfIteratorHelper(p),\n                _step6;\n              try {\n                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                  var subProperty = _step6.value;\n                  if (current && typeof current === \"object\" && Object.prototype.hasOwnProperty.call(current, subProperty)) {\n                    current = current[subProperty];\n                  } else {\n                    current = undefined;\n                    break;\n                  }\n                }\n              } catch (err) {\n                _iterator6.e(err);\n              } finally {\n                _iterator6.f();\n              }\n              if (current !== undefined) {\n                if (!condition.fn(current)) return false;\n                continue;\n              }\n            } else if (p in data) {\n              var value = data[p];\n              if (value !== undefined) {\n                if (!condition.fn(value)) return false;\n                continue;\n              }\n            }\n            if (!condition.matchWhenEmpty) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        var _iterator3 = _createForOfIteratorHelper(rule.effects),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var effect = _step3.value;\n            if (typeof effect === \"function\") {\n              var returnedEffects = effect(data);\n              var _iterator7 = _createForOfIteratorHelper(returnedEffects),\n                _step7;\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var _effect = _step7.value;\n                  effects.push(_effect);\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n            } else {\n              effects.push(effect);\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        if (rule.rules) {\n          var _iterator4 = _createForOfIteratorHelper(rule.rules),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var childRule = _step4.value;\n              execRule(data, childRule, effects);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n        if (rule.oneOf) {\n          var _iterator5 = _createForOfIteratorHelper(rule.oneOf),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _childRule = _step5.value;\n              if (execRule(data, _childRule, effects)) {\n                break;\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n        return true;\n      };\n      return {\n        references: refs,\n        exec: function exec(data) {\n          /** @type {Effect[]} */\n          var effects = [];\n          var _iterator8 = _createForOfIteratorHelper(rules),\n            _step8;\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var rule = _step8.value;\n              execRule(data, rule, effects);\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n          return effects;\n        }\n      };\n    }\n\n    /**\n     * @param {string} path current path\n     * @param {object[]} rules the raw rules provided by user\n     * @param {Map<string, any>} refs references\n     * @returns {CompiledRule[]} rules\n     */\n  }, {\n    key: \"compileRules\",\n    value: function compileRules(path, rules, refs) {\n      var _this = this;\n      return rules.map(function (rule, i) {\n        return _this.compileRule(\"\".concat(path, \"[\").concat(i, \"]\"), rule, refs);\n      });\n    }\n\n    /**\n     * @param {string} path current path\n     * @param {object} rule the raw rule provided by user\n     * @param {Map<string, any>} refs references\n     * @returns {CompiledRule} normalized and compiled rule for processing\n     */\n  }, {\n    key: \"compileRule\",\n    value: function compileRule(path, rule, refs) {\n      var unhandledProperties = new Set(Object.keys(rule).filter(function (key) {\n        return rule[key] !== undefined;\n      }));\n\n      /** @type {CompiledRule} */\n      var compiledRule = {\n        conditions: [],\n        effects: [],\n        rules: undefined,\n        oneOf: undefined\n      };\n      this.hooks.rule.call(path, rule, unhandledProperties, compiledRule, refs);\n      if (unhandledProperties.has(\"rules\")) {\n        unhandledProperties.delete(\"rules\");\n        var rules = rule.rules;\n        if (!Array.isArray(rules)) throw this.error(path, rules, \"Rule.rules must be an array of rules\");\n        compiledRule.rules = this.compileRules(\"\".concat(path, \".rules\"), rules, refs);\n      }\n      if (unhandledProperties.has(\"oneOf\")) {\n        unhandledProperties.delete(\"oneOf\");\n        var oneOf = rule.oneOf;\n        if (!Array.isArray(oneOf)) throw this.error(path, oneOf, \"Rule.oneOf must be an array of rules\");\n        compiledRule.oneOf = this.compileRules(\"\".concat(path, \".oneOf\"), oneOf, refs);\n      }\n      if (unhandledProperties.size > 0) {\n        throw this.error(path, rule, \"Properties \".concat(Array.from(unhandledProperties).join(\", \"), \" are unknown\"));\n      }\n      return compiledRule;\n    }\n\n    /**\n     * @param {string} path current path\n     * @param {any} condition user provided condition value\n     * @returns {Condition} compiled condition\n     */\n  }, {\n    key: \"compileCondition\",\n    value: function compileCondition(path, condition) {\n      var _this2 = this;\n      if (condition === \"\") {\n        return {\n          matchWhenEmpty: true,\n          fn: function fn(str) {\n            return str === \"\";\n          }\n        };\n      }\n      if (!condition) {\n        throw this.error(path, condition, \"Expected condition but got falsy value\");\n      }\n      if (typeof condition === \"string\") {\n        return {\n          matchWhenEmpty: condition.length === 0,\n          fn: function fn(str) {\n            return typeof str === \"string\" && str.startsWith(condition);\n          }\n        };\n      }\n      if (typeof condition === \"function\") {\n        try {\n          return {\n            matchWhenEmpty: condition(\"\"),\n            fn: condition\n          };\n        } catch (err) {\n          throw this.error(path, condition, \"Evaluation of condition function threw error\");\n        }\n      }\n      if (condition instanceof RegExp) {\n        return {\n          matchWhenEmpty: condition.test(\"\"),\n          fn: function fn(v) {\n            return typeof v === \"string\" && condition.test(v);\n          }\n        };\n      }\n      if (Array.isArray(condition)) {\n        var items = condition.map(function (c, i) {\n          return _this2.compileCondition(\"\".concat(path, \"[\").concat(i, \"]\"), c);\n        });\n        return this.combineConditionsOr(items);\n      }\n      if (typeof condition !== \"object\") {\n        throw this.error(path, condition, \"Unexpected \".concat(typeof condition, \" when condition was expected\"));\n      }\n      var conditions = [];\n      var _loop = function _loop() {\n        var key = _Object$keys[_i];\n        var value = condition[key];\n        switch (key) {\n          case \"or\":\n            if (value) {\n              if (!Array.isArray(value)) {\n                throw _this2.error(\"\".concat(path, \".or\"), condition.and, \"Expected array of conditions\");\n              }\n              conditions.push(_this2.compileCondition(\"\".concat(path, \".or\"), value));\n            }\n            break;\n          case \"and\":\n            if (value) {\n              if (!Array.isArray(value)) {\n                throw _this2.error(\"\".concat(path, \".and\"), condition.and, \"Expected array of conditions\");\n              }\n              var i = 0;\n              var _iterator9 = _createForOfIteratorHelper(value),\n                _step9;\n              try {\n                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                  var item = _step9.value;\n                  conditions.push(_this2.compileCondition(\"\".concat(path, \".and[\").concat(i, \"]\"), item));\n                  i++;\n                }\n              } catch (err) {\n                _iterator9.e(err);\n              } finally {\n                _iterator9.f();\n              }\n            }\n            break;\n          case \"not\":\n            if (value) {\n              var matcher = _this2.compileCondition(\"\".concat(path, \".not\"), value);\n              var _fn = matcher.fn;\n              conditions.push({\n                matchWhenEmpty: !matcher.matchWhenEmpty,\n                fn: function fn(v) {\n                  return !_fn(v);\n                }\n              });\n            }\n            break;\n          default:\n            throw _this2.error(\"\".concat(path, \".\").concat(key), condition[key], \"Unexpected property \".concat(key, \" in condition\"));\n        }\n      };\n      for (var _i = 0, _Object$keys = Object.keys(condition); _i < _Object$keys.length; _i++) {\n        _loop();\n      }\n      if (conditions.length === 0) {\n        throw this.error(path, condition, \"Expected condition, but got empty thing\");\n      }\n      return this.combineConditionsAnd(conditions);\n    }\n\n    /**\n     * @param {Condition[]} conditions some conditions\n     * @returns {Condition} merged condition\n     */\n  }, {\n    key: \"combineConditionsOr\",\n    value: function combineConditionsOr(conditions) {\n      if (conditions.length === 0) {\n        return {\n          matchWhenEmpty: false,\n          fn: function fn() {\n            return false;\n          }\n        };\n      } else if (conditions.length === 1) {\n        return conditions[0];\n      } else {\n        return {\n          matchWhenEmpty: conditions.some(function (c) {\n            return c.matchWhenEmpty;\n          }),\n          fn: function fn(v) {\n            return conditions.some(function (c) {\n              return c.fn(v);\n            });\n          }\n        };\n      }\n    }\n\n    /**\n     * @param {Condition[]} conditions some conditions\n     * @returns {Condition} merged condition\n     */\n  }, {\n    key: \"combineConditionsAnd\",\n    value: function combineConditionsAnd(conditions) {\n      if (conditions.length === 0) {\n        return {\n          matchWhenEmpty: false,\n          fn: function fn() {\n            return false;\n          }\n        };\n      } else if (conditions.length === 1) {\n        return conditions[0];\n      } else {\n        return {\n          matchWhenEmpty: conditions.every(function (c) {\n            return c.matchWhenEmpty;\n          }),\n          fn: function fn(v) {\n            return conditions.every(function (c) {\n              return c.fn(v);\n            });\n          }\n        };\n      }\n    }\n\n    /**\n     * @param {string} path current path\n     * @param {any} value value at the error location\n     * @param {string} message message explaining the problem\n     * @returns {Error} an error object\n     */\n  }, {\n    key: \"error\",\n    value: function error(path, value, message) {\n      return new Error(\"Compiling RuleSet failed: \".concat(message, \" (at \").concat(path, \": \").concat(value, \")\"));\n    }\n  }]);\n  return RuleSetCompiler;\n}();\nmodule.exports = RuleSetCompiler;","map":{"version":3,"names":["require","SyncHook","RuleSetCompiler","plugins","hooks","Object","freeze","rule","plugin","apply","ruleSet","refs","Map","rules","compileRules","execRule","data","effects","conditions","condition","p","property","Array","isArray","current","subProperty","prototype","hasOwnProperty","call","undefined","fn","value","matchWhenEmpty","effect","returnedEffects","push","childRule","oneOf","references","exec","path","map","i","compileRule","unhandledProperties","Set","keys","filter","key","compiledRule","has","delete","error","size","from","join","str","length","startsWith","err","RegExp","test","v","items","c","compileCondition","combineConditionsOr","and","item","matcher","combineConditionsAnd","some","every","message","Error","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/rules/RuleSetCompiler.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { SyncHook } = require(\"tapable\");\n\n/**\n * @typedef {Object} RuleCondition\n * @property {string | string[]} property\n * @property {boolean} matchWhenEmpty\n * @property {function(string): boolean} fn\n */\n\n/**\n * @typedef {Object} Condition\n * @property {boolean} matchWhenEmpty\n * @property {function(string): boolean} fn\n */\n\n/**\n * @typedef {Object} CompiledRule\n * @property {RuleCondition[]} conditions\n * @property {(Effect|function(object): Effect[])[]} effects\n * @property {CompiledRule[]=} rules\n * @property {CompiledRule[]=} oneOf\n */\n\n/**\n * @typedef {Object} Effect\n * @property {string} type\n * @property {any} value\n */\n\n/**\n * @typedef {Object} RuleSet\n * @property {Map<string, any>} references map of references in the rule set (may grow over time)\n * @property {function(object): Effect[]} exec execute the rule set\n */\n\nclass RuleSetCompiler {\n\tconstructor(plugins) {\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {SyncHook<[string, object, Set<string>, CompiledRule, Map<string, any>]>} */\n\t\t\trule: new SyncHook([\n\t\t\t\t\"path\",\n\t\t\t\t\"rule\",\n\t\t\t\t\"unhandledProperties\",\n\t\t\t\t\"compiledRule\",\n\t\t\t\t\"references\"\n\t\t\t])\n\t\t});\n\t\tif (plugins) {\n\t\t\tfor (const plugin of plugins) {\n\t\t\t\tplugin.apply(this);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {object[]} ruleSet raw user provided rules\n\t * @returns {RuleSet} compiled RuleSet\n\t */\n\tcompile(ruleSet) {\n\t\tconst refs = new Map();\n\t\tconst rules = this.compileRules(\"ruleSet\", ruleSet, refs);\n\n\t\t/**\n\t\t * @param {object} data data passed in\n\t\t * @param {CompiledRule} rule the compiled rule\n\t\t * @param {Effect[]} effects an array where effects are pushed to\n\t\t * @returns {boolean} true, if the rule has matched\n\t\t */\n\t\tconst execRule = (data, rule, effects) => {\n\t\t\tfor (const condition of rule.conditions) {\n\t\t\t\tconst p = condition.property;\n\t\t\t\tif (Array.isArray(p)) {\n\t\t\t\t\tlet current = data;\n\t\t\t\t\tfor (const subProperty of p) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcurrent &&\n\t\t\t\t\t\t\ttypeof current === \"object\" &&\n\t\t\t\t\t\t\tObject.prototype.hasOwnProperty.call(current, subProperty)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcurrent = current[subProperty];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrent = undefined;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (current !== undefined) {\n\t\t\t\t\t\tif (!condition.fn(current)) return false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else if (p in data) {\n\t\t\t\t\tconst value = data[p];\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\tif (!condition.fn(value)) return false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!condition.matchWhenEmpty) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const effect of rule.effects) {\n\t\t\t\tif (typeof effect === \"function\") {\n\t\t\t\t\tconst returnedEffects = effect(data);\n\t\t\t\t\tfor (const effect of returnedEffects) {\n\t\t\t\t\t\teffects.push(effect);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\teffects.push(effect);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rule.rules) {\n\t\t\t\tfor (const childRule of rule.rules) {\n\t\t\t\t\texecRule(data, childRule, effects);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rule.oneOf) {\n\t\t\t\tfor (const childRule of rule.oneOf) {\n\t\t\t\t\tif (execRule(data, childRule, effects)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\treturn {\n\t\t\treferences: refs,\n\t\t\texec: data => {\n\t\t\t\t/** @type {Effect[]} */\n\t\t\t\tconst effects = [];\n\t\t\t\tfor (const rule of rules) {\n\t\t\t\t\texecRule(data, rule, effects);\n\t\t\t\t}\n\t\t\t\treturn effects;\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * @param {string} path current path\n\t * @param {object[]} rules the raw rules provided by user\n\t * @param {Map<string, any>} refs references\n\t * @returns {CompiledRule[]} rules\n\t */\n\tcompileRules(path, rules, refs) {\n\t\treturn rules.map((rule, i) =>\n\t\t\tthis.compileRule(`${path}[${i}]`, rule, refs)\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} path current path\n\t * @param {object} rule the raw rule provided by user\n\t * @param {Map<string, any>} refs references\n\t * @returns {CompiledRule} normalized and compiled rule for processing\n\t */\n\tcompileRule(path, rule, refs) {\n\t\tconst unhandledProperties = new Set(\n\t\t\tObject.keys(rule).filter(key => rule[key] !== undefined)\n\t\t);\n\n\t\t/** @type {CompiledRule} */\n\t\tconst compiledRule = {\n\t\t\tconditions: [],\n\t\t\teffects: [],\n\t\t\trules: undefined,\n\t\t\toneOf: undefined\n\t\t};\n\n\t\tthis.hooks.rule.call(path, rule, unhandledProperties, compiledRule, refs);\n\n\t\tif (unhandledProperties.has(\"rules\")) {\n\t\t\tunhandledProperties.delete(\"rules\");\n\t\t\tconst rules = rule.rules;\n\t\t\tif (!Array.isArray(rules))\n\t\t\t\tthrow this.error(path, rules, \"Rule.rules must be an array of rules\");\n\t\t\tcompiledRule.rules = this.compileRules(`${path}.rules`, rules, refs);\n\t\t}\n\n\t\tif (unhandledProperties.has(\"oneOf\")) {\n\t\t\tunhandledProperties.delete(\"oneOf\");\n\t\t\tconst oneOf = rule.oneOf;\n\t\t\tif (!Array.isArray(oneOf))\n\t\t\t\tthrow this.error(path, oneOf, \"Rule.oneOf must be an array of rules\");\n\t\t\tcompiledRule.oneOf = this.compileRules(`${path}.oneOf`, oneOf, refs);\n\t\t}\n\n\t\tif (unhandledProperties.size > 0) {\n\t\t\tthrow this.error(\n\t\t\t\tpath,\n\t\t\t\trule,\n\t\t\t\t`Properties ${Array.from(unhandledProperties).join(\", \")} are unknown`\n\t\t\t);\n\t\t}\n\n\t\treturn compiledRule;\n\t}\n\n\t/**\n\t * @param {string} path current path\n\t * @param {any} condition user provided condition value\n\t * @returns {Condition} compiled condition\n\t */\n\tcompileCondition(path, condition) {\n\t\tif (condition === \"\") {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: true,\n\t\t\t\tfn: str => str === \"\"\n\t\t\t};\n\t\t}\n\t\tif (!condition) {\n\t\t\tthrow this.error(\n\t\t\t\tpath,\n\t\t\t\tcondition,\n\t\t\t\t\"Expected condition but got falsy value\"\n\t\t\t);\n\t\t}\n\t\tif (typeof condition === \"string\") {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: condition.length === 0,\n\t\t\t\tfn: str => typeof str === \"string\" && str.startsWith(condition)\n\t\t\t};\n\t\t}\n\t\tif (typeof condition === \"function\") {\n\t\t\ttry {\n\t\t\t\treturn {\n\t\t\t\t\tmatchWhenEmpty: condition(\"\"),\n\t\t\t\t\tfn: condition\n\t\t\t\t};\n\t\t\t} catch (err) {\n\t\t\t\tthrow this.error(\n\t\t\t\t\tpath,\n\t\t\t\t\tcondition,\n\t\t\t\t\t\"Evaluation of condition function threw error\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (condition instanceof RegExp) {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: condition.test(\"\"),\n\t\t\t\tfn: v => typeof v === \"string\" && condition.test(v)\n\t\t\t};\n\t\t}\n\t\tif (Array.isArray(condition)) {\n\t\t\tconst items = condition.map((c, i) =>\n\t\t\t\tthis.compileCondition(`${path}[${i}]`, c)\n\t\t\t);\n\t\t\treturn this.combineConditionsOr(items);\n\t\t}\n\n\t\tif (typeof condition !== \"object\") {\n\t\t\tthrow this.error(\n\t\t\t\tpath,\n\t\t\t\tcondition,\n\t\t\t\t`Unexpected ${typeof condition} when condition was expected`\n\t\t\t);\n\t\t}\n\n\t\tconst conditions = [];\n\t\tfor (const key of Object.keys(condition)) {\n\t\t\tconst value = condition[key];\n\t\t\tswitch (key) {\n\t\t\t\tcase \"or\":\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\t\t\tthrow this.error(\n\t\t\t\t\t\t\t\t`${path}.or`,\n\t\t\t\t\t\t\t\tcondition.and,\n\t\t\t\t\t\t\t\t\"Expected array of conditions\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconditions.push(this.compileCondition(`${path}.or`, value));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"and\":\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\t\t\tthrow this.error(\n\t\t\t\t\t\t\t\t`${path}.and`,\n\t\t\t\t\t\t\t\tcondition.and,\n\t\t\t\t\t\t\t\t\"Expected array of conditions\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\tfor (const item of value) {\n\t\t\t\t\t\t\tconditions.push(this.compileCondition(`${path}.and[${i}]`, item));\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"not\":\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tconst matcher = this.compileCondition(`${path}.not`, value);\n\t\t\t\t\t\tconst fn = matcher.fn;\n\t\t\t\t\t\tconditions.push({\n\t\t\t\t\t\t\tmatchWhenEmpty: !matcher.matchWhenEmpty,\n\t\t\t\t\t\t\tfn: v => !fn(v)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow this.error(\n\t\t\t\t\t\t`${path}.${key}`,\n\t\t\t\t\t\tcondition[key],\n\t\t\t\t\t\t`Unexpected property ${key} in condition`\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (conditions.length === 0) {\n\t\t\tthrow this.error(\n\t\t\t\tpath,\n\t\t\t\tcondition,\n\t\t\t\t\"Expected condition, but got empty thing\"\n\t\t\t);\n\t\t}\n\t\treturn this.combineConditionsAnd(conditions);\n\t}\n\n\t/**\n\t * @param {Condition[]} conditions some conditions\n\t * @returns {Condition} merged condition\n\t */\n\tcombineConditionsOr(conditions) {\n\t\tif (conditions.length === 0) {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: false,\n\t\t\t\tfn: () => false\n\t\t\t};\n\t\t} else if (conditions.length === 1) {\n\t\t\treturn conditions[0];\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: conditions.some(c => c.matchWhenEmpty),\n\t\t\t\tfn: v => conditions.some(c => c.fn(v))\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * @param {Condition[]} conditions some conditions\n\t * @returns {Condition} merged condition\n\t */\n\tcombineConditionsAnd(conditions) {\n\t\tif (conditions.length === 0) {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: false,\n\t\t\t\tfn: () => false\n\t\t\t};\n\t\t} else if (conditions.length === 1) {\n\t\t\treturn conditions[0];\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: conditions.every(c => c.matchWhenEmpty),\n\t\t\t\tfn: v => conditions.every(c => c.fn(v))\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} path current path\n\t * @param {any} value value at the error location\n\t * @param {string} message message explaining the problem\n\t * @returns {Error} an error object\n\t */\n\terror(path, value, message) {\n\t\treturn new Error(\n\t\t\t`Compiling RuleSet failed: ${message} (at ${path}: ${value})`\n\t\t);\n\t}\n}\n\nmodule.exports = RuleSetCompiler;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}