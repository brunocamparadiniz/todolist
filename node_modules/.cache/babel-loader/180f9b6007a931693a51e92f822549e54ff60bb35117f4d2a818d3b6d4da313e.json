{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar getGeneratedSourceInfo = require(\"./getGeneratedSourceInfo\");\nvar getSource = require(\"./getSource\");\nvar readMappings = require(\"./readMappings\");\nvar splitIntoLines = require(\"./splitIntoLines\");\nvar streamChunksOfSourceMapFull = function streamChunksOfSourceMapFull(source, sourceMap, onChunk, onSource, onName) {\n  var lines = splitIntoLines(source);\n  if (lines.length === 0) {\n    return {\n      generatedLine: 1,\n      generatedColumn: 0\n    };\n  }\n  var sources = sourceMap.sources,\n    sourcesContent = sourceMap.sourcesContent,\n    names = sourceMap.names,\n    mappings = sourceMap.mappings;\n  for (var i = 0; i < sources.length; i++) {\n    onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || undefined);\n  }\n  if (names) {\n    for (var _i = 0; _i < names.length; _i++) {\n      onName(_i, names[_i]);\n    }\n  }\n  var lastLine = lines[lines.length - 1];\n  var lastNewLine = lastLine.endsWith(\"\\n\");\n  var finalLine = lastNewLine ? lines.length + 1 : lines.length;\n  var finalColumn = lastNewLine ? 0 : lastLine.length;\n  var currentGeneratedLine = 1;\n  var currentGeneratedColumn = 0;\n  var mappingActive = false;\n  var activeMappingSourceIndex = -1;\n  var activeMappingOriginalLine = -1;\n  var activeMappingOriginalColumn = -1;\n  var activeMappingNameIndex = -1;\n  var onMapping = function onMapping(generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) {\n    if (mappingActive && currentGeneratedLine <= lines.length) {\n      var chunk;\n      var mappingLine = currentGeneratedLine;\n      var mappingColumn = currentGeneratedColumn;\n      var line = lines[currentGeneratedLine - 1];\n      if (generatedLine !== currentGeneratedLine) {\n        chunk = line.slice(currentGeneratedColumn);\n        currentGeneratedLine++;\n        currentGeneratedColumn = 0;\n      } else {\n        chunk = line.slice(currentGeneratedColumn, generatedColumn);\n        currentGeneratedColumn = generatedColumn;\n      }\n      if (chunk) {\n        onChunk(chunk, mappingLine, mappingColumn, activeMappingSourceIndex, activeMappingOriginalLine, activeMappingOriginalColumn, activeMappingNameIndex);\n      }\n      mappingActive = false;\n    }\n    if (generatedLine > currentGeneratedLine && currentGeneratedColumn > 0) {\n      if (currentGeneratedLine <= lines.length) {\n        var _chunk = lines[currentGeneratedLine - 1].slice(currentGeneratedColumn);\n        onChunk(_chunk, currentGeneratedLine, currentGeneratedColumn, -1, -1, -1, -1);\n      }\n      currentGeneratedLine++;\n      currentGeneratedColumn = 0;\n    }\n    while (generatedLine > currentGeneratedLine) {\n      if (currentGeneratedLine <= lines.length) {\n        onChunk(lines[currentGeneratedLine - 1], currentGeneratedLine, 0, -1, -1, -1, -1);\n      }\n      currentGeneratedLine++;\n    }\n    if (generatedColumn > currentGeneratedColumn) {\n      if (currentGeneratedLine <= lines.length) {\n        var _chunk2 = lines[currentGeneratedLine - 1].slice(currentGeneratedColumn, generatedColumn);\n        onChunk(_chunk2, currentGeneratedLine, currentGeneratedColumn, -1, -1, -1, -1);\n      }\n      currentGeneratedColumn = generatedColumn;\n    }\n    if (sourceIndex >= 0 && (generatedLine < finalLine || generatedLine === finalLine && generatedColumn < finalColumn)) {\n      mappingActive = true;\n      activeMappingSourceIndex = sourceIndex;\n      activeMappingOriginalLine = originalLine;\n      activeMappingOriginalColumn = originalColumn;\n      activeMappingNameIndex = nameIndex;\n    }\n  };\n  readMappings(mappings, onMapping);\n  onMapping(finalLine, finalColumn, -1, -1, -1, -1);\n  return {\n    generatedLine: finalLine,\n    generatedColumn: finalColumn\n  };\n};\nvar streamChunksOfSourceMapLinesFull = function streamChunksOfSourceMapLinesFull(source, sourceMap, onChunk, onSource, _onName) {\n  var lines = splitIntoLines(source);\n  if (lines.length === 0) {\n    return {\n      generatedLine: 1,\n      generatedColumn: 0\n    };\n  }\n  var sources = sourceMap.sources,\n    sourcesContent = sourceMap.sourcesContent,\n    mappings = sourceMap.mappings;\n  for (var i = 0; i < sources.length; i++) {\n    onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || undefined);\n  }\n  var currentGeneratedLine = 1;\n  var onMapping = function onMapping(generatedLine, _generatedColumn, sourceIndex, originalLine, originalColumn, _nameIndex) {\n    if (sourceIndex < 0 || generatedLine < currentGeneratedLine || generatedLine > lines.length) {\n      return;\n    }\n    while (generatedLine > currentGeneratedLine) {\n      if (currentGeneratedLine <= lines.length) {\n        onChunk(lines[currentGeneratedLine - 1], currentGeneratedLine, 0, -1, -1, -1, -1);\n      }\n      currentGeneratedLine++;\n    }\n    if (generatedLine <= lines.length) {\n      onChunk(lines[generatedLine - 1], generatedLine, 0, sourceIndex, originalLine, originalColumn, -1);\n      currentGeneratedLine++;\n    }\n  };\n  readMappings(mappings, onMapping);\n  for (; currentGeneratedLine <= lines.length; currentGeneratedLine++) {\n    onChunk(lines[currentGeneratedLine - 1], currentGeneratedLine, 0, -1, -1, -1, -1);\n  }\n  var lastLine = lines[lines.length - 1];\n  var lastNewLine = lastLine.endsWith(\"\\n\");\n  var finalLine = lastNewLine ? lines.length + 1 : lines.length;\n  var finalColumn = lastNewLine ? 0 : lastLine.length;\n  return {\n    generatedLine: finalLine,\n    generatedColumn: finalColumn\n  };\n};\nvar streamChunksOfSourceMapFinal = function streamChunksOfSourceMapFinal(source, sourceMap, onChunk, onSource, onName) {\n  var result = getGeneratedSourceInfo(source);\n  var finalLine = result.generatedLine,\n    finalColumn = result.generatedColumn;\n  if (finalLine === 1 && finalColumn === 0) return result;\n  var sources = sourceMap.sources,\n    sourcesContent = sourceMap.sourcesContent,\n    names = sourceMap.names,\n    mappings = sourceMap.mappings;\n  for (var i = 0; i < sources.length; i++) {\n    onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || undefined);\n  }\n  if (names) {\n    for (var _i2 = 0; _i2 < names.length; _i2++) {\n      onName(_i2, names[_i2]);\n    }\n  }\n  var mappingActiveLine = 0;\n  var onMapping = function onMapping(generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) {\n    if (generatedLine >= finalLine && (generatedColumn >= finalColumn || generatedLine > finalLine)) {\n      return;\n    }\n    if (sourceIndex >= 0) {\n      onChunk(undefined, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex);\n      mappingActiveLine = generatedLine;\n    } else if (mappingActiveLine === generatedLine) {\n      onChunk(undefined, generatedLine, generatedColumn, -1, -1, -1, -1);\n      mappingActiveLine = 0;\n    }\n  };\n  readMappings(mappings, onMapping);\n  return result;\n};\nvar streamChunksOfSourceMapLinesFinal = function streamChunksOfSourceMapLinesFinal(source, sourceMap, onChunk, onSource, _onName) {\n  var result = getGeneratedSourceInfo(source);\n  var generatedLine = result.generatedLine,\n    generatedColumn = result.generatedColumn;\n  if (generatedLine === 1 && generatedColumn === 0) {\n    return {\n      generatedLine: 1,\n      generatedColumn: 0\n    };\n  }\n  var sources = sourceMap.sources,\n    sourcesContent = sourceMap.sourcesContent,\n    mappings = sourceMap.mappings;\n  for (var i = 0; i < sources.length; i++) {\n    onSource(i, getSource(sourceMap, i), sourcesContent && sourcesContent[i] || undefined);\n  }\n  var finalLine = generatedColumn === 0 ? generatedLine - 1 : generatedLine;\n  var currentGeneratedLine = 1;\n  var onMapping = function onMapping(generatedLine, _generatedColumn, sourceIndex, originalLine, originalColumn, _nameIndex) {\n    if (sourceIndex >= 0 && currentGeneratedLine <= generatedLine && generatedLine <= finalLine) {\n      onChunk(undefined, generatedLine, 0, sourceIndex, originalLine, originalColumn, -1);\n      currentGeneratedLine = generatedLine + 1;\n    }\n  };\n  readMappings(mappings, onMapping);\n  return result;\n};\nmodule.exports = function (source, sourceMap, onChunk, onSource, onName, finalSource, columns) {\n  if (columns) {\n    return finalSource ? streamChunksOfSourceMapFinal(source, sourceMap, onChunk, onSource, onName) : streamChunksOfSourceMapFull(source, sourceMap, onChunk, onSource, onName);\n  } else {\n    return finalSource ? streamChunksOfSourceMapLinesFinal(source, sourceMap, onChunk, onSource, onName) : streamChunksOfSourceMapLinesFull(source, sourceMap, onChunk, onSource, onName);\n  }\n};","map":{"version":3,"names":["getGeneratedSourceInfo","require","getSource","readMappings","splitIntoLines","streamChunksOfSourceMapFull","source","sourceMap","onChunk","onSource","onName","lines","length","generatedLine","generatedColumn","sources","sourcesContent","names","mappings","i","undefined","lastLine","lastNewLine","endsWith","finalLine","finalColumn","currentGeneratedLine","currentGeneratedColumn","mappingActive","activeMappingSourceIndex","activeMappingOriginalLine","activeMappingOriginalColumn","activeMappingNameIndex","onMapping","sourceIndex","originalLine","originalColumn","nameIndex","chunk","mappingLine","mappingColumn","line","slice","streamChunksOfSourceMapLinesFull","_onName","_generatedColumn","_nameIndex","streamChunksOfSourceMapFinal","result","mappingActiveLine","streamChunksOfSourceMapLinesFinal","module","exports","finalSource","columns"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack-sources/lib/helpers/streamChunksOfSourceMap.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst getGeneratedSourceInfo = require(\"./getGeneratedSourceInfo\");\nconst getSource = require(\"./getSource\");\nconst readMappings = require(\"./readMappings\");\nconst splitIntoLines = require(\"./splitIntoLines\");\n\nconst streamChunksOfSourceMapFull = (\n\tsource,\n\tsourceMap,\n\tonChunk,\n\tonSource,\n\tonName\n) => {\n\tconst lines = splitIntoLines(source);\n\tif (lines.length === 0) {\n\t\treturn {\n\t\t\tgeneratedLine: 1,\n\t\t\tgeneratedColumn: 0\n\t\t};\n\t}\n\tconst { sources, sourcesContent, names, mappings } = sourceMap;\n\tfor (let i = 0; i < sources.length; i++) {\n\t\tonSource(\n\t\t\ti,\n\t\t\tgetSource(sourceMap, i),\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\n\t\t);\n\t}\n\tif (names) {\n\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\tonName(i, names[i]);\n\t\t}\n\t}\n\n\tconst lastLine = lines[lines.length - 1];\n\tconst lastNewLine = lastLine.endsWith(\"\\n\");\n\tconst finalLine = lastNewLine ? lines.length + 1 : lines.length;\n\tconst finalColumn = lastNewLine ? 0 : lastLine.length;\n\n\tlet currentGeneratedLine = 1;\n\tlet currentGeneratedColumn = 0;\n\n\tlet mappingActive = false;\n\tlet activeMappingSourceIndex = -1;\n\tlet activeMappingOriginalLine = -1;\n\tlet activeMappingOriginalColumn = -1;\n\tlet activeMappingNameIndex = -1;\n\n\tconst onMapping = (\n\t\tgeneratedLine,\n\t\tgeneratedColumn,\n\t\tsourceIndex,\n\t\toriginalLine,\n\t\toriginalColumn,\n\t\tnameIndex\n\t) => {\n\t\tif (mappingActive && currentGeneratedLine <= lines.length) {\n\t\t\tlet chunk;\n\t\t\tconst mappingLine = currentGeneratedLine;\n\t\t\tconst mappingColumn = currentGeneratedColumn;\n\t\t\tconst line = lines[currentGeneratedLine - 1];\n\t\t\tif (generatedLine !== currentGeneratedLine) {\n\t\t\t\tchunk = line.slice(currentGeneratedColumn);\n\t\t\t\tcurrentGeneratedLine++;\n\t\t\t\tcurrentGeneratedColumn = 0;\n\t\t\t} else {\n\t\t\t\tchunk = line.slice(currentGeneratedColumn, generatedColumn);\n\t\t\t\tcurrentGeneratedColumn = generatedColumn;\n\t\t\t}\n\t\t\tif (chunk) {\n\t\t\t\tonChunk(\n\t\t\t\t\tchunk,\n\t\t\t\t\tmappingLine,\n\t\t\t\t\tmappingColumn,\n\t\t\t\t\tactiveMappingSourceIndex,\n\t\t\t\t\tactiveMappingOriginalLine,\n\t\t\t\t\tactiveMappingOriginalColumn,\n\t\t\t\t\tactiveMappingNameIndex\n\t\t\t\t);\n\t\t\t}\n\t\t\tmappingActive = false;\n\t\t}\n\t\tif (generatedLine > currentGeneratedLine && currentGeneratedColumn > 0) {\n\t\t\tif (currentGeneratedLine <= lines.length) {\n\t\t\t\tconst chunk = lines[currentGeneratedLine - 1].slice(\n\t\t\t\t\tcurrentGeneratedColumn\n\t\t\t\t);\n\t\t\t\tonChunk(\n\t\t\t\t\tchunk,\n\t\t\t\t\tcurrentGeneratedLine,\n\t\t\t\t\tcurrentGeneratedColumn,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1\n\t\t\t\t);\n\t\t\t}\n\t\t\tcurrentGeneratedLine++;\n\t\t\tcurrentGeneratedColumn = 0;\n\t\t}\n\t\twhile (generatedLine > currentGeneratedLine) {\n\t\t\tif (currentGeneratedLine <= lines.length) {\n\t\t\t\tonChunk(\n\t\t\t\t\tlines[currentGeneratedLine - 1],\n\t\t\t\t\tcurrentGeneratedLine,\n\t\t\t\t\t0,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1\n\t\t\t\t);\n\t\t\t}\n\t\t\tcurrentGeneratedLine++;\n\t\t}\n\t\tif (generatedColumn > currentGeneratedColumn) {\n\t\t\tif (currentGeneratedLine <= lines.length) {\n\t\t\t\tconst chunk = lines[currentGeneratedLine - 1].slice(\n\t\t\t\t\tcurrentGeneratedColumn,\n\t\t\t\t\tgeneratedColumn\n\t\t\t\t);\n\t\t\t\tonChunk(\n\t\t\t\t\tchunk,\n\t\t\t\t\tcurrentGeneratedLine,\n\t\t\t\t\tcurrentGeneratedColumn,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1\n\t\t\t\t);\n\t\t\t}\n\t\t\tcurrentGeneratedColumn = generatedColumn;\n\t\t}\n\t\tif (\n\t\t\tsourceIndex >= 0 &&\n\t\t\t(generatedLine < finalLine ||\n\t\t\t\t(generatedLine === finalLine && generatedColumn < finalColumn))\n\t\t) {\n\t\t\tmappingActive = true;\n\t\t\tactiveMappingSourceIndex = sourceIndex;\n\t\t\tactiveMappingOriginalLine = originalLine;\n\t\t\tactiveMappingOriginalColumn = originalColumn;\n\t\t\tactiveMappingNameIndex = nameIndex;\n\t\t}\n\t};\n\treadMappings(mappings, onMapping);\n\tonMapping(finalLine, finalColumn, -1, -1, -1, -1);\n\treturn {\n\t\tgeneratedLine: finalLine,\n\t\tgeneratedColumn: finalColumn\n\t};\n};\n\nconst streamChunksOfSourceMapLinesFull = (\n\tsource,\n\tsourceMap,\n\tonChunk,\n\tonSource,\n\t_onName\n) => {\n\tconst lines = splitIntoLines(source);\n\tif (lines.length === 0) {\n\t\treturn {\n\t\t\tgeneratedLine: 1,\n\t\t\tgeneratedColumn: 0\n\t\t};\n\t}\n\tconst { sources, sourcesContent, mappings } = sourceMap;\n\tfor (let i = 0; i < sources.length; i++) {\n\t\tonSource(\n\t\t\ti,\n\t\t\tgetSource(sourceMap, i),\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\n\t\t);\n\t}\n\n\tlet currentGeneratedLine = 1;\n\n\tconst onMapping = (\n\t\tgeneratedLine,\n\t\t_generatedColumn,\n\t\tsourceIndex,\n\t\toriginalLine,\n\t\toriginalColumn,\n\t\t_nameIndex\n\t) => {\n\t\tif (\n\t\t\tsourceIndex < 0 ||\n\t\t\tgeneratedLine < currentGeneratedLine ||\n\t\t\tgeneratedLine > lines.length\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\twhile (generatedLine > currentGeneratedLine) {\n\t\t\tif (currentGeneratedLine <= lines.length) {\n\t\t\t\tonChunk(\n\t\t\t\t\tlines[currentGeneratedLine - 1],\n\t\t\t\t\tcurrentGeneratedLine,\n\t\t\t\t\t0,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1,\n\t\t\t\t\t-1\n\t\t\t\t);\n\t\t\t}\n\t\t\tcurrentGeneratedLine++;\n\t\t}\n\t\tif (generatedLine <= lines.length) {\n\t\t\tonChunk(\n\t\t\t\tlines[generatedLine - 1],\n\t\t\t\tgeneratedLine,\n\t\t\t\t0,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\t-1\n\t\t\t);\n\t\t\tcurrentGeneratedLine++;\n\t\t}\n\t};\n\treadMappings(mappings, onMapping);\n\tfor (; currentGeneratedLine <= lines.length; currentGeneratedLine++) {\n\t\tonChunk(\n\t\t\tlines[currentGeneratedLine - 1],\n\t\t\tcurrentGeneratedLine,\n\t\t\t0,\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t-1,\n\t\t\t-1\n\t\t);\n\t}\n\n\tconst lastLine = lines[lines.length - 1];\n\tconst lastNewLine = lastLine.endsWith(\"\\n\");\n\n\tconst finalLine = lastNewLine ? lines.length + 1 : lines.length;\n\tconst finalColumn = lastNewLine ? 0 : lastLine.length;\n\n\treturn {\n\t\tgeneratedLine: finalLine,\n\t\tgeneratedColumn: finalColumn\n\t};\n};\n\nconst streamChunksOfSourceMapFinal = (\n\tsource,\n\tsourceMap,\n\tonChunk,\n\tonSource,\n\tonName\n) => {\n\tconst result = getGeneratedSourceInfo(source);\n\tconst { generatedLine: finalLine, generatedColumn: finalColumn } = result;\n\n\tif (finalLine === 1 && finalColumn === 0) return result;\n\tconst { sources, sourcesContent, names, mappings } = sourceMap;\n\tfor (let i = 0; i < sources.length; i++) {\n\t\tonSource(\n\t\t\ti,\n\t\t\tgetSource(sourceMap, i),\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\n\t\t);\n\t}\n\tif (names) {\n\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\tonName(i, names[i]);\n\t\t}\n\t}\n\n\tlet mappingActiveLine = 0;\n\n\tconst onMapping = (\n\t\tgeneratedLine,\n\t\tgeneratedColumn,\n\t\tsourceIndex,\n\t\toriginalLine,\n\t\toriginalColumn,\n\t\tnameIndex\n\t) => {\n\t\tif (\n\t\t\tgeneratedLine >= finalLine &&\n\t\t\t(generatedColumn >= finalColumn || generatedLine > finalLine)\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\tif (sourceIndex >= 0) {\n\t\t\tonChunk(\n\t\t\t\tundefined,\n\t\t\t\tgeneratedLine,\n\t\t\t\tgeneratedColumn,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\tnameIndex\n\t\t\t);\n\t\t\tmappingActiveLine = generatedLine;\n\t\t} else if (mappingActiveLine === generatedLine) {\n\t\t\tonChunk(undefined, generatedLine, generatedColumn, -1, -1, -1, -1);\n\t\t\tmappingActiveLine = 0;\n\t\t}\n\t};\n\treadMappings(mappings, onMapping);\n\treturn result;\n};\n\nconst streamChunksOfSourceMapLinesFinal = (\n\tsource,\n\tsourceMap,\n\tonChunk,\n\tonSource,\n\t_onName\n) => {\n\tconst result = getGeneratedSourceInfo(source);\n\tconst { generatedLine, generatedColumn } = result;\n\tif (generatedLine === 1 && generatedColumn === 0) {\n\t\treturn {\n\t\t\tgeneratedLine: 1,\n\t\t\tgeneratedColumn: 0\n\t\t};\n\t}\n\n\tconst { sources, sourcesContent, mappings } = sourceMap;\n\tfor (let i = 0; i < sources.length; i++) {\n\t\tonSource(\n\t\t\ti,\n\t\t\tgetSource(sourceMap, i),\n\t\t\t(sourcesContent && sourcesContent[i]) || undefined\n\t\t);\n\t}\n\n\tconst finalLine = generatedColumn === 0 ? generatedLine - 1 : generatedLine;\n\n\tlet currentGeneratedLine = 1;\n\n\tconst onMapping = (\n\t\tgeneratedLine,\n\t\t_generatedColumn,\n\t\tsourceIndex,\n\t\toriginalLine,\n\t\toriginalColumn,\n\t\t_nameIndex\n\t) => {\n\t\tif (\n\t\t\tsourceIndex >= 0 &&\n\t\t\tcurrentGeneratedLine <= generatedLine &&\n\t\t\tgeneratedLine <= finalLine\n\t\t) {\n\t\t\tonChunk(\n\t\t\t\tundefined,\n\t\t\t\tgeneratedLine,\n\t\t\t\t0,\n\t\t\t\tsourceIndex,\n\t\t\t\toriginalLine,\n\t\t\t\toriginalColumn,\n\t\t\t\t-1\n\t\t\t);\n\t\t\tcurrentGeneratedLine = generatedLine + 1;\n\t\t}\n\t};\n\treadMappings(mappings, onMapping);\n\treturn result;\n};\n\nmodule.exports = (\n\tsource,\n\tsourceMap,\n\tonChunk,\n\tonSource,\n\tonName,\n\tfinalSource,\n\tcolumns\n) => {\n\tif (columns) {\n\t\treturn finalSource\n\t\t\t? streamChunksOfSourceMapFinal(\n\t\t\t\t\tsource,\n\t\t\t\t\tsourceMap,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName\n\t\t\t  )\n\t\t\t: streamChunksOfSourceMapFull(\n\t\t\t\t\tsource,\n\t\t\t\t\tsourceMap,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName\n\t\t\t  );\n\t} else {\n\t\treturn finalSource\n\t\t\t? streamChunksOfSourceMapLinesFinal(\n\t\t\t\t\tsource,\n\t\t\t\t\tsourceMap,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName\n\t\t\t  )\n\t\t\t: streamChunksOfSourceMapLinesFull(\n\t\t\t\t\tsource,\n\t\t\t\t\tsourceMap,\n\t\t\t\t\tonChunk,\n\t\t\t\t\tonSource,\n\t\t\t\t\tonName\n\t\t\t  );\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}