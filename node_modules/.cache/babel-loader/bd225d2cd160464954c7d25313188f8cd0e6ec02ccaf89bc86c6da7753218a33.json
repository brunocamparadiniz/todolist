{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar TOMBSTONE = Symbol(\"tombstone\");\nvar UNDEFINED_MARKER = Symbol(\"undefined\");\n\n/**\n * @template T\n * @typedef {T | undefined} Cell<T>\n */\n\n/**\n * @template T\n * @typedef {T | typeof TOMBSTONE | typeof UNDEFINED_MARKER} InternalCell<T>\n */\n\n/**\n * @template K\n * @template V\n * @param {[K, InternalCell<V>]} pair the internal cell\n * @returns {[K, Cell<V>]} its “safe” representation\n */\nvar extractPair = function extractPair(pair) {\n  var key = pair[0];\n  var val = pair[1];\n  if (val === UNDEFINED_MARKER || val === TOMBSTONE) {\n    return [key, undefined];\n  } else {\n    return (/** @type {[K, Cell<V>]} */pair\n    );\n  }\n};\n\n/**\n * @template K\n * @template V\n */\nvar StackedMap = /*#__PURE__*/function () {\n  /**\n   * @param {Map<K, InternalCell<V>>[]=} parentStack an optional parent\n   */\n  function StackedMap(parentStack) {\n    _classCallCheck(this, StackedMap);\n    /** @type {Map<K, InternalCell<V>>} */\n    this.map = new Map();\n    /** @type {Map<K, InternalCell<V>>[]} */\n    this.stack = parentStack === undefined ? [] : parentStack.slice();\n    this.stack.push(this.map);\n  }\n\n  /**\n   * @param {K} item the key of the element to add\n   * @param {V} value the value of the element to add\n   * @returns {void}\n   */\n  _createClass(StackedMap, [{\n    key: \"set\",\n    value: function set(item, value) {\n      this.map.set(item, value === undefined ? UNDEFINED_MARKER : value);\n    }\n\n    /**\n     * @param {K} item the item to delete\n     * @returns {void}\n     */\n  }, {\n    key: \"delete\",\n    value: function _delete(item) {\n      if (this.stack.length > 1) {\n        this.map.set(item, TOMBSTONE);\n      } else {\n        this.map.delete(item);\n      }\n    }\n\n    /**\n     * @param {K} item the item to test\n     * @returns {boolean} true if the item exists in this set\n     */\n  }, {\n    key: \"has\",\n    value: function has(item) {\n      var topValue = this.map.get(item);\n      if (topValue !== undefined) {\n        return topValue !== TOMBSTONE;\n      }\n      if (this.stack.length > 1) {\n        for (var i = this.stack.length - 2; i >= 0; i--) {\n          var value = this.stack[i].get(item);\n          if (value !== undefined) {\n            this.map.set(item, value);\n            return value !== TOMBSTONE;\n          }\n        }\n        this.map.set(item, TOMBSTONE);\n      }\n      return false;\n    }\n\n    /**\n     * @param {K} item the key of the element to return\n     * @returns {Cell<V>} the value of the element\n     */\n  }, {\n    key: \"get\",\n    value: function get(item) {\n      var topValue = this.map.get(item);\n      if (topValue !== undefined) {\n        return topValue === TOMBSTONE || topValue === UNDEFINED_MARKER ? undefined : topValue;\n      }\n      if (this.stack.length > 1) {\n        for (var i = this.stack.length - 2; i >= 0; i--) {\n          var value = this.stack[i].get(item);\n          if (value !== undefined) {\n            this.map.set(item, value);\n            return value === TOMBSTONE || value === UNDEFINED_MARKER ? undefined : value;\n          }\n        }\n        this.map.set(item, TOMBSTONE);\n      }\n      return undefined;\n    }\n  }, {\n    key: \"_compress\",\n    value: function _compress() {\n      if (this.stack.length === 1) return;\n      this.map = new Map();\n      var _iterator = _createForOfIteratorHelper(this.stack),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var data = _step.value;\n          var _iterator2 = _createForOfIteratorHelper(data),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var pair = _step2.value;\n              if (pair[1] === TOMBSTONE) {\n                this.map.delete(pair[0]);\n              } else {\n                this.map.set(pair[0], pair[1]);\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.stack = [this.map];\n    }\n  }, {\n    key: \"asArray\",\n    value: function asArray() {\n      this._compress();\n      return Array.from(this.map.keys());\n    }\n  }, {\n    key: \"asSet\",\n    value: function asSet() {\n      this._compress();\n      return new Set(this.map.keys());\n    }\n  }, {\n    key: \"asPairArray\",\n    value: function asPairArray() {\n      this._compress();\n      return Array.from(this.map.entries(), extractPair);\n    }\n  }, {\n    key: \"asMap\",\n    value: function asMap() {\n      return new Map(this.asPairArray());\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      this._compress();\n      return this.map.size;\n    }\n  }, {\n    key: \"createChild\",\n    value: function createChild() {\n      return new StackedMap(this.stack);\n    }\n  }]);\n  return StackedMap;\n}();\nmodule.exports = StackedMap;","map":{"version":3,"names":["TOMBSTONE","Symbol","UNDEFINED_MARKER","extractPair","pair","key","val","undefined","StackedMap","parentStack","map","Map","stack","slice","push","item","value","set","length","delete","topValue","get","i","data","_compress","Array","from","keys","Set","entries","asPairArray","size","module","exports"],"sources":["/Users/brunocamparadiniz/Desktop/coding/BC-AY/react/todolist/node_modules/webpack/lib/util/StackedMap.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst TOMBSTONE = Symbol(\"tombstone\");\nconst UNDEFINED_MARKER = Symbol(\"undefined\");\n\n/**\n * @template T\n * @typedef {T | undefined} Cell<T>\n */\n\n/**\n * @template T\n * @typedef {T | typeof TOMBSTONE | typeof UNDEFINED_MARKER} InternalCell<T>\n */\n\n/**\n * @template K\n * @template V\n * @param {[K, InternalCell<V>]} pair the internal cell\n * @returns {[K, Cell<V>]} its “safe” representation\n */\nconst extractPair = pair => {\n\tconst key = pair[0];\n\tconst val = pair[1];\n\tif (val === UNDEFINED_MARKER || val === TOMBSTONE) {\n\t\treturn [key, undefined];\n\t} else {\n\t\treturn /** @type {[K, Cell<V>]} */ (pair);\n\t}\n};\n\n/**\n * @template K\n * @template V\n */\nclass StackedMap {\n\t/**\n\t * @param {Map<K, InternalCell<V>>[]=} parentStack an optional parent\n\t */\n\tconstructor(parentStack) {\n\t\t/** @type {Map<K, InternalCell<V>>} */\n\t\tthis.map = new Map();\n\t\t/** @type {Map<K, InternalCell<V>>[]} */\n\t\tthis.stack = parentStack === undefined ? [] : parentStack.slice();\n\t\tthis.stack.push(this.map);\n\t}\n\n\t/**\n\t * @param {K} item the key of the element to add\n\t * @param {V} value the value of the element to add\n\t * @returns {void}\n\t */\n\tset(item, value) {\n\t\tthis.map.set(item, value === undefined ? UNDEFINED_MARKER : value);\n\t}\n\n\t/**\n\t * @param {K} item the item to delete\n\t * @returns {void}\n\t */\n\tdelete(item) {\n\t\tif (this.stack.length > 1) {\n\t\t\tthis.map.set(item, TOMBSTONE);\n\t\t} else {\n\t\t\tthis.map.delete(item);\n\t\t}\n\t}\n\n\t/**\n\t * @param {K} item the item to test\n\t * @returns {boolean} true if the item exists in this set\n\t */\n\thas(item) {\n\t\tconst topValue = this.map.get(item);\n\t\tif (topValue !== undefined) {\n\t\t\treturn topValue !== TOMBSTONE;\n\t\t}\n\t\tif (this.stack.length > 1) {\n\t\t\tfor (let i = this.stack.length - 2; i >= 0; i--) {\n\t\t\t\tconst value = this.stack[i].get(item);\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\tthis.map.set(item, value);\n\t\t\t\t\treturn value !== TOMBSTONE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.map.set(item, TOMBSTONE);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {K} item the key of the element to return\n\t * @returns {Cell<V>} the value of the element\n\t */\n\tget(item) {\n\t\tconst topValue = this.map.get(item);\n\t\tif (topValue !== undefined) {\n\t\t\treturn topValue === TOMBSTONE || topValue === UNDEFINED_MARKER\n\t\t\t\t? undefined\n\t\t\t\t: topValue;\n\t\t}\n\t\tif (this.stack.length > 1) {\n\t\t\tfor (let i = this.stack.length - 2; i >= 0; i--) {\n\t\t\t\tconst value = this.stack[i].get(item);\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\tthis.map.set(item, value);\n\t\t\t\t\treturn value === TOMBSTONE || value === UNDEFINED_MARKER\n\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t: value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.map.set(item, TOMBSTONE);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t_compress() {\n\t\tif (this.stack.length === 1) return;\n\t\tthis.map = new Map();\n\t\tfor (const data of this.stack) {\n\t\t\tfor (const pair of data) {\n\t\t\t\tif (pair[1] === TOMBSTONE) {\n\t\t\t\t\tthis.map.delete(pair[0]);\n\t\t\t\t} else {\n\t\t\t\t\tthis.map.set(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.stack = [this.map];\n\t}\n\n\tasArray() {\n\t\tthis._compress();\n\t\treturn Array.from(this.map.keys());\n\t}\n\n\tasSet() {\n\t\tthis._compress();\n\t\treturn new Set(this.map.keys());\n\t}\n\n\tasPairArray() {\n\t\tthis._compress();\n\t\treturn Array.from(this.map.entries(), extractPair);\n\t}\n\n\tasMap() {\n\t\treturn new Map(this.asPairArray());\n\t}\n\n\tget size() {\n\t\tthis._compress();\n\t\treturn this.map.size;\n\t}\n\n\tcreateChild() {\n\t\treturn new StackedMap(this.stack);\n\t}\n}\n\nmodule.exports = StackedMap;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}